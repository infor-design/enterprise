/**
* Soho XI Controls v4.3.0
* Date: 26/06/2017 3:47:05 PM
* Revision: e1649fef432e1ef0ad1470490e2fd0c807c79575
*/
(function(factory) {
      if (typeof define === 'function' && define.amd) {
        // AMD. Register as an anonymous module
        define(['jquery'], factory);
      } else if (typeof exports === 'object') {
        // Node/CommonJS
        module.exports = factory(require('jquery'));
      } else {
        // Browser globals
        factory(jQuery);
      }
    }(function($) {
  //NOTE: Just this part will show up in SoHo Xi Builds.

  $.fn.personalize = function(options) {
    'use strict';

    // Settings and Options
    var pluginName = 'personalize',
        defaults = {
          colors: '',
          theme: ''
        },
        settings = $.extend({}, defaults, options);

    /**
     * Personalize Control
     * @constructor
     * @param {Object} element
     */
    function Personalize(element) {
      this.settings = $.extend({}, settings);
      this.element = $(element);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    // Plugin Methods
    Personalize.prototype = {
      init: function() {
        this.makeSohoObject()
        .handleEvents();

        if (this.settings.colors) {
          this.setColors(this.settings.colors);
        }

        if (this.settings.theme) {
          this.setTheme(this.settings.theme);
        }
        return this;
      },

      makeSohoObject: function () {
        var self = this;

        window.Soho = window.Soho || {};

        //Handle Personalization and theme
        window.Soho.theme = 'light';

        window.Soho.setTheme = function(theme) { // jshint ignore:line
          self.setTheme(theme);
        };

        window.Soho.setColors = function(colors) { // jshint ignore:line
          self.setColors(colors);
        };

        window.Soho.getColorStyleSheet = function(colors) { // jshint ignore:line
          return self.getColorStyleSheet(colors);
        };

        return this;
      },

      // Sets up event handlers for this control and its sub-elements
      handleEvents: function() {
        var self = this;

        this.element.on('updated.' + pluginName, function() {
          self.updated();
        }).on('changecolors.' + pluginName, function(e, newColor, noAnimate) {
          self.setColors(newColor, noAnimate);
        }).on('changetheme.' + pluginName, function(e, theme) {
          self.setTheme(theme);
        });

        return this;
      },

      // Validates a string containing a hexadecimal number
      // @param {String} hex: A hex color.
      // @returns {String} a validated hexadecimal string.
      validateHex: function(hex) {
        hex = String(hex).replace(/[^0-9a-f]/gi, '');

        if (hex.length < 6) {
          hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
        }

        return '#' + hex;
      },

      appendStyleSheet: function(cssRules) {
        var sheet = document.getElementById('soho-personalization');
        if (sheet) {
          sheet.parentNode.removeChild(sheet);
        }

        // Create the <style> tag
        sheet = document.createElement('style');
        sheet.setAttribute('id', 'soho-personalization');
        sheet.appendChild(document.createTextNode(cssRules));

      	// Add the <style> element to the page
      	document.head.appendChild(sheet);
      },

      getColorStyleSheet: function(colors)  {
        Soho.colors = colors;

        if (typeof colors === 'string') {
          Soho.colors = {};
          Soho.colors.header = colors;
        }

        if (!colors || colors === '') {
          return this;
        }

        // Default Colors...
        // (Color)07 for the main color (fx headers)
        // (Color)06 for the secondary color (fx sub-headers)
        // Light or Dark (fff or 000) for the contrast color

        // (Color)06 for the vertical borders between module tabs - 133C59
        // (Color)07 for the page header and active module tab - 2578A9 DEFAULT
        // (Color)08 for the inactive module tab - 1d5f8a
        // (Color)09 for the horizontal border - 134D71
        // (Color)10 for the hover state on module tab - 133C59
        var defaultColors = {header: '2578A9',
                             subheader: '368AC0',
                             text: 'ffffff',
                             verticalBorder: '133C59',
                             horizontalBorder: '134D71',
                             inactive: '1d5f8a',
                             hover: '133C59'};

        // If an event sends a blank string through instead of a hex,
        // reset any color values back to the theme defaults.  Otherwise, get a valid hex value.
        Soho.colors.header = this.validateHex(Soho.colors.header || defaultColors.header);
        Soho.colors.text = this.validateHex(Soho.colors.text || defaultColors.text);
        Soho.colors.subheader = this.validateHex(Soho.colors.subheader || this.getLuminousColorShade(Soho.colors.header, 0.2));
        Soho.colors.inactive = this.validateHex(Soho.colors.inactive || this.getLuminousColorShade(Soho.colors.header, -0.22));
        Soho.colors.verticalBorder = this.validateHex(Soho.colors.verticalBorder || this.getLuminousColorShade(Soho.colors.header, 0.1));
        Soho.colors.horizontalBorder = this.validateHex(Soho.colors.horizontalBorder || this.getLuminousColorShade(Soho.colors.header, -0.4));
        Soho.colors.hover = this.validateHex(Soho.colors.hover || this.getLuminousColorShade(Soho.colors.header, -0.5));

        //not that the sheet is appended in backwards
        var cssRules = '.tab-container.module-tabs.is-personalizable { border-top: 1px solid '+ Soho.colors.horizontalBorder +'; border-bottom: 1px solid ' + Soho.colors.horizontalBorder + '}' +
        ' .module-tabs.is-personalizable .tab:not(:first-child) { border-left: 1px solid '+ Soho.colors.verticalBorder +'}'  +
        ' .module-tabs.is-personalizable { background-color: '+ Soho.colors.inactive +'}'  +
        ' .module-tabs.is-personalizable .tab.is-selected { background-color: '+ Soho.colors.header +'}'  +
        ' .builder-header.is-personalizable{ background-color: '+ Soho.colors.subheader +'}'  +
        ' .header.is-personalizable { background-color: '+ Soho.colors.header +'}' +
        ' .header.is-personalizable .title { color: '+ Soho.colors.text +'}' +
        ' .header.is-personalizable h1 { color: '+ Soho.colors.text +'}' +
        ' .module-tabs.is-personalizable .tab-more { border-left: '+ Soho.colors.verticalBorder +' }' +
        ' .module-tabs.is-personalizable .tab-more:hover { background-color: '+ Soho.colors.hover +' }' +
        ' .module-tabs.is-personalizable .tab-more.is-open { background-color: '+ Soho.colors.hover +' }' +
        ' .module-tabs.is-personalizable .tab-more.is-selected { background-color: '+ Soho.colors.header +' }' +
        ' .subheader.is-personalizable { background-color: '+ Soho.colors.subheader +'}' +
        ' .builder .sidebar .header {border-right: 1px solid '+ Soho.colors.verticalBorder +'}' +
        ' .module-tabs.is-personalizable .tab:hover { background-color: '+ Soho.colors.hover +'}' +
        ' .module-tabs.has-toolbar.is-personalizable .tab-list-container + .toolbar { border-left: '+ Soho.colors.verticalBorder +' }' +
        ' .module-tabs.is-personalizable [class^="btn"] { background-color: '+ Soho.colors.inactive +' }' +
        ' .hero-widget.is-personalizable { background-color: '+ Soho.colors.subheader +' }' +
        ' .hero-widget.is-personalizable .hero-bottom { background-color: '+ Soho.colors.header +' }' +
        ' .hero-widget.is-personalizable .hero-footer .hero-footer-nav li::before { color: '+ Soho.colors.verticalBorder +' }' +
        ' .hero-widget.is-personalizable .chart-container .arc { stroke: '+ Soho.colors.subheader +' }' +
        ' .hero-widget.is-personalizable .chart-container .bar { stroke: '+ Soho.colors.subheader +' }' +
        ' .hero-widget.is-personalizable .chart-container.line-chart .dot { stroke: '+ Soho.colors.subheader +' }' +
        '';

        return cssRules;
      },

      // Changes all personalizable elements inside this element to match the personalization scheme provided.
      // The original hex color as a string or an object with all the Colors
      setColors: function(colors) {
        if (!colors) {
          return;
        }

        this.appendStyleSheet(this.getColorStyleSheet(colors));
        return this;
      },

      // Takes a color and performs a change in luminosity of that color programatically.
      // @param {String} hex: The original Hexadecimal base color.
      // @param {Number} lum: A percentage used to set luminosity change on the base color:  -0.1 would be 10% darker, 0.2 would be 20% brighter
      // @returns {String} hexadecimal color.
      getLuminousColorShade: function(hex, lum) {
        // validate hex string
        hex = this.validateHex(hex).substr(1);
        lum = lum || 0;

        // convert to decimal and change luminosity
        var rgb = '#', c, i;
        for (i = 0; i < 3; i++) {
          c = parseInt(hex.substr(i*2, 2), 16);
          c = Math.round(Math.min(Math.max(0, c + (c * lum)), 255)).toString(16);
          rgb += ('00' + c).substr(c.length);
        }

        return rgb;
      },

      availableThemes: [
        'light',
        'dark',
        'high-contrast'
      ],

      // @param {String} theme: Represents the file name of a color scheme
      setTheme: function(theme) {
        if (Soho.theme === theme) {
          return;
        }

        Soho.theme = theme;
        // validate theme
        if (this.availableThemes.indexOf(theme) === -1) {
          return;
        }

        this.blockUi();

        var self = this,
          originalCss = $('#stylesheet, #sohoxi-stylesheet'),
          newCss = $('<link rel="stylesheet">'),
          path = originalCss.attr('href');

        newCss.on('load', function() {
          originalCss.remove();
          self.unBlockUi();
        });

        newCss.attr({
          id: originalCss.attr('id'),
          href: path.substring(0, path.lastIndexOf('/')) + '/' + theme + '-theme' + (path.indexOf('.min') > -1 ? '.min' : '') + '.css'
        });
        originalCss.removeAttr('id');
        originalCss.after(newCss);
      },

      //Block the ui from FOUC
      blockUi: function () {

        this.pageOverlay = this.pageOverlay || $('<div style="' +
        	'background: ' + (Soho.theme === 'light' ? '#f0f0f0;' : (Soho.theme === 'dark' ? '#313236;' : '#bdbdbd;')) +
        	'display: block;' +
          'height: 100%;' +
        	'left: 0;' +
        	'position: fixed;' +
          'text-align: center;' +
        	'top: 0;' +
        	'width: 100%;' +
          'z-index: 10000;' +
          '"></div>'
        );

        $('body').append(this.pageOverlay);
      },

      unBlockUi: function (){
        var self = this;

        self.pageOverlay.fadeOut(300, function() {
          self.pageOverlay.remove();
          self.pageOverlay = undefined;
        });
      },

      // Handle Updating Settings
      updated: function() {
        return this
          .teardown()
          .init();
      },

      // Simple Teardown - remove events & rebuildable markup.
      // Ideally this will do non-destructive things that make it possible to easily rebuild
      teardown: function() {
        this.element.off('updated.' + pluginName);
        return this;
      },

      // Teardown - Remove added markup and events
      destroy: function() {
        this.teardown();
        $.removeData(this.element[0], pluginName);
      }
    };

    // Initialize the plugin (Once)
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (instance) {
        instance.settings = $.extend({}, instance.settings, options);
        instance.updated();
      } else {
        instance = $.data(this, pluginName, new Personalize(this, settings));
      }
    });
  };


  $.fn.initialize = function(options) {
    'use strict';

    // Settings and Options
    var pluginName = 'initialize',
        defaults = {
          locale: Locale.currentLocale.name || 'en-US'
        },
        settings;

      if (typeof options === 'string') {
        settings = {};
        settings.locale = options;
      } else {
        settings = $.extend({}, defaults, options);
      }

    /**
     * Page Bootstrapper
     * @constructor
     * @param {Object} element
     */
    function Initialize(element, settings) {
      this.settings = $.extend({}, settings);
      this.element = $(element);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    // Plugin Methods
    Initialize.prototype = {
      init: function() {
        var self = this;

        Locale.set(this.settings.locale).done(function () {
          self.initAll();
        });

        return this;
      },

      initAll : function () {
        var self = this;

        // Iterate all objects we are initializing
        this.element.filter(':not(.no-init)').each(function() {
          var elem = $(this),
            noinitExcludes = '.no-init, [data-init]';

          function invokeWithInlineOptions(elem, plugin) {
            var options = $.fn.parseOptions(elem);
            $(elem)[plugin](options);
          }

          function matchedItems(selector) {
            var items = elem.find(selector);
            if (elem.filter(selector).length) {
              items = items.add(elem);
            }
            return items;
          }

          function simpleInit(plugin, selector) {
            //Allow only the plugin name to be specified if the default selector is a class with the same name
            //Like $.fn.header applying to elements that match .header
            if (typeof selector === 'undefined') {
              selector = '.' + plugin;
            }

            if ($.fn[plugin]) {
              matchedItems(selector).each(function () {
                var elem = $(this);

                if (elem.is(noinitExcludes) && selector !=='[data-trackdirty="true"]') {
                  return;
                }

                if (elem.parents().hasClass('no-init')) {
                  return;
                }

                // Don't invoke elements inside of "container" controls that need to invoke their internal
                // items in a specific order.
                if (!elem.is('.icon') && elem.parents('.toolbar').length && !elem.parents().hasClass('masthead')) {
                  return;
                }

                invokeWithInlineOptions(this, plugin);
              });
            }

            // Radio switch
            matchedItems('.radio-section input:radio.handle').change(function() {
              if (this.checked) {
                var option = $(this).closest('.option'),
                siblings = option.siblings(),
                fields = 'button, select, input[type="text"]';

                $(fields, option).removeAttr('disabled');
                $(fields, siblings).attr('disabled','disabled');
              }
            });
          }

          // Mobile Zoom Control
          // Needs manual invokation because the rest of initialization is scoped to the
          // calling element, which is the <body> tag.
          if ($.fn.zoom) {
            $('head').zoom();
          }

          // Application Menu
          if ($.fn.applicationmenu) {
            matchedItems('#application-menu').applicationmenu({
              triggers: elem.find('.application-menu-trigger')
            });
          }

          // Personalization
          if ($.fn.personalize) {
            matchedItems('body').personalize();
          }

          //Array of plugin names and selectors (optional) for no-configuration initializations
          var simplePluginMappings = [
            // Icons
            ['icon'],

            ['splitter'],

            //Tabs
            ['tabs', '.tab-container:not(.vertical)'],

            //Vertical Tabs
            ['verticaltabs', '.tab-container.vertical'],

            //Select / DropDowns
            ['dropdown', 'select.dropdown:not(.multiselect)'],
            ['dropdown', 'select.dropdown-xs:not(.multiselect)'],
            ['dropdown', 'select.dropdown-sm:not(.multiselect)'],
            ['dropdown', 'select.dropdown-lg:not(.multiselect)'],

            //Modals
            ['modal'],

            //Sliders
            ['slider', 'input[type="range"], .slider'],

            //Editors
            ['editor'],

            //Tooltips
            ['tooltip', '[title]'],

            //Tree
            ['tree'],

            //Rating
            ['rating'],

            //Listbuilder
            ['listbuilder'],

            //Composite Form Wrapper
            ['compositeform', '.composite-form'],

            //Progress
            ['progress', '.progress-bar'],

            //Format
            ['mask', 'input[data-mask]'],

            //Auto Complete
            ['autocomplete', '.autocomplete:not([data-init])'],

            //Multiselect
            ['multiselect', 'select[multiple]:not(.dropdown), .multiselect:not([data-init])'],

            //Button with Effects
            ['button', '.btn, .btn-toggle, .btn-secondary, .btn-primary, .btn-modal-primary, .btn-tertiary, .btn-icon, .btn-actions, .btn-menu, .btn-split, .btn-secondary-border'],

            //Hide Focus
            ['hideFocus', 'a.hide-focus, a.tick, a.hyperlink, .checkbox, .radio, .switch'],

            //Circle Pager
            ['circlepager'],

            //Track Dirty
            ['trackdirty', '[data-trackdirty="true"]'],

            //Clear x
            ['clearable', '[data-clearable="true"]'],

            //Text Area
            ['textarea', 'textarea'],

            //Spinbox
            ['spinbox'],

            //sort drag and drop
            ['arrange'],

            //Swap List
            ['swaplist'],

            //Color Picker
            ['colorpicker'],

            //Date Picker
            ['datepicker'],

            //Time Picker
            ['timepicker'],

            //Tag
            ['tag'],

            //Busy Indicator
            ['busyindicator','.busy, .busy-xs, .busy-sm'],

            ['header'],

            ['fileupload'],

            ['fileuploadadvanced', '.fileupload-advanced'],

            ['about'],

            ['contextualactionpanel', '.contextual-action-panel-trigger'],

            ['expandablearea', '.expandable-area'],

            ['modalsearch', '.modal-search'],

            ['signin'],

            ['homepage'],

            ['lookup', '.lookup:not([data-init])'],

            ['wizard'],

            ['popdown', '[data-popdown]']
          ];

          //Do initialization for all the simple controls
          for(var i = 0; i < simplePluginMappings.length; i++) {
            simpleInit.apply(null, simplePluginMappings[i]);
          }

          if ($.fn.popupmenu) {
            // Don't double-invoke menu buttons
            var btnExcludes = ', .btn-actions, .btn-filter, .btn-menu';

            //Context Menus
            matchedItems('[data-popupmenu]:not('+ noinitExcludes + btnExcludes + ')').each(function () {
              var triggerButton = $(this),
                options = $.extend({}, $.fn.parseOptions(this)),
                popupData = triggerButton.attr('data-popupmenu');

              if (popupData) {
                options.menuId = popupData;
              }

              triggerButton.popupmenu(options);
            });

            //Button-based Popup-Menus (Action/More Button, Menu Buttons, etc.)
            matchedItems('.btn-filter, .btn-menu, .btn-actions').filter(':not('+ noinitExcludes +')').each(function() {
              var triggerButton = $(this);

              // Don't auto-invoke Toolbar's Popupmenus.
              // Toolbar needs to completely control its contents and invoke each one manually.
              if (triggerButton.parents('.toolbar').length > 0) {
                return;
              }

              invokeWithInlineOptions(triggerButton, 'popupmenu');
            });
          }

          //Popovers
          if ($.fn.popover) {
            matchedItems('[data-popover]:not('+ noinitExcludes +')').each(function () {
              var obj = $(this),
                trigger = obj.attr('data-trigger'),
                title = obj.attr('data-title'),
                placement = obj.attr('data-placement');

              obj.popover({
                content: $('#' + obj.attr('data-popover')),
                trigger: trigger ? trigger : 'click',
                title: title ? title : undefined,
                placement: placement || 'right'
              });
            });
          }

          //Cardstack
          if ($.fn.listview) {
            matchedItems('.listview:not('+ noinitExcludes +')').each(function () {
              var cs = $(this),
                attr = cs.attr('data-dataset'),
                tmpl = cs.attr('data-tmpl'),
                options = $.fn.parseOptions(this) || {};

              options.dataset = options.dataset || attr;
              options.template = options.template || tmpl;

              if (window[options.dataset]) {
                options.dataset = window[options.dataset];
              }
              if (options.template && options.template.length) {
                options.template = $('#' + options.template).html();
              }

              cs.listview(options);
            });
          }

          // Searchfield
          // NOTE:  The Toolbar Control itself understands how to invoke internal searchfields, so they
          // are excluded from this initializer.
          if ($.fn.searchfield) {
            var searchfields = matchedItems('.searchfield:not('+ noinitExcludes +')'),
              toolbarSearchfields = searchfields.filter(function() {
                return $(this).parents('.toolbar').length;
              });
            searchfields = searchfields.not(toolbarSearchfields);

            searchfields.each(function() {
              invokeWithInlineOptions(this, 'searchfield');
            });
          }

          // Accordion
          if ($.fn.accordion) {
            matchedItems('.accordion:not('+ noinitExcludes +')').each(function() {
              var a = $(this);
              if (a.parents('.application-menu').length) {
                return;
              }

              invokeWithInlineOptions(a, 'accordion');
            });
          }

          // Toolbar
          if ($.fn.toolbar) {
            matchedItems('.toolbar:not('+ noinitExcludes +')').each(function() {
              var t = $(this);
              // Don't re-invoke toolbars that are part of the page/section headers.
              // header.js manually invokes these toolbars during its setup process.
              if (t.parents('.header').length || t.parents('.contextual-action-panel').length) {
                return;
              }

              invokeWithInlineOptions(t, 'toolbar');
            });
          }

          matchedItems('[data-translate="text"]').each(function () {
            var obj = $(this);
            obj.text(Locale.translate(obj.text()));
          });

          //Toggle boxes on image list
          matchedItems('.block').on('click', function () {
            $(this).toggleClass('is-selected');
          });

          //Validation
          //Should be one of the last items to invoke
          if ($.fn.validate) {
            matchedItems('[data-validate-on="submit"]').validate();
          }

          matchedItems('.breadcrumb ol').attr('aria-label', Locale.translate('Breadcrumb'));
        });

        // NOTE: use of .triggerHandler() here causes event listeners for "initialized" to fire, but prevents the
        // "initialized" event from bubbling up the DOM.  It should be possible to initialize just the contents
        // of an element on the page without causing the entire page to re-initialize.
        this.element.triggerHandler('initialized');

        if ($.fn.validate) {
          self.element.validate();
        }

        return this;
      }

    };

    // Initialize the plugin (Once)
    return this.each(function() {
      var instance = new Initialize(this, settings); // jshint ignore:line
    });
  };


  function Base(element) {
    this.element = $(element);
    this.url = this.getCurrentURL();

    window.Soho = window.Soho || {};

    if (!window.Soho.base) {
      $.detectBaseTag();
    }

    return this;
  }

  // Provides a global object that detects the existence of a Base Tag,
  // and provides some methods that can be used to get an accurate relative
  // URL using the base tag.
  Base.prototype = {
    getCurrentURL: function() {
      return window.location.href
        .replace(window.location.hash, '');
    },

    getBaseURL: function(hash) {
      if (hash) {
        // absolute links
        if (hash.indexOf('/') === 0) {
          return window.location.origin + hash;
        }

        hash = (hash.indexOf('#') === -1 ? '#' : '') + hash;
        return this.url + hash;
      }

      return this.url;
    }
  };

  // Setup a default function that just returns the contents of the hash,
  // if no base tag is present.
  $.getBaseURL = function(hash) {
    return hash;
  };

  // Detect the Base tag and install a global object, if necessary
  $.detectBaseTag = function detectBaseTag() {
    var base = $('base[href]');
    if (base.length) {
      window.Soho.base = new Base(base);

      // override the "getBaseURL"
      $.getBaseURL = window.Soho.base.getBaseURL.bind(window.Soho.base);
    }
  };

/**
 * Transition Support Check
 * Returns the vendor-prefixed name of the 'transition' property available by the browser.
 * If the browser doesn't support transitions, it returns null.
 * @private
 */


  window.Soho = window.Soho || {};
  window.Soho.utils = {};
  window.Soho.DOM = {};

  // Used for changing the stacking order of jQuery events.  This is needed to override certain
  // Events invoked by other plugins http://stackoverflow.com/questions/2360655
  $.fn.bindFirst = function(name, fn) {
    this.on(name, fn);
    this.each(function() {
        var handlers = $._data(this, 'events')[name.split('.')[0]];
        // take out the handler we just inserted from the end
        var handler = handlers.pop();
        // move it at the beginning
        handlers.splice(0, 0, handler);
    });
  };

  function visible(element) {
    return $.expr.filters.visible( element ) &&
      !$(element).parents().addBack().filter(function() {
        return $.css(this, 'visibility') === 'hidden';
      }).length;
  }

  //Get a unique ID
  window.Soho.uniqueIdCount = 0;
  $.fn.uniqueId = function(className, prefix, suffix) {
    var predefinedId = $(this).attr('id');

    if (predefinedId && $('#' + predefinedId).length < 2) {
      return predefinedId;
    }

    prefix = (!prefix ? '' : prefix + '-');
    suffix = (!suffix ? '' : '-' + suffix);
    className = (!className ? $(this).attr('class') : className);

    var str = prefix + className + Soho.uniqueIdCount + suffix;
    Soho.uniqueIdCount = Soho.uniqueIdCount + 1;
    return str;
  };

  // Check for CSS Property Support in a cross browser way
  $.fn.cssPropSupport = function(prop) {
    'use strict';

    if (!prop) {
      return null;
    }

    var el = $('<div></div>')[0],
      propStr = prop.toString(),
      prefixes = ['Moz', 'Webkit', 'O', 'ms'],
      prop_ = propStr.charAt(0).toUpperCase() + propStr.substr(1);

    if (prop in el.style) {
      $(el).remove();
      return prop;
    }

    for (var i = 0; i < prefixes.length; i++) {
      var vendorProp = prefixes[i] + prop_;
      if (vendorProp in el.style) {
        $(el).remove();
        return vendorProp;
      }
    }

    $(el).remove();
    return null;
  };

  // Returns the name of the TransitionEnd event.
  $.fn.transitionEndName = function() {
    var prop = $.fn.cssPropSupport('transition'),
      eventNames = {
        'WebkitTransition' :'webkitTransitionEnd',
        'MozTransition'    :'transitionend',
        'MSTransition'     :'msTransitionEnd',
        'OTransition'      :'oTransitionEnd',
        'transition'       :'transitionend'
      };

    return eventNames[prop] || null;
  };

  // From jQueryUI Core: https://github.com/jquery/jquery-ui/blob/24756a978a977d7abbef5e5bce403837a01d964f/ui/jquery.ui.core.js#L93
  // Adapted from:  http://stackoverflow.com/questions/7668525/is-there-a-jquery-selector-to-get-all-elements-that-can-get-focus
  // Adds the ':focusable' selector to Sizzle to allow for the selection of elements that can currently be focused.
  function focusable(element) {
    var map, mapName, img,
      nodeName = element.nodeName.toLowerCase(),
      isTabIndexNotNaN = !isNaN($.attr(element, 'tabindex'));

    if ('area' === nodeName) {
      map = element.parentNode;
      mapName = map.name;
      if (!element.href || !mapName || map.nodeName.toLowerCase() !== 'map') {
        return false;
      }
      img = $('img[usemap=#' + mapName + ']')[0];
      return !!img && visible(img);
    }

    return (/input|select|textarea|button|object/.test(nodeName) ?
      !element.disabled :
      'a' === nodeName ?
        element.href || isTabIndexNotNaN :
        isTabIndexNotNaN) &&
      // the element and all of its ancestors must be visible
      visible( element );
  }

  $.extend($.expr[':'], {
    focusable: function(element) {
      return focusable(element, !isNaN($.attr(element, 'tabindex')));
    }
  });

  // Custom Touch Event Handler that simply passes Touch Event Handlers onto a Click Event Handler.
  // Used for avoiding the 300ms wait time that click events have in most mobile environments
  // if 'one' is defined, it only listens once.
  $.fn.onTouchClick = function(eventNamespace, filter, one) {
    eventNamespace = (eventNamespace !== null || eventNamespace !== undefined ? '.' + eventNamespace : '');
    filter = (filter !== null || filter !== undefined ? filter : '');

    return this.each(function() {
      var self = $(this),
        listener = one ? 'one' : 'on',
        threshold = 10,
        thresholdReached = false,
        pos;

     self[listener]('touchstart' + eventNamespace, filter, function handleMove(e) {
        pos = {
          x: e.originalEvent.touches[0].pageX,
          y: e.originalEvent.touches[0].pageY
        };
      });

      self[listener]('touchmove' + eventNamespace, filter, function handleMove(e) {
        var newPos;
        newPos = {
          x: e.originalEvent.touches[0].pageX,
          y: e.originalEvent.touches[0].pageY
        };

        if ((newPos.x >= pos.x + threshold) || (newPos.x <= pos.x - threshold) ||
            (newPos.y >= pos.y + threshold) || (newPos.y <= pos.y - threshold)) {
          thresholdReached = true;
        }
      });

      self[listener]('touchend' + eventNamespace + ' touchcancel' + eventNamespace, filter, function handleTouches(e) {
        var elem = $(this);
        if (thresholdReached) {
          thresholdReached = false;
          return;
        }

        setTimeout(function(){
          thresholdReached = false;
          e.preventDefault();

          if (elem.attr('disabled')) {
            return;
          }

          elem.trigger('click');
        }, 0);

        return false;
      });

      return self;
    });
  };

  // Reverses the .onTouchClick() method and turns off a matching event listener
  $.fn.offTouchClick = function(eventNamespace, filter) {
    eventNamespace = (eventNamespace !== null || eventNamespace !== undefined ? '.' + eventNamespace : '');
    filter = (filter !== null || filter !== undefined ? filter : '');

    return this.each(function() {
      return $(this).off('touchend' + eventNamespace + ' touchcancel' + eventNamespace + ' touchstart' + eventNamespace + ' touchmove' + eventNamespace, filter);
    });
  };

  // Returns a key/value list of currently attached event listeners
  $.fn.listEvents = function() {
    var data = {};

    this.each(function() {
      data = $._data(this, 'events');
    });

    return data;
  };

  // Implements consistent support for the placeholder attribute in browsers that do not handle it
  // ** Supports any kind of input (no issues with password) and textarea
  // ** does nothing if native support exists
  $.fn.placeholderPolyfill = function(options) {
    if (!('placeholder' in document.createElement('input'))) {
      var settings = $.extend({className: 'is-placeholder'}, options),
        setInputType = function (input, type, opt) {
          if(opt) {
            input.attr('type', type);
          }
        };
      $('[placeholder]').each(function() {
        var input = $(this),
        isPassword = input.is('input[type="password"]');
        input.removeClass(settings.className).on('focus.placeholderPolyfill, click.placeholderPolyfill', function() {
          if (input.val() === input.attr('placeholder') && input.data('placeholder')) {
            input.get(0).setSelectionRange(0, 0);
          }
        }).on('keydown.placeholderPolyfill', function() {
          setInputType(input, 'password', isPassword);
          if (input.val() === input.attr('placeholder') && input.data('placeholder')) {
            input.val('');
            input.removeClass(settings.className);
          }
        }).on('blur.placeholderPolyfill', function() {
          if (input.val() === '') {
            setInputType(input, 'text', isPassword);
            input.addClass(settings.className);
            input.val(input.attr('placeholder'));
            input.data('placeholder', true);
          } else {
            input.data('placeholder', false);
          }
        }).trigger('blur.placeholderPolyfill').parents('form').on('submit', function() {
          $('[placeholder]', this).each(function () {
            var field = $(this);
            if (field.val() === field.attr('placeholder') && field.data('placeholder')) {
              field.val('');
            }
          });
        });
      });
    }
   return this;
  };

  // Parse options from attribute and return obj
  $.fn.parseOptions = function(element, attr) {
    var options;

    attr = attr || 'data-options'; //default
    options = $(element).attr(attr);

    if (options && options.length) {
      if (options.indexOf('{') > -1) {
        try {
          options = JSON.parse(options.replace(/'/g, '"'));
        } catch(err) {
          // Attempt a manual parse
          var regex = /({|,)(?:\s*)(?:')?([A-Za-z_$\.][A-Za-z0-9_ \-\.$]*)(?:')?(?:\s*):/g; //get keys
          options = options.replace(regex, '$1\"$2\":'); //add double quotes to keys
          regex = /:(?:\s*)(?!(true|false|null|undefined))([A-Za-z_$\.#][A-Za-z0-9_ \-\.$]*)/g; //get strings in values
          options = options.replace(regex, ':\"$2\"'); //add double quotes to strings in values
          options = JSON.parse(options.replace(/'/g, '"')); //replace single to double quotes
        }
      }
    }

    if (!options) {
      options = {};
    }

    return options;
  };

  // Timer - can be use for play/pause or stop for given time
  // use as new instance [ var timer = new $.fn.timer(function() {}, 6000); ]
  // then can be listen events as [ $(timer.event).on('update', function(e, data){console.log(data.counter)}); ]
  // or can access as [ timer.cancel(); -or- timer.pause(); -or- timer.resume(); ]
  $.fn.timer = function(callback, delay) {
    var self = $(this),
      interval,
      speed = 10,
      counter = 0,
      cancel = function() {
        self.triggerHandler('cancel');
        clearInterval(interval);
        counter = 0;
      },
      pause = function() {
        self.triggerHandler('pause');
        clearInterval(interval);
      },
      update = function() {
        interval = setInterval(function() {
          counter += speed;
          self.triggerHandler('update', [{'counter': counter}]);
          if (counter > delay) {
            self.triggerHandler('timeout');
            callback.apply(arguments);
            clearInterval(interval);
            counter = 0;
          }
        }, speed);
      },
      resume = function() {
        self.triggerHandler('resume');
        update();
      };

      update();
    return { event: this, cancel: cancel, pause: pause, resume: resume };
  };

  // Copies a string to the clipboard. Must be called from within an event handler such as click.
  // May return false if it failed, but this is not always
  // possible. Browser support for Chrome 43+, Firefox 42+, Edge and IE 10+.
  // No Safari support, as of (Nov. 2015). Returns false.
  // IE: The clipboard feature may be disabled by an adminstrator. By default a prompt is
  // shown the first time the clipboard is used (per session).
  $.copyToClipboard = function(text) {
    if (window.clipboardData && window.clipboardData.setData) {
      // IE specific code path to prevent textarea being shown while dialog is visible.
      return window.clipboardData.setData('Text', text);
    }
    else if (document.queryCommandSupported && document.queryCommandSupported('copy')) {
      var textarea = document.createElement('textarea');
      textarea.textContent = text;
      textarea.style.position = 'fixed'; // Prevent scrolling to bottom of page in MS Edge.
      document.body.appendChild(textarea);
      textarea.select();
      try {
        return document.execCommand('copy'); // Security exception may be thrown by some browsers.
      }
      catch (ex) {
        // console.warn('Copy to clipboard failed.', ex);
        return false;
      }
      finally {
        document.body.removeChild(textarea);
      }
    }
  };

  //Functions For Sanitising and Escaping Html
  $.escapeHTML = function(value) {
    var newValue = value;
    if (typeof value === 'string') {
      newValue = newValue.replace(/&/g, '&amp;');
      newValue = newValue.replace(/</g, '&lt;').replace(/>/g, '&gt;');
    }
    return newValue;
  };

  $.unescapeHTML = function(value) {
    var newValue = value;
    if (typeof value === 'string') {
      newValue = newValue.replace(/&lt;/g, '<').replace(/&gt;/g, '>');
      newValue = newValue.replace(/&amp;/g, '&');
    }
    return newValue;
  };

  //Remove Script tags and all onXXX functions
  $.sanitizeHTML = function(html) {
    var santizedHtml = html.replace(/<script\b[^<]*(?:(?!<\/script>)<[^<]*)*<\/script>/g, '');
     santizedHtml = santizedHtml.replace(/on\w+="[^"]*"/g, '');
     santizedHtml = santizedHtml.replace(/ on\w+='[^']*'/g, '');

    return santizedHtml;
  };

  //Hide Focus - Only show on key entry
  $.fn.hideFocus = function() {
    var element = $(this),
      label = element.next(),
      isClick = false,
      isFocused = false,
      labelClicked = false;

    // Checkbox, Radio buttons or Switch
    if (element.is('.checkbox, .radio, .switch')) {
      if (label.is('[type="hidden"]')) {
        label = label.next();
      }
      element.addClass('hide-focus')
        .on('focusin.hide-focus', function() {
          if (!isClick && !isFocused && !labelClicked) {
            element.removeClass('hide-focus');
          }
          isClick = false;
          isFocused = true;
          labelClicked = false;
        })
        .on('focusout.hide-focus', function() {
          element.addClass('hide-focus');
          labelClicked = label.is(labelClicked);
          isClick = false;
          isFocused = false;
        });

      label.on('mousedown.hide-focus', function() {
        labelClicked = this;
        isClick = true;
        element.addClass('hide-focus');
      });
    }

    // All other elements (ie. Hyperlinks)
    else {
      element.addClass('hide-focus')
        .on('mousedown.hide-focus touchstart.hide-focus', function() {
          isClick = true;
          element.addClass('hide-focus');
        })
        .on('focusin.hide-focus', function() {
          if (!isClick && !isFocused) {
            element.removeClass('hide-focus');
          }
          isClick = false;
          isFocused = true;
        })
        .on('focusout.hide-focus', function() {
          element.addClass('hide-focus');
          isClick = false;
          isFocused = false;
        });
    }
  };

  //Clearable (Shows an X to clear)
  $.fn.clearable = function() {
    var self = this;
    this.element = $(this);

    //Create an X icon button styles in icons.scss
    this.xButton = $.createIconElement({ classes: 'close is-empty', icon: 'close' }).icon();

    //Create a function
    this.checkContents = function () {
      var text = self.element.val();
      if (!text || !text.length) {
        this.xButton.addClass('is-empty');
      } else {
        this.xButton.removeClass('is-empty');
      }

      this.element.trigger('contents-checked');
    };

    //Add the button to field parent
    self.element.parent().append(this.xButton);

    //Handle Events
    this.xButton.offTouchClick('clearable').off()
      .onTouchClick('clearable', '.clearable')
      .on('click.clearable', function handleClear() {
        self.element.val('').trigger('change').focus().trigger('cleared');
        self.checkContents();
      });

    this.element.on('change.clearable, blur.clearable, keyup.clearable', function () {
      self.checkContents();
    });

    //Set initial state
    this.checkContents();
  };

  // Replacement for String.fromCharCode() that takes meta keys into account when determining which
  // character key was pressed.
  $.actualChar = function(e) {
      var key = e.which,
        character = '',
        toAscii = {
          '188': '44',
          //'109': '45', // changes "m" to "-" when using keypress
          '190': '46',
          '191': '47',
          '192': '96',
          '220': '92',
          '222': '39',
          '221': '93',
          '219': '91',
          '173': '45',
          '187': '61', //IE Key codes
          '186': '59', //IE Key codes
          '189': '45'  //IE Key codes
        },
        shiftUps = {
          '96': '~',
          '49': '!',
          '50': '@',
          '51': '#',
          '52': '$',
          '53': '%',
          '54': '^',
          '55': '&',
          '56': '*',
          '57': '(',
          '48': ')',
          '45': '_',
          '61': '+',
          '91': '{',
          '93': '}',
          '92': '|',
          '59': ':',
          '37': '%',
          '38': '&',
          '39': '\"',
          '44': '<',
          '46': '>',
          '47': '?'
        };

      // Normalize weird keycodes
      if (toAscii.hasOwnProperty(key)) {
        key = toAscii[key];
      }

      // Convert Keycode to Character String
      if (!e.shiftKey && (key >= 65 && key <= 90)) {
        character = String.fromCharCode(key + 32);
      } else if (e.shiftKey && shiftUps.hasOwnProperty(key)) { // User was pressing Shift + any key
        character = shiftUps[key];
      } else {
        character = String.fromCharCode(key);
      }

      return character;
  };

  window.Soho.utils.equals = function equals(a, b) {
    return JSON.stringify(a) === JSON.stringify(b);
  };

  // Returns an array containing an element's attributes.
  window.Soho.DOM.getAttributes = function getAttributes(element) {
    if (!element || (!(element instanceof HTMLElement) && !(element instanceof SVGElement))) {
      return;
    }

    return element.attributes;
  };

  //Adding, removing, and testing for classes
  window.Soho.DOM.classNameExists = function classNameExists(element) {
    var cn = element.className;
    return cn && cn.length > 0;
  };

  window.Soho.DOM.classNameHas = function has(classNameString, targetContents) {
    return classNameString.indexOf(targetContents) > -1;
  };

  window.Soho.DOM.hasClass = function hasClass (el, className) {
    return el.classList ? el.classList.contains(className) : new RegExp('\\b'+ className+'\\b').test(el.className);
	};

  window.Soho.DOM.addClass = function addClass(el, className) {
     if (el.classList) {
      el.classList.add(className);
    } else if (!window.Soho.DOM.hasClass(el, className)) {
      el.className += ' ' + className;
    }
  };

  /**
   * Checks if an element is valid
   * @param {HTMLElement|SVGElement|jQuery[]} el - The element being checked
   * @returns {boolean} - represents all values normally contained by a DOMRect or ClientRect
   */
  window.Soho.DOM.isElement = function isElement(el) {
    if ((el instanceof HTMLElement) || (el instanceof SVGElement) || (el instanceof $ && el.length)) {
      return true;
    }
    return false;
  };

  /**
   * Runs the generic _getBoundingClientRect()_ method on an element, but returns its results
   * as a plain object instead of a ClientRect
   * @param {HTMLElement|SVGElement|jQuery[]} el - The element being manipulated
   * @returns {object} - represents all values normally contained by a DOMRect or ClientRect
   */
  window.Soho.DOM.getDimensions = function getDimensions(el) {
    if (!Soho.DOM.isElement(el)) {
      return {};
    }

    if (el instanceof $) {
      if (!el.length) {
        return {};
      }

      el = el[0];
    }

    var rect = el.getBoundingClientRect(),
      rectObj = {};
    for (var prop in rect) {
      if (!isNaN(rect[prop])) {
        rectObj[prop] = rect[prop];
      }
    }
    return rectObj;
  };

  // Debounce method
  window.Soho.utils.debounce = function(func, threshold, execAsap) {
    var timeout;

    return function debounced () {
      var obj = this, args = arguments;
      function delayed () {
        if (!execAsap) {
          func.apply(obj, args);
        }
        timeout = null;
      }

      if (timeout) {
        clearTimeout(timeout);
      } else if (execAsap) {
        func.apply(obj, args);
      }

      timeout = setTimeout(delayed, threshold || 100);
    };
  };

  // Debounced Resize method
  // https://www.paulirish.com/2009/throttled-smartresize-jquery-event-handler/
  (function($,sr){
    // smartresize
    $.fn[sr] = function(fn){  return fn ? this.bind('resize', Soho.utils.debounce(fn)) : this.trigger(sr); };
  })($, 'debouncedResize');

  // String parsing utils
  window.Soho.string = {};

  /**
   * The splice() method changes the content of a string by removing a range of
   * characters and/or adding new characters.
   *
   * @param {String} str The string that will be manipulated.
   * @param {number} start Index at which to start changing the string.
   * @param {number} delCount An integer indicating the number of old chars to remove.
   * @param {string} newSubStr The String that is spliced in.
   * @return {string} A new string with the spliced substring.
   */
  window.Soho.string.splice = function splice(str, start, delCount, newSubStr) {
    return str.slice(0, start) + newSubStr + str.slice(start + Math.abs(delCount));
  };

  /**
   * Hack for IE11 and SVGs that get moved around/appended at inconvenient times.
   * The action of changing the xlink:href attribute to something else and back will fix the problem.
   * @return {undefined}
   */
  window.Soho.utils.fixSVGIcons = function fixSVGIcons(rootElement) {
    if (Soho.env.browser.name !== 'ie' && Soho.env.browser.version !== '11') {
      return;
    }

    if (rootElement === undefined) {
      return;
    }

    if (rootElement instanceof $) {
      if (!rootElement.length) {
        return;
      }

      rootElement = rootElement[0];
    }

    setTimeout(function () {
      var uses = rootElement.getElementsByTagName('use');
      for (var i = 0; i < uses.length; i++) {
        var attr = uses[i].getAttribute('xlink:href');
        uses[i].setAttribute('xlink:href', 'x');
        uses[i].setAttribute('xlink:href', attr);
      }
    }, 1);
  };

  /**
   * Gets the current size of the viewport
   * @returns {object}
   */
  window.Soho.utils.getViewportSize = function getViewportSize() {
    return {
      width: Math.max(document.documentElement.clientWidth, window.innerWidth || 0),
      height: Math.max(document.documentElement.clientHeight, window.innerHeight || 0)
    };
  };

  /**
   * Gets the various scrollable containers that an element is nested inside of, and returns their scrollHeight and scrollLeft values.
   * @returns {object[]}
   */
  window.Soho.utils.getContainerScrollDistance = function getContainerScrollDistance(element) {
    if (!Soho.DOM.isElement(element)) {
      return [];
    }

    var containers = [],
      scrollableElements = [
        '.scrollable', '.scrollable-x', '.scrollable-y', '.modal',
        '.card-content', '.widget-content', '.tab-panel',
        '.datagrid-content'
      ];

    $(element).parents(scrollableElements.join(', ')).each(function() {
      var el = this;

      containers.push({
        element: el,
        left: el.scrollLeft,
        top: el.scrollTop
      });
    });

    // Push the body's scroll area if it's not a "no-scroll" area
    if (!document.body.classList.contains('no-scroll')) {
      containers.push({
        element: document.body,
        left: document.body.scrollLeft,
        top: document.body.scrollTop
      });
    }

    return containers;
  };

  /**
   * Takes an element that is currently hidden by some means (FX: "display: none;") and gets its potential dimensions by checking a clone of the element that is NOT hidden.
   * @param {HTMLElement|SVGElement|jQuery[]} el - The element being manipulated.
   * @param {object} options - incoming options.
   * @param {jQuery[]} [parentElement=undefined] - the parent element where a clone of this hidden element will be attached.
   * @returns {object}
   */
  window.Soho.utils.getHiddenSize = function getHiddenSize(el, options) {
    var defaults = {
      dims: { width: 0, height: 0, innerWidth: 0, innerHeight: 0, outerWidth: 0, outerHeight: 0 },
      parentElement: undefined,
      includeMargin: false
    };

    if (!Soho.DOM.isElement(el)) {
      return defaults.dims;
    }

    el = $(el);
    options = $.extend({}, defaults, options);

    // element becomes clone and appended to a parentElement, if defined
    var hasDefinedParentElement = Soho.DOM.isElement(options.parentElement);
    if (hasDefinedParentElement) {
      el = el.clone().appendTo(options.parentElement);
    }

    var dims = options.dims,
      hiddenParents = el.parents().add(el),
      props = {
        transition: 'none',
        webkitTransition: 'none',
        mozTransition: 'none',
        msTransition: 'none',
        visibility: 'hidden',
        display: 'block',
      },
      oldProps = [];

    hiddenParents.each(function () {
      var old = {};

      for (var name in props) {
        if (this.style[name]) {
          old[name] = this.style[name];
          this.style[name] = props[name];
        }
      }

      oldProps.push(old);
    });

    dims.padding = {
      bottom: el.css('padding-bottom'),
      left: el.css('padding-left'),
      right: el.css('padding-right'),
      top: el.css('padding-top')
    };
    dims.width = el.width();
    dims.outerWidth = el.outerWidth(options.includeMargin);
    dims.innerWidth = el.innerWidth();
    dims.scrollWidth = el[0].scrollWidth;
    dims.height = el.height();
    dims.innerHeight = el.innerHeight();
    dims.outerHeight = el.outerHeight(options.includeMargin);
    dims.scrollHeight = el[0].scrollHeight;

    hiddenParents.each(function (i) {
      var old = oldProps[i];
      for (var name in props) {
        if (old[name]) {
          this.style[name] = old[name];
        }
      }
    });

    // element is ONLY removed when a parentElement is defined because it was cloned.
    if (hasDefinedParentElement) {
      el.remove();
    }

    return dims;
  };

  /**
   * Binds the Soho Util _getHiddenSize()_ to a jQuery selector
   * @param {object} options - incoming options
   * @returns {object}
   */
  $.fn.getHiddenSize = function(options) {
    return window.Soho.utils.getHiddenSize(this, options);
  };

  //==================================================================
  // Simple Behaviors
  //==================================================================
  window.Soho.behaviors = {};

  /**
   * Allows for the smooth scrolling of an element's content area.
   * @param {HTMLElement|SVGElement|jQuery[]} el - The element being manipulated.
   * @param {Number} target - target distance.
   * @param {Number} duration - the time that will be needed for the scrolling to complete.
   * @returns {$.Deferred}
   */
  window.Soho.behaviors.smoothScrollTo = function(el, target, duration) {
    var dfd = $.Deferred();

    if (!Soho.DOM.isElement(el)) {
      // Not a workable element
      return dfd.reject();
    }

    // Strip the jQuery
    if (el instanceof $ && el.length) {
      el = el[0];
    }

    // undefined (not zero) target should instantly resolve
    if (target === undefined || target === null) {
      return dfd.resolve();
    }

    if (isNaN(duration)) {
      duration = 0;
    }

    target = Math.round(target);
    duration = Math.round(duration);

    if (duration < 0) {
      // bad duration
      return dfd.fail();
    }

    if (duration === 0) {
      el.scrollLeft = el.scrollLeft + target;
      return dfd.resolve();
    }

    var startTime = Date.now(),
      endTime = startTime + duration,
      startLeft = el.scrollLeft,
      distance = target /*- startLeft*/;

    // based on http://en.wikipedia.org/wiki/Smoothstep
    function smoothStep(start, end, point) {
      if (point <= start) { return 0; }
      if (point >= end) { return 1; }
      var x = (point - start) / (end - start); // interpolation
      return x*x*(3 - 2*x);
    }

    // This is to keep track of where the element's scrollLeft is
    // supposed to be, based on what we're doing
    var previousLeft = el.scrollLeft;

    // This is like a think function from a game loop
    function scrollFrame() {
      if (el.scrollLeft !== previousLeft) {
        // interrupted
        dfd.reject();
        return;
      }

      // set the scrollLeft for this frame
      var now = Date.now();
      var point = smoothStep(startTime, endTime, now);
      var frameLeft = Math.round(startLeft + (distance * point));
      el.scrollLeft = frameLeft;

      // check if we're done!
      if (now >= endTime) {
        dfd.resolve();
        return;
      }

      // If we were supposed to scroll but didn't, then we
      // probably hit the limit, so consider it done; not
      // interrupted.
      if (el.scrollLeft === previousLeft && el.scrollLeft !== frameLeft) {
        dfd.resolve();
        return;
      }
      previousLeft = el.scrollLeft;

      // schedule next frame for execution
      setTimeout(scrollFrame, 0);
    }

    // boostrap the animation process
    setTimeout(scrollFrame, 0);

    return dfd;
  };

  /**
   * Binds the Soho Behavior _smoothScrollTo()_ to a jQuery selector
   * @param {Number} target - target distance to scroll the element
   * @param {Number} duration - the time that will be needed for the scrolling to complete.
   * @returns {$.Deferred}
   */
  $.fn.smoothScroll = function(target, duration) {
    return window.Soho.behaviors.smoothScrollTo(this, target, duration);
  };

  //==================================================================
  // JS-level Breakpoint Access
  // NOTE: these should match whatever the breakpoints are in "/sass/_config.scss"
  //==================================================================
  window.Soho.breakpoints = {
    'phone': 320,
    'slim': 400,
    'phablet': 610,
    'phone-to-tablet': 767,
    'wide-tablet': 968,
    'tablet-to-desktop': 1280,
    'desktop-to-extralarge': 1600
  };

  /**
   * @param {string} breakpoint - matches one of the entries in the "Soho.breakpoints" object.
   * @returns {boolean}
   */
  window.Soho.breakpoints.isAbove = function isAbove(breakpoint) {
    var bp = Soho.breakpoints[breakpoint];
    if (!bp) {
      return false;
    }

    var windowWidth = $(window).width();
    return windowWidth > bp;
  };

  /**
   * @param {string} breakpoint - matches one of the entries in the "Soho.breakpoints" object.
   * @returns {boolean}
   */
  window.Soho.breakpoints.isBelow = function isBelow(breakpoint) {
    var bp = Soho.breakpoints[breakpoint];
    if (!bp) {
      return false;
    }

    var windowWidth = $(window).width();
    return windowWidth < bp;
  };


// Page Bootstrapper


  var environment = {

    // Setup a global resize event trigger for controls to listen to
    addGlobalResize: function() {
      $(window).debouncedResize(function() {
        $('body').triggerHandler('resize', [window]);
      });

      return this;
    },

    set: function () {
      this
        .makeSohoObject()
        .addBrowserClasses()
        .addGlobalResize();
    },

    // Global Classes for browser, version and device as needed.
    addBrowserClasses: function() {
      var ua = navigator.userAgent || navigator.vendor || window.opera,
        html = $('html'),
        cssClasses = ''; // User-agent string

      if (ua.indexOf('Safari')  !== -1 &&
          ua.indexOf('Chrome')  === -1 &&
          ua.indexOf('Android') === -1) {
        cssClasses += 'is-safari ';
        Soho.env.browser.name = 'safari';
      }

      if (ua.indexOf('Chrome') !== -1) {
        cssClasses += 'is-chrome ';
        Soho.env.browser.name = 'chrome';
      }

      if (ua.indexOf('Mac OS X') !== -1) {
        cssClasses += 'is-mac ';
        Soho.env.os.name = 'Mac OS X';
      }

      if (ua.indexOf('Firefox') > 0) {
        cssClasses += 'is-firefox ';
        Soho.env.browser.name = 'firefox';
      }

      //Class-based detection for IE
      if (ua.match(/Edge\//)) {
        cssClasses += 'ie ie-edge ';
        Soho.env.browser.name = 'edge';
      }
      if (ua.match(/Trident/)) {
        cssClasses += 'ie ';
        Soho.env.browser.name = 'ie';
      }
      if (navigator.appVersion.indexOf('MSIE 8.0') > -1 ||
        ua.indexOf('MSIE 8.0') > -1 ||
        document.documentMode === 8) {
        cssClasses += 'ie8 ';
        Soho.env.browser.version = '8';
      }
      if (navigator.appVersion.indexOf('MSIE 9.0') > -1) {
        cssClasses += 'ie9 ';
        Soho.env.browser.version = '9';
      }
      if (navigator.appVersion.indexOf('MSIE 10.0') > -1) {
        cssClasses += 'ie10 ';
        Soho.env.browser.version = '10';
      } else {
        if (ua.match(/Trident\/7\./)) {
          cssClasses += 'ie11 ';
          Soho.env.browser.version = '11';
        }
      }

      // Class-based detection for iOS
      // /iPhone|iPod|iPad|Silk|Android|BlackBerry|Opera Mini|IEMobile/
      if ((/iPhone|iPod|iPad/).test(ua)) {
        cssClasses += 'ios ';
        Soho.env.os.name = 'ios';

        var iDevices = ['iPod', 'iPad', 'iPhone'];
        for (var i = 0; i < iDevices.length; i++) {
          if (new RegExp(iDevices[i]).test(ua)) {
            cssClasses += iDevices[i].toLowerCase() + ' ';
            Soho.env.device = iDevices[i];
          }
        }
      }

      if ((/Android/.test(ua))) {
        cssClasses += 'android ';
        Soho.env.os.name = 'android';
      }

      html.addClass(cssClasses);

      return this;
    },

    makeSohoObject: function() {
      window.Soho = window.Soho || {};

      window.Soho.logTimeStart = function(label) {
        if (window.Soho.logTime) {
          console.time(label); // jshint ignore:line
        }
      };

      window.Soho.logTimeEnd = function(label) {
        if (window.Soho.logTime) {
          console.timeEnd(label); // jshint ignore:line
        }
      };

      // Environment object provides JS-friendly way to figure out our browser support
      window.Soho.env = {
        browser: {},
        os: {}
      };

      // Get the name of the paste event.  Could be "paste" or "input" based on the browser.
      window.Soho.env.pasteEvent = (function getPasteEvent() {
        var el = document.createElement('input'),
            name = 'onpaste';
        el.setAttribute(name, '');
        return ((typeof el[name] === 'function') ? 'paste' : 'input');
      })();

      window.Soho.theme = 'light';

      return this;
    }

  };

  environment.set();
// Height Animation Controls
// Adapted from: http://n12v.com/css-transition-to-from-auto/
// Contains a handful of animation helper methods that attempt to DRY up CSS-powered sliding animations.


  // Use CSS Transitions to animate from "0" to "auto" widths
  $.fn.animateOpen = function(options) {
    'use strict';

    // Settings and Options
    var defaults = {
        direction: 'vertical', // Can also be 'horizontal'
        distance: 'auto', // Distance in pixels that the animation covers.  'auto', or pixel value size
        timing: 300, // in Miliseconds
        transition: 'cubic-bezier(.17, .04, .03, .94)' // CSS Transition Timing Function
      },
      settings = $.extend({}, defaults, options);

    // Initialize the plugin (Once)
    return this.each(function() {
      var self = this,
        $self = $(this),
        eventName = $.fn.transitionEndName(),
        dim = settings.direction === 'horizontal' ? 'width' : 'height',
        cDim = dim.charAt(0).toUpperCase() + dim.slice(1),
        distance = !isNaN(settings.distance) ? parseInt(settings.distance, 10) + 'px' : 'auto',
        timeout;

      function transitionEndCallback() {
        if (timeout) {
          clearTimeout(timeout);
        }

        if ($self.data('ignore-animation-once')) {
          $.removeData($self[0], 'ignore-animation-once');
        }

        if ($self.data('is-animating')) {
          $.removeData($self[0], 'is-animating');
        }

        $self.off(eventName + '.animateopen');
        self.style.transition = '';
        self.style[dim] = distance;
        $self.trigger('animateopencomplete');
      }

      // Clear any previous attempt at this animation when the animation starts new
      $self.one('animateopenstart.animation', function(e) {
        e.stopPropagation();
        $self.off(eventName + '.animateopen');
      });
      $self.trigger('animateopenstart');

      // Trigger the callback either by Timeout or by TransitionEnd
      if (eventName) {
        $self.one(eventName + '.animateopen', transitionEndCallback);
      }

      // Animate
      $self.data('is-animating', true);
      var prevVal = this.style[dim];
      this.style[dim] = distance;
      var endVal = getComputedStyle(this)[dim];
      this.style[dim] = prevVal;
      // next line forces a repaint
      this['offset' + cDim]; // jshint ignore:line
      this.style.transition = dim + ' ' + settings.timing + 'ms ' + settings.transition;

      timeout = setTimeout(transitionEndCallback, settings.timing);
      this.style[dim] = endVal;

      // Trigger immediately if this element is invisible or has the 'no-transition' class
      if ($self.is(':hidden') || $self.is('.no-transition') || $self.data('ignore-animation-once')) {
        transitionEndCallback();
      }
    });
  };

  // Use CSS Transitions to animate from "auto" to "0" widths
  $.fn.animateClosed = function(options) {

    // Settings and Options
    var defaults = {
        direction: 'vertical', // can also be 'horizontal'
        timing: 300, // in Miliseconds
        transition: 'cubic-bezier(.17, .04, .03, .94)'
      },
      settings = $.extend({}, defaults, options);

    // Initialize the plugin (Once)
    return this.each(function() {
      var self = this,
        $self = $(this),
        eventName = $.fn.transitionEndName(),
        dim = settings.direction === 'horizontal' ? 'width' : 'height',
        cDim = dim.charAt(0).toUpperCase() + dim.slice(1),
        timeout;

      function transitionEndCallback() {
        if (timeout) {
          clearTimeout(timeout);
        }

        if ($self.data('ignore-animation-once')) {
          $.removeData($self[0], 'ignore-animation-once');
        }

        if ($self.data('is-animating')) {
          $.removeData($self[0], 'is-animating');
        }

        $self.off(eventName + '.animatedclosed');
        self.style.transition = '';
        self.style[dim] = '0px';
        $self.trigger('animateclosedcomplete');
      }

      // Clear any previous attempt at this animation when the animation starts new
      $self.one('animateclosedstart', function(e) {
        e.stopPropagation();
        $self.off(eventName + '.animatedclosed');
      });
      $self.trigger('animateclosedstart');

      // Trigger the callback either by Timeout or by TransitionEnd
      if (eventName) {
        $self.one(eventName + '.animatedclosed', transitionEndCallback);
      }

      // Animate
      $self.data('is-animating', true);
      this.style[dim] = getComputedStyle(this)[dim];
      // next line forces a repaint
      this['offset' + cDim]; // jshint ignore:line
      this.style.transition = dim + ' ' + settings.timing + 'ms ' + settings.transition;

      timeout = setTimeout(transitionEndCallback, settings.timing);
      this.style[dim] = '0px';

      // Trigger immediately if this element is invisible or has the 'no-transition' class
      if ($self.is(':hidden') || $self.is('.no-transition') || $self.data('ignore-animation-once')) {
        transitionEndCallback();
      }
    });
  };

  // Chainable jQuery plugin that checks if an element is in the process of animating
  $.fn.isAnimating = function() {
    return this.each(function() {
      return $(this).data('is-animating') === true;
    });
  };

// Localization Routines
// Data From: http://www.unicode.org/repos/cldr-aux/json/22.1/main/
// For Docs See: http://ibm.co/1nXyNxp


  //If there already exists a Locale object with a culturesPath use that path
  //This allows manually setting the directory for the culture files to be retrieved from
  var existingCulturePath = '';

  if (window.Locale && window.Locale.hasOwnProperty('culturesPath')) {
    existingCulturePath = window.Locale.culturesPath;
  }

  window.Locale = {

    currentLocale:  {name: '', data: {}}, //default
    cultures: {},
    culturesPath: existingCulturePath,

    //Sets the Lang in the Html Header
    updateLang: function () {
      var html = $('html');

      html.attr('lang', this.currentLocale.name);
      if (this.isRTL()) {
        html.attr('dir', 'rtl');
      } else {
        html.removeAttr('dir');
      }
    },

    //Get the path to the directory with the cultures
    getCulturesPath: function() {
      if (!this.culturesPath) {
        var scripts = document.getElementsByTagName('script'),
          partialPathMin = 'sohoxi.min.js',
          partialPath = 'sohoxi.js';

        for (var i = 0; i < scripts.length; i++) {
          var src = scripts[i].src;

          //remove from ? to end
          var idx = src.indexOf('?');
          if (src !== '' && idx > -1) {
            src = src.substr(0, idx);
          }

          if (scripts[i].id === 'sohoxi-script') {
            return src.substring(0, src.lastIndexOf('/')) + '/';
          }

          if (src.indexOf(partialPathMin) > -1) {
            this.culturesPath = src.replace(partialPathMin, '') + 'cultures/';
          }
          if (src.indexOf(partialPath) > -1) {
            this.culturesPath = src.replace(partialPath, '') + 'cultures/';
          }


        }
      }
      return this.culturesPath;
    },

    cultureInHead: function() {
      var isThere = false,
        scripts = document.getElementsByTagName('script'),
        partialPath = 'cultures';


        for (var i = 0; i < scripts.length; i++) {
          var src = scripts[i].src;

          if (src.indexOf(partialPath) > -1) {
            isThere = true;
          }
        }

      return isThere;
    },

    addCulture: function(locale, data) {
      this.cultures[locale] = data;
    },

    //Set the Local
    set: function (locale) {

      var self = this;
      this.dff = $.Deferred();

      //Map incorrect java locale to correct locale
      if (locale === 'in-ID') {
        locale = 'id-ID';
      }
      if (locale && !this.cultures[locale] && this.currentLocale.name !== locale) {
        this.setCurrentLocale(locale);

        //fetch the local and cache it
        $.ajax({
          url: this.getCulturesPath() + this.currentLocale.name + '.js',
          dataType: 'script',
          error: function () {
            self.dff.reject();
          }
        }).done(function () {
          self.setCurrentLocale(locale, self.cultures[locale]);
          self.addCulture(locale, self.currentLocale.data);
          self.dff.resolve(self.currentLocale.name);
        });
      }

      if (locale && self.currentLocale.data && self.currentLocale.dataName === locale) {
        self.dff.resolve(self.currentLocale.name);
      }

      self.setCurrentLocale(locale, self.cultures[locale]);

      if (self.cultures[locale] && this.cultureInHead()) {
        self.dff.resolve(self.currentLocale.name);
      }
      return this.dff.promise();
    },

    setCurrentLocale: function(name, data) {
      this.currentLocale.name = name;

      if (data) {
        this.currentLocale.data = data;
        this.currentLocale.dataName = name;
      }
      this.updateLang();
    },

    //Format a Date Object and return it parsed in the current locale
    formatDate: function(value, attribs) {

      //We will use http://www.unicode.org/reports/tr35/tr35-dates.html#Date_Field_Symbol_Table
      if (!attribs) {
        attribs = {date: 'short'};  //can be date, time, datetime or pattern
      }

      if (!value) {
        return undefined;
      }

      //Convert if a string..
      if (!(value instanceof Date)) {
        var tDate = new Date(value);
        if (isNaN(tDate) && attribs.date === 'datetime' &&
          value.substr(4, 1) === '-' &&
          value.substr(7, 1) === '-') {
          tDate = new Date(
            value.substr(0, 4),
            value.substr(5, 2) - 1,
            value.substr(8, 2),
            value.substr(11, 2),
            value.substr(14, 2),
            value.substr(17, 2)
          );
        }
        value = tDate;
      }

      // TODO: Can we handle this if (this.dff.state()==='pending')
       var data = this.currentLocale.data,
        pattern, ret = '', cal = (data.calendars ? data.calendars[0] : null);

      if (attribs.pattern) {
        pattern = attribs.pattern;
      }

      if (attribs.date) {
        pattern = cal.dateFormat[attribs.date];
      }

      var day = value.getDate(), month = value.getMonth(), year = value.getFullYear(),
        mins = value.getMinutes(), hours = value.getHours(), seconds = value.getSeconds();

      //Special
      pattern = pattern.replace('ngy','nnnn');
      pattern = pattern.replace('thng','t1ng');
      pattern = pattern.replace('den','nnn');

      //Day of Month
      ret = pattern.replace('dd', this.pad(day, 2));
      ret = ret.replace('d', day);

      //years
      ret = ret.replace('yyyy', year);
      ret = ret.replace('yy', year.toString().substr(2));
      ret = ret.replace('y', year);

      //Time
      var showDayPeriods = ret.indexOf(' a') > -1;

      if (showDayPeriods && hours === 0) {
        ret = ret.replace('hh', 12);
        ret = ret.replace('h', 12);
      }

      ret = ret.replace('hh', (hours > 12 ? this.pad(hours - 12, 2) : this.pad(hours, 2)));
      ret = ret.replace('h', (hours > 12 ? hours - 12 : hours));
      ret = ret.replace('HH', this.pad(hours, 2));
      ret = ret.replace('H', (hours > 12 ? hours - 12 : hours));
      ret = ret.replace('mm', this.pad(mins, 2));
      ret = ret.replace('ss', this.pad(seconds, 2));
      ret = ret.replace('SSS', this.pad(value.getMilliseconds(), 0));

      //months
      ret = ret.replace('MMMM', cal ? cal.months.wide[month] : null);  //full
      ret = ret.replace('MMM',  cal ? cal.months.abbreviated[month] : null);  //abreviation
      if (pattern.indexOf('MMM') === -1) {
        ret = ret.replace('MM', this.pad(month+1, 2));  //number padded
        ret = ret.replace('M', month+1);                //number unpadded
      }

      //PM
      if (cal) {
        ret = ret.replace(' a', ' '+ (hours >= 12 ? cal.dayPeriods[1] : cal.dayPeriods[0]));
        ret = ret.replace('EEEE', cal.days.wide[value.getDay()]);  //Day of Week
      }

      //Day of Week
      if (cal) {
        ret = ret.replace('EEEE', cal.days.wide[value.getDay()]);  //Day of Week
      }
      ret = ret.replace('nnnn','ngy');
      ret = ret.replace('t1ng','thng');
      ret = ret.replace('nnn','den');

      return ret.trim();
    },

    isValidDate: function (date) {
      if (Object.prototype.toString.call(date) === '[object Date]') {
        // it is a date
        if (isNaN(date.getTime())) {  // d.valueOf() could also work
          return false;
        } else {
          return true;
        }
      } else {
        return false;
      }
    },

    // Take a date string written in the current locale and parse it into a Date Object
    parseDate: function(dateString, dateFormat, isStrict) {
      var thisLocaleCalendar = this.calendar(),
        orgDatestring = dateString;

      if (!dateString) {
        return undefined;
      }

      if (!dateFormat) {
        dateFormat = this.calendar().dateFormat.short;
      }

      if (dateFormat.pattern) {
        dateFormat = dateFormat.pattern;
      }

      if (typeof dateFormat === 'object' && dateFormat.date)  {
        dateFormat = this.calendar().dateFormat[dateFormat.date];
      }

      var formatParts,
        dateStringParts,
        dateObj = {},
        isDateTime = (dateFormat.toLowerCase().indexOf('h') > -1),
		isUTC = (dateString.toLowerCase().indexOf('z') > -1),
        i, l;

      if (isDateTime) {
        //replace [space & colon & dot] with "/"
        dateFormat = dateFormat.replace(/[T\s:.-]/g,'/').replace(/z/i, '');
        dateString = dateString.replace(/[T\s:.-]/g,'/').replace(/z/i, '');
      }

      if (dateFormat === 'Mdyyyy' || dateFormat === 'dMyyyy') {
        dateString = dateString.substr(0, dateString.length - 4) + '/' + dateString.substr(dateString.length - 4, dateString.length);
        dateString = dateString.substr(0, dateString.indexOf('/')/2) + '/' + dateString.substr(dateString.indexOf('/')/2);
      }

      if (dateFormat === 'Mdyyyy') {
        dateFormat = 'M/d/yyyy';
      }

      if (dateFormat === 'dMyyyy') {
        dateFormat = 'd/M/yyyy';
      }

      if (dateFormat.indexOf(' ') !== -1 ) {
        dateFormat = dateFormat.replace(/[\s:.]/g,'/');
        dateString = dateString.replace(/[\s:.]/g,'/');
      }

      if (dateFormat.indexOf(' ') === -1 && dateFormat.indexOf('.') === -1  && dateFormat.indexOf('/')  === -1 && dateFormat.indexOf('-')  === -1) {
        var lastChar = dateFormat[0],
          newFormat = '', newDateString = '';

        for (i = 0, l = dateFormat.length; i < l; i++) {
          newFormat +=  (dateFormat[i] !== lastChar ? '/' + dateFormat[i]  : dateFormat[i]);
          newDateString += (dateFormat[i] !== lastChar ? '/' + dateString[i]  : dateString[i]);

          if (i > 1) {
            lastChar = dateFormat[i];
          }
        }

        dateString = newDateString;
        dateFormat = newFormat;
      }

      formatParts = dateFormat.split('/');
      dateStringParts = dateString.split('/');

      if (formatParts.length === 1) {
        formatParts = dateFormat.split('.');
      }

      if (dateStringParts.length === 1) {
        dateStringParts = dateString.split('.');
      }

      if (formatParts.length === 1) {
        formatParts = dateFormat.split('-');
      }

      if (dateStringParts.length === 1) {
        dateStringParts = dateString.split('-');
      }

      if (formatParts.length === 1) {
        formatParts = dateFormat.split(' ');
      }

      if (dateStringParts.length === 1) {
        dateStringParts = dateString.split(' ');
      }

      // Check the incoming date string's parts to make sure the values are valid against the localized
      // Date pattern.
      var month = this.getDatePart(formatParts, dateStringParts, 'M', 'MM', 'MMM'),
        year = this.getDatePart(formatParts, dateStringParts, 'yy', 'yyyy'),
        hasDays = false;

      for (i = 0, l = dateStringParts.length; i < l; i++) {
        var pattern = formatParts[i] + '',
          value = dateStringParts[i],
          numberValue = parseInt(value);

        if (!hasDays) {
          hasDays = pattern.toLowerCase().indexOf('d') > -1;
        }

        switch(pattern) {
          case 'd':
            var lastDay = new Date(year, month, 0).getDate();

            if (numberValue < 1 || numberValue > 31 || numberValue > lastDay) {
              return;
            }
            dateObj.day = value;
            break;
          case 'dd':
            if ((numberValue < 1 || numberValue > 31) || (numberValue < 10 && value.substr(0,1) !== '0')) {
              return;
            }
            dateObj.day = value;
            break;
          case 'M':
            if (numberValue < 1 || numberValue > 12) {
              return;
            }
            dateObj.month = value-1;
            break;
          case 'MM':
            if ((numberValue < 1 || numberValue > 12) || (numberValue < 10 && value.substr(0,1) !== '0')) {
              return;
            }
            dateObj.month = value-1;
            break;
          case 'MMM':
              var abrMonth = this.calendar().months.abbreviated;

              for (var len = 0; len < abrMonth.length; len++) {
                if (orgDatestring.indexOf(abrMonth[len]) > -1) {
                  dateObj.month = len;
                }
              }

              break;
          case 'MMMM':
            var textMonths = this.calendar().months.wide;

            for (var k = 0; k < textMonths.length; k++) {
              if (orgDatestring.indexOf(textMonths[k]) > -1) {
                dateObj.month = k;
              }
            }

            break;
          case 'yy':
            dateObj.year = parseInt('20'+value, 10);
            break;
          case 'yyyy':
            dateObj.year = value;
            break;
          case 'h':
            if (numberValue < 0 || numberValue > 12) {
              return;
            }
            dateObj.h = value;
            break;
          case 'HH':
            if (numberValue < 0 || numberValue > 24) {
              return;
            }
            dateObj.h = value;
            break;

          case 'ss':
            if (numberValue < 0 || numberValue > 60) {
              dateObj.ss = 0;
              break;
            }
            dateObj.ss = value;
            break;
			
	      case 'SSS':
            dateObj.ms = value;
            break;

          case 'mm':
            if (numberValue < 0 || numberValue > 60) {
              dateObj.mm = 0;
              break;
            }
            dateObj.mm = value;
            break;

          case 'a':
            if((value.toLowerCase() === thisLocaleCalendar.dayPeriods[0]) ||
             (value.toUpperCase() === thisLocaleCalendar.dayPeriods[0])) {
              dateObj.a = 'AM';

              if (dateObj.h) {
                if (dateObj.h === 12 || dateObj.h === '12') {
                  dateObj.h = 0;
                }
              }
            }

            if((value.toLowerCase() === thisLocaleCalendar.dayPeriods[1]) ||
             (value.toUpperCase() === thisLocaleCalendar.dayPeriods[1])) {
              dateObj.a = 'PM';

              if (dateObj.h) {
                if (dateObj.h < 12) {
                  dateObj.h = parseInt(dateObj.h) + 12;
                }
              }
            }
            break;
        }
      }

      dateObj.return = undefined;
      dateObj.leapYear = ((dateObj.year % 4 === 0) && (dateObj.year % 100 !== 0)) || (dateObj.year % 400 === 0);

      if ((isDateTime && !dateObj.h && !dateObj.mm)) {
        return undefined;
      }

      if (!dateObj.year && dateObj.year !== 0 && !isStrict) {
        dateObj.isUndefindedYear = true;
        for (i = 0, l = formatParts.length; i < l; i++) {
          if (formatParts[i].indexOf('y') > -1 && dateStringParts[i] !== undefined) {
            dateObj.isUndefindedYear = false;
            break;
          }
        }
        if (dateObj.isUndefindedYear) {
          dateObj.year = (new Date()).getFullYear();
        } else {
          delete dateObj.year;
        }
      }

      //Fix incomelete 2 and 3 digit years
      if (dateObj.year && dateObj.year.length === 2) {
        dateObj.year = '20' + dateObj.year;
      }

      // TODO: Need to find solution for three digit year
      // http://jira/browse/SOHO-4691
      // if (dateObj.year && dateObj.year.length === 3) {
      //   dateObj.year = '2' + dateObj.year;
      // }

      dateObj.year = $.trim(dateObj.year);
      dateObj.day = $.trim(dateObj.day);

      if (dateObj.year === '' || (dateObj.year && !((dateObj.year + '').length === 2 || (dateObj.year + '').length === 4))) {
        delete dateObj.year;
      }

      if (!dateObj.month && dateObj.month !== 0 && !isStrict) {
        dateObj.isUndefindedMonth = true;
        for (i = 0, l = formatParts.length; i < l; i++) {
          if (formatParts[i].indexOf('M') > -1 && dateStringParts[i] !== undefined) {
            dateObj.isUndefindedMonth = false;
            break;
          }
        }
        if (dateObj.isUndefindedMonth) {
          dateObj.month = (new Date()).getMonth();
        }
      }

      if (!dateObj.day && dateObj.day !== 0 && (!isStrict || !hasDays)) {
        dateObj.isUndefindedDay = true;
        for (i = 0, l = formatParts.length; i < l; i++) {
          if (formatParts[i].indexOf('d') > -1 && dateStringParts[i] !== undefined) {
            dateObj.isUndefindedDay = false;
            break;
          }
        }
        if (dateObj.isUndefindedDay) {
          dateObj.day = 1;
        } else {
          delete dateObj.day;
        }
      }

      if (isDateTime) {
        if (isUTC) {
          if (dateObj.h) {
            dateObj.return = new Date(Date.UTC(dateObj.year, dateObj.month, dateObj.day, dateObj.h, dateObj.mm));
          }
          if (dateObj.ss !== undefined) {
            dateObj.return = new Date(Date.UTC(dateObj.year, dateObj.month, dateObj.day, dateObj.h, dateObj.mm, dateObj.ss));
          }
          if (dateObj.ms !== undefined) {
            dateObj.return = new Date(Date.UTC(dateObj.year, dateObj.month, dateObj.day, dateObj.h, dateObj.mm, dateObj.ss, dateObj.ms));
          }
        }
        else
        {
          if (dateObj.h) {
            dateObj.return = new Date(dateObj.year, dateObj.month, dateObj.day, dateObj.h, dateObj.mm);
          }
          if (dateObj.ss !== undefined) {
            dateObj.return = new Date(dateObj.year, dateObj.month, dateObj.day, dateObj.h, dateObj.mm, dateObj.ss);
          }
          if (dateObj.ms !== undefined) {
            dateObj.return = new Date(dateObj.year, dateObj.month, dateObj.day, dateObj.h, dateObj.mm, dateObj.ss, dateObj.ms);
          }
        }
      } else {
        dateObj.return = new Date(dateObj.year, dateObj.month, dateObj.day);
      }

      return (this.isValidDate(dateObj.return) ? dateObj.return : undefined);

    },

    getDatePart: function (formatParts, dateStringParts, filter1, filter2, filter3) {
      var ret = 0;

      $.each(dateStringParts, function(i) {
        if (filter1 === formatParts[i] || filter2 === formatParts[i] || filter3 === formatParts[i]) {
          ret = dateStringParts[i];
        }
      });

      return ret;
    },

    //format a decimal with thousands and padding in the current locale
    // options.style can be decimal, currency, percent and integer
    // http://mzl.la/1MUOEWm
    // percentSign, minusSign, decimal, group
    // minimumFractionDigits (0), maximumFractionDigits (3)
    formatNumber: function(number, options) {
      //Lookup , decimals, decimalSep, thousandsSep
      var formattedNum, curFormat, percentFormat,
        decimal = options && options.decimal ? options.decimal : this.numbers().decimal,
        group = options && options.group !== undefined ? options.group : this.numbers().group,
        minimumFractionDigits = options && options.minimumFractionDigits !== undefined ? options.minimumFractionDigits : (options && options.style && options.style === 'currency' ? 2 : (options && options.style && options.style === 'percent') ? 0 : 2),
        maximumFractionDigits = options && options.maximumFractionDigits !== undefined ? options.maximumFractionDigits : (options && options.style && (options.style === 'currency' || options.style === 'percent') ? 2 : (options && options.minimumFractionDigits ? options.minimumFractionDigits : 3));

      if (number === undefined || number === null || number === '') {
        return undefined;
      }

      if (options && options.style === 'integer') {
        maximumFractionDigits = 0;
        minimumFractionDigits = 0;
      }

      //TODO: Doc Note: Uses Truncation
      if (options && options.style === 'currency') {
        var sign = this.currentLocale.data.currencySign;

        curFormat = this.currentLocale.data.currencyFormat;
        curFormat = curFormat.replace('', sign);
      }

      if (options && options.style === 'percent') {
        var percentSign = this.currentLocale.data.numbers.percentSign;

        percentFormat = this.currentLocale.data.numbers.percentFormat;
        percentFormat = percentFormat.replace('', percentSign);
      }

      if (typeof number === 'string') {

        if (decimal !== '.') {
          number = number.replace(decimal, '.');
        }
        number = Locale.parseNumber(number);
      }

      if (options && options.style === 'percent') {
        number = (number * 100).toFixed(minimumFractionDigits);
      }

      var parts = this.truncateDecimals(number, minimumFractionDigits, maximumFractionDigits, options && options.round).split('.');
      parts[0] = parts[0].replace(/\B(?=(\d{3})+(?!\d))/g, group);
      formattedNum = parts.join(decimal);

      if (minimumFractionDigits === 0) { //Not default
        formattedNum = formattedNum.replace(/(\.[0-9]*?)0+$/, '$1'); // remove trailing zeros
        formattedNum = formattedNum.replace(/\.$/, '');              // remove trailing dot
      }

      if (minimumFractionDigits === 0 && decimal !== '.') { //Not default
        formattedNum = formattedNum.replace(/(\,[0-9]*?)0+$/, '$1'); // remove trailing zeros
        formattedNum = formattedNum.replace(/\,$/, '');              // remove trailing dot
      }

      if (minimumFractionDigits > 0) {
        var expr = new RegExp('(\\..{' + minimumFractionDigits+ '}[0-9]*?)0+$');
        formattedNum = formattedNum.replace(expr, '$1'); // remove trailing zeros
        formattedNum = formattedNum.replace(/\.$/, '');  // remove trailing dot
      }

      //Confirm Logic After All Locales are added.
      if (options && options.style === 'currency') {
        formattedNum = curFormat.replace('#,##0.00', formattedNum);
      }

      if (options && options.style === 'percent') {
        formattedNum = percentFormat.replace('#,##0', formattedNum);
      }

      return formattedNum;
    },

    decimalPlaces: function(number) {
      var result= /^-?[0-9]+\.([0-9]+)$/.exec(number);
      return result === null ? 0 : result[1].length;
    },

    truncateDecimals: function (number, minDigits, maxDigits, round) {
      var multiplier = Math.pow(10, maxDigits),
        adjustedNum = number * multiplier,
        truncatedNum;

      //Round Decimals
      var decimals = this.decimalPlaces(number);

      //Handle larger numbers
      if (number.toString().length - decimals - 1 >= 10 ||
        (decimals === minDigits && decimals === maxDigits) || (decimals < maxDigits)) {
        multiplier = Math.pow(100, maxDigits);
        adjustedNum = number * multiplier;
      }

      truncatedNum = Math[adjustedNum < 0 ? 'ceil' : 'floor'](adjustedNum);

      if (round && decimals >= maxDigits && adjustedNum > 0) {
        truncatedNum = Math.round(adjustedNum);
      }

      if (round && decimals <= maxDigits && decimals > 0) {
        truncatedNum = Math.round(adjustedNum);
      }

      if (decimals < maxDigits && decimals > 0) {
        truncatedNum = Math.floor(adjustedNum);
        maxDigits = Math.max(decimals, minDigits);
      }

      return (truncatedNum / multiplier).toFixed(maxDigits);
    },


    //Take a Formatted Number and return a real number
    parseNumber: function(input) {
      var numSettings = this.currentLocale.data.numbers,
        numString, group, decimal, percentSign, currencySign;

      numString = input;

      if (!numString) {
        return NaN;
      }

      group = numSettings ? numSettings.group  : ',';
      decimal = numSettings ? numSettings.decimal  : '.';
      percentSign = numSettings ? numSettings.percentSign  : '%';
      currencySign = currencySign ? this.currentLocale.data.currencySign  : '$';

      numString = numString.replace(new RegExp('\\' + group, 'g'), '');
      numString = numString.replace(decimal, '.');
      numString = numString.replace(percentSign, '');
      numString = numString.replace(currencySign, '');
      numString = numString.replace(' ', '');

      return parseFloat(numString);
    },

    // Overridable culture messages
    translate: function(key) {
      if (this.currentLocale.data === undefined || this.currentLocale.data.messages === undefined) {
        return key;
      }

      if (this.currentLocale.data.messages[key] === undefined) {
        // Substitue English Expression if missing
        if (!this.cultures['en-US'] || this.cultures['en-US'].messages[key] === undefined) {
          return undefined;
        }
        return this.cultures['en-US'].messages[key].value;
      }

      return this.currentLocale.data.messages[key].value;
    },

    // Translate Day Period
    translateDayPeriod: function(period) {
      if (/am|pm|AM|PM/i.test(period)) {
        return Locale.calendar().dayPeriods[/AM|am/i.test(period) ? 0 : 1];
      }
      return period;
    },

    // Short cut function to get 'first' calendar
    calendar: function() {
      if (this.currentLocale.data.calendars) {
        return this.currentLocale.data.calendars[0];
      }

      //Defaults to ISO 8601
      return {dateFormat: 'yyyy-MM-dd', timeFormat: 'HH:mm:ss'};
    },

    // Short cut function to get numbers
    numbers: function() {
      return this.currentLocale.data.numbers ? this.currentLocale.data.numbers : {
          percentSign: '%',
          percentFormat: '#,##0 %',
          minusSign: '-',
          decimal: '.',
          group: ','
        };
    },

    pad: function(n, width, z) {
      z = z || '0';
      n = n + '';
      return n.length >= width ? n : new Array(width - n.length + 1).join(z) + n;
    },

    isRTL: function() {
      return this.currentLocale.data.direction === 'right-to-left';
    },

    /**
     * Takes a string and converts its contents to upper case, taking into account Locale-specific character conversions.
     * In most cases this method will simply pipe the string to `String.prototype.toUpperCase()`
     * @param {string} str - the incoming string
     * @returns {string}
     */
    toUpperCase: function(str) {
      if (typeof this.currentLocale.data.toUpperCase === 'function') {
        return this.currentLocale.data.toUpperCase(str);
      }

      return str.toLocaleUpperCase();
    },

    /**
     * Takes a string and converts its contents to lower case, taking into account Locale-specific character conversions.
     * In most cases this method will simply pipe the string to `String.prototype.toLowerCase()`
     * @param {string} str - the incoming string
     * @returns {string}
     */
    toLowerCase: function(str) {
      if (typeof this.currentLocale.data.toLowerCase === 'function') {
        return this.currentLocale.data.toLowerCase(str);
      }

      return str.toLocaleLowerCase();
    },

    /**
     * Takes a string and capitalizes the first letter, taking into account Locale-specific character conversions.
     * In most cases this method will simply use a simple algorithm for captializing the first letter of the string.
     * @param {string} str - the incoming string
     * @returns {string}
     */
    capitalize: function(str) {
      return this.toUpperCase(str.charAt(0)) + str.slice(1);
    },

    /**
     * Takes a string and capitalizes the first letter of each word in a string, taking into account Locale-specific character conversions.
     * In most cases this method will simply use a simple algorithm for captializing the first letter of the string.
     * @param {string} str - the incoming string
     * @returns {string}
     */
    capitalizeWords: function(str) {
      var words = str.split(' ');

      for(var i = 0; i < words.length; i++) {
        words[i] = this.capitalize(words[i]);
      }

      return words.join(' ');
    },

    flipIconsHorizontally: function() {
      var icons = [
        'attach',
        'bottom-aligned',
        'bullet-list',
        'cancel',
        'cart',
        'collapse-app-tray',
        'cut',
        'document',
        'drilldown',
        'duplicate',
        'expand-app-tray',
        'export',
        'first-page',
        'folder',
        'import',
        'last-page',
        'launch',
        'left-align',
        'left-text-align',
        'left-arrow',
        'new-document',
        'next-page',
        'number-list',
        'paste',
        'previous-page',
        'quote',
        'redo',
        'refresh',
        'right-align',
        'right-arrow',
        'right-text-align',
        'save',
        'search-folder',
        'search-list',
        'search',
        'send',
        'tack',
        'tree-collapse',
        'tree-expand',
        'undo',
        'unlocked',
        'add-grid-record',
        'add-grid-row',
        'additional-help',
        'bubble',
        'cascade',
        'change-font',
        'clear-screen',
        'script',
        'clockwise-90',
        'close-cancel',
        'close-save',
        'contacts',
        'copy-from',
        'copy-mail',
        'copy-url',
        'counter-clockwise-90',
        'create-report',
        'delete-grid-record',
        'delete-grid-row',
        'display',
        'employee-directory',
        'export-2',
        'export-to-pdf',
        'generate-key',
        'get-more-rows',
        'group-selection',
        'headphones',
        'help',
        'helper-list-select',
        'history',
        'invoice-released',
        'language',
        'logout',
        'key',
        'lasso',
        'line-bar-chart',
        'line-chart',
        'new-expense-report',
        'new-payment-request',
        'new-time-sheet',
        'new-travel-plan',
        'no-attachment',
        'no-comment',
        'no-filter',
        'overlay-line',
        'pdf-file',
        'phone',
        'payment-request',
        'pie-chart',
        'queries',
        'quick-access',
        'refresh-current',
        'restore-user',
        'run-quick-access',
        'save-close',
        'save-new',
        'search-results-history',
        'select',
        'send-submit',
        'show-last-x-days',
        'special-item',
        'stacked',
        'timesheet',
        'unsubscribe',
        'update-preview',
        'zoom-100',
        'zoom-in',
        'zoom-out',
        'caret-left',
        'caret-right'
      ];

      $('svg').each(function() {
        var iconName = $(this).getIconName();

        if (iconName && $.inArray(iconName, icons) !== -1) {
          $(this).addClass('icon-rtl-rotate');
        }
      });
    }

  };

  //Has to delay in order to check if no culture in head since scripts load async
  $(function() {
    setTimeout(function() {
      if (!window.Locale.cultureInHead() && !window.Locale.currentLocale.name) {
        window.Locale.set('en-US');
      }

      // ICONS: Right to Left Direction
      if (window.Locale.isRTL()) {
        window.Locale.flipIconsHorizontally();
      }
    }, 50);
  });



  var defaults = {
      caseSensitive: false, // Set to true if searches ARE case sensitive
      filterMode: 'startsWith', // see "filterModes" var for possible values
      highlightMatchedText: false, // inserts markup that appears to highlight text
      highlightCallback: null // if defined, will execute this code for highlighting text instead of the built-in highlighting code
    },
    filterModes = ['startsWith', 'contains'];

  /**
   * Abstracted search/filter for use in other controls
   * @constructor
   */
  function ListFilter(settings) {
    this.settings = $.extend({}, defaults, settings);
    Soho.logTimeStart('ListFilter');
    this.init();
    Soho.logTimeEnd('ListFilter');
  }

  ListFilter.prototype = {

    init: function() {
      // Sanitize Incoming Options
      function setReasonableDefaults(setting, limits, preset) {
        if ($.inArray(setting, limits) === -1) {
          setting = preset;
        }
      }

      var checks = [
        { setting: this.settings.filterMode, limits: filterModes, preset: defaults.filterMode }
      ];

      for (var i = 0; i < checks.length; i++) {
        setReasonableDefaults(checks[i].setting, checks[i].limits, checks[i].preset);
      }

      return this;
    },

    filter: function(list, term) {
      if (!list) {
        return false;
      }

      // Check incoming list type
      if (!$.isArray(list) && !(list instanceof jQuery)) {
        return false;
      }

      // Search term must exist and must not be nothing
      if (!term || typeof term !== 'string' || !term.length) {
        return false;
      }

      var self = this,
        items = [],
        isJQuery = false;

      // make search term lowercase if the search is not case-senstive
      if (!this.settings.caseSensitive) {
        term = term.toLowerCase();
      }

      // If it's not an array, build an array of the incoming object(s) for iterating through
      if (!$.isArray(list)) {
        if (list instanceof jQuery || typeof list === 'object') {
          list = $.makeArray(list);
          isJQuery = true;
        }
      }

      function searchItemIterator(item) {
        var isString = typeof item === 'string',
          text = (isString ? item : $(item).text()),
          parts = text.split(' '),
          match = false;

        if (self.settings.filterMode === 'startsWith') {
          for (var a = 0; a < parts.length; a++) {
            if (parts[a].toLowerCase().indexOf(term) === 0) {
              match = true;
              break;
            }
          }

          //Direct Match
          if (text.toLowerCase().indexOf(term) === 0) {
            match = true;
          }

          //Partial dual word match
          if (term.indexOf(' ') > 0 && text.toLowerCase().indexOf(term) > 0) {
            match = true;
          }
        }

        if (self.settings.filterMode === 'contains') {
          if (text.toLowerCase().indexOf(term) >= 0) {
            match = true;
          }
        }

        if (match) {
          items.push(item);
        }

        return;
      }

      // Run the iterator
      list.forEach(searchItemIterator);

      // If we originally took in a jQuery selector, rebuild that jQuery selector with the relevant results.
      if (isJQuery) {
        items = $(items);
      }

      return items;
    },

    updated: function(settingsObj) {
      this.settings = $.extend({}, this.settings, settingsObj);
      return this
        .teardown()
        .init();
    },

    teardown: function() {
      return this;
    },

    destroy: function() {
      return this.teardown();
    }

  };

  // Add it to the Window for use
  window.ListFilter = ListFilter;


  $.fn.about = function(options) {

    // Settings and Options
    var pluginName = 'about',
        defaults = {
          appName: 'Infor Application Name',
          content: undefined,
          copyrightYear: new Date().getFullYear(),
          deviceSpecs: true,
          productName: undefined,
          useDefaultCopyright: true,
          version: undefined
        },
        settings = $.extend({}, defaults, options);

    /**
    * The About Dialog Component is displays information regarding the application.
    *
    * @class About
    * @param {String} appName  &nbsp;-&nbsp; The Main Application Name to display in the heading
    * @param {String} content  &nbsp;-&nbsp; Additional Text content to display at the top.
    * @param {String} copyrightYear  &nbsp;-&nbsp; The year displayed in the copyright, defaults to current year.
    * @param {Boolean} deviceSpecs  &nbsp;-&nbsp; Determines whether or not to display device information (Browser, Platform, Locale, Cookies Enabled)
    * @param {String} productName  &nbsp;-&nbsp; Additional product name information to display
    * @param {Boolean} useDefaultCopyright  &nbsp;-&nbsp; Add the Legal Approved Infor Copy Right Text
    * @param {String} version  &nbsp;-&nbsp; Semantic Version Number for example (4.0.0)
    *
    */
    function About(element) {
      this.settings = $.extend({}, settings);
      this.element = $(element);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    // Plugin Methods
    About.prototype = {

      init: function() {
        return this
          .setup()
          .build()
          .handleEvents();
      },

      setup: function() {
        this.isBody = $(this.element).is('body');
        var appName = this.element.attr('data-appname');
        this.settings.appName = appName !== undefined ? appName.toString() : this.settings.appName;

        var content = this.element.attr('data-about-content');
        this.settings.content = content !== undefined ? content.toString() : this.settings.content;

        var copyrightYear = this.element.attr('data-copyright-year');
        this.settings.copyrightYear = copyrightYear !== undefined ? copyrightYear.toString() : this.settings.copyrightYear;

        var deviceSpecs = this.element.attr('data-device-specs');
        if (deviceSpecs) {
          this.settings.deviceSpecs = deviceSpecs === 'true';
        }

        var productName = this.element.attr('data-product-name');
        this.settings.productName = productName !== undefined ? productName.toString() : this.settings.productName;

        var useDefaultCopyright = this.element.attr('data-use-default');
        if (useDefaultCopyright !== undefined) {
          this.settings.useDefaultCopyright = useDefaultCopyright === 'true';
        }

        var version = this.element.attr('data-version');
        this.settings.version = version !== undefined ? version.toString() : this.settings.version;

        // Get the default copyright text and cut in the current year
        this.defaultCopyright = Locale.translate('AboutText') + ' <a class="hyperlink" href="http://www.infor.com" target="_blank">www.infor.com</a>.';
        this.defaultCopyright = this.defaultCopyright.replace('{0}', this.settings.copyrightYear);

        return this;
      },

      build: function() {
        this.modal = $('<div class="modal about" id="about-modal"></div>');
        $('<div class="modal-content"></div>').appendTo(this.modal);
        var header = $('<div class="modal-header"></div>').appendTo(this.modal.find('.modal-content'));
        $('<div class="close-container"></div>')
          .append($('<button name="close" type="button" class="btn-icon hide-focus"></button>')
            .append($.createIconElement({ icon: 'close', classes: 'icon-close' }))
            .append('<span>' + Locale.translate('Close') + '</span>'))
          .appendTo(header);
        $.createIconElement({ icon: 'logo-trademark', classes: ['icon', 'about-logo'] }).attr({ viewBox: '0 0 44 44' }).appendTo(header);
        this.title = $('<h1 class="title"></h1>').text(this.settings.appName).appendTo(this.modal.find('.modal-header'));

        var body = $('<div class="modal-body"></div>').appendTo(this.modal.find('.modal-content'));

        if (this.settings.version || this.settings.productName) {
          var productAndVersion = '' + (this.settings.productName ? this.settings.productName + ' ' : '') +
            (this.settings.version ? this.settings.version : '');
          $('<p></p>').text(productAndVersion).appendTo(body);
        }

        if (this.settings.content) {
          $('<div class="additional-content"></div>').html(this.settings.content).appendTo(body);
        }

        if (this.settings.useDefaultCopyright || !this.settings.content) {
          $('<p></p>').html(this.defaultCopyright).appendTo(body);
        }

        if (this.settings.deviceSpecs) {
          var specs = this.getDeviceSpecs(),
            text = '<span class="browser">Browser: ' + specs.browser + '</span><br>' +
              '<span class="platform">Platform: ' + specs.os + '</span><br>' +
              '<span class="locale">Locale: ' + specs.locale + '</span><br>' +
              '<span class="cookiesEnabled">Cookies Enabled: ' + specs.cookiesEnabled + '</span><br>';
          $('<p></p>').html(text).appendTo(body);
        }

        //$('<div class="modal-buttonset"><button type="button" name="done" class="btn-modal">Done</button></div>').appendTo(this.modal.find('.modal-content'));
        this.buttons = this.modal.find('button');

        this.modal.find('.hide-focus').one('blur', function () {
          $(this).removeClass('hide-focus');
        });

        this.element.attr('data-modal','about-modal');

        $('.modal-body', this.modal)[0].tabIndex = 0;

        this.modal.appendTo('body');
        this.modal.modal({trigger: this.isBody ? 'immediate' : 'click'});
        return this;
      },

      /**
      * Return the browser specs. Currently returns browse, os, cookiesEnabled and locale
      * @returns {String}
      */
      getDeviceSpecs: function() {
        var locale = navigator.appName === 'Microsoft Internet Explorer' ? navigator.userLanguage : navigator.language,
          browser = (function(){
            var ua= navigator.userAgent, tem,
            M= ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];
            if (/trident/i.test(M[1])){
              tem=  /\brv[ :]+(\d+)/g.exec(ua) || [];
              return 'IE '+(tem[1] || '');
            }
            if (M[1]=== 'Chrome'){
              tem= ua.match(/\bOPR\/(\d+)/);
              if (tem !== null) {
                return 'Opera '+tem[1];
              }
            }
            M= M[2]? [M[1], M[2]]: [navigator.appName, navigator.appVersion, '-?'];
            if((tem= ua.match(/version\/(\d+)/i)) !== null) {
              M.splice(1, 1, tem[1]);
            }
            return M.join(' ');
          })();

        return {
          browser: browser,
          os: navigator.platform,
          cookiesEnabled: navigator.cookieEnabled,
          locale: locale
        };
      },

      /**
      * Progamatically Close the About Dialog.
      */
      close: function() {
        var modalApi = this.modal.data('modal');

        if (modalApi) {
          modalApi.close();
        }

        if (this.isBody) {
          this.destroy();
        }
      },

      /**
      * Teardown and remove any added markup and events.
      */
      destroy: function() {
        var modalApi = this.modal.data('modal');

        if (modalApi) {
          modalApi.element.off('beforeopen.about');
          modalApi.destroy();
        }

        this.buttons.off();
        this.element.off('open.about');
        $.removeData(this.element[0], pluginName);
      },

      /**
       *  This component fires the following events.
       *
       * @fires About#events
       * @param {Object} beforeclose  &nbsp;-&nbsp; Fires before the dialog is closing. You can return false asyncronously to delay closing.
       * @param {Object} close  &nbsp;-&nbsp; Fires as the dialog is closing
       * @param {Object} afterclose  &nbsp;-&nbsp; Fires after the dialog has closed in the DOM entirely
       *
       */
      handleEvents: function() {
        var self = this;

        this.element.on('open.about', function(e) {
          e.stopPropagation();
          self.element.trigger('click');
        });

        this.buttons.filter('[name="done"], [name="close"]').on('click.about', function() {
          self.close();
        });

        this.modal.data('modal').element.on('beforeopen.about', function() {
          self.modal.find('.modal-body').scrollTop(0);
        });

        $(document).on('keydown.about', function(e) {
          // Close on Escape.
          if (e.which === 0 || e.which === 27) {
            self.close();
          }
        });

        return this;
      }

    };

    // Initialize the plugin (Once)
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (instance) {
        instance.settings = $.extend({}, instance.settings, options);
      } else {
        instance = $.data(this, pluginName, new About(this, settings));
      }
    });
  };

// NOTE:  There are AMD Blocks available


  //NOTE: Just this part will show up in SoHo Xi Builds.

  $.fn.accordion = function(options) {
    'use strict';

    // Settings and Options
    var pluginName = 'accordion',
        defaults = {
          allowOnePane: true,
          displayChevron: true,
          rerouteOnLinkClick: true,
          source: null
        },
        settings = $.extend({}, defaults, options);

    /**
    * The Accordion is a grouped set of collapsible panels used to navigate sections of
    * related content. Each panel consists of two levels: the top level identifies the
    * category or section header, and the second level provides the associated options.
    *
    * @class Accordion
    * @param {String} allowOnePane &nbsp;-&nbsp; If set to true, allows only one pane of the Accordion to be open at a time.  If an Accordion pane is open, and that pane contains sub-headers, only one of the pane's sub-headers can be open at a time. (default true)
    * @param {String} displayChevron  &nbsp;-&nbsp; Displays a "Chevron" icon that sits off to the right-most side of a top-level accordion header.  Used in place of an Expander (+/-) if enabled.
    * @param {String} rerouteOnLinkClick  &nbsp;-&nbsp; Can be set to false if routing is externally handled
    * @param {Boolean} source  &nbsp;-&nbsp; A callback function that when implemented provided a call back for "ajax loading" of tab contents on open.
    *
    */
    function Accordion(element) {
      this.settings = $.extend({}, settings);
      this.element = $(element);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    // Plugin Methods
    Accordion.prototype = {
      init: function() {
        return this
          .setup()
          .build()
          .handleEvents();
      },

      setup: function() {
        return this;
      },

      build: function() {
        var self = this;

        this.headers = this.element.find('.accordion-header');
        this.anchors = this.headers.children('a');
        this.panes = this.headers.next('.accordion-pane');

        var headersHaveIcons = false;

        // Accordion Headers that have an expandable pane need to have an expando-button added inside of them
        this.headers.each(function addExpander() {
          var header = $(this),
            hasIcons = false,
            containerPane = header.parent(),
            isTopLevel = containerPane.is('.accordion');

          function checkIfIcons() {
            if (isTopLevel) {
              return;
            }

            if (!hasIcons) {
              header.addClass('no-icon');
              return;
            }

            containerPane.addClass('has-icons');
          }

          header.attr('role', 'presentation').hideFocus();

          // For backwards compatibility:  If an icon is found inside an anchor, bring it up to the level of the header.
          header.children('a').find('svg').detach().insertBefore(header.children('a'));

          var outerIcon = header.children('.icon, svg');
          outerIcon.addClass('icon').attr({'role': 'presentation', 'aria-hidden': 'true', 'focusable': 'false'});
          if (isTopLevel && outerIcon.length) {
            headersHaveIcons = true;
          }

          if (header.is('.list-item') || (!isTopLevel && header.find('button').length)) {
            hasIcons = true;
          }

          // Enable/Disable
          if (header.hasClass('is-disabled')) {
            header.children('a, button').attr('tabindex', '-1');
          }

          // Don't continue if there's no pane
          if (!header.next('.accordion-pane').length) {
            checkIfIcons();
            return;
          }

          hasIcons = true;

          var expander = header.children('.btn');
          if (!expander.length) {
            expander = $('<button class="btn" type="button"></button>');

            var method = 'insertBefore';
            if (self.settings.displayChevron && isTopLevel) {
              header.addClass('has-chevron');
              method = 'insertAfter';
            }
            expander[method](header.children('a'));
            header.data('addedExpander', expander);
          }

          // Hide Focus functionality
          expander.hideFocus();

          // If Chevrons are turned off and an icon is present, it becomes the expander
          if (outerIcon.length && !self.settings.displayChevron) {
            outerIcon.appendTo(expander);
          }

          var expanderIcon = expander.children('.icon, .svg, .plus-minus');
          if (!expanderIcon.length) {
            if (self.settings.displayChevron && isTopLevel) {
              expanderIcon = $.createIconElement({ icon: 'caret-down', classes: ['chevron'] });
            } else {
              var isActive = self.isExpanded(header) ? ' active' : '';
              expanderIcon = $('<span class="icon plus-minus'+ isActive +'" aria-hidden="true" role="presentation"></span>');
            }
            expanderIcon.appendTo(expander);
          }
          var expanderIconOpts = {
            'role': 'presentation',
            'aria-hidden': 'true'
          };
          if (!expanderIcon.is('span')) {
            expanderIconOpts.focusable = 'false';
          }
          expanderIcon.attr(expanderIconOpts);

          // Move around the Expander depending on whether or not it's a chevron
          if (expanderIcon.is('.chevron')) {
            header.addClass('has-chevron');
            expander.insertAfter(header.children('a'));
          } else {
            header.removeClass('has-chevron');
            expander.insertBefore(header.children('a'));
          }

          // Double check to see if we have left-aligned expanders or icons present,
          // so we can add classes that do alignment
          if (!self.settings.displayChevron && isTopLevel) {
            headersHaveIcons = true;
          }
          checkIfIcons();

          // Add an Audible Description to the button
          var description = expander.children('.audible');
          if (!description.length) {
            description = $('<span class="audible"></span>').appendTo(expander);
          }
          description.text(Locale.translate('Expand'));
        });

        if (headersHaveIcons) {
          this.element.addClass('has-icons');
        }

        // Setup correct ARIA for accordion panes, and auto-collapse them
        this.panes.each(function addPaneARIA() {
          var pane = $(this),
            header = pane.prev('.accordion-header');

          header.children('a').attr({'aria-haspopup': 'true', 'role': 'button'});

          if (!self.isExpanded(header)) {
            pane.data('ignore-animation-once', true);
            self.collapse(header);
          }
        });

        // Expand to the current accordion header if we find one that's selected
        if (!this.element.data('updating')) {
          var targetsToExpand = this.headers.filter('.is-selected, .is-expanded');

          if (this.settings.allowOnePane) {
            targetsToExpand = targetsToExpand.first();
          }

          this.expand(targetsToExpand);
          this.select(targetsToExpand.last());
        }

        return this;
      },

      handleHeaderClick: function(e, header) {
        if (!header || !header.length || this.isDisabled(header) || header.data('is-animating')) {
          e.preventDefault();
          return;
        }

        // Check that we aren't clicking the expando button.  If we click that, this listener dies
        if ($(e.target).is('[class^="btn"]')) {
          e.preventDefault();
          return;
        }

        var anchor = header.children('a');
        return this.handleAnchorClick(e, anchor);
      },

      handleAnchorClick: function(e, anchor) {
        var self = this,
          header = anchor.parent('.accordion-header'),
          pane = header.next('.accordion-pane'),
          ngLink = anchor.attr('ng-reflect-href');

        if (e && !ngLink) {
          e.preventDefault();
        }

        if (!header.length || this.isDisabled(header)) {
          return false;
        }

        var canSelect = this.element.triggerHandler('beforeselect', [anchor]);
        if (canSelect === false) {
          return;
        }

        this.element.trigger('selected', header);

        // Set the original element for DOM traversal by keyboard
        this.originalSelection = anchor;

        this.select(anchor);

        function followLink() {
          var href = anchor.attr('href');
          if (href && href !== '' && href !== '#') {
            if (!self.settings.rerouteOnLinkClick) {
              return true;
            }

            window.location.href = href;
            return true;
          }
          return false;
        }

        function toggleExpander() {
          if (pane.length) {
            self.toggle(header);
          }
          anchor.focus();
        }

        // Stop propagation here because we don't want to bubble up to the Header and potentially click the it twice
        if (e) {
          e.stopPropagation();
        }

        // If the anchor's a real link, follow the link and die here
        if (followLink()) {
          this.element.trigger('followlink', [anchor]);
          return true;
        }

        // If it's not a real link, try and toggle an expansion pane
        toggleExpander();
        return true;
      },

      handleExpanderClick: function(e, expander) {
        var header = expander.parent('.accordion-header');
        if (!header.length || this.isDisabled(header) || header.data('is-animating')) {
          return;
        }

        // Set the original element for DOM traversal by keyboard
        this.originalSelection = expander;

        // Don't propagate when clicking the expander.  Propagating can cause the link to be clicked in cases
        // where it shouldn't be clicked.
        if (e) {
          e.stopPropagation();
        }

        var pane = header.next('.accordion-pane');
        if (pane.length) {
          this.toggle(header);
          this.select(header);
          expander.focus();
          return;
        }

        // If there's no accordion pane, attempt to simply follow the link.
        return this.handleAnchorClick(null, header.children('a'));
      },

      handleKeys: function(e) {
        var self = this,
          key = e.which,
          target = $(e.target), // will be either an anchor or expando button.  Should NEVER be the header itself.
          header = target.parent(),
          expander = header.children('[class^="btn"]').first(),
          anchor = header.children('a');

        function setInitialOriginalSelection(selection) {
          if (!selection) {
            selection = target;
          }

          if (!self.originalSelection) {
            self.originalSelection = selection;
          }
        }

        if (key === 9) { // Tab (also triggered by Shift + Tab)
          this.headers.removeClass('is-selected');

          if (target.is('a') && expander.length) {
            setInitialOriginalSelection(expander);
          } else {
            setInitialOriginalSelection(anchor);
          }
        }

        if (key === 32) { // Spacebar
          e.preventDefault();

          // Don't let this propagate and run against the header element, if it's a button
          if (target.is('[class^="btn"]')) {
            e.stopPropagation();
            e.stopImmediatePropagation();

            // Firefox will attempt to run this twice, despite the fact that we're stopping propagation.
            // Just cancel the whole thing if Firefox is running this method.
            if ($('html').hasClass('is-firefox')) {
              return;
            }
          }

          if (expander.length) {
            setInitialOriginalSelection(expander);
            return this.handleExpanderClick(null, target);
          } else {
            setInitialOriginalSelection(anchor);
            return this.handleAnchorClick(null, target);
          }
        }

        if (key === 37 || key === 38) { // Left Arrow/Up Arrow
          e.preventDefault();
          setInitialOriginalSelection();
          if (e.shiftKey) {
            return this.ascend(header);
          }
          return this.prevHeader(header);
        }

        if (key === 39 || key === 40) { // Right Arrow/Down Arrow
          e.preventDefault();
          setInitialOriginalSelection();
          if (e.shiftKey) {
            return this.descend(header);
          }
          return this.nextHeader(header);
        }
      },

      // Makes a header "selected" if its expander button or anchor tag is focused.
      // @param {Object} element - a jQuery Object containing either an expander button or an anchor tag.
      select: function(element) {
        if (!element || !element.length) {
          return;
        }

        // Make sure we select the anchor
        var anchor = element,
          header = anchor.parent();

        if (element.is('.accordion-header')) {
          header = element;
          anchor = header.children('a');
        }

        if (anchor.is('[class^="btn"]')) {
          anchor = element.next('a');
        }

        if (this.isDisabled(header)) {
          return;
        }

        this.headers.removeClass('child-selected').removeClass('is-selected');

        header.addClass('is-selected');

        var items = header.parentsUntil(this.element, '.accordion-pane')
          .prev('.accordion-header');

        items.addClass('child-selected');
      },

      /**
      * Checks if a particular header is disabled, or if the entire accordion is disabled..
      * @param {Object} header &nbsp;-&nbsp; the jquery header element
      * @returns {Boolean}
      */
      isDisabled: function(header) {
        if (this.element.hasClass('is-disabled')) {
          return true;
        }

        if (!header) {
          return false;
        }

        return header.hasClass('is-disabled');
      },

      /**
      * Checks if an Accordion Section is currently expanded
      * @param {Object} header &nbsp;-&nbsp; the jquery header element
      * @returns {Boolean}
      */
      isExpanded: function(header) {
        if (!header || !header.length) {
          return;
        }

        return header.children('a').attr('aria-expanded') === 'true';
      },

      /**
      * Toggle the given Panel on the Accordion between expanded and collapsed
      * @param {Object} header &nbsp;-&nbsp; the jquery header element
      */
      toggle: function(header) {
        if (!header || !header.length || this.isDisabled(header)) {
          return;
        }

        if (this.isExpanded(header)) {
          this.collapse(header);
          return;
        }
        this.expand(header);
      },

      /**
      * Expand the given Panel on the Accordion.
      * @param {Object} header &nbsp;-&nbsp; the jquery header element
      */
      expand: function(header) {
        if (!header || !header.length) {
          return;
        }

        var self = this,
          pane = header.next('.accordion-pane'),
          a = header.children('a');

        var canExpand = this.element.triggerHandler('beforeexpand', [a]);
        if (canExpand === false) {
          return;
        }

        function continueExpand() {
          // Change the expander button into "collapse" mode
          var expander = header.children('.btn');
          if (expander.length) {
            expander.children('.plus-minus, .chevron').addClass('active');
            expander.children('.audible').text(Locale.translate('Collapse'));
          }

          var headerParents = header.parentsUntil(self.element).filter('.accordion-pane').prev('.accordion-header').add(header);

          // If we have the correct settings defined, close other accordion headers that are not parents of this one.
          if (self.settings.allowOnePane) {
            self.headers.not(headerParents).each(function() {
              var h = $(this);
              if (self.isExpanded(h)) {
                self.collapse(h);
              }
            });
          }

          // Expand all headers that are parents of this one, if applicable
          headerParents.not(header).each(function() {
            var h = $(this);
            if (!self.isExpanded(h)) {
              self.expand(h);
            }
          });

          pane.addClass('is-expanded');
          self.element.trigger('expand', [a]);

          pane.one('animateopencomplete', function(e) {
            e.stopPropagation();
            header.children('a').attr('aria-expanded', 'true');
            self.element.trigger('afterexpand', [a]);
          }).css('display', 'block').animateOpen();
        }

        // Load from an external source, if applicable
        if (!this.callSource(a, continueExpand)) {
          continueExpand.apply(this);
        }
      },

      /**
      * Collapse the given Panel on the Accordion.
      * @param {Object} header &nbsp;-&nbsp; the jquery header element
      */
      collapse: function(header) {
        if (!header || !header.length) {
          return;
        }

        var self = this,
          pane = header.next('.accordion-pane'),
          a = header.children('a');

        var canExpand = this.element.triggerHandler('beforecollapse', [a]);
        if (canExpand === false) {
          return;
        }

        // Change the expander button into "expand" mode
        var expander = header.children('.btn');
        if (expander.length) {
          expander.children('.plus-minus, .chevron').removeClass('active');
          expander.children('.audible').text(Locale.translate('Expand'));
        }

        pane.removeClass('is-expanded').closeChildren();
        a.attr('aria-expanded', 'false');

        self.element.trigger('collapse', [a]);

        pane.one('animateclosedcomplete', function(e) {
          e.stopPropagation();
          pane[0].style.display = 'none';
          self.element.trigger('aftercollapse', [a]);
        }).animateClosed();
      },

      // Uses a function (this.settings.source()) to call out to an external API to fill the
      // inside of an accordion pane.
      callSource: function(anchor, animationCallback) {
        if (!this.settings.source || typeof this.settings.source !== 'function') {
          return false;
        }

        var self = this,
          header = anchor.parent(),
          pane = header.next('.accordion-pane'),
          ui = {
            anchor: anchor,
            header: header,
            pane: pane
          };

        function response() {
          self.updated();
          setTimeout(function() {
            animationCallback.apply(self);
          }, 1);
          return;
        }

        // Trigger the external method and wait for a response.
        return this.settings.source(ui, response);
      },

      // Prepares a handful of references to a specific
      getElements: function(eventTarget) {
        var target = $(eventTarget),
          header, anchor, expander, pane;

        if (target.is('.accordion-header')) {
          header = target;
          expander = target.children('[class^="btn"]');
          anchor = target.children('a');
        }

        if (target.is('.btn')) {
          expander = target;
          header = expander.parent();
          anchor = header.children('a');
        }

        if (target.is('a')) {
          anchor = target;
          header = anchor.parent();
          expander = header.children('.btn');
        }

        pane = header.next('.accordion-pane');

        return {
          header: header,
          expander: expander,
          anchor: anchor,
          pane: pane
        };
      },

      // Selects an adjacent Accordion Header that sits directly before the currently selected Accordion Header.
      // @param {Object} element - a jQuery Object containing either an expander button or an anchor tag.
      // @param {boolean} noDescend - if it's normally possible to descend into a sub-accordion, prevent against descending.
      prevHeader: function(element, noDescend) {
        var elem = this.getElements(element),
          adjacentHeaders = elem.header.parent().children(),
          currentIndex = adjacentHeaders.index(elem.header),
          target = $(adjacentHeaders.get(currentIndex - 1));

        if (!adjacentHeaders.length || currentIndex === 0) {
          if (elem.header.parent('.accordion-pane').length) {
            return this.ascend(elem.header);
          }
          target = adjacentHeaders.last();
        }

        while (target.is('.accordion-content') || this.isDisabled(target)) {
          if (target.is(':only-child') || target.is(':first-child')) {
            return this.ascend(elem.header);
          }
          target = target.prev();
        }

        if (target.is('.accordion-pane')) {
          var prevHeader = target.prev('.accordion-header');
          if (this.isExpanded(prevHeader)) {
            var descendantChildren = prevHeader.next('.accordion-pane').children(':not(.accordion-content)');
            if (descendantChildren.length && !noDescend) {
              return this.descend(prevHeader, -1);
            }
          }
          target = prevHeader;

          // if no target's available here, we've hit the end and need to wrap around
          if (!target.length) {
            if (elem.header.parent('.accordion-pane').length) {
              return this.ascend(elem.header);
            }

            target = adjacentHeaders.last();
            while (target.is('.accordion-content') || this.isDisabled(target)) {
              target = target.prev();
            }
          }
        }

        this.focusOriginalType(target);
      },

      // Selects an adjacent Accordion Header that sits directly after the currently selected Accordion Header.
      // @param {Object} element - a jQuery Object containing either an expander button or an anchor tag.
      // @param {boolean} noDescend - if it's normally possible to descend into a sub-accordion, prevent against descending.
      nextHeader: function(element, noDescend) {
        var elem = this.getElements(element),
          adjacentHeaders = elem.header.parent().children(),
          currentIndex = adjacentHeaders.index(elem.header),
          target = $(adjacentHeaders.get(currentIndex + 1));

        if (!adjacentHeaders.length || currentIndex === adjacentHeaders.length - 1) {
          if (elem.header.parent('.accordion-pane').length) {
            return this.ascend(elem.header, -1);
          }
          target = adjacentHeaders.first();
        }

        while (target.is('.accordion-content') || this.isDisabled(target)) {
          if (target.is(':only-child') || target.is(':last-child')) {
            return this.ascend(elem.header);
          }
          target = target.next();
        }

        if (target.is('.accordion-pane')) {
          var prevHeader = target.prev('.accordion-header');
          if (this.isExpanded(prevHeader)) {
            var descendantChildren = prevHeader.next('.accordion-pane').children(':not(.accordion-content)');
            if (descendantChildren.length && !noDescend) {
              return this.descend(prevHeader);
            }
          }
          target = $(adjacentHeaders.get(currentIndex + 2));

          // if no target's available here, we've hit the end and need to wrap around
          if (!target.length) {
            if (elem.header.parent('.accordion-pane').length) {
              return this.ascend(elem.header, -1);
            }

            target = adjacentHeaders.first();
            while (target.is('.accordion-content') || this.isDisabled(target)) {
              target = target.next();
            }
          }
        }

        this.focusOriginalType(target);
      },

      // Selects the first Accordion Header in the parent container of the current Accordion Pane.
      // If we're at the top level, jump out of the accordion to the last focusable element.
      // @param {Object} header - a jQuery Object containing an Accordion header.
      // @param {integer} direction - if -1, sets the position to be at the end of this set of headers instead of at the beginning.
      ascend: function(header, direction) {
        if (!direction) {
          direction = 0;
        }

        var pane = header.parent('.accordion-pane'),
          target = pane.prev();

        if (direction === -1) {
          target = pane.next('.accordion-header');
          if (!target.length) {
            if (pane.parent('.accordion').length) {
              return this.nextHeader(pane.prev().children('a'), true);
            }

            return this.ascend(pane.prev(), -1);
          }
        }

        this.focusOriginalType(target);
      },

      // Selects the first Accordion Header in the child container of the current Accordion Header.
      // @param {Object} header - a jQuery Object containing an Accordion header.
      // @param {integer} direction - if -1, sets the position to be at the end of this set of headers instead of at the beginning.
      descend: function(header, direction) {
        if (!direction) {
          direction = 0;
        }

        var pane = header.next('.accordion-pane'),
          target = pane.children('.accordion-header').first();

        if (direction === -1) {
          target = pane.children('.accordion-header').last();
        }

        // No headers may be present.  In which case, it may be necessary to simply focus the header for the current pane.
        if (!target.length) {
          return this.focusOriginalType(header);
        }

        if (this.isExpanded(target)) {
          return this.descend(target, -1);
        }

        this.focusOriginalType(target);
      },

      // Selects an Accordion Header, then focuses either an expander button or an anchor.
      // Governed by the property "this.originalSelection".
      // @param {Object} header - a jQuery Object containing an Accordion header.
      focusOriginalType: function(header) {
        //this.select(header.children('a'));

        if (this.originalSelection.is('.btn') && header.children('.btn').length) {
          header.children('.btn').focus();
        } else {
          header.children('a').focus();
        }
      },

      /**
      * Disable an accordion from events
      */
      disable: function() {
        this.element
          .addClass('is-disabled');

        this.anchors.add(this.headers.children('[class^="btn"]')).attr('tabindex', '-1');
      },

      /**
      * Enable a disabled accordion.
      */
      enable: function() {
        this.element
          .removeClass('is-disabled');

        this.anchors.add(this.headers.children('[class^="btn"]')).removeAttr('tabindex');
      },

      updated: function() {
        this.element.data('updating', true);

        var currentFocus = $(document.activeElement);
        if (!$.contains(this.element[0], currentFocus[0])) {
          currentFocus = undefined;
        }

        this
          .teardown()
          .init();

        if (currentFocus && currentFocus.length) {
          currentFocus.focus();
        }

        $.removeData(this.element[0], 'updating');
        return this;
      },

      teardown: function() {
        this.headers
          .off('touchend.accordion click.accordion focusin.accordion focusout.accordion keydown.accordion mousedown.accordion mouseup.accordion')
          .each(function() {
            var expander = $(this).data('addedExpander');
            if (expander) {
              expander.remove();
              $.removeData(this, 'addedExpander');
            }
          });

        this.anchors.off('touchend.accordion keydown.accordion click.accordion');

        this.headers.children('[class^="btn"]')
          .off('touchend.accordion click.accordion keydown.accordion');

        this.element.off('updated.accordion selected.accordion');

        return this;
      },

      /**
      * Teardown and remove any added markup and events.
      */
      destroy: function() {
        this.teardown();
        $.removeData(this.element[0], pluginName);
      },

      /**
       *  This component fires the following events.
       *
       * @fires Accordion#events
       * @param {Object} selected  &nbsp;-&nbsp; Fires when a panel is opened.
       * @param {Object} followlink  &nbsp;-&nbsp; If the anchor is a real link, follow the link and die here. This indicates the link has been followed.
       * @param {Object} expand  &nbsp;-&nbsp; Fires when expanding a pane is initiated.
       * @param {Object} afterexpand  &nbsp;-&nbsp; Fires after a pane is expanded.
       * @param {Object} collapse  &nbsp;-&nbsp; Fires when collapsed a pane is initiated.
       * @param {Object} aftercollapse  &nbsp;-&nbsp; Fires after a pane is collapsed.
       *
       */
      handleEvents: function() {
        var self = this,
          headerWhereMouseDown = null,
          linkFollowedByTouch = null;

        // Returns "Header", "Anchor", or "Expander" based on the element's tag
        function getElementType(element) {
          var elementType = 'Header';
          if (element.is('a')) {
            elementType = 'Anchor';
          }
          if (element.is('button')) {
            elementType = 'Expander';
          }
          return elementType;
        }

        // Intercepts a 'touchend' event in order to either prevent a link from being followed,
        // or allows it to continue.
        function touchendInterceptor(e, element) {
          linkFollowedByTouch = true;
          var type = getElementType(element),
            result = self['handle' + type + 'Click'](e, element);

          if (!result) {
            e.preventDefault();
          }
          return result;
        }

        // Intercepts a 'click' event in order to either prevent a link from being followed,
        // or allows it to continue.
        function clickInterceptor(e, element) {
          var type = getElementType(element);
          if (linkFollowedByTouch) {
            linkFollowedByTouch = null;
            return false;
          }
          return self['handle' + type + 'Click'](e, element);
        }

        this.headers.on('touchend.accordion', function(e) {
          return touchendInterceptor(e, $(this));
        }).on('click.accordion', function(e) {
          return clickInterceptor(e, $(this));
        }).on('focusin.accordion', function(e) {
          var target = $(e.target);

          if (!self.originalSelection) {
            self.originalSelection = target;
          }

          if (target.is(':not(.btn)')) {
            $(this).addClass('is-focused');
          }
        }).on('focusout.accordion', function() {
          if (!$.contains(this, headerWhereMouseDown) || $(this).is($(headerWhereMouseDown))) {
            $(this).removeClass('is-focused');
          }
        }).on('keydown.accordion', function(e) {
          self.handleKeys(e);
        }).on('mousedown.accordion', function(e) {
          $(this).addClass('is-focused');
          headerWhereMouseDown = e.target;
        }).on('mouseup.accordion', function() {
          headerWhereMouseDown = null;
        });

        this.anchors.on('touchend.accordion', function(e) {
          return touchendInterceptor(e, $(this));
        }).on('click.accordion', function(e) {
          return clickInterceptor(e, $(this));
        });

        this.headers.children('[class^="btn"]')
          .on('touchend.accordion', function(e) {
            return touchendInterceptor(e, $(this));
          })
          .on('click.accordion', function(e) {
            return clickInterceptor(e, $(this));
          }).on('keydown.accordion', function(e) {
            self.handleKeys(e);
          });

        this.element.on('selected.accordion', function(e) {
          // Don't propagate this event above the accordion element
          e.stopPropagation();
        }).on('updated.accordion', function(e) {
          // Don't propagate just in case this is contained by an Application Menu
          e.stopPropagation();
          self.updated();
        });

        return this;
      }

    };

    // Initialize the plugin (Once)
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (instance) {
        instance.settings = $.extend({}, instance.settings, options);
        instance.updated();
      } else {
        instance = $.data(this, pluginName, new Accordion(this, settings));
      }
    });
  };


  $.fn.applicationmenu = function(options) {

    'use strict';

    // Settings and Options
    var pluginName = 'applicationmenu',
        defaults = {
          breakpoint: 'phablet',
          openOnLarge: false,
          triggers: []
        },
        settings = $.extend({}, defaults, options);

    /**
    * The Application Menu provides access to all the functions, pages, and forms in an application.
    *
    * @class ApplicationMenu
    * @param {String} breakpoint  &nbsp;-&nbsp; Can be 'tablet' (+720), 'phablet (+968), ' 'desktop' +(1024), or 'large' (+1280). Default is phablet (968)
    * @param {String} openOnLarge  &nbsp;-&nbsp; If true, will automatically open the Application Menu when a large screen-width breakpoint is met.
    * @param {String} triggers  &nbsp;-&nbsp; An Array of jQuery-wrapped elements that are able to open/close this nav menu.
    * @param {Boolean} deviceSpecs  &nbsp;-&nbsp; Determines whether or not to display device information (Browser, Platform, Locale, Cookies Enabled)
    * @param {String} productName  &nbsp;-&nbsp; Additional product name information to display
    * @param {Boolean} useDefaultCopyright  &nbsp;-&nbsp; Add the Legal Approved Infor Copy Right Text
    * @param {String} version  &nbsp;-&nbsp; Semantic Version Number for example (4.0.0)
    *
    */
    function ApplicationMenu(element) {
      this.settings = $.extend({}, settings);
      this.element = $(element);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    // Plugin Methods
    ApplicationMenu.prototype = {

      init: function() {
        this
          .setup()
          .handleEvents();
      },

      setup: function() {
        this.hasTrigger = false;
        this.isAnimating = false;

        if (!this.hasTriggers()) {
          this.triggers = $();
        }

        this.menu = this.element;

        var openOnLarge = this.element.attr('data-open-on-large');
        this.settings.openOnLarge = openOnLarge !== undefined ? openOnLarge === 'true' : this.settings.openOnLarge;

        var breakpoints = {
          'tablet': 767,
          'phablet': 968,
          'desktop': 1024,
          'large': 1280
        },
        dataBreakpoint = this.element.attr('data-breakpoint');
        this.settings.breakpoint = breakpoints[dataBreakpoint] !== undefined ? dataBreakpoint : this.settings.breakpoint;
        this.breakpoint = breakpoints[this.settings.breakpoint];

        // Pull in the list of Nav Menu trigger elements and store them internally.
        this.modifyTriggers(this.settings.triggers, false, true);

        this.scrollTarget = this.menu.parents('.header');
        var masthead = this.menu.prevAll('.masthead'),
          moduleTabs = this.menu.prevAll('.module-tabs');

        if (masthead.length > 0) {
          this.scrollTarget = masthead;
          this.menu.addClass('short');
        }
        if (moduleTabs.length > 0) {
          this.scrollTarget = moduleTabs;
        }

        this.accordion = this.menu.find('.accordion');
        this.accordion.addClass('panel').addClass('inverse');

        // Check to make sure that the internal Accordion Control is invoked
        var accordion = this.accordion.data('accordion');
        if (!accordion) {
          var accOpts = $.fn.parseOptions(this.accordion[0]);
          this.accordion.accordion(accOpts);
        }

        this.adjustHeight();

        return this;
      },

      // Setup click events on this.element if it's not the menu itself
      // (this means that it's a trigger button)
      handleTriggerEvents: function() {
        var self = this;

        function triggerClickHandler(e) {
          // Don't allow hamburger buttons that have changed state to activate/deactivate the app menu.
          if ($(e.currentTarget).find('.icon.app-header').hasClass('go-back')) {
            return false;
          }

          if (self.isAnimating) {
            return false;
          }

          var isOpen = self.menu.hasClass('is-open');
          if (!isOpen) {
            self.openMenu();
          } else {
            self.closeMenu();
          }
          return true;
        }

        if (this.triggers.length) {
          this.triggers.off('click.applicationmenu').on('click.applicationmenu', triggerClickHandler);
        }
      },

      handleKeyDown: function(e) {
        var key = e.which;

        if (key === 27) { // Escape
          e.preventDefault();
          this.closeMenu();
          if (this.triggers.length) {
            this.triggers.eq(0).focus();
          }
          return false;
        }
      },

      notify: function(anchor, value) {
        if (!anchor || anchor === undefined) {
          return;
        }
        if (anchor instanceof HTMLElement) {
          anchor = $(anchor);
        }
        if (!anchor.is('a')) {
          return;
        }

        var tag = anchor.find('.tag');

        // Close the tag if an undefined or '0' value is passed
        if (!value || value === undefined || parseInt(value, 10) === 0) {
          if (tag.length) {
            tag.remove();
          }
          return;
        }

        if (!tag.length) {
          tag = $('<span class="tag"></span>').appendTo(anchor);
        }

        tag.text(value.toString());
        return tag;
      },

      adjustHeight: function() {
        var isSticky = this.scrollTarget.is('.is-sticky'),
          totalHeight = this.scrollTarget.outerHeight(true),
          offset = totalHeight - (!isSticky ? $(window).scrollTop() : 0);

        if (this.scrollTarget.prev().is('.masthead')) {
          offset += this.scrollTarget.prev().outerHeight(true);
        }

        this.menu[0].style.height = offset > 0 ? ('calc(100% - ' + offset + 'px)') : '100%';
      },

      isLargerThanBreakpoint: function() {
        return $(window).width() > this.breakpoint;
      },

      testWidth: function() {
        if (this.isLargerThanBreakpoint()) {
          this.menu.removeClass('show-shadow');
          if (this.settings.openOnLarge && !this.menu.hasClass('is-open') && this.isAnimating === false) {
            this.openMenu(true);
          }
        } else {
          this.menu.addClass('show-shadow');
          if (!this.element.find(document.activeElement).length && this.menu.is('.is-open') && this.isAnimating === false) {
            this.closeMenu();
          }
        }
      },

      openMenu: function(noFocus) {
        if (this.isAnimating === true) {
          return;
        }

        var self = this,
          transitionEnd = $.fn.transitonEndName;

        this.isAnimating = true;
        this.adjustHeight();

        function isOpen() {
          if (self.timeout !== null) {
            clearTimeout(self.timeout);
            self.timeout = null;
          }

          self.isAnimating = false;
          self.element.trigger('applicationmenuopen');
          self.menu.removeClass('no-transition');
          $('.page-container').removeClass('no-transition');
        }

        this.triggers.each(function() {
          var trig = $(this);
          if (trig.parents('.header').length > 0 || trig.parents('.masthead').length > 0) {
            var header = trig.parents('.header, .masthead');
            if (header.parents('.page-container').length) {
              return;
            }

            trig.find('.icon.app-header').removeClass('go-back').addClass('close');
            trig.trigger('icon-change');
          }
        });

        this.menu.off(transitionEnd + '.applicationmenu');
        this.menu[0].style.display = '';
        // next line forces a repaint
        this.menu[0].offsetHeight; //jshint ignore:line
        this.menu.addClass('is-open');

        if (!noFocus || noFocus !== true) {
          this.menu.find('.is-selected > a').focus();
        }

        this.menu.one(transitionEnd + '.applicationmenu', isOpen);
        this.timeout = setTimeout(isOpen, 300);

        // Events that will close the nav menu
        // On a timer to prevent conflicts with the Trigger button's click events
        setTimeout(function() {
          $(document).on('touchend.applicationmenu touchcancel.applicationmenu', function(e) {
            e.preventDefault();
            $(e.target).click();
          }).on('click.applicationmenu', function(e) {
            if ($(e.target).parents('.application-menu').length < 1 && !self.isLargerThanBreakpoint()) {
              self.closeMenu($(e.target).hasClass('application-menu-trigger'));
            }
          }).on('keydown.applicationmenu', function(e) {
            self.handleKeyDown(e);
          });
        }, 0);
      },

      closeMenu: function() {
        if (this.isAnimating === true) {
          return;
        }

        var self = this,
          transitionEnd = $.fn.transitionEndName();

        this.isAnimating = true;

        function close() {
          if (self.timeout !== null) {
            clearTimeout(self.timeout);
            self.timeout = null;
          }

          self.menu.off(transitionEnd + '.applicationmenu');
          self.menu[0].style.display = 'none';
          self.isAnimating = false;
          self.element.trigger('applicationmenuclose');
        }

        this.triggers.each(function() {
          var trig = $(this);
          if (trig.parents('.header').length > 0 || trig.parents('.masthead').length > 0) {
            trig.find('.icon.app-header').removeClass('close');
            trig.trigger('icon-change');
          }
        });

        this.menu.one(transitionEnd + '.applicationmenu', close);
        this.timeout = setTimeout(close, 300);

        this.menu.removeClass('is-open').find('[tabindex]');
        $(document).off('touchend.applicationmenu touchcancel.applicationmenu click.applicationmenu keydown.applicationmenu');
      },

      hasTriggers: function() {
        return (this.triggers !== undefined && this.triggers instanceof $ && this.triggers.length);
      },

      // Externally Facing function that can be used to add/remove application nav menu triggers.
      // If the 'remove' argument is defined, triggers that are defined will be removed internally instead of added.
      // If the 'norebuild' argument is defined, this control's events won't automatically be rebound to include
      // the new triggers.
      modifyTriggers: function(triggers, remove, norebuild) {
        if (!triggers || !triggers.length) {
          return;
        }
        var changed = $();

        $.each(triggers, function(i, obj) {
          changed = changed.add($(obj));
        });

        this.triggers = this.triggers[!remove ? 'add' : 'not'](changed);
        this.handleTriggerEvents();

        if (norebuild && norebuild === true) {
          return;
        }

        this.updated();
      },

      teardown: function() {
        var api;
        this.accordion.off('blur.applicationmenu');
        this.menu.off('animateopencomplete animateclosedcomplete');
        $(window).off('scroll.applicationmenu');
        $(document).off('touchend.applicationmenu touchcancel.applicationmenu click.applicationmenu open-applicationmenu close-applicationmenu');

        api = this.accordion ? this.accordion.data('accordion') : null;
        if (api && api.destroy) {
          api.destroy();
        }

        if (this.hasTriggers()) {
          this.triggers.off('click.applicationmenu');
        }

        return this;
      },

      /**
      * Triggers a UI Resync.
      */
      updated: function() {
        return this
          .teardown()
          .init();
      },

      /**
      * Teardown - Remove added markup and events
      */
      destroy: function() {
        this.teardown();
        this.menu
          .detach()
          .appendTo(this.originalParent)
          .removeClass('short')
          .removeAttr('style');
        $.removeData(this.element[0], pluginName);
      },

      /**
       *  This component fires the following events.
       *
       * @fires Applicationmenu#events
       * @param {Object} applicationmenuopen  &nbsp;-&nbsp; Fires when the menu is opened.
       * @param {Object} applicationmenuclose  &nbsp;-&nbsp; Fires as the menu is closed.
        *
       */
      handleEvents: function() {
        var self = this;

        this.handleTriggerEvents();

        // Setup notification change events
        this.menu.on('notify.applicationmenu', function(e, anchor, value) {
          self.notify(anchor, value);
        }).on('updated.applicationmenu', function() {
          self.updated();
        });

        this.accordion.on('blur.applicationmenu', function() {
          self.closeMenu();
        });

        $(document).on('open-applicationmenu', function() {
          self.openMenu();
        }).on('close-applicationmenu', function() {
          self.closeMenu();
        });

        $(window).on('scroll.applicationmenu', function() {
          self.adjustHeight();
        }).on('resize.applicationmenu', function() {
          self.testWidth();
        });

        if (this.settings.openOnLarge && this.isLargerThanBreakpoint()) {
          this.menu.addClass('no-transition');
          $('.page-container').addClass('no-transition');
        }
        this.testWidth();

        //Remove after initial transition
        setTimeout(function() {
          self.menu.removeClass('no-transition');
          $('.page-container').removeClass('no-transition');
        }, 800);

        return this;
      }

    };

    // Initialize the plugin (Once)
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (instance) {
        instance.settings = $.extend({}, instance.settings, options);
        instance.updated();
      } else {
        instance = $.data(this, pluginName, new ApplicationMenu(this, settings));
      }
    });
  };


  $.fn.autocomplete = function(options) {
    'use strict';

    /**
    * The Autocomplete control provides an easier means of searching through a large amount of data by filtering down the results based on keyboard input from the user.
    *
    * @class Autocomplete
    *
    * @param {String} source  &nbsp;-&nbsp; Defines the data to use, must be specified.
    * @param {String} sourceArguments  &nbsp;-&nbsp; If a source method is defined, this flexible object can be passed into the source method, and augmented with parameters specific to the implementation.
    * @param {Boolean} template  &nbsp;-&nbsp; If defined, use this to draw the contents of each search result instead of the default draw routine.
    * @param {String} filterMode  &nbsp;-&nbsp; The matching algorithm, startsWith and contains are supported - false will not filter client side
    * @param {Boolean} delay  &nbsp;-&nbsp; The delay between key strokes on the keypad before it thinks you stopped typing
    * @param {String} width  &nbsp;-&nbsp; Width of the open auto complete menu
    * @param {String} offset  &nbsp;-&nbsp; For the open menu, the left or top offset
    * @param {String} autoSelectFirstItem  &nbsp;-&nbsp; Whether or not to select he first item in the list to be selected
    *
    */
    var pluginName = 'autocomplete',
      defaults = {
        source: [],
        sourceArguments: {},
        template: undefined,
        filterMode: 'startsWith',
        delay: 300,
        width: null,
        offset: null,
        autoSelectFirstItem: false
      },
      settings = $.extend({}, defaults, options);

    function Autocomplete(element) {
      this.settings = $.extend({}, settings);
      this.element = $(element);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    // Default Autocomplete Result Item Template
    var resultTemplate = '<li id="{{listItemId}}" data-index="{{index}}" {{#hasValue}}data-value="{{value}}"{{/hasValue}} role="listitem">' + '\n\n' +
      '<a href="#" tabindex="-1">' + '\n\n' +
        '<span>{{{label}}}</span>' + '\n\n' +
      '</a>' + '\n\n' +
    '</li>';

    // Plugin Object
    Autocomplete.prototype = {

      init: function() {
        // data-autocomplete can be a url, 'source' or an array
        var data = this.element.attr('data-autocomplete');
        if (data && data !== 'source') {
          this.settings.source = data;
        }

        this.addMarkup();
        this.handleEvents();
      },

      addMarkup: function () {
        this.element.addClass('autocomplete').attr({
          'role': 'combobox',
          'autocomplete': 'off'
        });
      },

      isLoading: function() {
        return this.element.hasClass('is-loading') && this.element.hasClass('is-blocked');
      },

      openList: function (term, items) {
        if (this.element.is('[disabled], [readonly]') || this.isLoading()) {
          return;
        }

        var self = this,
          matchingOptions = [];

        term = Locale.toLowerCase(term);

        //append the list
        this.list = $('#autocomplete-list');
        if (this.list.length === 0) {
          this.list = $('<ul id="autocomplete-list" aria-expanded="true"></ul>').appendTo('body');
        }

        this.list[0].style.height = 'auto';
        this.list[0].style.width = this.element.outerWidth() + 'px';
        this.list.addClass('autocomplete');
        this.list.empty();

        if (this.settings.width) {
          this.list[0].style.width = this.settings.width + (/(px|%)/i.test(this.settings.width + '') ? '' : 'px');
        }

        // Pre-compile template.
        // Try to get an element first, and use its contents.
        // If the string provided isn't a selector, attempt to use it as a string, or fall back to the default template.
        var templateAttr = $(this.element.attr('data-tmpl'));
        this.tmpl = $(templateAttr).length ? $(templateAttr).text() :
          typeof templateAttr === 'string' ? templateAttr :
          $(this.settings.template).length ? $(this.settings.template).text() :
          typeof this.settings.template === 'string' ? this.settings.template :
          resultTemplate;

        for (var i = 0; i < items.length; i++) {
          var isString = typeof items[i] === 'string',
            option = (isString ? items[i] : items[i].label),
            baseData = {
              label: option
            },
            dataset = isString ? baseData : $.extend(baseData, items[i]),
            parts = option.split(' '),
            containsTerm = !this.settings.filterMode ? true : false;

          if (this.settings.filterMode === 'startsWith') {
              for (var a = 0; a < parts.length; a++) {
                if (Locale.toLowerCase(parts[a]).indexOf(term) === 0) {
                  containsTerm = true;
                }
              }

              //Direct Match
              if (Locale.toLowerCase(option).indexOf(term) === 0) {
                containsTerm = true;
              }

              if (term.indexOf(' ') > 0 && Locale.toLowerCase(option).indexOf(term) > 0) {
                //Partial dual word match
                containsTerm = true;
              }

          }

          if (this.settings.filterMode === 'contains') {
            if (Locale.toLowerCase(option).indexOf(term) >= 0) {
              containsTerm = true;
            }
          }

          if (containsTerm) {
            matchingOptions.push(option);

            // Build the dataset that will be submitted to the template
            dataset.listItemId = 'ac-list-option' + i;
            dataset.index = i;

            if (this.settings.filterMode === 'contains') {
              dataset.label = dataset.label.replace(new RegExp('(' + term + ')', 'ig'), '<i>$1</i>');
            } else {
              dataset.label = Locale.toLowerCase(option).indexOf(term)===0 ? '<i>' + option.substr(0,term.length) + '</i>' + option.substr(term.length) : option;

              var pos = Locale.toLowerCase(option).indexOf(term);
              if (pos > 0) {
                dataset.label = option.substr(0, pos) + '<i>' + option.substr(pos, term.length) + '</i>' + option.substr(term.length + pos);
              }
            }

            dataset.hasValue = !isString && items[i].value !== undefined;

            if (dataset.hasValue) {
              dataset.value = items[i].value;
            }

            if (typeof Tmpl !== 'undefined') {
              var compiledTmpl = Tmpl.compile(this.tmpl),
                renderedTmpl = compiledTmpl.render(dataset);

              self.list.append($.sanitizeHTML(renderedTmpl));
            } else {
              var listItem = $('<li role="listitem"></li>');
              listItem.attr('id', dataset.listItemId);
              listItem.attr('data-index', dataset.index);
              listItem.attr('data-value', dataset.value);
              listItem.append('<a href="#" tabindex="-1"><span>' + dataset.label + '</span></a>');
              self.list.append($.sanitizeHTML(listItem));
            }
          }
        }

        function autocompletePlaceCallback(placementObj) {
          // Nudge the autocomplete to the right by 1px in Chrome
          if (Soho.env.browser.name === 'chrome') {
            placementObj.setCoordinate('x', placementObj.x + 1);
          }
          return placementObj;
        }

        var popupOpts = {
          menuId: 'autocomplete-list',
          ariaListbox: true,
          mouseFocus: false,
          trigger: 'immediate',
          attachToBody: true,
          autoFocus: false,
          placementOpts: {
            callback: autocompletePlaceCallback,
            parent: this.element
          }
        };

        this.element.addClass('is-open')
          .popupmenu(popupOpts)
          .on('close.autocomplete', function () {
            self.closeList(true);
          });

        // Optionally select the first item in the list
        if (self.settings.autoSelectFirstItem) {
          self.list.children().filter(':not(.separator):not(.hidden):not(.heading):not(.group):not(.is-disabled)').first()
            .addClass('is-selected');
        }

        this.noSelect = true;
        this.element.trigger('populated', [matchingOptions]).focus();

        // Overrides the 'click' listener attached by the Popupmenu plugin
        self.list.off('click touchend')
          .on('touchend.autocomplete click.autocomplete', 'a', function(e) {
            self.select(e, items);
          })
          .off('focusout.autocomplete').on('focusout.autocomplete', function() {
            self.checkActiveElement();
          });

        // Highlight anchors on focus
        var all = self.list.find('a').on('focus.autocomplete touchend.autocomplete', function () {
          self.highlight($(this), all);
        });

        if (this.settings.offset) {
          var domListParent = this.list.parent()[0];

          if (this.settings.offset.left) {
            domListParent.style.left = parseInt(domListParent.style.left, 10) + this.settings.offset.left + 'px';
          }
          if (this.settings.offset.top) {
            domListParent.style.top = parseInt(domListParent.style.top, 10) + this.settings.offset.top + 'px';
          }
        }

        // As chars are typed into the edit field, nothing was announced to indicate
        // that a value has been suggested, for the non-sighted user an offscreen span
        // added and will remove soon popup close that includes aria-live="polite"
        // which have the first suggested item automatically announced when it
        // appears without moving focus.
        self.list.parent('.popupmenu-wrapper').append(''+
          '<span id="ac-is-arialive" aria-live="polite" class="audible">'+
            $.trim(this.list.find('>li:first-child').text()) +
          '</span>');

        this.noSelect = true;
        this.element.trigger('listopen', [items]);
      },

      closeList: function(dontClosePopup) {
        var popup = this.element.data('popupmenu');
        if (!popup) {
          return;
        }

        if (!dontClosePopup) {
          popup.close();
        }

        this.element.trigger('listclose');
        $('#autocomplete-list').parent('.popupmenu-wrapper').remove();
        $('#autocomplete-list').remove();
        this.element.removeClass('is-open');
      },

      listIsOpen: function() {
        return this.list instanceof $ && this.list.length && this.list.is(':visible');
      },

      // Handles the Autocomplete's "keydown" event
      handleAutocompleteKeydown: function(e) {
        var self = this;

        if (this.isLoading()) {
          e.preventDefault();
          return false;
        }

        if (!this.listIsOpen()) {
          return;
        }

        function getHighlighted(items) {
          return items.filter('.is-selected');
        }

        function unhighlight(item) {
          item.removeClass('is-selected is-focused');
        }

        function highlight(item) {
          item.addClass('is-selected').find('a').focus();
        }

        var excludes = 'li:not(.separator):not(.hidden):not(.heading):not(.group):not(.is-disabled)',
          items = this.list.find(excludes),
          highlighted = getHighlighted(items);

        //Down - select next
        if (e.keyCode === 40 && this.listIsOpen()) {
          if (highlighted.length) {
            self.noSelect = true;
            unhighlight(highlighted);
            highlight( items.eq(items.index(highlighted) + 1) );
            e.preventDefault();
            e.stopPropagation();
          }
        }

        //Up select prev
        if (e.keyCode === 38 && this.listIsOpen()) {
          if (highlighted.length) {
            self.noSelect = true;
            unhighlight(highlighted);
            highlight( items.eq(items.index(highlighted) - 1) );
            e.preventDefault();
            e.stopPropagation();
          }
        }

        //Enter/Tab - apply selected item
        if ((e.keyCode === 9 || e.keyCode === 13) && this.listIsOpen()) {
          //Apply selection if an item is selected, otherwise close list and allow default tab/enter behavior to happen
          if (highlighted.length) {
            e.stopPropagation();
            e.preventDefault();
            self.noSelect = true;
            self.select(highlighted, this.currentDataSet);
          } else {
            self.closeList();
          }
        }

        if (e.keyCode === 8 && this.listIsOpen()) {
          self.element.trigger('input');
        }
      },

      // Handles the Autocomplete's "input" event
      handleAutocompleteInput: function(e) {
        var self = this;

        if (self.isLoading()) {
          e.preventDefault();
          return false;
        }

        // Makes a new AJAX call every time a key is pressed.
        var waitForSource = this.getDataFromSource();
        waitForSource.done(function doneHandler(term, response) {
          self.currentDataSet = response;
          self.openList(term, response);
        });
      },

      /**
       * Check to see whether or not the currently-focused element resides within the Autocomplete's field
       * or list, and if not, fires a "safe-blur" event on the element.
       *
       * @private
       * @param {Object} e - The event object passed in from the jQuery `.on()` listener.
       */
      checkActiveElement: function() {
        var self = this;
        setTimeout( function() {
          var activeElem = document.activeElement;

          if ((self.listIsOpen() && $.contains(self.list[0], activeElem)) || self.element.is(activeElem)) {
            return;
          }

          self.element.trigger('safe-blur');
        }, 0);
      },

      getDataFromSource: function() {
        var self = this;

        // Don't attempt to load if we're already loading.
        if (self.isLoading()) {
          return false;
        }

        var field = this.element,
          dfd = $.Deferred(),
          buffer;

        clearTimeout(this.loadingTimeout);

        function done(searchTerm, response, deferredStatus) {
          self.element.triggerHandler('complete'); // For Busy Indicator
          self.element.trigger('requestend', [searchTerm, response]);

          if (deferredStatus === false) {
            return dfd.reject(searchTerm);
          }
          return dfd.resolve(searchTerm, response);
        }

        this.loadingTimeout = setTimeout(function () {
          if (self.isLoading()) {
            return;
          }

          buffer = field.val();
          if (buffer === '') {
            if (self.element.data('popupmenu')) {
              self.element.data('popupmenu').close();
            }
            return;
          }
          buffer = buffer;

          var sourceType = typeof self.settings.source;
          self.element.triggerHandler('start'); // For Busy Indicator
          self.element.trigger('requeststart', [buffer]);

          if (sourceType === 'function') {
            // Call the 'source' setting as a function with the done callback.
            self.settings.source(buffer, done, self.settings.sourceArguments);
          } else if (sourceType === 'object') {
            // Use the 'source' setting as pre-existing data.
            // Sanitize accordingly.
            var sourceData = $.isArray(self.settings.source) ? self.settings.source : [self.settings.source];
            done(buffer, sourceData, true);
          } else if (!self.settings.source) {
            dfd.reject(buffer);
            return;
          } else {

            // Attempt to resolve source as a URL string.  Do an AJAX get with the URL
            var sourceURL = self.settings.source.toString(),
              request = $.getJSON(sourceURL + buffer);

            request.done(function(data) {
              done(buffer, data, true);
            }).fail(function() {
              done(buffer, [], false);
            });
          }

        }, self.settings.delay);

        return dfd;
      },

      // Handles the Autocomplete's "focus" event
      handleAutocompleteFocus: function() {
        var self = this;
        if (this.noSelect) {
          this.noSelect = false;
          return;
        }

        //select all
        setTimeout(function () {
          self.element.select();
        }, 10);
      },

      highlight: function(anchor, allAnchors) {
        var text = anchor.text().trim();

        if (anchor.find('.display-value').length > 0) {
          text = anchor.find('.display-value').text().trim();
        }

        if (allAnchors && allAnchors.length) {
          allAnchors.parent('li').removeClass('is-selected');
        }
        anchor.parent('li').addClass('is-selected');

        this.noSelect = true;
        this.element.val(text).focus();
      },

      select: function(anchorOrEvent, items) {
        var a, li, ret, dataIndex, dataValue,
          isEvent = false;

        // Initial Values
        if (anchorOrEvent instanceof $.Event) {
          isEvent = true;
          a = $(anchorOrEvent.currentTarget);
        } else {
          a = anchorOrEvent;
        }

        if (a.is('li')) {
          li = a;
          a = a.children('a');
        }

        li = a.parent('li');
        ret = a.text().trim();
        dataIndex = li.attr('data-index');
        dataValue = li.attr('data-value');

        this.element.attr('aria-activedescendant', li.attr('id'));

        if (items && items.length) {
          // If the data-index attr is supplied, use it to get the item (since two items could have same value)
          if (dataIndex) {
            ret = items[parseInt(dataIndex, 10)];
          } else if (dataValue) {
            // Otherwise use data-value to get the item (a custom template may not supply data-index)
            for (var i = 0, value; i < items.length; i++) {
              value = items[i].value.toString();
              if (value === dataValue) {
                ret = items[i];
              }
            }
          }
        }

        this.closeList();
        this.highlight(a);

        this.noSelect = true;
        this.element
          .trigger('selected', [a, ret])
          .focus();

        if (isEvent) {
          anchorOrEvent.preventDefault();
        }

        return false;
      },

      updated: function() {
        this.teardown().init();
        return this;
      },

      /**
      * Enable the input from readonly or disabled state.
      */
      enable: function() {
        this.element.prop('disabled', false);
      },

      /**
      * Disable the input from editing
      */
      disable: function() {
        this.element.prop('disabled', true);
      },

      teardown: function(){
        var popup = this.element.data('popupmenu');
        if (popup) {
          popup.destroy();
        }

        this.element.off('keypress.autocomplete focus.autocomplete requestend.autocomplete updated.autocomplete');
        return this;
      },

      /**
      * Teardown and remove any added markup and events.
      */
      destroy: function() {
        this.teardown();
        $.removeData(this.element[0], pluginName);
      },

      /**
       *  This component fires the following events.
       *
       * @fires Autocomplete#events
       * @param {Object} listopen  &nbsp;-&nbsp; Fires when the menu is opened.
       * @param {Object} listclosed  &nbsp;-&nbsp; Fires when the menu is closed.
       * @param {Object} populated  &nbsp;-&nbsp; Fires after the menu is populated with its contents.
       * @param {Object} input  &nbsp;-&nbsp; Fires after the input is edited.
       * @param {Object} safe-blur  &nbsp;-&nbsp; Fires after the input (and menu) both loose focus
       * @param {Object} requestend  &nbsp;-&nbsp; Fires when the ajax request (source option) is completed
       * @param {Object} requeststart  &nbsp;-&nbsp; Fires when the ajax request (source option) is initiated
       */
      handleEvents: function () {
        //similar code as dropdown but close enough to be dry
        var self = this;

        this.element.off('updated.autocomplete').on('updated.autocomplete', function() {
          self.updated();
        }).off('keydown.autocomplete').on('keydown.autocomplete', function(e) {
          self.handleAutocompleteKeydown(e);
        }).off('input.autocomplete').on('input.autocomplete', function (e) {
          self.handleAutocompleteInput(e);
        }).off('focus.autocomplete').on('focus.autocomplete', function () {
          self.handleAutocompleteFocus();
        }).off('focusout.autocomplete').on('focusout.autocomplete', function () {
          self.checkActiveElement();
        });
      }

    };

    // Initialize Once
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (!instance) {
        instance = $.data(this, pluginName, new Autocomplete(this, settings));
      } else {
        instance.settings = $.extend({}, instance.settings, options);
        instance.updated();
      }
    });
  };


  $.fn.busyindicator = function(options) {
    'use strict';

    // Settings and Options
    var pluginName = 'busyindicator',
        defaults = {
          blockUI: true,
          text: null,
          displayDelay: 1000,
          timeToComplete: 0,
          transparentOverlay: false
        },
        settings = $.extend({}, defaults, options);

    /**
    * A Busy Indicator notifies the user that the system is processing a request, and that they must wait for that request to be processed before continuing with the current task.
    *
    * @class BusyIndicator
    * @param {String} blockUI  &nbsp;-&nbsp; makes the element that Busy Indicator is invoked on unusable while it's displayed.
    * @param {String} text  &nbsp;-&nbsp; Custom Text To Show or Will Show Localized Loading....
    * @param {String} displayDelay  &nbsp;-&nbsp; umber in miliseconds to pass before the markup is displayed.  If 0, displays immediately.
    * @param {Boolean} timeToComplete  &nbsp;-&nbsp; fires the 'complete' trigger at a certain timing interval.  If 0, goes indefinitely.
    * @param {String} transparentOverlay  &nbsp;-&nbsp; If true, allows the "blockUI" setting to display an overlay that prevents interaction, but appears transparent instead of gray.
    *
    */
    function BusyIndicator(element) {
      this.settings = $.extend({}, settings);
      this.element = $(element);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    // Plugin Methods
    BusyIndicator.prototype = {

      init: function() {
        this.inlineLabel = this.element.closest('label');
        this.inlineLabelText = this.inlineLabel.find('.label-text');
        this.isInlineLabel = this.element.parent().is('.inline');

        this
          .setup()
          .handleEvents();
      },

      // Sanitize incoming option values
      setup: function() {
        var blockUI = this.element.attr('data-block-ui'),
          delay = this.element.attr('data-display-delay'),
          completionTime = this.element.attr('data-completion-time');

        this.blockUI = blockUI !== undefined ? blockUI : this.settings.blockUI;
        this.loadingText = this.settings.text ? this.settings.text : Locale.translate('Loading');
        this.delay = delay !== undefined && !isNaN(delay) && parseInt(delay, 10) > 20 ? delay : !isNaN(this.settings.displayDelay) && this.settings.displayDelay >= 20 ? this.settings.displayDelay : 20;
        this.completionTime = completionTime !== undefined && !isNaN(completionTime) ? parseInt(completionTime, 10) : this.settings.timeToComplete;

        return this;
      },

      /**
      * Builds and starts the indicator
      */
      activate: function() {
        var self = this;

        // If the markup already exists don't do anything but clear
        if (this.container) {
          if (self.closeTimeout) {
            clearTimeout(self.closeTimeout);
          }
          this.label.remove();
          this.label = $('<span>' + this.loadingText + '</span>').appendTo(this.container);

          if (this.element.is('input, .dropdown, .multiselect, .busy-xs, .busy-sm')) {
            this.label.addClass('audible');
          }

          this.container
            .removeClass('is-hidden')
            .trigger('afterstart');
          return;
        }

        // Build all the markup
        this.container = $('<div class="busy-indicator-container is-hidden"></div>').attr({
          'aria-live': 'polite',
          'role': 'status'
        });
        this.loader = $('<div class="busy-indicator active"></div>').appendTo(this.container);

        $('<div class="bar one"></div>' +
          '<div class="bar two"></div>' +
          '<div class="bar three"></div>' +
          '<div class="bar four"></div>' +
          '<div class="bar five"></div>').appendTo(this.loader);

        this.label = $('<span>'+ this.loadingText +'</span>').appendTo(this.container);

        var transparency = '';

        if (this.blockUI) {
          if (this.settings.transparentOverlay) {
            transparency = ' transparent';
          }

          this.originalPositionProp = this.element[0].style.position;
          this.element[0].style.position = 'relative';
          this.overlay = $('<div class="overlay busy is-hidden'+ transparency +'"></div>').appendTo(this.element);
          this.container.addClass('blocked-ui');
        }

        if (this.element.is('.busy-xs, .busy-sm')) {
          this.label.addClass('audible');
        }

        // Append the markup to the page
        // Use special positioning logic for compatibility with certain controls
        if (this.element.is('input, .dropdown, .multiselect')) {
          this.element.addClass('is-loading');
          if (this.blockUI) {
            this.element.addClass('is-blocked');
          }
          this.label.addClass('audible');

          var target;

          if (this.element.is('input')) {
            target = this.element;
            this.container.insertAfter(this.isInlineLabel ? this.inlineLabel : this.element);
          } else {
            var dd = this.element.data('dropdown');
            target = dd.pseudoElem;
            this.container.appendTo(target.parent());
          }

          if (this.overlay) {
            this.overlay.insertAfter(this.container);
          }

          var rect = target.position(),
            h = target.outerHeight(),
            w = target.outerWidth(),
            elements = this.container.add(this.overlay),
            setCssStyle = function(el, key, value) {
              el.style[key] = value + 'px';
            };

          for (var i = 0, l = elements.length; i < l; i++) {
            setCssStyle(elements[i], 'left', rect.left);
            setCssStyle(elements[i], 'top', rect.top);
            setCssStyle(elements[i], 'bottom', rect.bottom);
            setCssStyle(elements[i], 'right', rect.right);
            setCssStyle(elements[i], 'height', h);
            setCssStyle(elements[i], 'width', w);
          }
        } else {
          // Normal Operations
          this.container.appendTo(this.element);
        }

        // Fade in shortly after adding the markup to the page (prevents the indicator from abruptly showing)
        setTimeout(function() {
          if (self.container) {
            self.container.removeClass('is-hidden');
          }
          if (self.overlay) {
            self.overlay.removeClass('is-hidden');
          }
        }, self.delay);

        // Lets external code know that we've successully kicked off.
        this.element.trigger('afterstart');

        // Start the JS Animation Loop if IE9
        if (!$.fn.cssPropSupport('animation')) {
          self.isAnimating = true;
          self.animateWithJS();
        }


        // Triggers complete if the "timeToComplete" option is set.
        if (this.completionTime > 0) {
          setTimeout(function() {
            self.element.trigger('complete');
          }, self.completionTime);
        }
      },

      /**
      * Removes the appended markup and hides any trace of the indicator
      */
      close: function(fromEvent) {
        var self = this;

        // If closed from an event, fire the necessary event triggers
        // and removes the 'is-loading' CSS class.
        if (fromEvent) {
          this.element.removeClass('is-loading');
          this.element.removeClass('is-blocked');
        }

        if (this.container) {
          this.container.addClass('is-hidden');
        }

        if (this.overlay) {
          this.overlay.addClass('is-hidden');
        }
        // Give the indicator time to fade out before removing all of its components from view
        self.closeTimeout = setTimeout(function() {
          clearTimeout(self.closeTimeout);
          if (self.container) {
            self.container.remove();
          }
          self.container = undefined;
          self.loader = undefined;
          self.label = undefined;
          if (self.overlay) {
            self.overlay.remove();
            self.element[0].style.position = self.originalPositionProp;
            self.originalPositionProp = undefined;
          }
          self.overlay = undefined;
          self.element.trigger('aftercomplete.busyindicator');
          self.element.off('complete.busyindicator');
        }, 500);
      },

      // Browsers that don't support CSS-based animation can still show the animating Busy Indicator.
      animateWithJS: function() {
        var self = this,
          bar1 = this.container.find('.bar.one'),
          bar2 = this.container.find('.bar.two'),
          bar3 = this.container.find('.bar.three'),
          bar4 = this.container.find('.bar.four'),
          bar5 = this.container.find('.bar.five'),
          t = 0,
          interval;

        // Animation Loop
        function animate() {
          if (!self.isAnimating) {
            clearInterval(interval);
            return;
          }

          t += 1;

          if (t === 1) {
            bar1.addClass('half');
          }
          if (t === 13) {
            bar1.removeClass('half').addClass('full');
            bar2.addClass('half');
          }
          if (t === 26) {
            bar1.removeClass('full').addClass('half');
            bar2.removeClass('half').addClass('full');
            bar3.addClass('half');
          }
          if (t === 39) {
            bar1.removeClass('half');
            bar2.removeClass('full').addClass('half');
            bar3.removeClass('half').addClass('full');
            bar4.addClass('half');
          }
          if (t === 51) {
            bar2.removeClass('half');
            bar3.removeClass('full').addClass('half');
            bar4.removeClass('half').addClass('full');
            bar5.addClass('half');
          }
          if (t === 64) {
            bar3.removeClass('half');
            bar4.removeClass('full').addClass('half');
            bar5.removeClass('half').addClass('full');
          }
          if (t === 77) {
            bar4.removeClass('half');
            bar5.removeClass('full').addClass('half');
          }
          if (t === 90) {
            bar5.removeClass('half');
          }

          if (t === 103) {
            t = 0;
          }
        }

        setInterval(animate, 10);
      },

      updated: function() {
        return this.setup();
      },

      /**
      * Teardown and remove any added markup and events.
      */
      destroy: function() {
        this.element.off('start.busyindicator complete.busyindicator afterstart.busyindicator aftercomplete.busyindicator updated.busyindicator');
        $.removeData(this.element[0], pluginName);
      },

      /**
       *  This component listens to the following events.
       *
       * @fires Busyindicator#events
       * @param {Object} start  &nbsp;-&nbsp; Starts / shows the indictor.
       * @param {Object} complete  &nbsp;-&nbsp; Hides / Ends the indictaor
       * @param {Object} updated  &nbsp;-&nbsp; Sync the UI/Settings. Fx chnaging the text in the DOM.
       *
       */
      handleEvents: function() {
        var self = this;
        self.element.on('start.busyindicator', function(e) {
          e.stopPropagation();
          self.activate();
        }).on('afterstart.busyindicator', function() {
          // Complete event is only active once the indicator is "started"
          self.element.on('complete.busyindicator', function(e) {
            e.stopPropagation();
            self.close(true);
          });
        }).on('updated.busyindicator', function() {
          self.close(true);
          self.updated();
        });

        return this;
      },

    };

    // Initialize the plugin (Once)
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (instance) {
        instance.settings = $.extend({}, instance.settings, options);
        instance.updated();
      } else {
        instance = $.data(this, pluginName, new BusyIndicator(this, settings));
      }
    });
  };


  $.fn.button = function(options) {
    'use strict';

    /**
    * Clickable Button Elements.
    *
    * @class Button
    *
    * @param {String} toggleOnIcon  &nbsp;-&nbsp; The icon to use for on state on toggle buttons
    * @param {String} toggleOffIcon  &nbsp;-&nbsp; The icon to use for off state on toggle buttons
    *
    */
    var pluginName = 'button',
      defaults = {
        toggleOnIcon: null,
        toggleOffIcon: null
      },
      settings = $.extend({}, defaults, options);

    function Button(element) {
      this.element = $(element);
      this.settings = $.extend({}, settings);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    // Plugin Methods
    Button.prototype = {
      init: function() {
        var self = this;

        this.isTouch = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        this.isSafari = $('html').is('.is-safari');
        this.isFirefox = $('html').is('.is-firefox');

        if (this.element.hasClass('no-ripple')) {
          return;
        }

        if (this.element.hasClass('btn-menu') && !this.element.hasClass('btn-icon') && !this.element.hasClass('btn-actions')) {
          var ddIcon = this.element.children('svg.icon'),
              use = ddIcon.find('use'), hasIcon = false;

          if (ddIcon.length > 0 && use.length === 1) {
            hasIcon = use.attr('xlink:href').indexOf('#icon-dropdown') > -1;
          }

          if (!hasIcon) {
            ddIcon = $.createIconElement({ icon: 'dropdown', classes: ['icon-dropdown']});
            this.element.append(ddIcon);
          }

          if (!ddIcon.hasClass('icon-dropdown')) {
            ddIcon.addClass('icon-dropdown');
          }
        }

        if (this.element.hasClass('btn-toggle') || this.element.hasClass('icon-favorite')) {
          this.element.on('click.favorite', function() {
            var elem = $(this),
              svg = elem.find('svg:not(.ripple-effect)'),
              isPressed = elem.attr('aria-pressed') === 'true';

            elem.attr('aria-pressed', isPressed ? 'false' : 'true');
            if (self.settings.toggleOffIcon && self.settings.toggleOnIcon) {
              svg.changeIcon(isPressed ? self.settings.toggleOffIcon : self.settings.toggleOnIcon);
            } else {
              elem.toggleClass('is-pressed');
            }

            if (elem.hasClass('icon-favorite') && !elem.hasClass('btn-toggle') && svg.find('use').attr('xlink:href') === '#icon-star-filled') {
              svg.changeIcon('star-outlined');
            } else if (elem.hasClass('icon-favorite') && !elem.hasClass('btn-toggle')) {
              svg.changeIcon('star-filled');
            }

          });

          if (!this.element.attr('aria-pressed')) {
            this.element.attr('aria-pressed', 'false');
          }

        }

        if (!this.element.parent().is('.field') && this.element.hasClass('btn-actions') && !this.element.data('tooltip')) {
          this.element.attr('title', Locale.translate('More')).tooltip({
            content: Locale.translate('More')
          });
        }

        this.element.hideFocus();

        this.element
        .on('touchstart.button click.button', function (e) {

          if ((self.element.attr('disabled')) || self.element.is('.is-disabled') || (!self.isTouch && e.which !== 1) ||
              ($('.ripple-effect', this).length) || (self.isTouch && e.type !== 'touchstart')) {
            return;
          }

          var element = $(this),
            btnOffset = element.offset(),
            xPos = e.pageX - btnOffset.left,
            yPos = e.pageY - btnOffset.top,
            ripple = $('<svg class="ripple-effect" focusable="false" aria-hidden="true" role="presentation"><circle r="0" class="ripple-circle"></circle></svg>');


          if (self.isTouch) {
            // Make sure the user is using only one finger and then get the touch position relative to the ripple wrapper
            e = e.originalEvent;
            if (e && e.touches && e.touches.length === 1) {
              xPos = e.touches[0].pageX - btnOffset.left;
              yPos = e.touches[0].pageY - btnOffset.top;
            }
          }

          // Using keyboard to click
          xPos = (xPos < 0) ? self.element.outerWidth()/2 : xPos;
          yPos = (yPos < 0) ? self.element.outerHeight()/2 : yPos;

          $('svg.ripple-effect', element).remove();
          ripple[0].style.left = xPos + 'px';
          ripple[0].style.top = yPos + 'px';
          element.prepend(ripple);

          // Start the JS Animation Loop if IE9
          // Or Safari/Firefox has bug with combination like: animation, overflow, position, border-radius etc.)
          if (!$.fn.cssPropSupport('animation') || self.isSafari || self.isFirefox) {
            ripple.removeClass('is-animation');
            self.animateWithJS(ripple);
          } else {
            var elem = $('svg.ripple-effect', element);
            elem.attr('class', elem.attr('class') + ' is-animation');
          }

          setTimeout(function() {
            ripple.remove();
          }, 1000);

        });
      },

      // Browsers that don't support CSS-based animation can still show the animation
      animateWithJS: function(el) {
        var scale = 200,
        elStyle = el[0].style,
        xPos = (parseFloat(elStyle.left) - (scale / 2)) + 'px',
        yPos = (parseFloat(elStyle.top)  - (scale / 2)) + 'px';

        el[0].style.opacity = '0.4';
        el.animate({
          opacity: 0,
          left: xPos,
          top: yPos,
          width: scale,
          height: scale
        }, 1000);
      },

      /**
      * Teardown and remove any added markup and events.
      */
      destroy: function() {
        this.element.off('click.button touchstart.button focusin.hide-focus focusout.hide-focus mousedown.hide-focus touchstart.hide-focus');

        var moreTooltip = this.element.data('tooltip');
        if (this.element.hasClass('btn-actions') && moreTooltip) {
          moreTooltip.destroy();
        }

        $.removeData(this.element[0], pluginName);
      },

      /**
       *  This component fires the following events.
       *
       * @fires Autocomplete#events
       * @param {Object} click  &nbsp;-&nbsp; Fires when the button is clicked (if enabled).
       * @param {Object} focus  &nbsp;-&nbsp; Fires when the menu is focused.
       */
      handleEvents: function () {
      }
    };

    // Initialize the plugin (Once)
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (!instance) {
        instance = $.data(this, pluginName, new Button(this));
      }
    });
  };

/**
* @constructor
*/

window.Chart = function(container) {
  'use strict';

  var charts = this;

  //IE8 and Below Message
  if (typeof d3 === 'undefined') {
    $(container).append('<p class="chart-message"></p>');
    return null;
  }

  var colorRange = ['#1D5F8A', '#8ED1C6', '#9279A6', '#5C5C5C', '#F2BC41', '#66A140', '#AD4242',
   '#8DC9E6', '#EFA836', '#317C73', '#EB9D9D', '#999999', '#488421', '#C7B4DB',
   '#54A1D3', '#6e5282', '#AFDC91', '#69ADA3', '#DB7726', '#D8D8D8'];

  this.isTouch = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
  this.pieColors = d3.scale.ordinal().range(colorRange);
  this.colorRange = colorRange;
  this.greyColors = d3.scale.ordinal().range(['#737373', '#999999', '#bdbdbd', '#d8d8d8']);
  this.sparklineColors = d3.scale.ordinal().range(['#1D5F8A', '#999999', '#bdbdbd', '#d8d8d8']);
  this.colors = d3.scale.ordinal().range(colorRange);

  this.chartColor = function(i, chartType, data) {
    var specColor = (data && data.color ? data.color : null);

    //error, alert, alertYellow, good, neutral or hex
    if (specColor) {
      if (specColor ==='error' ) {
        return '#e84f4f';
      }
      if (specColor ==='alert' ) {
        return '#ff9426';
      }
      if (specColor ==='alertYellow' ) {
        return '#ffd726';
      }
      if (specColor ==='good' ) {
        return '#80ce4d';
      }
      if (specColor ==='neutral' ) {
        return '#dbdbdb';
      }
      if (specColor && specColor.indexOf('#') === 0) {
        return data.color;
      }
    }

    if (chartType === 'pie') {
      return this.colorRange[i];
    }
    if (chartType === 'bar-single' || chartType === 'column-single') {
      return '#1D5F8A';
    }
    if (chartType === 'bar' || chartType === 'line') {
      return this.colors(i);
    }
  };

  // Help Function to Select from legend click
  this.selectElem = function (line, series) {
    var idx = $(line).index(),
      elem = series[idx],
      s = charts.settings,
      selector;

    if (s.chartType === 'Pie') {
      selector = d3.select(s.svg.selectAll('.arc')[0][idx]);
    }
    else if (s.type === 'column-positive-negative') {
      if (!elem.option || (elem.option && elem.option === 'target')) {
        return;
      }
      selector = s.svg.select('.bar.'+ elem.option);
    }
    else if (['Column', 'HorizontalBar'].indexOf(s.chartType) !== -1) {
      // Grouped or singlular
      if (s.isGrouped || s.isSingular) {
        selector = s.svg.select('.series-'+ idx);
      }
      // Stacked
      else if (s.isStacked && !s.isSingular) {
        var thisGroup = d3.select(s.svg.selectAll(s.chartType==='HorizontalBar' ? '.series-group' : '.g')[0][idx]);
        selector = thisGroup.select('.bar');
      }
    }

    if (['Pie', 'Column', 'HorizontalBar'].indexOf(s.chartType) !== -1) {
      s.isByLegends = true;
      selector.on('click').call(selector.node(), selector.datum(), idx);
    }

    if (elem.selectionObj) {
      charts.selectElement(d3.select(elem.selectionObj[0][idx]), elem.selectionInverse, elem.data);
    }
  };

  this.addLegend = function(series) {
    var i, s = charts.settings;

    if (series.length === 0) {
      return;
    }
    var isTwoColumn = series[0].display && series[0].display === 'twocolumn',
      legend = isTwoColumn ? $('<div class="chart-legend" style="margin: 2em auto auto; border-top: 1px solid #ccc; padding-top: 1em;"></div>') : $('<div class="chart-legend"></div>');

    // Legend width
    var width = 0,
      currentWidth,
      widthPercent;

    for (i = 0; i < series.length; i++) {
      currentWidth = series[i].name.length * 6;
      width = (series[i].name && currentWidth > width) ? currentWidth : width;
    }

    width += 55;
    widthPercent = width / $(container).width() * 100;

    for (i = 0; i < series.length; i++) {
      if (!series[i].name) {
        continue;
      }

      var extraClass = '';
      if (isTwoColumn || (series[i].display && series[i].display === 'block')) {
        extraClass += ' lg';
      }
      if (s.type === 'column-positive-negative' && series[i].option) {
        extraClass += ' '+ series[i].option;
      }

      var seriesLine = '<span class="chart-legend-item'+ extraClass +'" tabindex="0"></span>',
        hexColor = charts.chartColor(i, (series.length === 1 ? 'bar-single' : 'bar'), series[i]);

      var color = $('<span class="chart-legend-color" style="background-color: '+ (series[i].pattern ? 'transparent' : hexColor) +'"></span>'),
        textBlock = $('<span class="chart-legend-item-text">'+ series[i].name + '</span>');

      if (series[i].pattern) {
        color.append('<svg width="12" height="12"><rect style="fill: '+ hexColor +'" mask="url(#'+ series[i].pattern +')" height="12" width="12" /></svg>');
      }

      if (series[i].percent) {
        var pct = $('<span class="chart-legend-percent"></span>').text(series[i].percent);
        textBlock.append(pct);
      }

      if (series[i].display && series[i].display==='block') {
        seriesLine = '<span class="chart-legend-item'+ extraClass +'" tabindex="0" style="float: none; display: block; margin: 0 auto; width: '+ width +'px;"></span>';
      }

      if (isTwoColumn) {
        if(widthPercent > 45) {
          seriesLine = '<span class="chart-legend-item'+ extraClass +'" tabindex="0" style="float: none; display: block; margin: 0 auto; width: '+ width +'px;"></span>';
        } else {
          seriesLine = '<span class="chart-legend-item'+ extraClass +'" tabindex="0" style="float: none; display: inline-block; width: 45%;"></span>';
        }
      }
      seriesLine = $(seriesLine);
      seriesLine.append(color, textBlock);
      legend.append(seriesLine);
    }

    if (legend instanceof $) {
      legend.on('click.chart', '.chart-legend-item', function () {
          charts.selectElem(this, series);
        }).on('keypress.chart', '.chart-legend-item', function (e) {
          if (e.which === 13 || e.which === 32) {
            charts.selectElem(this, series);
          }
        });

      $(container).append(legend);
    }
  };

  this.renderLegend = function() {
    if (charts.legendformatter && typeof charts.legendformatter === 'function') {
      var markup = '';
      var runInterval = true,
      legendInterval = setInterval(function () {
        if(runInterval) {
          runInterval = false;
          charts.legendformatter(function (data) {
            markup = data;
          });
        }
        if(markup !== '') {
          clearInterval(legendInterval);
          $(container).append(markup);
        }
      }, 10);
    }
  };

  //Add Toolbar to the page
  this.appendTooltip = function() {
    this.tooltip = $('#svg-tooltip');
    if (this.tooltip.length === 0) {
      this.tooltip = $('<div id="svg-tooltip" class="tooltip right is-hidden"><div class="arrow"></div><div class="tooltip-content"><p><b>32</b> Element</p></div></div>').appendTo('body');
      if (this.isTouch) {
        this.tooltip[0].style.pointerEvents = 'auto';
        this.tooltip.on('touchend.svgtooltip', function () {
          charts.hideTooltip();
        });
      }
    }
  };

  this.triggerContextMenu = function(elem, d) {
    d3.event.preventDefault();
    d3.event.stopPropagation();
    d3.event.stopImmediatePropagation();

    var e = $.Event('contextmenu');
    e.target = elem;
    e.pageX = d3.event.pageX;
    e.pageY = d3.event.pageY;
    $(container).trigger(e, [elem, d]);
  };

  //Show Tooltip
  this.showTooltip = function(x, y, content, arrow) {
    //Simple Collision of left side
    if (x < 0) {
      x = 2;
    }

    this.tooltip[0].style.left = x + 'px';
    this.tooltip[0].style.top = y + 'px';
    this.tooltip.find('.tooltip-content').html(content);

    this.tooltip.removeClass('bottom top left right').addClass(arrow);
    this.tooltip.removeClass('is-hidden');
  };

  this.getTooltipSize = function(content) {
    this.tooltip.find('.tooltip-content').html(content);
    return {height: this.tooltip.outerHeight(), width: this.tooltip.outerWidth()};
  };

  //Hide Tooltip
  this.hideTooltip = function() {
    d3.select('#svg-tooltip').classed('is-hidden', true).style('left', '-999px');
  };

  //Format Currency
  this.formatCurrency = function(num) {
    var symbol = (Locale.currentLocale.data ? Locale.currentLocale.data.currencySign : '$');
    num = (isNaN(num * 1)) ? 0 : num;
    return symbol + (num * 1).toFixed(2);
  };

  this.HorizontalBar = function(chartData, isNormalized, isStacked) {
    //Original http://jsfiddle.net/datashaman/rBfy5/2/

    var defaults = {
      // Use d3 Format
      // http://koaning.s3-website-us-west-2.amazonaws.com/html/d3format.html
      // [null | formatter string] - Only value will be formated
      formatterString: null,
    },
    settings = $.extend(true, defaults, charts.options),
    isFormatter = !!settings.formatterString,
    format = function (value) {
      return isFormatter ? d3.format(settings.formatterString)(value) : value;
    };

    var dataset, maxTextWidth, width, height, series, rects, svg, stack, xMin, xMax,
        xScale, yScale, yAxis, yMap, xAxis, groups, isGrouped, isSingle, legendMap,
        gindex, totalBarsInGroup, totalGroupArea, totalHeight, gap, barHeight;

    var tooltipInterval,
      tooltipDataCache = [],
      tooltipData = charts.options.tooltip;

    var maxBarHeight = 30,
      legendHeight = 40,
      gapBetweenGroups = 0.5; // As of one bar height (barHeight * 0.5)

    isStacked = isStacked === undefined ? true : isStacked;

    var isViewSmall = $(container).parent().width() < 450;

    var margins = {
      top: isStacked ? 30 : 20,
      left: 30,
      right: 30,
      bottom: 30 // 30px plus size of the bottom axis (20)
    };

    dataset = chartData;
    $(container).addClass('chart-vertical-bar');

    width =  parseInt($(container).parent().width()) - margins.left - margins.right;
    height =  parseInt($(container).parent().height()) - margins.top - margins.bottom - legendHeight;  //influences the bar width

    //Get the Legend Series'
    series = dataset.map(function (d) {
      return {name: d.name, color: d.color, pattern: d.pattern};
    });

    //Map the Data Sets and Stack them.
    dataset = dataset.map(function (d) {
      return d.data.map(function (o) {
        return $.extend({}, o, {
            y: o.value,
            x: o.name,
            color: o.color,
            pattern: o.pattern
        });
      });
    });
    stack = d3.layout.stack();
    stack(dataset);

    //Calculate max text width
    maxTextWidth = 0;
    dataset = dataset.map(function (group, i) {
      if (!isStacked) {
        if (series[i]) {
          maxTextWidth = (series[i].name.length > maxTextWidth ? series[i].name.length : maxTextWidth);
        }
      }
      return group.map(function (d) {
        if(isStacked) {
          maxTextWidth = (d.x.length > maxTextWidth ? d.x.length : maxTextWidth);
        }

        // Invert the x and y values, and y0 becomes x0
        return $.extend({}, d, {
            x: d.y,
            y: d.x,
            x0: d.y0,
            color: d.color,
            pattern: d.pattern
        });

      });
    });

    var h = parseInt($(container).parent().height()) - margins.bottom - (isStacked ? 0 : (legendHeight / 2)),
      w = parseInt($(container).parent().width()) - margins.left,
      textWidth = margins.left + (maxTextWidth * 6);

    svg = d3.select(container)
      .append('svg')
      .attr('width',  w)
      .attr('height', h)
      .append('g')
      .attr('class', 'group')
      .attr('transform', 'translate(' + (textWidth) + ',' + margins.top + ')');

    xMin = d3.min(dataset, function (group) {
      return d3.min(group, function (d) {
          return isStacked ? (d.x + d.x0) : d.x;
      });
    });

    xMax = d3.max(dataset, function (group) {
      return d3.max(group, function (d) {
          return isStacked ? (d.x + d.x0) : d.x;
      });
    });

    if (isStacked && isNormalized) {
      var gMax = [];
      //get the max for each array group
      dataset.forEach(function(d) {
        d.forEach(function(d, i) {
        gMax[i] = (gMax[i] === undefined ? 0 : gMax[i]) + d.x;
       });
      });

      //Normalize Each Group
      dataset.forEach(function(d) {
        d.forEach(function(d, i) {
          var xDif = gMax[i]/100;
          d.x = d.x / xDif;
          d.x0 = d.x0 / xDif;
       });
      });
      xMax = 100;
    }

    //Width of the bar minus the margin
    var barWith = w - textWidth - margins.left;

    xScale = d3.scale.linear()
      .domain([(xMin < 0 ? xMin : 0), xMax])
      .nice()
      .range([0, barWith]).nice();

    if (isStacked) {
      yMap = dataset[0].map(function (d) {
        return d.y;
      });

      barHeight = 0.32;
    } else {
      yMap = series.map(function (d) {
        return d.name;
      });

      (function() {
        var i, l, lm;
        // Loop backwards to catch and override with found first custom info from top
        for (i = dataset.length-1,l = -1; i > l; i--) {
          lm = dataset[i].map(function (d) {
            return d;
          });
          $.extend(true, legendMap, lm);
          // Convert back to array from object
          legendMap = $.map(legendMap, function(d) {
            return d;
          });
        }
      })();

      gindex = 0;
      totalBarsInGroup = legendMap.length;
      totalGroupArea = height / yMap.length;
      barHeight = totalGroupArea / totalBarsInGroup;
      totalHeight = totalBarsInGroup > 1 ?
        totalGroupArea - (barHeight * gapBetweenGroups) : maxBarHeight;
      gap = totalGroupArea - totalHeight;
      maxBarHeight = totalHeight / totalBarsInGroup;
      barHeight = 0;
    }

    yScale = d3.scale.ordinal()
      .domain(yMap)
      .rangeRoundBands([0, height], barHeight, barHeight);

    xAxis = d3.svg.axis()
      .scale(xScale)
      .tickSize(-height)
      .orient('middle');

    if (isViewSmall) {
      xAxis.ticks(textWidth < 100 ? 5 : 3);
    }

    if (isStacked && isNormalized) {
      xAxis.tickFormat(function(d) { return d + '%'; });
    }

    yAxis = d3.svg.axis()
      .scale(yScale)
      .tickSize(0)
      .orient('left');

    svg.append('g')
      .attr('class', 'axis x')
      .attr('transform', 'translate(0,' + height + ')')
      .call(xAxis);

    svg.append('g')
      .attr('class', 'axis y')
      .call(yAxis);

    groups = svg.selectAll('g.group')
      .data(dataset)
      .enter()
      .append('g')
      .attr('class', 'series-group')
      .attr('data-group-id', function (d, i) {
        return i;
      });

    isGrouped = (svg.selectAll('.series-group')[0].length > 1 && !isStacked);
    isSingle = (svg.selectAll('.series-group')[0].length === 1 && isStacked);

    $.extend(charts.settings, {
      svg: svg,
      chartType: 'HorizontalBar',
      isSingle: isSingle,
      isGrouped: isGrouped,
      isStacked: isStacked
    });

    rects = groups.selectAll('rect')
      .data(function (d, i) {
        d.forEach(function(d) {
          d.index = i;

          if(!isStacked) {
            d.gindex = gindex++;
          }

        });
        return d;
    })
    .enter()
    .append('rect')
    .attr('class', function(d, i) {
      return 'bar series-'+ i;
    })
    .style('fill', function(d, i) {
      return isStacked ?
        (series.length === 1 ? (charts.chartColor(i, 'bar-single', d)) :
          (charts.chartColor(d.index, 'bar', series[d.index]))) :
        (charts.chartColor(i, 'bar', legendMap[i]));
    })
    .attr('mask', function (d, i) {
      if (dataset.length === 1 && dataset[0][i].pattern) {
        return 'url(#'+ dataset[0][i].pattern +')';
      }
      else if (isStacked && series[d.index].pattern) {
        return 'url(#'+ series[d.index].pattern +')';
      }
      else if (!isStacked && legendMap[i].pattern) {
        return 'url(#'+ legendMap[i].pattern +')';
      }
    })
    .attr('x', function (d) {
      return (isStacked && !isSingle) ? xScale(d.x0) : xScale(0);
    })
    .attr('y', function (d) {
      return isStacked ? yScale(d.y) :
        ((((totalGroupArea - totalHeight) / 2) + (d.gindex * maxBarHeight)) + (d.index * gap));
    })
    .attr('height', function () {
      return isStacked ? (yScale.rangeBand()) : maxBarHeight;
    })
    .attr('width', 0) //Animated in later
    .on('mouseenter', function (d, i) {
      var j, l, hexColor,
        total = 0,
        totals = [],
        content = '',
        data = d3.select(this.parentNode).datum(),
        mid = Math.round(data.length/2),
        shape = d3.select(this),
        setPattern = function(pattern, hexColor) {
          return !pattern || !hexColor ? '' :
            '<svg width="12" height="12">'+
              '<rect style="fill: '+ hexColor +'" mask="url(#'+ pattern +')" height="12" width="12" />'+
            '</svg>';
        },

        show = function(xPosS, yPosS, isTooltipBottom) {
          var size = charts.getTooltipSize(content),
            x = xPosS+(parseFloat(shape.attr('width'))/2)-(size.width/2),
            y = isTooltipBottom ? yPosS : (yPosS-size.height-13);

          if(content !== '') {
            charts.showTooltip(x, y, content, isTooltipBottom ? 'bottom' : 'top');
          }
        };

       if (dataset.length === 1) {
          content = '<p><b>'+ d.y +' </b>'+ d.x +'</p>';
        }
        else {
          content = '<div class="chart-swatch">';

          if (isStacked) {
            for (j=0,l=dataset.length; j<l; j++) {
              total = 0;
              hexColor = charts.chartColor(j, 'bar', series[j]);
              for (var k=0,kl=dataset.length; k<kl; k++) {
                total += dataset[k][i].x;
                totals[k] = dataset[k][i].x;
              }
              content += ''+
                '<div class="swatch-row">'+
                  '<div style="background-color:'+ (series[j].pattern ? 'transparent' : hexColor) +';">'+
                    setPattern(series[j].pattern, hexColor)+
                  '</div>'+
                  '<span>'+ series[j].name +'</span><b> '+ (isFormatter ? format(totals[j]) : (Math.round((totals[j]/total)*100)+'%')) +' </b>'+
                '</div>';
            }

          }
          else {
            if(mid > 1) {
              shape = d3.select(this.parentNode).select('.series-' + mid);
            }
            for (j=0,l=data.length; j<l; j++) {
              hexColor = charts.chartColor(j, 'bar', legendMap[j]);
              content += ''+
                '<div class="swatch-row">'+
                  '<div style="background-color:'+ (legendMap[j].pattern ? 'transparent' : hexColor) +';">'+
                    setPattern(legendMap[j].pattern, hexColor)+
                  '</div>'+
                  '<span>'+ data[j].name +'</span><b>'+ format(data[j].value) +'</b>'+
                '</div>';
            }
          }
          content += '</div>';
        }

        if (total > 0) {
          content = '<span class="chart-tooltip-total"><b>' + total + '</b> '+Locale.translate('Total')+'</span>' +content;
        }

        var yPosS = shape[0][0].getBoundingClientRect().top + $(window).scrollTop(),
            xPosS = shape[0][0].getBoundingClientRect().left + $(window).scrollLeft();

        var maxBarsForTopTooltip = 6,
          isTooltipBottom = (!isStacked && (data.length > maxBarsForTopTooltip));

        if (tooltipData && typeof tooltipData === 'function' && !tooltipDataCache[i]) {
          content = '';
            var runInterval = true;
            tooltipInterval = setInterval(function() {
              if (runInterval) {
                runInterval = false;
                tooltipData(function (data) {
                  content = tooltipDataCache[i] = data;
                });
              }
              if (content !== '') {
                clearInterval(tooltipInterval);
                show(xPosS, yPosS, isTooltipBottom);
              }
            }, 10);
          } else {
            content = tooltipDataCache[i] || tooltipData || d.tooltip || content || '';
            show(xPosS, yPosS, isTooltipBottom);
          }
    })
    .on('mouseleave', function () {
      clearInterval(tooltipInterval);
      charts.hideTooltip();
    })
    .on('click', function (d, i) {
      var isSelected = this && d3.select(this).classed('is-selected'),
        thisGroupId = parseInt(d3.select(this.parentNode).attr('data-group-id'), 10);

      charts.setSelectedElement({
        task: (isSelected ? 'unselected' : 'selected'),
        container: container,
        selector: this,
        isTrigger: !isSelected,
        triggerGroup: isGrouped,
        d: d,
        i: i
      });

      if (isSelected) {
        $(container).triggerHandler('selected', [d3.select(this)[0], {}, (isGrouped ? thisGroupId : i)]);
      }
      return;
    });

    //Adjust the labels
    svg.selectAll('.axis.y text').attr({'x': charts.isRTL ? 15 : -15});
    svg.selectAll('.axis.x text').attr('class', function(d) {
      return d < 0 ? 'negative-value' : 'positive-value';
    });

    if (charts.isRTL && charts.isIE) {
      svg.selectAll('text').attr('transform', 'scale(-1, 1)');
      svg.selectAll('.y.axis text').style('text-anchor', 'start');
    }

    //Animate the Bars In
    svg.selectAll('.bar')
      .transition().duration(1000)
      .attr('width', function (d) {
        return Math.abs(xScale(d.x) - xScale(0));
      })
      .attr('x', function (d) {
        return (isStacked && !isSingle) ? xScale(d.x0) : (d.x < 0 ? xScale(d.x) : xScale(0));
      });

    //Add Legends
    if (charts.showLegend) {
      charts.addLegend(isStacked ? series : legendMap);
    }
    charts.appendTooltip();

    // Set initial selected
    (function () {
      var selected = 0,
        legendsNode = svg.node().parentNode.nextSibling,
        legends = d3.select(legendsNode),
        isLegends = legends.node() && legends.classed('chart-legend'),
        barIndex, selector, isStackedGroup,

        setSelectedBar = function (g) {
          g = g ? d3.select(g) : svg;
          g.selectAll('.bar').each(function(d, i) {
            if (!d) {
              return;
            }
            if (d.selected && selected < 1) {
              selected++;
              selector = d3.select(this);
              barIndex = i;
            }
          });
        },

        setSelectedGroup = function () {
          var groups = svg.selectAll('.series-group');
          if (groups[0].length) {
            groups.each(function() {
              setSelectedBar(this);
            });
          }
        };

      if (isGrouped || (isStacked && !isSingle)) {
        chartData.forEach(function(d, i) {
          if (d.selected && selected < 1) {
            selected++;
            selector = svg.select('[data-group-id="'+ i +'"]').select('.bar');
            barIndex = i;
            if (isStacked && !isGrouped) {
              isStackedGroup = true;
            }
          }
        });
        if (selected < 1) {
          setSelectedGroup();
        }
      }
      else {
        setSelectedBar();
      }

      if (selected > 0) {
        if (isStackedGroup) {
          if (isLegends) {
            $(legends.selectAll('.chart-legend-item')[0][barIndex]).trigger('click.chart');
          }
        }
        else {
          selector.on('click').call(selector.node(), selector.datum(), barIndex);
        }
      }

    })();

    $(container).trigger('rendered');
    return $(container);
  };


  this.Pie = function(initialData, isDonut, options) {
    var defaults = {
      labels: {
        // true|false
        hideLabels: true,
        isTwoline: true,

        // 'name'|'value'|'percentage'|'name, value'|'name (value)'|'name (percentage)'
        contentsTop: 'percentage',
        contentsBottom: 'name',

        // Use d3 Format
        // http://koaning.s3-website-us-west-2.amazonaws.com/html/d3format.html
        // [null | formatter string] - Only value will be formated
        formatterTop: null,
        formatterBottom: null,

        // 'default'|'color-as-arc'|'#000000'|'black'
        colorTop: 'color-as-arc',
        colorBottom: 'default',
        lineColor: 'default',
        lineWidth: 2,
        linehideWhenMoreThanPercentage: 10
      }
    },
    settings = $.extend(true, defaults, options),
    lb = settings.labels;

    if (!lb.isTwoline && options && !options.labels.colorTop) {
      lb.colorTop = lb.colorBottom;
    }

    var self = this,
      parent = $(container).parent(),
      isRTL = charts.isRTL;

    var tooltipInterval,
      tooltipDataCache = [],
      tooltipData = charts.options.tooltip;

    charts.appendTooltip();

    var showLegend = charts.showLegend || false;

    var chartData = initialData[0].data;
    chartData = chartData.sort(function(a, b) {
      return isRTL ? +b.value - +a.value : +a.value - +b.value;
    });

    var total = d3.sum(chartData, function(d) { return d.value; });

    chartData = chartData.map(function (d) {
      return { data: d, elm: d, name: d.name, color: d.color, value: d.value, percent:d3.round(100*(d.value/total)) };
    });

    var svg = d3.select(container).append('svg'),
      arcs = svg.append('g').attr('class','arcs'),
      lines = svg.append('g').attr('class','lines'),
      centerLabel = initialData[0].centerLabel;

    $(container).addClass('chart-pie');

    var pie = d3.layout.pie().value(function (d) {
      return d.value;
    }).sort(null);


    // Store our chart dimensions
    var dims = {
      height: parseInt(parent.height()),  //header + 20 px padding
      width: parseInt(parent.width()),
      widgetheight: 318
    };
    var isSmall = (dims.width < 405);
    dims.height = dims.height > dims.widgetheight ? dims.widgetheight : dims.height;
    dims.height = isSmall && !lb.hideLabels ? dims.width : dims.height;

    dims.outerRadius = ((Math.min(dims.width, dims.height) / 2) - 40);
    dims.innerRadius = isDonut ? dims.outerRadius - (!lb.hideLabels ? 50 : 30) : 0;
    dims.labelRadius = dims.outerRadius + 20;
    dims.center = { x: dims.width / 2, y: dims.height / 2 };

    svg.attr({
      'width': '100%',
      'height': ((isSmall && !lb.hideLabels) || dims.height === dims.widgetheight) ? dims.height - 50 : '100%',
      'viewBox': '0 0 ' + dims.width + ' ' + dims.height
    });

    // move the origin of the group's coordinate space to the center of the SVG element
    arcs.attr('transform', 'translate(' + dims.center.x + ',' + dims.center.y  + ')');
    lines.attr('transform', 'translate(' + dims.center.x + ',' + dims.center.y + ')');

    var pieData = pie(chartData);

    // calculate the path information for each wedge
    var pieArcs = d3.svg.arc()
        .innerRadius(dims.innerRadius)
        .outerRadius(dims.outerRadius);

    var pieCircles = d3.svg.arc()
        .innerRadius(dims.outerRadius)
        .outerRadius(dims.outerRadius);

    var pieLabelCircles = d3.svg.arc()
        .innerRadius(dims.labelRadius)
        .outerRadius(dims.labelRadius);

    $.extend(charts.settings, {
      svg: svg,
      chartType: 'Pie'
    });

    // Draw the arcs.
    var enteringArcs = arcs.selectAll('.arc').data(pieData).enter();
    enteringArcs.append('path')
      .attr('class', 'arc')
      .on('contextmenu',function (d) {
        self.triggerContextMenu(d3.select(this).select('path')[0][0], d);
      })
      .on('click', function (d, i) {
        var isSelected = this && d3.select(this).classed('is-selected');

        if (isSelected) {
          // Make unselected
          charts.setSelectedElement({
            task: 'unselected',
            container: container,
            selector: '.chart-container .is-selected',
            isTrigger: false,
            d: d.data,
            i: i
          });
          $(container).triggerHandler('selected', [d3.select(this)[0], {}, i]);
        }
        else {
          // Make selected
          charts.setSelectedElement({
            task: 'selected',
            container: container,
            selector: this,
            isTrigger: true,
            d: d.data,
            i: i
          });
        }
      })
      .on('mouseenter', function(d, i) {
        var size, x, y, t, tx, ty,
          offset = parent.offset(),
          content = '',
          show = function() {
            size = charts.getTooltipSize(content);
            x -= size.width/2;
            y -= size.height/2;

            if (content !== '') {
              charts.showTooltip(x, y, content, 'top');
            }
          };

        var circles = svg.selectAll('.pie-circle');
        t = d3.transform(d3.select(circles[0][i]).attr('transform'));
        tx = t.translate[0] + (t.translate[0] > 0 ? 10 * -1: 10 * 1);
        ty = t.translate[1] + (t.translate[1] > 0 ? 10 * -1: 10 * 1);

        //Adjustments
        ty += (t.translate[0] > 0 && t.translate[1] > 0 ? -32 : 0);
        tx += (t.translate[1] > 0 && t.translate[0] < 0 ? 17 : 0);
        ty += (t.translate[1] < 0 && t.translate[0] < 0 ? -17 : 0);
        ty += (t.translate[0] < 0 && t.translate[1] > 0 ? -24 : 0);

        x = tx + offset.left + dims.center.x;
        y = ty + offset.top + dims.center.y;

        if (tooltipData && typeof tooltipData === 'function' && !tooltipDataCache[i]) {
          var runInterval = true;
          tooltipInterval = setInterval(function() {
            if(runInterval) {
              runInterval = false;
              tooltipData(function (data) {
                content = tooltipDataCache[i] = data;
              });
            }
            if(content !== '') {
              clearInterval(tooltipInterval);
              show();
            }
          }, 10);
        } else {
          tooltipData = typeof tooltipData === 'object' ? '' : tooltipData;
          content = tooltipDataCache[i] || tooltipData || d.data.tooltip || d.data.data.tooltip || '';
          content = content.replace('{{percent}}', d.data.percent + '%');
          content = content.replace('{{value}}', d.value);
          content = content.replace('%percent%', d.data.percent + '%');
          content = content.replace('%value%', d.value);
          show();
        }
      })
      .on('mouseleave', function () {
        clearInterval(tooltipInterval);
        charts.hideTooltip();
      })
      .style('fill', function(d, i) {return charts.chartColor(self.isRTL ? chartData.length-i-1 : i, 'pie', d.data); })
      .transition().duration(750)
      .attrTween('d', function(d) {
        var i = d3.interpolate(d.startAngle + 0.1, d.endAngle);
        return function(t) { d.endAngle = i(t); return pieArcs(d); };
      });

    // Now we'll draw our label lines, etc.
    var textLabels, textX=[], textY=[], textLabelsLength = 0,
      perEvenRound = [], perRound = [], perRoundTotal = 0,

      // http://stackoverflow.com/a/13484393
      // Fix: http://jira/browse/SOHO-4951
      evenRound = function(orig, target) {
        var i = orig.length,
          j = 0,
          total = 0,
          change,
          newVals = [],
          next, factor1,
          factor2,
          len = orig.length,
          marginOfErrors = [],
          errorFactor = function (oldNum, newNum) {
            return Math.abs(oldNum - newNum) / oldNum;
          };

        // map original values to new array
        while (i--) {
          total += newVals[i] = Math.round(orig[i]);
        }

        change = total < target ? 1 : -1;

        while (total !== target) {
          // Iterate through values and select the one that once changed will introduce
          // the least margin of error in terms of itself. e.g. Incrementing 10 by 1
          // would mean an error of 10% in relation to the value itself.
          for (i = 0; i < len; i++) {
            next = i === len - 1 ? 0 : i + 1;
            factor2 = errorFactor(orig[next], newVals[next] + change);
            factor1 = errorFactor(orig[i], newVals[i] + change);

            if (factor1 > factor2) {
              j = next;
            }
          }
          newVals[j] += change;
          total += change;
        }
        for (i = 0; i < len; i++) {
          marginOfErrors[i] = newVals[i] && Math.abs(orig[i] - newVals[i]) / orig[i];
        }

        // Math.round() causes some problems as it is difficult to know at the beginning
        // whether numbers should have been rounded up or down to reduce total margin of error.
        // This section of code increments and decrements values by 1 to find the number
        // combination with least margin of error.
        for (i = 0; i < len; i++) {
          for (j = 0; j < len; j++) {
            if (j === i) {
              continue;
            }
            var roundUpFactor = errorFactor(orig[i], newVals[i] + 1)  + errorFactor( orig[j], newVals[j] - 1);
            var roundDownFactor = errorFactor(orig[i], newVals[i] - 1) + errorFactor( orig[j], newVals[j] + 1);
            var sumMargin = marginOfErrors[i] + marginOfErrors[j];

            if(roundUpFactor < sumMargin) {
              newVals[i] = newVals[i] + 1;
              newVals[j] = newVals[j] - 1;
              marginOfErrors[i] = newVals[i] && Math.abs(orig[i] - newVals[i]) / orig[i];
              marginOfErrors[j] = newVals[j] && Math.abs(orig[j] - newVals[j]) / orig[j];
            }
            if(roundDownFactor < sumMargin) {
              newVals[i] = newVals[i] - 1;
              newVals[j] = newVals[j] + 1;
              marginOfErrors[i] = newVals[i] && Math.abs(orig[i] - newVals[i]) / orig[i];
              marginOfErrors[j] = newVals[j] && Math.abs(orig[j] - newVals[j]) / orig[j];
            }
          }
        }
        return newVals;
      },

      setEvenRoundPercentage = function() {
        var arr = [];
        for (var i = 0, l = chartData.length; i < l; i++) {
          var d = chartData[i],
            v = d.value / total,
            f1 = d3.format('0.0%'),
            f2 = d3.format('0.3%'),
            r1 = f1(v),
            r2 = f2(v);
          perRound.push(+(r1.replace('%','')));
          arr.push(+(r2.replace('%','')));
        }
        perEvenRound = evenRound(arr, 100);
        perRoundTotal = perRound.reduce(function(a, b) { return a + b; });
      },

      labelsContextFormatter = function (d, context, formatterString, isShortName, idx) {
        formatterString = /percentage/i.test(context) ? '0.0%' : formatterString;
        var r,
          format = d3.format(formatterString || ''),
          percentage = format(d.value / total),
          name = isShortName ? (d.data.shortName || d.data.name.substring(0, 6) +'...') : d.data.name,
          value = formatterString && formatterString !== '0.0%' ? format(d.value) : d.value;

        if (/percentage/i.test(context) && perRoundTotal !== 100) {
          percentage = perEvenRound[idx] +'%';
        }
        // 'name'|'value'|'percentage'|'name, value'|'name (value)'|'name (percentage)'
        switch (context) {
          case 'name': r = name; break;
          case 'value': r = value; break;
          case 'percentage': r = percentage; break;
          case 'name, value': r = name + ', '  + value; break;
          case 'name (value)': r = name + ' (' + value + ')'; break;
          case 'name (percentage)': r = name + ' (' + percentage + ')'; break;
          default: r = name + ', ' + value + ' (' + percentage + ')'; break;
        }
        return r || '';
      },

      labelsColorFormatter = function (d, i, opt) {
        return opt === 'color-as-arc' ? (charts.chartColor(self.isRTL ? chartData.length-i-1 : i, 'pie', d.data)) : (opt === 'default' ? '' : opt);
      },

      drawTextlabels = function (isShortName) {
        svg.selectAll('.lb-top').each(function(d, i) {
          var parentX = +d3.select(this.parentNode).attr('x');

          if (((dims.center.x + parentX) - (d.data.name.length*5)) < 25 ||
          parentX > 0 && (dims.center.x - (d.data.name.length*5 + parentX)) < 25) {
            isShortName =  true;
          }

          d3.select(this)
            .text(function() {
              return labelsContextFormatter(d, lb.contentsTop, lb.formatterTop, isShortName, i);
            })
            .style({
              'font-weight': lb.isTwoline ? 'bold' : 'normal',
              'font-size': lb.isTwoline ? (dims.width > 450 ? '1.3em' : '1.1em') : '1em',
              'fill': function() {
                return labelsColorFormatter(d, i, lb.colorTop);
              }
            });
        });

        if (lb.isTwoline) {
          svg.selectAll('.lb-bottom').each(function(d, i) {
            var parentX = +d3.select(this.parentNode).attr('x');

            if (((dims.center.x + parentX) - (d.data.name.length*5)) < 25 ||
            parentX > 0 && (dims.center.x - (d.data.name.length*5 + parentX)) < 25) {
              isShortName =  true;
            }

            d3.select(this)
              .text(function() {
                return labelsContextFormatter(d, lb.contentsBottom, lb.formatterBottom, isShortName);
              })
              .style({
                'font-size': '1em',
                'fill': function() {
                  return labelsColorFormatter(d, i, lb.colorBottom);
                }
              });

              isShortName = null;
          });
        }
      },

      addLabels = function () {
        svg.selectAll('.labels').remove();

        var labels = svg.append('g').attr('class','labels'),
          enteringLabels = labels.selectAll('.label').data(pieData).enter(),
          labelGroups = enteringLabels.append('g').attr('class', 'label');

        labels.attr('transform', 'translate(' + dims.center.x + ',' + dims.center.y + ')');

        labelGroups.append('circle')
          .style('fill', 'none')
          .attr({'class': 'pie-circle', x: 0, y: 0, r: 1,
            transform: function (d) {
              var x = pieCircles.centroid(d)[0],
                y = pieCircles.centroid(d)[1];
              return 'translate(' + x + ',' + y + ')';
            }
          });

        labelGroups.append('circle')
          .style('fill', 'none')
          .attr({'class': 'label-circle', x: 0, y: 0, r: 1,
            transform: function (d) {
              var x = pieLabelCircles.centroid(d)[0],
                y = pieLabelCircles.centroid(d)[1];
              return 'translate(' + x + ',' + y + ')';
            }
          });

        textLabels = labelGroups.append('text').attr({
          'class': 'label-text',
          'x': function (d) {
            var centroid = pieArcs.centroid(d),
              midAngle = Math.atan2(centroid[1], centroid[0]),
              x = Math.cos(midAngle) * dims.labelRadius,
              sign = (x > 0) ? 1 : -1,
              labelX = x + (1 * sign);

            textLabelsLength++;

            textX.push(labelX);
            return labelX;
          },
          'y': function (d) {
            var centroid = pieArcs.centroid(d),
              midAngle = Math.atan2(centroid[1], centroid[0]),
              y = Math.sin(midAngle) * dims.labelRadius;
            textY.push(y);
            return y;
          },
          'text-anchor': function (d) {
            var centroid = pieArcs.centroid(d),
             midAngle = Math.atan2(centroid[1], centroid[0]),
              x = Math.cos(midAngle) * dims.labelRadius;

            if (isRTL && charts.isIE) {
              return (x > 0 ? 'start' : 'end');
            }

            return isRTL ? (x > 0 ? 'end' : 'start') : (x > 0 ? 'start' : 'end');
          }
        });

        textLabels.append('tspan').attr('class', 'lb-top');
        if (lb.isTwoline) {
          textLabels.append('tspan')
            .attr({'class': 'lb-bottom',
              'x': function(d, i) { return textX[i]-2; },
              'dy': '18'
            });
        }

        setEvenRoundPercentage();

        if (lb.hideLabels) {
          drawTextlabels();

          // Add center label only if its donut chart
          if (isDonut) {
            arcs.append('text')
              .attr('dy', '.35em')
              .style('text-anchor', 'middle')
              .attr('class', 'chart-donut-text')
              .html(centerLabel);

            // FIX: IE does not render .html
            if (charts.isIE) {
              if (charts.isHTML(centerLabel)) {
                // http://stackoverflow.com/questions/13962294/dynamic-styling-of-svg-text
                var text  = arcs.select('.chart-donut-text'),
                  tmp = document.createElement('text');
                tmp.innerHTML = centerLabel;
                var nodes = Array.prototype.slice.call(tmp.childNodes);
                nodes.forEach(function(node) {
                  text.append('tspan')
                    .attr('style', node.getAttribute && node.getAttribute('style'))
                    .attr('x', node.getAttribute && node.getAttribute('x'))
                    .attr('dy', node.getAttribute && node.getAttribute('dy'))
                    .text(node.textContent);
                });
              }
              else {
                arcs.select('.chart-donut-text').text(centerLabel);
              }
            }
          }
        }
      };
      addLabels();

      if (lb.hideLabels) {
        var isRunning = true,
          maxRunning = textLabelsLength * 15,
          orgLabelPos,
          spacing = 35;

        // Resolve label positioning collisions
        (function () {
          // Record org x, y position
          orgLabelPos = textLabels[0].map(function(d) {
            d = d3.select(d);
            return { x: +d.attr('x'), y: +d.attr('y') };
          });

          // Fix y position
          function relax() {
            var again = false;
            maxRunning--;
            textLabels.each(function (d, i) {
              var a = this,
                da = d3.select(a),
                y1 = +da.attr('y');

              textLabels.each(function (d2, i2) {
                if (i2 > i) {
                  var deltaY,
                    b = this,
                    db = d3.select(b),
                    y2 = +db.attr('y');

                  if (da.attr('text-anchor') === db.attr('text-anchor') && (a === textLabels[0][i2-1])) {
                    deltaY = Math.round(Math.abs(y1 - y2));
                    if (deltaY < spacing) {
                      deltaY += 1;
                      var newY = y2 > 0 ? y2-(deltaY/2) : y2+(deltaY/2)+1;
                      again = true;
                      db.attr('y', newY); //padding

                      if (Math.round(Math.abs(newY)) < 2) {
                        again = false;
                        newY = y2 > 0 ? y2-(spacing) : y2+(spacing/2);
                        db.attr('y', newY);
                      }
                    }
                  }
                }
              });
            });

            if(again && maxRunning > 0) {
              setTimeout(function() {
                relax();
              }, 0);
            } else {
              isRunning = false;
            }
          }
          relax();
        })();

        // Draw lines and set short name
        var intervalId = setInterval(function() {
          if (isRunning) {
            return;
          }
          clearInterval(intervalId);

          // Fix x position
          var labelCircles = svg.selectAll('.label-circle');
          spacing *=  -1;
          textLabels.each(function(d, i) {
            var x,
              label = d3.select(this),
              x1 = +label.attr('x'),
              y1 = +label.attr('y'),
              sign = (x1 > 0 ? 1 : -1);

              x = isRTL ?
                ((dims.labelRadius - Math.abs(y1) + Math.abs(orgLabelPos[i].x - (spacing * 2.5))) * sign):
                ((dims.labelRadius - Math.abs(y1) + Math.abs(orgLabelPos[i].x + (spacing * 2.5))) * sign);

            if (orgLabelPos[i].y !== y1 || (i === 0 && chartData[i].percent < 10)) {
              x += chartData[i].percent <= 10 ? Math.ceil(x1/2) : Math.ceil(x1-x)- (spacing/2);
              label.attr('x', x);

              if (lb.isTwoline) {
                label.select('.lb-bottom').attr('x', x);
              }

              var t = d3.transform(d3.select(labelCircles[0][i]).attr('transform')),
                tx = t.translate[0] + (t.translate[0] > 0 ? 10 : -10);

              if (x < tx || Math.abs(x) > dims.center.x) {
                label.attr('x', tx);
                if (lb.isTwoline) {
                  label.select('.lb-bottom').attr('x', tx);
                }
              }
            }
          });

          var lineFunction = d3.svg.line()
            .x(function(d) { return d.x; })
            .y(function(d) { return d.y; })
            .interpolate('basis');

          var labels = svg.selectAll('.label');

          svg.selectAll('.label-text tspan').each(function() {
            if (d3.select(this).text().substring(5) === '...') {
              showLegend = true;
            }
          });

          // Collect source and targets [x, y] position
          labels.each(function(d, i) {
            var label = d3.select(this),
              pieCircle = label.select('.pie-circle'),
              labelCircle = label.select('.label-circle'),
              text = label.select('.label-text'),
              ct = d3.transform(pieCircle.attr('transform')),
              ct2 = d3.transform(labelCircle.attr('transform')),
              points = [
                { x:Number(ct.translate[0]), y:Number(ct.translate[1]) },
                { x:Number(ct2.translate[0]), y:Number(ct2.translate[1]) },
                { x:Number(text.attr('x')), y:Number(text.attr('y')) + (lb.isTwoline ? 5 : 0) }
              ];

            // Draw line from center of arc to label
            if (lb.linehideWhenMoreThanPercentage > chartData[i].percent) {
              lines.append('path')
                .attr({
                  'class': 'label-line',
                  'd': lineFunction(points)
                })
                .style({
                  'stroke-width': lb.lineWidth,
                  'stroke': function() { return labelsColorFormatter(d, i, lb.lineColor); }
                });
              }
          });

        }, 1);

      } // END: lb.hideLabels
      else {
        showLegend = true;
      }

    //Get the Legend Series'
    var series = chartData.map(function (d) {
      var name = d.name +' ('+ d.percent +'%)';
      return {name:name, display:'twocolumn', color: d.color};
    });

    // Add Legends
    if (showLegend || charts.legendformatter) {
      charts[charts.legendformatter ? 'renderLegend' : 'addLegend'](series);
    }

    // Set initial selected
    (function () {
      var selected = 0,
        selector;
      arcs.selectAll('.arc').each(function(d, i) {
        if (!d || !d.data || !d.data.data) {
          return;
        }
        if (d.data.data.selected && selected < 1) {
          selected++;
          selector = d3.select(this);
          selector.on('click').call(selector.node(), selector.datum(), i);
        }
      });
    })();

    if (isRTL && lb.isTwoline) {
      // Fix: incorrect text tspan position when RTL
      // https://connect.microsoft.com/IE/feedback/details/846683
      setTimeout(function() {
        svg.selectAll('.label-text').each(function() {
          var label = d3.select(this),
            parent = d3.select(label.node().parentNode),
            clone = d3.select(parent.node().appendChild(label.node().cloneNode(true)));
          label.select('.lb-bottom').remove();
          clone.select('.lb-top').remove();
        });
      }, 100);
    }

    $(container).trigger('rendered');
    return $(container);
  };

  this.elementTransform = function(options) {
    options.element.attr('transform', function () {
      var el = options.sameAs || this,
        t = d3.transform(d3.select(el).attr('transform')),
        x = t.translate[0],
        y = t.translate[1];

      x = options.addtoX ? (x>0?(x+options.addtoX):(x-options.addtoX)) : x;
      y = options.addtoY ? (y>0?(y+options.addtoY):(y-options.addtoY)) : y;
      return 'translate('+ x +','+ y +')';
    });
  };

  this.moveLabels = function(options) {
    var labelElements = options.textLabels[0];
    if (options.addtoX) {
      options.textLabels.attr('x',function() {
        var x = d3.select(this).attr('x');
        return x > 0 ? (x + options.addtoX) : (x - options.addtoX);
      });
      options.textLines.attr('x2',function(d, i) {
        var labelForLine = d3.select(labelElements[i]);
        return labelForLine.attr('x');
      });
    }
    else if (options.addtoY) {
      options.textLabels.attr('y',function() {
        var y = Number(d3.select(this).attr('y'));
        return y > 0 ? (y + options.addtoY) : (y - options.addtoY);
      });
      options.textLines.attr('y2',function(d, i) {
        var labelForLine = d3.select(labelElements[i]);
        return labelForLine.attr('y');
      });
    }
  };

  //TODO: Test this with two charts on the page.
  this.handleResize = function () {
    var timeout = null,
      width = 0;

    //Handle Resize / Redraw
    function resizeCharts() {
      clearTimeout(timeout);
      timeout = setTimeout(function () {
        var api = $(container).data('chart'),
            cont = $(container);

        if (width === cont.width()) {
          return;
        }

        width = cont.width();

        if (!cont.is(':visible')) {
          return true;
        }
        cont.empty();
        api.initChartType(api.settings);
      }, 100);
    }

    if (this.redrawOnResize) {
      $(window).on('resize.charts', resizeCharts);
      $(container).off('resize').on('resize', resizeCharts);
    }
  };

  // Donut Chart - Same as Pie but inner radius
  this.Ring = function(chartData) {
    return charts.Pie(chartData, true);
  };

  //Conserve aspect ratio of the orignal region. Useful when shrinking/enlarging
  this.calculateAspectRatioFit = function (d) {
    var ratio = Math.min(d.maxWidth / d.srcWidth, d.maxHeight / d.srcHeight);
    return { width: d.srcWidth*ratio, height: d.srcHeight*ratio };
  };

  // Sparkline Chart
  this.Sparkline = function(chartData, options) {
    var tooltipIntervalMedianRange,
      tooltipIntervalDots,
      tooltipDataCacheMedianRange = [],
      tooltipDataCacheDots = [],
      tooltipData = charts.options.tooltip;

    // calculate max and min values in the NLWest data
    var max=0, min=0, len=0, i,
      dimensions = this.calculateAspectRatioFit({
        srcWidth: 385,
        srcHeight: 65,
        maxWidth: $(container).width(),
        maxHeight: 600 //container min-height
      }),
      dotsize = dimensions.width > 300 ? 4 : 3;

    for (i = 0; i < chartData.length; i++) {
      min = d3.min([d3.min(chartData[i].data), min]);
      max = d3.max([d3.max(chartData[i].data), max]);
      len = d3.max([chartData[i].data.length, len]);
    }

    var p = 10,
      w = dimensions.width,
      h = dimensions.height,
      x = d3.scale.linear().domain([0, len]).range([p, w - p]),
      y = d3.scale.linear().domain([min, max]).range([h - p, p]),
      line = d3.svg.line()
                   .x(function(d, i) { return x(i); })
                   .y(function(d) { return y(d); });

    charts.appendTooltip();
    var svg = d3.select(container)
      .append('svg')
      .attr('height', h)
      .attr('width', w);

    //Add Median Range
    //https://www.purplemath.com/modules/meanmode.htm
    if(options.isMedianRange) {
      max = d3.max(chartData[0].data);
      min = d3.min(chartData[0].data);

      var minWidth = 10,
        maxWidth = w-45,
        median = d3.median(chartData[0].data),
        range = max-min,
        scaleMedianRange = d3.scale.linear().domain([min, max]).range([0, h]),
        top = h-scaleMedianRange(median>range ? median : range),
        bot = h-scaleMedianRange(median<range ? median : range);

      svg.append('g')
        .attr('class', 'medianrange')
        .attr('transform', function() {return 'translate('+ minWidth +','+ top +')';})
        .append('rect')
        .attr('width', maxWidth)
        .attr('height', bot)
        .style('fill', '#d8d8d8')
        .on('mouseenter', function(d, i) {
          var rect = this.getBoundingClientRect(),
            content = '<p>' + (chartData[0].name ? chartData[0].name +'<br> ' : '') +
            Locale.translate('Median') + ': <b>'+ median +'</b><br>'+
            Locale.translate('Range') +': <b>'+ range +'</b>'+
            (options.isPeakDot ? '<br>'+Locale.translate('Peak') +': <b>'+ max +'</b>' : '') +'</p>',
            show = function() {
              var size = charts.getTooltipSize(content),
                x = rect.left + ((rect.width - size.width)/2),
                y = rect.top - size.height - 5; // 5: extra padding

              if(content !== '') {
                charts.showTooltip(x, y, content, 'top');
              }
            };

          if (tooltipData && typeof tooltipData === 'function' && !tooltipDataCacheMedianRange[i]) {
            content = '';
            var runInterval = true;
            tooltipIntervalMedianRange = setInterval(function() {
              if(runInterval) {
                runInterval = false;
                tooltipData(function (data) {
                  content = tooltipDataCacheMedianRange[i] = data;
                });
              }
              if(content !== '') {
                clearInterval(tooltipIntervalMedianRange);
                show();
              }
            }, 10);
          } else {
            tooltipData = typeof tooltipData === 'object' ? '' : tooltipData;
            content = tooltipDataCacheMedianRange[i] || tooltipData || chartData[0].tooltip || content || '';
            show();
          }
        })
        .on('mouseleave', function() {
          clearInterval(tooltipIntervalMedianRange);
          charts.hideTooltip();
        });
    }

    for (i = 0; i < chartData.length; i++) {
      var set = chartData[i],
        g = svg.append('g');
        g.append('path')
         .attr('d', line(set.data))
         .attr('stroke', options.isMinMax ? '#999999' : charts.sparklineColors(i))
         .attr('class', 'team');
    }


    //Add Dots (Dots/Peak/MinMAx)
    min = d3.min(chartData[0].data);
      svg.selectAll('.point')
        .data(chartData[0].data)
        .enter()
        .append('circle')
        .attr('r', function(d) {
          return (options.isMinMax && max === d || options.isMinMax && min === d) ? (dotsize+1) :
            (options.isDots || (options.isPeakDot && max === d)) ? dotsize : 0;
        })
        .attr('class', function(d) {
          return (options.isPeakDot && max === d && !options.isMinMax) ? 'point peak' :
            (options.isMinMax && max === d) ? 'point max' :
            (options.isMinMax && min === d) ? 'point min' : 'point';
        })
        .style('fill', function(d) {
          return (options.isPeakDot && max === d && !options.isMinMax) ? '#ffffff' :
            (options.isMinMax && max === d) ? '#56932E' :
            (options.isMinMax && min === d) ? '#941E1E' : charts.sparklineColors(0);
        })
        .style('stroke', function(d) {
          return (options.isPeakDot && max === d && !options.isMinMax) ? charts.sparklineColors(0) :
            (options.isMinMax && max === d) ? 'none' :
            (options.isMinMax && min === d) ? 'none' : '#ffffff';
        })
        .style('cursor', 'pointer')
        .attr('cx', function(d, i) { return x(i); })
        .attr('cy', function(d) { return y(d); })
        .on('mouseenter', function(d) {
          var rect = this.getBoundingClientRect(),
            content = '<p>' + (chartData[0].name ? chartData[0].name + '<br> ' +
              ((options.isMinMax && max === d) ? Locale.translate('Highest') + ': ' :
               (options.isMinMax && min === d) ? Locale.translate('Lowest') + ': ' :
               (options.isPeakDot && max === d) ? Locale.translate('Peak') + ': ' : '') : '') + '<b>' + d  + '</b></p>',
            show = function() {
              var size = charts.getTooltipSize(content),
                x = rect.left - (size.width /2) + 6,
                y = rect.top - size.height - 8;

              if(content !== '') {
                charts.showTooltip(x, y, content, 'top');
              }
            };

          if (tooltipData && typeof tooltipData === 'function' && !tooltipDataCacheDots[i]) {
            content = '';
            var runInterval = true;
            tooltipIntervalDots = setInterval(function() {
              if(runInterval) {
                runInterval = false;
                tooltipData(function (data) {
                  content = tooltipDataCacheDots[i] = data;
                });
              }
              if(content !== '') {
                clearInterval(tooltipIntervalDots);
                show();
              }
            }, 10);
          } else {
            tooltipData = typeof tooltipData === 'object' ? '' : tooltipData;
            content = tooltipDataCacheDots[i] || tooltipData || chartData[0].tooltip || content || '';
            show();
          }

          d3.select(this).attr('r', (options.isMinMax && max === d ||
            options.isMinMax && min === d) ? (dotsize+2) : (dotsize+1));
        })
        .on('mouseleave', function(d) {
          clearInterval(tooltipIntervalDots);
          charts.hideTooltip();
          d3.select(this).attr('r', (options.isMinMax && max === d ||
            options.isMinMax && min === d) ? (dotsize+1) : dotsize);
        });

    $(container).trigger('rendered');

    return $(container);
  };

  // Column Chart - Sames as bar but reverse axis
  this.Column = function(chartData, isStacked) {
    var defaults = {
      // Use d3 Format
      // http://koaning.s3-website-us-west-2.amazonaws.com/html/d3format.html
      // [null | formatter string] - Only value will be formated
      formatterString: null,
    },
    settings = $.extend(true, defaults, charts.options),
    isFormatter = !!settings.formatterString,
    format = function (value) {
      return isFormatter ? d3.format(settings.formatterString)(value) : value;
    };

    var datasetStacked,
      dataset = chartData,
      self = this,
      parent = $(container).parent(),
      isRTL = charts.isRTL,
      isPositiveNegative = (charts.settings.type === 'column-positive-negative'),
      isSingular = (dataset.length === 1),
      margin = {top: 40, right: 40, bottom: (isSingular && chartData[0].name === undefined ? (isStacked ? 20 : 50) : 35), left: 45},
      legendHeight = 40,
      width = parent.width() - margin.left - margin.right - 10,
      height = parent.height() - margin.top - margin.bottom - (isSingular && chartData[0].name === undefined ? (isStacked || isPositiveNegative ? (legendHeight - 10) : 0) : legendHeight),
      yMin, yMax, yMinTarget, yMaxTarget, series, seriesStacked,
      pnColors, pnPatterns, pnLegends, pnSeries;

    yMin = d3.min(dataset, function (group) {
      return d3.min(group.data, function (d) {
          return d.value;
      });
    });

    yMax = d3.max(dataset, function (group) {
      return d3.max(group.data, function (d) {
          return d.value;
      });
    });

    if (isPositiveNegative) {
      yMinTarget = d3.min(dataset, function (group) {
        return d3.min(group.data, function (d) {
            return d.target;
        });
      });

      yMaxTarget = d3.max(dataset, function (group) {
        return d3.max(group.data, function (d) {
            return d.target;
        });
      });

      yMin = d3.min([yMin, yMinTarget]);
      yMax = d3.max([yMax, yMaxTarget]);

      pnLegends = {target: 'Target', positive: 'Positive', negative: 'Negative'};
      pnColors = {target: 'neutral', positive: 'good', negative: 'error'};
      pnPatterns = {};

      if (dataset[0]) {
        if (dataset[0].colors) {
          $.extend(true, pnColors, dataset[0].colors);
        }
        if (dataset[0].legends) {
          $.extend(true, pnLegends, dataset[0].legends);
        }
        if (dataset[0].patterns) {
          $.extend(true, pnPatterns, dataset[0].patterns);
        }
      }
      //Converting object into array
      pnSeries = [];
      $.each(pnLegends, function(key, val) {
        pnSeries.push({
          name: val,
          color: pnColors[key],
          pattern: pnPatterns[key],
          option: key
        });
      });
    }

    $(container).addClass('column-chart');

    var tooltipInterval,
      tooltipDataCache = [],
      tooltipData = charts.options.tooltip;

    var x0 = d3.scale.ordinal()
      .rangeRoundBands([0, width], 0.1);

    var x1 = d3.scale.ordinal();

    var y = d3.scale.linear()
      .range([height, 0]);

    if (isStacked) {
      //Map the Data Sets and Stack them.
      if (isSingular) {
        datasetStacked = dataset[0].data.map(function (d) {
          return [$.extend({}, d, {
            y: d.value,
            x: d.name,
            color: d.color,
            pattern: d.pattern,
            parentName: d.name,
            tooltip: d.tooltip
          })];
        });
      } else {
        datasetStacked = dataset.map(function (d) {
          return d.data.map(function (o) {
            return $.extend({}, o, {
              y: o.value,
              x: o.name,
              color: o.color,
              pattern: o.pattern,
              parentName: d.name,
              tooltip: d.tooltip
            });
          });
        });
      }

      var stack = d3.layout.stack();
      stack(datasetStacked);

      var xScale = d3.scale.ordinal()
        .domain(d3.range(datasetStacked[0].length))
        .rangeRoundBands([0, width], 0.05);

      var yScale = d3.scale.linear()
        .domain([0,
          d3.max(datasetStacked, function(d) {

            return d3.max(d, function(d) {
              return d.y0 + d.y;
            });
          })
        ])
        .range([0, height]);
    }

    //List the values along the x axis
    var xAxisValues = dataset[0].data.map(function (d) {return d.name;});

    var xAxis = d3.svg.axis()
        .scale(x0)
        .tickSize(0)
        .tickPadding(12)
        .orient('bottom');

    var yAxis = d3.svg.axis()
        .scale(y)
        .tickSize(-width)
        .tickPadding(isRTL ? -12 : 12)
        .tickFormat(d3.format(charts.format || 's'))
        .orient('left');

    var svg = d3.select(container)
      .append('svg')
        .attr('width', width + margin.left + margin.right)
        .attr('height', height + margin.top + margin.bottom)
        .append('g')
          .attr('transform', 'translate('+ margin.left +','+ margin.top +')');

    // Get the Different Names
    var names = dataset.map(function (d) {
      return d.name;
    });

    //Get the Maxes of each series
    var maxesStacked, maxes = dataset.map(function (d) {
      return d3.max(d.data, function(d){
        return isPositiveNegative ? d.target : d.value;
      });
    });

    if (isStacked) {
      maxesStacked = datasetStacked.map(function (d) {
        return d3.max(d, function(d){ return d.y + d.y0;});
      });
    }

    if (isSingular) {
      names = dataset[0].data.map(function (d) {
        return d.name;
      });
    }

    // Extra ticks
    if (isPositiveNegative) {
      yMin += yMin / y.ticks().length;
      maxes[0] += maxes[0] / y.ticks().length;
    }

    // Set series
    (function() {
      if (isStacked && isSingular) {
        series = dataset[0].data;
      }
      else {
        var i, l, lm;
        // Loop backwards to catch and override with found first custom info from top
        for (i = dataset.length-1,l = -1; i > l; i--) {
          lm = dataset[i].data.map(function (d) {
            return d;
          });
          $.extend(true, series, lm);
          // Convert back to array from object
          series = $.map(series, function(d) {
            return d;
          });
        }
      }
    })();

    if (isStacked && !isSingular) {
      seriesStacked = names.map(function (d, i) {
        return dataset[i];
      });
    }

    x0.domain(isStacked ? xAxisValues : names);
    x1.domain(xAxisValues).rangeRoundBands([0, (isSingular||isStacked) ? width : x0.rangeBand()]);
    y.domain([(yMin < 0 ? yMin : (charts.settings.minValue || 0)), d3.max(isStacked ? maxesStacked : maxes)]).nice();

    if (!isSingular || (isSingular && !isStacked)) {
      svg.append('g')
        .attr('class', 'x axis')
        .attr('transform', 'translate(0,' + (height + (isPositiveNegative ? 10 : 0)) + ')')
        .call(xAxis);
    }

    svg.append('g')
        .attr('class', 'y axis')
        .call(yAxis);

    // Adjust extra(x) space for negative values for RTL
    if (isRTL && yMin < 0) {
      var yMaxLength = 0,
        tempLength;

      svg.selectAll('.axis.y text')
        .attr('class', function(d) {
          tempLength = d3.select(this).text().length;
          yMaxLength = (tempLength > yMaxLength) ? tempLength : yMaxLength;
          return d < 0 ? 'negative-value' : 'positive-value';
        })
        .attr('x', function(d) {
          return d < 0 ? ((yMaxLength ) * 9) : ((yMaxLength ) * 5);
        });

    }

    //Make an Array of objects with name + array of all values
    var dataArray = [];
    chartData.forEach(function(d) {
      dataArray.push($.extend({}, d, {values: d.data}));
    });

    if (isSingular) {
      dataArray = [];
      names = dataset[0].data.forEach(function (d) {
        dataArray.push(d);
      });
    }

    var bars, targetBars, pnBars,
      barMaxWidth = 35,
      color = function(colorStr) {
        return charts.chartColor(0, '', {'color': colorStr});
      },
      onEndAllTransition = function (transition, callback) {
        var n;
        if (transition.empty()) {
          callback();
        }
        else {
          n = transition.size();
          transition.each('end', function() {
            n--;
            if (n === 0) {
              callback();
            }
          });
        }
      };

    function drawBars(isTargetBars) {
      var bars;
      isTargetBars = isPositiveNegative && isTargetBars;

      // Add the bars - done different depending on if grouped or singlular
      if (isSingular || isPositiveNegative) {
        bars = svg.selectAll('rect' + (isTargetBars ? '.target-bar' : '.bar'))
          .data(isStacked ? datasetStacked : dataArray)
          .enter()
          .append('rect')
          .attr('class', function(d, i) {
            var classStr = 'bar series-'+ i;

            if (isPositiveNegative) {
              classStr = (isTargetBars ? ('target-bar series-'+ i) : classStr) +
                (d.value > 0 ? ' positive' : ' negative');
            }
            return classStr;
          })
          .attr('width', Math.min.apply(null, [x1.rangeBand()-2, barMaxWidth]))
          .attr('x', function(d) {
            return isStacked ? xScale(0) : (x1(d.name) + (x1.rangeBand() - barMaxWidth)/2);
          })
          .attr('y', function() {
            return y(0) > height ? height : y(0);
          })
          .attr('height', function() {
            return 0;
          })
          .attr('mask', function (d) {
            return !isPositiveNegative ? null :
              (isTargetBars ? (pnPatterns.target ? 'url(#' + pnPatterns.target + ')' : null) :
                (d.value < 0 ? (pnPatterns.negative ? 'url(#' + pnPatterns.negative + ')' : null) :
                (pnPatterns.positive ? 'url(#' + pnPatterns.positive + ')' : null))
              );
          })
          .style('fill', function(d) {
            return !isPositiveNegative ? null :
              color(isTargetBars ? pnColors.target : (d.value < 0 ? pnColors.negative : pnColors.positive));
          });

        if (isPositiveNegative) {
          var yTextPadding = 12;
          svg.selectAll(isTargetBars ? '.target-bartext' : '.bartext')
            .data(dataArray)
            .enter()
            .append('text')
            .attr('class', function(d) {
              return (isTargetBars ? 'target-bartext' : 'bartext') +
                (d.value > 0 ? ' positive' : ' negative');
            })
            .attr('text-anchor', 'middle')
            .attr('x', function(d) {
              return (x1(d.name) + (x1.rangeBand())/2) * (isRTL ? -1 : 1);
            })
            .attr('y', function(d) {
              return isTargetBars ?
                (y(d.target) - (yTextPadding/2)) : (y(d.value > 0 ? 0 : d.value) + yTextPadding);
            })
            .style('opacity', 0)
            .style('fill', function(d) {
              return isTargetBars ? '' /* color(pnColors.target) */ :
                (d.value < 0 ? color(pnColors.negative) : color(pnColors.positive));
            })
            .style('font-weight', 'bold')
            .text(function(d) {
              return format(isTargetBars ? d.target : d.value);
            });
        }

        bars.transition().duration(1000)
          .call(onEndAllTransition, function () {
            svg.selectAll('.target-bartext, .bartext')
              .transition().duration(300).style('opacity', 1);
          })
          .attr('y', function(d) {
            var r = isStacked ? (height - yScale(d[0].y) - yScale(d[0].y0)) :
            (d.value < 0 ? y(0) : y(d.value));
            return (isTargetBars ? y(d.target) : (d.value < 0 ? r : (r > (height-3) ? height-2 : r)));
          })
          .attr('height', function(d) {
            var r;
            if (isStacked) {
              r = yScale(d[0].y);
            }
            else {
              if (d.value < 0) {
                r = (height-y(0)) - (height-y(d.value));
              }
              else {
                r = (height-y(d.value)) - (height-y(0));
              }
            }
            r = d.value < 0 ? r : (r < 3 ? 2 : (r > height ? (height-y(d.value)) : r));
            return isTargetBars ? (height-y(d.target)) - (height-y(0)) : r;
          });
      } else {
        var xValues = svg.selectAll('.x-value')
          .data(isStacked ? datasetStacked : dataArray)
          .enter()
          .append('g')
          .attr('class', 'series-group g')
          .attr('data-group-id', function (d, i) {
            return i;
          })
          .attr('transform', function(d) {
            return 'translate(' + x0(isStacked ? xAxisValues[0] : d.name) + ',0)';
          });

        bars = xValues.selectAll('rect')
          .data(function(d) {return isStacked ? d : d.values;})
          .enter()
          .append('rect')
            .attr('class', function(d, i) {
              return 'series-'+ i +' bar';
            })
            .attr('width', Math.min.apply(null, [x1.rangeBand()-2, barMaxWidth]))
            .attr('x', function(d, i) {
              var width = Math.min.apply(null, [x1.rangeBand()-2, barMaxWidth]);
              return isStacked ? xScale(i) : (x1.rangeBand()/2 + ((width + 2) * i) - (dataArray[0].values.length === 1 || dataArray[0].values.length === 5 || dataArray[0].values.length === 4  ? (width/2) : 0) );//' * (dataArray[0].values.length/2)) );
            })
            .attr('y', function() {return y(0) > height ? height : y(0);})
            .attr('height', function() {return 0;});

        bars
          .transition().duration(1000)
          .attr('y', function(d) {
            var r = isStacked ? (height-yScale(d.y)-yScale(d.y0)) : (d.value < 0 ? y(0) : y(d.value));
            return d.value < 0 ? r : (r > (height-3) ? height-2 : r);
          })
          .attr('height', function(d) {
            var r;
           if (isStacked) {
             r = yScale(d.y);
           }
           else {
             if (d.value < 0) {
               r = (height-y(0)) - (height-y(d.value));
             }
             else {
               r = (height-y(d.value)) - (height-y(0));
             }
           }
           return d.value < 0 ? r : (r < 3 ? 2 : (r > height ? (height-y(d.value)) : r));
          });
      }
      return bars;
    }

    if (isPositiveNegative) {
      targetBars = drawBars(true); //Draw target bars
    }
    bars = drawBars();

    if (isPositiveNegative) {
      pnBars = d3.selectAll('.empty-bars');
      charts.mergeArrays(pnBars[0], targetBars[0], bars[0]);
    }

    if (!isPositiveNegative) {
      //Style the bars and add interactivity
      if (!isStacked) {
        bars
          .style('fill', function(d, i) {
            return isSingular ?
              charts.chartColor(i, 'column-single', chartData[0].data[i]) :
              charts.chartColor(i, 'bar', series[i]);
          })
          .attr('mask', function (d, i) {
            return isSingular ?
              (chartData[0].data[i].pattern ? 'url(#'+ chartData[0].data[i].pattern +')' : null) :
              (series[i].pattern ? 'url(#'+ series[i].pattern +')' : null);
          });
      } else if (isStacked && !isSingular) {
        bars
          .style('fill', function() {
            var thisGroup = d3.select(this.parentNode).attr('data-group-id');
            return charts.chartColor(thisGroup, 'bar', dataset[thisGroup]);
          })
          .attr('mask', function() {
            var thisGroup = d3.select(this.parentNode).attr('data-group-id');
            return (dataset[thisGroup].pattern ? 'url(#'+ dataset[thisGroup].pattern +')' : null);
          });
      } else if (isStacked && isSingular) {
        bars
          .style('fill', function(d, i) {
            return charts.chartColor(i, 'bar', d[0]);
          })
          .attr('mask', function(d) {
            return (d[0].pattern ? 'url(#'+ d[0].pattern +')' : null);
          });
      }
    }

    var isSingle = isSingular || !isSingular && isStacked,
      isGrouped = !isSingle;

    $.extend(charts.settings, {
      svg: svg,
      chartType: 'Column',
      isSingle: isSingle,
      isGrouped: isGrouped,
      isStacked: isStacked,
      isSingular: isSingular
    });

    (isPositiveNegative ? pnBars : bars)
      .on('mouseenter', function(d, i) {
        var x, y, j, l, hexColor, size, isTooltipBottom,
          maxBarsForTopTooltip = 6,
          thisShape = this,
          shape = $(this),
          content = '',
          ePageY = d3.event.pageY,

          setPattern = function(pattern, hexColor) {
            return !pattern || !hexColor ? '' :
              '<svg width="12" height="12">'+
                '<rect style="fill: '+ hexColor +'" mask="url(#'+ pattern +')" height="12" width="12" />'+
              '</svg>';
          },

          show = function(isTooltipBottom) {
            size = charts.getTooltipSize(content);
            x = shape[0].getBoundingClientRect().left - (size.width /2) + (shape.attr('width')/2);

            if (isStacked) {
              y = shape[0].getBoundingClientRect().top - size.height - 10;
            } else {
              y = ePageY-charts.tooltip.outerHeight() - 25;
              if (dataset.length > 1) {
                x = thisShape.parentNode.getBoundingClientRect().left - (size.width /2) + (thisShape.parentNode.getBoundingClientRect().width/2);
                if (isTooltipBottom) {
                  y += charts.tooltip.outerHeight() + 50;
                  if (y > (thisShape.parentNode.getBoundingClientRect().bottom + 10)) {
                    y = thisShape.parentNode.getBoundingClientRect().bottom + 10;
                  }
                } else {
                  y = thisShape.parentNode.getBoundingClientRect().top-charts.tooltip.outerHeight() + 25;
                }
              }
            }

            if (content !== '') {
              charts.showTooltip(x, y, content, isTooltipBottom ? 'bottom' : 'top');
            }
          };

        // Stacked
        if (isStacked) {
          if (isSingular) {
            content = '<p><b>'+ format(d[0].value) +'</b> '+ d[0].name +'</p>';
          } else {
            content = ''+
              '<div class="chart-swatch">'+
                '<div class="swatch-caption"><b>'+ datasetStacked[0][i].name +'</b></div>';
            for (j=datasetStacked.length-1,l=0; j>=l; j--) {
              hexColor = charts.chartColor(j, 'bar', dataset[j]);
              content += ''+
                '<div class="swatch-row">'+
                  '<div style="background-color:'+ (dataset[j].pattern ? 'transparent' : hexColor) +';">'+
                    (setPattern(dataset[j].pattern, hexColor))+
                  '</div>'+
                  '<span>'+ datasetStacked[j][i].parentName +'</span><b>'+ format(datasetStacked[j][i].value) +'</b>'+
                '</div>';
            }
            content += '</div>';
          }
          size = charts.getTooltipSize(content);
          x = shape[0].getBoundingClientRect().left - (size.width /2) + (shape.attr('width')/2);
          y = shape[0].getBoundingClientRect().top - size.height - 10;
        }

        // No Stacked
        else {
          if (isPositiveNegative) {
            content = ''+
              '<div class="chart-swatch">'+
                '<div class="swatch-caption"><b>'+ d.name +'</b></div>'+
                '<div class="swatch-row">'+
                  '<div style="background-color:'+ (pnPatterns.target ? 'transparent' : color(pnColors.target)) +';">'+
                    (setPattern(pnPatterns.target, color(pnColors.target)))+
                  '</div>'+
                  '<span>'+ pnLegends.target +'</span><b>'+ format(d.target) +'</b>'+
                '</div>'+
                '<div class="swatch-row">'+
                  '<div style="background-color:'+ (d.value < 0 ?
                    (pnPatterns.negative ? 'transparent' : color(pnColors.negative)) :
                    (pnPatterns.positive ? 'transparent' : color(pnColors.positive))) +
                  ';">'+
                    (d.value < 0 ?
                      setPattern(pnPatterns.negative, color(pnColors.negative)) :
                      setPattern(pnPatterns.positive, color(pnColors.positive)))+
                  '</div>'+
                  '<span>'+ pnLegends[d.value < 0 ? 'negative' : 'positive'] +'</span><b>'+ format(d.value) +'</b>'+
                '</div>'+
              '</div>';
          }
          else if (dataset.length === 1) {
            content = '<p><b>'+ format(d.value) + '</b> '+ d.name +'</p>';
          } else {
            var data = d3.select(this.parentNode).datum().values;

            content = '<div class="chart-swatch">';
            for (j=0,l=data.length; j<l; j++) {
              hexColor = charts.chartColor(j, 'bar', series[j]);
              content += ''+
                '<div class="swatch-row">'+
                  '<div style="background-color:'+ (series[j].pattern ? 'transparent' : hexColor) +';">'+
                    (setPattern(series[j].pattern, hexColor))+
                  '</div>'+
                  '<span>'+ data[j].name +'</span><b>'+ format(data[j].value) +'</b>'+
                '</div>';
            }
            content += '</div>';
            isTooltipBottom = data.length > maxBarsForTopTooltip;
          }

          size = charts.getTooltipSize(content);
          x = shape[0].getBoundingClientRect().left - (size.width /2) + (shape.attr('width')/2);
          y = ePageY-charts.tooltip.outerHeight() - 25;
          if (dataset.length > 1) {
            x = this.parentNode.getBoundingClientRect().left - (size.width /2) + (this.parentNode.getBoundingClientRect().width/2);
            y = this.parentNode.getBoundingClientRect().top-charts.tooltip.outerHeight() + 25;
          }
        }

        if (tooltipData && typeof tooltipData === 'function' && !tooltipDataCache[i]) {
          content = '';
          var runInterval = true;
          tooltipInterval = setInterval(function() {
            if (runInterval) {
              runInterval = false;
              tooltipData(function (data) {
                content = tooltipDataCache[i] = data;
              });
            }

            if (content !== '') {
              clearInterval(tooltipInterval);
              show();
            }
          }, 10);
        } else {

          content = tooltipDataCache[i] || tooltipData || content || '';
          if (d.tooltip) {
            var val = d.tooltip.replace('{{value}}', format(d.value));
            content = '<p>'+ val +'</p>';
          }
          show(isTooltipBottom);
        }

      })

      // Mouseleave
      .on('mouseleave', function() {
        clearInterval(tooltipInterval);
        charts.hideTooltip();
      })

      // Click
      .on('click', function (d, i) {
        var selector, isTargetBar = this && d3.select(this).classed('target-bar');
        if (isTargetBar) {
          selector = svg.select('.bar.series-'+ i);
          selector.on('click').call(selector.node(), selector.datum(), i);
          return;
        }

        var isSelected = this && d3.select(this).classed('is-selected'),
          thisGroupId = parseInt(d3.select(this.parentNode).attr('data-group-id'), 10);

        charts.setSelectedElement({
          task: (isSelected ? 'unselected' : 'selected'),
          container: container,
          selector: this,
          isTrigger: !isSelected,
          triggerGroup: isGrouped,
          d: d,
          i: i
        });

        if (isSelected) {
          $(container).triggerHandler('selected', [d3.select(this)[0], {}, (isGrouped ? thisGroupId : i)]);
        }
        return;
      })

      // Contextmenu
      .on('contextmenu',function (d) {
        self.triggerContextMenu(d3.select(this)[0][0], d);
      });

    //Add Legend
    if (isSingular && chartData[0].name) {
      charts.addLegend([{name: chartData[0].name}]);
    } else if (isPositiveNegative) {
      charts.addLegend(pnSeries);
    } else if (isStacked && isSingular) {
      charts.addLegend(series);
    } else if (!isSingular) {
      charts.addLegend(isStacked ? seriesStacked : series);
    }

    if (charts.isRTL && charts.isIE) {
      svg.selectAll('text').attr('transform', 'scale(-1, 1)');
      svg.selectAll('.y.axis text').style('text-anchor', 'start');

      if (isPositiveNegative) {
        svg.selectAll('.negative-value').style('text-anchor', 'end');
      }

    }

    //Add Tooltips
    charts.appendTooltip();

    //See if any labels overlap and use shorter */
    // [applyAltLabels] - function(svg, dataArray, elem, selector, isNoEclipse)
    if (charts.labelsColide(svg)) {
      charts.applyAltLabels(svg, dataArray, 'shortName');
    }

    if (charts.labelsColide(svg)) {
      charts.applyAltLabels(svg, dataArray, 'abbrName');
    }

    if (charts.labelsColide(svg)) {
      charts.applyAltLabels(svg, dataArray, null, null, true);

      // Adjust extra(x) space with short name for RTL
      if (isPositiveNegative) {
        svg.selectAll('.target-bartext, .bartext').attr('x', function() {
          return +d3.select(this).attr('x') - (isRTL ? -6 : 6);
        });
      }
    }

    // Set initial selected
    (function () {
      var selected = 0,
        legendsNode = svg.node().parentNode.nextSibling,
        legends = d3.select(legendsNode),
        isLegends = legends.node() && legends.classed('chart-legend'),
        barIndex, selector, isStackedGroup,

        setSelectedBar = function (g) {
          g = g ? d3.select(g) : svg;
          g.selectAll('.bar').each(function(d, i) {
            if (!d) {
              return;
            }
            if ((isSingular && isStacked ? d[0].selected : d.selected) && selected < 1) {
              selected++;
              selector = d3.select(this);
              barIndex = i;
            }
          });
        },

        setSelectedGroup = function () {
          var groups = svg.selectAll('.series-group');
          if (groups[0].length) {
            groups.each(function() {
              setSelectedBar(this);
            });
          }
        };

      if (isGrouped || (isStacked && !isSingular && !isGrouped)) {
        chartData.forEach(function(d, i) {
          if (d.selected && selected < 1) {
            selected++;
            selector = svg.select('[data-group-id="'+ i +'"]').select('.bar');
            barIndex = i;
            if (isStacked && !isSingular && !isGrouped) {
              isStackedGroup = true;
            }
          }
        });
        if (selected < 1) {
          setSelectedGroup();
        }
      }
      else {
        setSelectedBar();
      }

      if (selected > 0) {
        if (isStackedGroup) {
          if (isLegends) {
            $(legends.selectAll('.chart-legend-item')[0][barIndex]).trigger('click.chart');
          }
        }
        else {
          selector.on('click').call(selector.node(), selector.datum(), barIndex);
        }
      }

    })();

    $(container).trigger('rendered');
    return $(container);
  };

  // Merge the contents of multiple arrays together into the first array
  this.mergeArrays = function() {
    var i, len = arguments.length;
    if (len > 1) {
      for (i = 1; i < len; i++) {
        arguments[i].forEach(function(v) {
          this.push(v);
        }, arguments[0]);
      }
    }
  };

  this.labelsColide = function(svg) {
    var ticks = svg.selectAll('.x text'),
      collides = false;

    ticks.each(function(d, i) {
      var rect1 = this.getBoundingClientRect(), rect2;

      ticks.each(function(d, j) {
        if (i !== j) {
          rect2 = this.getBoundingClientRect();

          var overlap = !(rect1.right < rect2.left ||
            rect1.left > rect2.right ||
            rect1.bottom < rect2.top ||
            rect1.top > rect2.bottom);

          if (overlap) {
            collides = true;
          }
        }

      });
    });

    return collides;
  };

  this.applyAltLabels = function(svg, dataArray, elem, selector, isNoEclipse) {
    var ticks = selector ? svg.selectAll(selector) : svg.selectAll('.x text');

    ticks.each(function(d, i) {
      var text = dataArray[i][elem];

      text = text || (isNoEclipse ?
        ((d3.select(this).text().substring(0, 1))) : (d3.select(this).text().substring(0, 6) +'...'));
      d3.select(this).text(text);
    });
  };

  this.Line = function(chartData, options, isArea, isBubble) {
    var defaults = {
      // Use d3 Format
      // http://koaning.s3-website-us-west-2.amazonaws.com/html/d3format.html
      // [null | formatter string] - Only value will be formated
      formatterString: null,
    },
    settings = $.extend(true, defaults, charts.options),
    isFormatter = !!settings.formatterString,
    format = function (value) {
      return isFormatter ? d3.format(settings.formatterString)(value) : value;
    };

    $(container).addClass('line-chart' + (isBubble ? ' bubble' : ''));

    var dots = {
      radius: 5,
      radiusOnHover: 7,
      strokeWidth: 2,
      class: 'dot'
    };
    if (isBubble) {
      dots.radius = 0;
      dots.radiusOnHover = 0;
      dots.strokeWidth = 0;
    }
    $.extend(true, dots, settings.dots);

    var isRTL = charts.isRTL;

    var tooltipInterval,
      tooltipDataCache = [],
      tooltipData = charts.options.tooltip;

    //Config axis labels
    var i, l,
      axisLabels = {},
      isAxisLabels = {atLeastOne: false},
      axisArray = ['left', 'top', 'right', 'bottom'];
    if (charts.options.axisLabels) {
      $.extend(true, axisLabels, charts.options.axisLabels);
    }
    if (!$.isEmptyObject(axisLabels)) {
      for (i = 0, l = axisArray.length; i < l; i++) {
        var thisAxis = axisLabels[axisArray[i]];
        if (thisAxis && typeof thisAxis === 'string' && $.trim(thisAxis) !== '') {
          isAxisLabels[axisArray[i]] = true;
          isAxisLabels.atLeastOne = true;
        }
      }
    }

    //Append the SVG in the parent area.
    var dataset = chartData,
      hideDots = (options.hideDots),
      parent = $(container).parent(),
      isCardAction = !!$('.widget-chart-action', parent).length,
      isAxisXRotate = !!(!!settings.xAxis && settings.xAxis.rotate !== undefined),
      isViewSmall = parent.width() < 450,
      margin = {
        top: (isAxisLabels.top ? (isCardAction ? 15 : 40) : (isCardAction ? 5 : 30)),
        right: (isAxisLabels.right ? (isViewSmall ? 45 : 65) : (isViewSmall ? 45 : 55)),
        bottom: (isAxisLabels.bottom ? (isAxisXRotate ? 60 : 50) : (isAxisXRotate ? 45 : 35)),
        left: (isAxisLabels.right ? (isViewSmall ? 55 : 75) : (isViewSmall ? 45 : 65))
      },
      width = parent.width() - margin.left - margin.right,
      height = parent.height() - margin.top - margin.bottom - 30; //legend

    if (isCardAction) {
      height -= 40;
    }

    var svg = d3.select(container).append('svg')
        .attr('width', width + margin.left + margin.right)
        .attr('height', height + margin.top + margin.bottom)
        .append('g')
        .attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');

    var names = dataset[0].data.map(function (d) {
      return d.name;
    });

    var formatValue,
      valueFormatterString = {};
    if (dataset[0] && dataset[0].valueFormatterString) {
      $.extend(true, valueFormatterString, dataset[0].valueFormatterString);
    }
    formatValue = function (s, value) {
      return !$.isEmptyObject(valueFormatterString) && !!s ?
        (d3.format(s)(s === '0.0%' ? value/100 : value)) : value;
    };

    var labels = {
      name: 'Name',
      value: {
        x: 'Value.x',
        y: 'Value.y',
        z: 'Value.z'
      }
    };
    if (dataset[0] && dataset[0].labels) {
      $.extend(true, labels, dataset[0].labels);
    }

    // Calculate the Domain X and Y Ranges
    var maxes,
      x = ((!!settings.xAxis && !!settings.xAxis.scale) ? (settings.xAxis.scale) : (d3.scale.linear())).range([0, width]),
      y = d3.scale.linear().range([height, 0]),
      z = d3.scale.linear().range([1, 25]),
      getMaxes = function (d, option) {
        return d3.max(d.data, function(d) {
          return option ? d.value[option] : d.value;
        });
      };

    if (isBubble) {
      maxes = {
        x: dataset.map(function (d) { return getMaxes(d, 'x'); }),
        y: dataset.map(function (d) { return getMaxes(d, 'y'); }),
        z: dataset.map(function (d) { return getMaxes(d, 'z'); })
      };
    } else {
      maxes = dataset.map(function (d) { return getMaxes(d); });
    }

    var entries = d3.max(dataset.map(function(d){ return d.data.length; })) -1,
      xScale = x.domain(!!settings.xAxis && !!settings.xAxis.domain ? (settings.xAxis.domain) : ([0, isBubble ? d3.max(maxes.x) : entries])).nice(),
      yScale = y.domain([0, d3.max(isBubble ? maxes.y : maxes)]).nice(),
      zScale = z.domain([0, d3.max(isBubble ? maxes.z : maxes)]).nice();

    var xAxis = d3.svg.axis()
      .scale(xScale)
      .orient('bottom')
      .ticks((!!settings.xAxis && !!settings.xAxis.ticks) ? (settings.xAxis.ticks) : (isBubble && isViewSmall ? Math.round(entries/2) : entries))
      .tickPadding(10)
      .tickSize(isBubble ? -(height + 10) : 0)
      .tickFormat(function (d, i) {
        if (!!settings.xAxis && !!settings.xAxis.formatter) {
          return settings.xAxis.formatter(d, i);
        }
        return isBubble ? d : names[i];
      });

    var yAxis = d3.svg.axis()
      .scale(yScale)
      .tickSize(-(width + 20))
      .tickPadding(isRTL ? -18 : 20)
      .orient('left');

    //Append The Axis Labels
    if (isAxisLabels.atLeastOne) {
      var axisLabelsGroup = svg.append('g').attr('class', 'axis-labels'),
        place = {
          top: 'translate('+ (width/2) +','+(-10)+')',
          right: 'translate('+ (width+28) +','+(height/2)+')rotate(90)',
          bottom: 'translate('+ (width/2) +','+(height+40)+')',
          left: 'translate('+ (-40) +','+(height/2)+')rotate(-90)'
        },
        placeStyle = {
          top: 'rotate(0deg) scaleX(-1) translate(-'+(width/2)+'px, '+ (-10) +'px)',
          right: 'rotate(90deg) scaleX(-1) translate(-'+(height/2)+'px, -'+ (width+28) +'px)',
          bottom: 'rotate(0deg) scaleX(-1) translate(-'+(width/2)+'px, '+ (height+40) +'px)',
          left: 'rotate(90deg) scaleX(-1) translate(-'+(height/2)+'px, '+ (55) +'px)'
        },
        addAxis = function(pos) {
          if (isAxisLabels[pos]) {
            axisLabelsGroup.append('text')
              .attr({
                'class': 'axis-label-'+ pos,
                'text-anchor': 'middle',
                'transform': isRTL ? '' : place[pos]
              })
              .style({
                'font-size': '1.3em',
                'transform': isRTL ? placeStyle[pos] : ''
              })
              .text(axisLabels[pos]);
          }
        };

      for (i = 0, l = axisArray.length; i < l; i++) {
        addAxis(axisArray[i]);
      }
    }


    //Append The Axis to the svg
    svg.append('g')
    .attr('class', 'x axis')
    .attr('transform', 'translate(0,' + height + ')')
    .call(xAxis);

    svg.append('g')
      .attr('class', 'y axis')
      .call(yAxis);

    //Offset the tick inside, uses the fact that the yAxis has 20 added.
    svg.selectAll('.tick line').attr('x1', '-10');

    if (isBubble) {
      svg.selectAll('.x.axis .tick line, .y.axis .tick line').style('opacity', 0);
      svg.select('.x.axis .tick line').attr('x2', '-10').style('opacity', 1);
      svg.select('.y.axis .tick line').style('opacity', 1);
    }

    if (charts.isRTL) {
      svg.selectAll('text').attr('transform', 'scale(-1, 1)');
      svg.selectAll('.y.axis text').style('text-anchor', 'start');
    }

    if (isAxisXRotate) {
      svg.selectAll('.x.axis .tick text')  // select all the text for the xaxis
      .attr('transform', function() {
         return 'translate(' + this.getBBox().height*-2 + ', '+ this.getBBox().height + ')rotate('+ settings.xAxis.rotate +')';
     });
    }

    // Create the line generator
    var line = d3.svg.line()
      .x(function(d, i) {
        if (!!settings.xAxis && !!settings.xAxis.parser)  {
          return xScale(settings.xAxis.parser(d, i));
        }
        return xScale(isBubble ? d.value.x : i);
      })
      .y(function(d) {
        return yScale(isBubble ? d.value.y : d.value);
      });

    //append the three lines.
    dataset.forEach(function(d, i) {

      var lineGroups = svg.append('g')
        .attr({'data-group-id': i, 'class': 'line-group'});

      if (isArea) {
        var area = d3.svg.area()
          .x(function(d, i) {
            return xScale(i);
          })
          .y0(height)
          .y1(function(d) {
            return yScale(isBubble ? d.value.y : d.value);
          });

        lineGroups.append('path')
          .datum(d.data)
          .attr('fill', function () { return charts.chartColor(i, 'line', d); })
          .style('opacity', '.2')
          .attr('class', 'area')
          .attr('d', area);
      }

      var path = lineGroups.append('path')
        .datum(d.data)
        .attr('d', line(d.data))
        .attr('stroke', function () { return isBubble ? '' : charts.chartColor(i, 'line', d); })
        .attr('stroke-width', 2)
        .attr('fill', 'none')
        .attr('class', 'line')
        .on('click.chart', function() {
          charts.selectElement(d3.select(this.parentNode), svg.selectAll('.line-group'), d);
        });

      // Add animation
      var totalLength = path.node().getTotalLength();
      path
        .attr('stroke-dasharray', totalLength + ' ' + totalLength)
        .attr('stroke-dashoffset', totalLength)
        .transition()
          .duration(750)
          .ease('cubic')
          .attr('stroke-dashoffset', 0);

      if (!hideDots) {
          lineGroups.selectAll('circle')
          .data(d.data)
          .enter()
          .append('circle')
          .attr('class', dots.class)
          .attr('cx', function (d, i) {
            if (!!settings.xAxis && !!settings.xAxis.parser)  {
              return xScale(settings.xAxis.parser(d, i));
            }
            return xScale(isBubble ? d.value.x : i);
          })
          .attr('cy', function (d) { return yScale(isBubble ? 0 : d.value); })
          .attr('r', dots.radius)
          .style('stroke-width', dots.strokeWidth)
          .style('fill', function () { return charts.chartColor(i, 'line', d); })
          .style('opacity', (isBubble ? '.7' : '1'))
          .on('mouseenter.chart', function(d2) {
            var rect = this.getBoundingClientRect(),
              content = '<p><b>' + d2.name + ' </b> ' + format(d2.value) + '</p>',

              show = function() {
                var size = charts.getTooltipSize(content),
                  x = rect.left - (size.width /2) + 6,
                  y = rect.top - size.height - 18;

                x = isBubble ? ((rect.left + (rect.width /2)) - (size.width /2)) : x;

                if(content !== '') {
                  charts.showTooltip(x, y, content, 'top');
                }
              };

            if (isBubble) {
              content = ''+
                '<div class="chart-swatch" style="min-width: 95px;">'+
                  '<div class="swatch-caption">'+
                    '<span style="background-color:'+ charts.chartColor(i, 'line', d) +';" class="indicator-box"></span>'+
                    '<b>'+ d.name +'</b>'+
                  '</div>';

                var obj = d2;
                for (var key in obj) {
                  if(obj.hasOwnProperty(key)) {
                    if (typeof obj[key] !== 'object') {
                      content += ''+
                        '<div class="swatch-row">'+
                          '<span>'+ labels[key] +'</span>'+
                          '<b>'+ obj[key] +'</b>'+
                        '</div>';
                    } else {
                      var obj2 = obj[key];
                      for (var key2 in obj2) {
                        if(obj2.hasOwnProperty(key2)) {
                          content += ''+
                            '<div class="swatch-row">'+
                              '<span style="text-transform: capitalize;">'+ labels[key][key2] +'</span>'+
                              '<b>'+ formatValue(valueFormatterString[key2], obj2[key2]) +'</b>'+
                            '</div>';
                        }
                      }
                    }
                  }
                }
              content += '</div>';
            }

            if (tooltipData && typeof tooltipData === 'function' && !tooltipDataCache[i]) {
              content = '';
              var runInterval = true;
              tooltipInterval = setInterval(function() {
                if(runInterval) {
                  runInterval = false;
                  tooltipData(function (data) {
                    content = tooltipDataCache[i] = data;
                  });
                }
                if(content !== '') {
                  clearInterval(tooltipInterval);
                  show();
                }
              }, 10);
            } else {
              tooltipData = typeof tooltipData === 'object' ? '' : tooltipData;
              content = tooltipDataCache[i] || tooltipData || d2.tooltip || d.tooltip || content || '';
              show();
            }

            //Circle associated with hovered point
            d3.select(this).attr('r', function (d) {
              return isBubble ? (2 + zScale(d.value.z)) : dots.radiusOnHover;
            });
          })
          .on('mouseleave.chart', function() {
            clearInterval(tooltipInterval);
            charts.hideTooltip();
            d3.select(this).attr('r', function (d) {
              return isBubble ? zScale(d.value.z) : dots.radius;
            });
          })
          .on('click.chart', function(d) {
            charts.selectElement(d3.select(this.parentNode), svg.selectAll('.line-group'), d);
          });

        if (isBubble) {
          // Add animation
          lineGroups.selectAll('circle')
            .attr('cy', function (d) { return yScale(d.value.y); })
            .transition().duration(750).ease('cubic')
            .attr('r', function (d) { return zScale(d.value.z); });
        }
      }

    });

    var series = dataset.map(function (d) {
      return {color: d.color, name: d.name, selectionObj: svg.selectAll('.line-group'), selectionInverse: svg.selectAll('.line-group'), data: d};
    });

    if (charts.showLegend) {
      charts.addLegend(series);
    }
    charts.appendTooltip();

    // Set initial selected
    (function () {
      var selected = 0,
        selector,
        selectorData,

        setSelected = function (node, d, i) {
          if (node.selected && selected < 1) {
            selected++;
            selector = d3.select(svg.selectAll('.line-group')[0][i]);
            selectorData = d;
          }
        };

      dataset.forEach(function(d, i) {
        if (d) {
          setSelected(d, d, i);
        }
      });
      dataset.forEach(function(d, i) {
        if (d || d.data) {
          d.data.forEach(function(d2) {
            setSelected(d2, d, i);
          });
        }
      });

      if (selected > 0) {
        charts.selectElement(selector, svg.selectAll('.line-group'), selectorData);
      }
    })();


    $(container).trigger('rendered');
    return $(container);
  };

  this.Bullet = function(chartData) {
    $(container).addClass('bullet-chart');

    var tooltipInterval,
      tooltipDataCache = [],
      tooltipData = charts.options.tooltip;

    //Append the SVG in the parent area.
    var dataset = chartData,
      noMarkers = false,
      parent = $(container).parent(),
      margin = {top: 30, right: 55, bottom: 35, left: 55},
      width = parent.width() - margin.left - margin.right,
      height = parent.height() - margin.top - margin.bottom - 30; //legend

    height = height < 0 ? 50 : height; //default minimum height

    var svg = d3.select(container).append('svg')
              .attr('width', width + margin.left + margin.right)
              .attr('height', height + margin.top + margin.bottom)
              .append('g')
                .attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');

    //Functions Used in the Loop
    function bulletWidth(x) {
      var x0 = x(0);
      return function(d) {
        return Math.abs(x(d) - x0);
      };
    }

    for (var i = 0; i < dataset[0].data.length; i++) {
      var duration = 600,
          barHeight = 20,
          rowData = dataset[0].data[i],
          ranges = rowData.ranges.slice().sort(d3.descending),
          markers = (rowData.markers ? rowData.markers.slice().sort(d3.descending) : []),
          measures = (rowData.measures ? rowData.measures.slice().sort(d3.descending) : []),
          rangesAsc = rowData.ranges.slice().sort(d3.ascending),
          markersAsc = (rowData.markers ? rowData.markers.slice().sort(d3.ascending) : []),
          measuresAsc = (rowData.measures ? rowData.measures.slice().sort(d3.ascending) : []);

      if (markers.length === 0) {
        markers = measures;
        markersAsc = measuresAsc;
        noMarkers = true;
      }

      var g = svg.append('g')
              .attr('class', 'bullet')
              .attr('transform', 'translate(0, ' + (i * (barHeight * 3.5)) + ')');

      //Add Title and Subtitle
      var title = g.append('g');

      var text = title.append('text')
          .attr('class', 'title')
          .attr('dy', '-10px')
          .text(function() { return rowData.title; });

      text.append('tspan')
          .attr('class', 'subtitle')
          .attr('dx', '15px')
          .text(function() { return rowData.subtitle; });

      var maxAll = Math.max(ranges[0], markers[0], measures[0]),
          minAll = Math.min(rangesAsc[0], markersAsc[0], measuresAsc[0]);

      minAll = minAll < 0 ? minAll : 0;

      // Compute the new x-scale.
      var x1 = d3.scale.linear()
          .domain([minAll, maxAll])
          .range([0, width])
          .nice();

      // Derive width-scales from the x-scales.
      var w1 = bulletWidth(x1);

      // Update the range rects.
      var range = g.selectAll('rect.range')
          .data(ranges);

      range.enter().append('rect')
          .attr('class', function(d, i) { return 'range s' + i; })
          .attr('data-idx', i)
          .attr('width', 0)
          .attr('x', function (d) { return x1(d < 0 ? d : 0); })
          .style('fill', function(d, i) {
            if (chartData[0].barColors) {
              return chartData[0].barColors[i];
            }
          })
          .attr('height', barHeight)
          .on('click', function () {
            var bar = d3.select(this);
            $(container).trigger('selected', [bar, chartData[0].data[bar.attr('data-idx')]]);
          })
          .on('mouseenter', function(d, i) {

            var bar = d3.select(this),
              data = chartData[0].data[bar.attr('data-idx')],
              rect = this.getBoundingClientRect(),
              content = '<p>' + d + '</p>',

              show = function() {
              var size = charts.getTooltipSize(content),
                x = rect.left + rect.width - (size.width/2),
                y = rect.top - size.height + $(window).scrollTop() - 5;

              if(content !== '') {
                charts.showTooltip(x, y, content, 'top');
              }
            };

            if (data.tooltip && data.tooltip[i]) {
              content = data.tooltip[data.tooltip.length - i -1];
            }

            if (tooltipData && typeof tooltipData === 'function' && !tooltipDataCache[i]) {
              content = '';
              var runInterval = true;
              tooltipInterval = setInterval(function() {
                if(runInterval) {
                  runInterval = false;
                  tooltipData(function (data) {
                    content = tooltipDataCache[i] = data;
                  });
                }
                if(content !== '') {
                  clearInterval(tooltipInterval);
                  show();
                }
              }, 10);
            } else {
              tooltipData = typeof tooltipData === 'object' ? '' : tooltipData;
              content = tooltipDataCache[i] || tooltipData || content || '';
              show();
            }

          })
          .on('mouseleave', function() {
            clearInterval(tooltipInterval);
            charts.hideTooltip();
          });


      range.transition()
          .duration(duration)
          .attr('width', w1);

      // Update the measure rects.
      var measure = g.selectAll('rect.measure')
          .data(measures);

      measure.enter().append('rect')
          .attr('class', function(d, i) { return 'measure s' + i; })
          .attr('width', 0)
          .attr('height', 3)
          .attr('x', function (d) { return x1(d < 0 ? d : 0); })
          .style('fill', function(d,i) {
            if (chartData[0].lineColors) {
              return chartData[0].lineColors[i];
            }
          })
          .attr('y', 8.5);

      measure.transition()
          .duration(duration)
          .attr('width', w1);

      // Update the marker lines.
      var marker = g.selectAll('line.marker')
          .data(markers);

      marker.enter().append('line')
          .attr('class', (noMarkers ? 'hidden' : 'marker'))
          .attr('x1', 0)
          .attr('x2', 0)
          .style('stroke', function(d, i) {
            if (chartData[0].markerColors) {
              return chartData[0].markerColors[i];
            }
          })
          .attr('y1', barHeight / 6)
          .attr('y2', barHeight * 5 / 6);

      marker.transition()
          .duration(duration)
          .attr('x1', x1)
          .attr('x2', x1)
          .attr('y1', barHeight / 6)
          .attr('y2', barHeight * 5 / 6);

      //Difference
      var diff = (markers[0] > measures[0] ? '-' : '+') + Math.abs(markers[0] - measures[0]),
        line;

      if (Math.abs(markers[0] - measures[0]) !== 0) {
        line = marker.enter().append('text')
            .attr('class', 'inverse')
            .attr('text-anchor', 'middle')
            .attr('y', barHeight /2 + 4)
            .attr('dx', charts.isRTL ? '-20px' : '20px')
            .attr('x', 0)
            .text(diff);

          marker.transition()
              .duration(duration)
              .attr('x', function() {
                var total = 0;

                g.selectAll('.measure').each(function(d) {
                  var w = w1(d),
                    x = x1(d);

                  if (w > total) {
                    total = w;
                  }

                  if (x > total) {
                    total = x;
                  }
                });

                return charts.isRTL ? -total : total;
              })
              .style('opacity', 1);
      }

      // Update the tick groups.
      var tick = g.selectAll('g.tick')
          .data(x1.ticks(8));

      // Initialize the ticks with the old scale, x0.
      var tickEnter = tick.enter().append('g')
          .attr('class', 'tick')
          .attr('transform', 'translate(0,0)')
          .style('opacity', 0);

      tickEnter.append('line')
          .attr('y1', barHeight)
          .attr('y2', Math.round((barHeight * 7) / 4.7));

      tickEnter.append('text')
          .attr('text-anchor', 'middle')
          .attr('dy', '1.1em')
          .attr('y', Math.round((barHeight * 7) / 4.7))
          .attr('class', function(d) {
            return d < 0 ? 'negative-value' : 'positive-value';
          })
          .text(function (d) {
            return d;
          });

      // Transition the entering ticks to the new scale, x1.
      tickEnter.transition()
          .duration(duration)
          .attr('transform', function (d) {
            return 'translate(' + x1(d) + ',0)';
          })
          .style('opacity', 1);

      if (charts.isRTL && charts.isIE) {
        svg.selectAll('text').attr('transform', 'scale(-1, 1)');
      }

    }

    //Add Legends
    //charts.addLegend(isStacked ? series);
    charts.appendTooltip();
    $(container).trigger('rendered');

  };

  //Completion chart
  this.Completion = function(chartData) {

    // Set dataset
    var dataset = chartData[0].data[0],
      isTarget = charts.settings.type === 'completion-target',
      isAchievment = charts.settings.type === 'targeted-achievement';

    $(container).addClass('completion-chart' + (charts.settings.type === 'targeted-achievement' ? ' chart-targeted-achievement': ''));

    // Set total defaults
    dataset.total = $.extend({}, {value: 100}, dataset.total);

    // Basic functions
    var isUndefined = function(value) {
        return typeof value === 'undefined';
      },
      fixUndefined = function(value, isNumber) {
        return !isUndefined(value) ? value : (isNumber ? 0 : '');
      },
      toValue = function(percent) {
        return percent /100 * fixUndefined(dataset.total.value, true);
      },
      toPercent = function(value) {
        return d3.round(100 * (value / fixUndefined(dataset.total.value, true)));
      },
      format = function (value, formatterString) {
        if (formatterString === '.0%') {
          return toPercent(value) +'%';
        }
        return d3.format(formatterString || '')(value);
      },
      fixPercent = function(value) {
        var s = value.toString();
        if (s.indexOf('%') !== -1) {
          return toValue(s.replace(/%/g, ''));
        }
        return value;
      },
      updateWidth = function(elem, value) {
        var w = toPercent(value) > 100 ? 100 : (toPercent(value) < 0 ? 0 : toPercent(value));
        elem[0].style.width = w + '%';
      },
      updateTargetline = function(elem, value) {
        var w = value > 100 ? 100 : (value < 0 ? 0 : value);
        elem[0].style.left = w + '%';
      },
      setFormat = function(obj) {
        return (obj && !isUndefined(obj.value) && obj.format) ?
          format(fixPercent(obj.value), obj.format) : (obj ? fixPercent(obj.value) : 0);
      },
      setOverlap = function() {
        if (isTarget && !isAchievment) {
          setTimeout(function() {
            var remaining = $('.remaining', container),
              total = $('.total', container),
              rect1 = $('.completed .value', container)[0].getBoundingClientRect(),
              rect2 = remaining.find('.value')[0].getBoundingClientRect();

            remaining.add(total)
              [(rect1.right > rect2.left-20) ? 'addClass' : 'removeClass']('overlap');
          }, 500);
        }
      };

      this.update = function(o) {
        var type, bar, nodes, jsonData;
        if (!o.data) {
          return;
        }

        if (!o.type) {
          nodes = o.node;
        }
        else {
          type = o.type;
          if (!dataset[type]) {
            return;
          }
          nodes = (type === 'name') ?
            $('.name', container) : ((type === 'total') ?
              $('.total.value', container) :
                $('.'+ type +' .value, .'+ type +' .text', container));
        }

        jsonData = (nodes.length === 1 ? nodes : nodes.first()).data('jsonData');

        type = jsonData ? Object.keys(jsonData)[0] : 'name';
        bar = $('.'+ type +'.bar', container);
        $.extend(true, dataset[type], o.data);

        nodes.each(function() {
          var node = $(this);

          // Update text
          if (o.data.text && node.is('.name, .text')) {
            node.html(fixUndefined(dataset[type].text));
          }

          // Update color for text, value, bar
          if (o.data.color && node.is('.name, .info, .text, .value')) {
            if (o.data.color.indexOf('#') === -1) {
              ((type === 'completed' && (!dataset.info || (dataset.info && isUndefined(dataset.info.value)))) ?
                node.add($('.info .value', container)) : node).add(bar)
                  .removeClass('error dark good primary amethyst07')
                  .addClass(o.data.color);
            }
            else {
              if (node.is('.name, .total')) {
                node[0].style.color = dataset[type].color;
              }
              else {
                ((type === 'completed' && (!dataset.info || (dataset.info && isUndefined(dataset.info.value)))) ?
                  $('.'+ type +' .value, .'+ type +' .text, .info .value', container) :
                  $('.'+ type +' .value, .'+ type +' .text', container))[0].style.color = dataset[type].color;
                bar[0].style.backgroundColor = dataset[type].color;
              }
            }
          }

          // Update value & bar width
          if (o.data.value && node.is('.value')) {
            var w,
              completed = $('.completed', container),
              remaining = $('.remaining', container);

            if (type === 'completed') {
              ((!dataset.info || (dataset.info && isUndefined(dataset.info.value))) ?
                node.add($('.info .value', container)) : node)
                  .html(setFormat(dataset[type]));

              if (toPercent(fixPercent(dataset[type].value)) >= 100) {
                remaining.hide();
                completed[0].style.marginTop = 'inherit';
              }
            }
            else {
              node.html(setFormat(dataset[type]));
            }

            if (!node.is('.name, .total') && type !== 'targetline') {
              if (type === 'completed') {
                w = fixPercent(dataset[type].value);
                updateWidth(bar, w);
                w += fixPercent(dataset.remaining.value);
                updateWidth($('.remaining.bar', container), w);
              }
              else if (type === 'remaining') {
                w = fixPercent(dataset[type].value) + fixPercent(dataset.completed.value);
                updateWidth(bar, w);
              }
            }
            else if (!node.is('.name, .total, .remaining') && type === 'targetline') {
              w = fixPercent(dataset[type].value);
              updateTargetline(bar, w);
            }
            setOverlap();
          }
        });
      };

    // Render
    var html = {body: $('<div class="total bar" />')};
    if (isTarget || isAchievment) {
      var difference = {};
      html.body.addClass('chart-completion-target' + (isAchievment ? ' chart-targeted-achievement' : ''));

      if (dataset.total.difference) {
        difference.value = (dataset.total.value - dataset.completed.value);
        difference.format = dataset.total.format;
      }

      var totalText = setFormat(dataset.total.difference ? difference : dataset.total) + (dataset.total.text ? dataset.total.text : '');
      totalText = isAchievment && dataset.remaining ? setFormat(dataset.remaining) + (dataset.remaining.text ? dataset.remaining.text : ''): totalText;

      html.label = ''+
      '<span class="label">'+
        '<span class="name">'+
        (dataset.completed.color && dataset.completed.color === 'error' ? '<svg class="icon icon-error" focusable="false" aria-hidden="true" role="presentation"><use xlink:href="#icon-error"></use></svg>' : '' ) +
        fixUndefined(dataset.name.text) + '</span>'+
        '<span class="l-pull-right total value">'+ totalText +'</span>'+
      '</span>';
    }
    else {
      html.body.addClass('chart-completion');
      html.label = ''+
      '<b class="label name ">'+ fixUndefined(dataset.name.text) +'</b>'+
      '<b class="label info '+ (dataset.info.color ?
        fixUndefined(dataset.info.color) :
          fixUndefined(dataset.completed.color) +' colored') +'">'+
        '<span class="value">'+
        (dataset.info && !isUndefined(dataset.info.value) ? fixUndefined(dataset.info.value) :
          setFormat(dataset.completed)) +
        '</span> '+
        '<span class="text">'+ fixUndefined(dataset.info.text) +'</span>'+
      '</b>';
    }

    if (dataset.remaining) {
      html.remaining = ''+
      '<div class="target remaining bar '+ fixUndefined(dataset.remaining.color) +'">'+
      (isAchievment ? '' : '<span aria-hidden="true"'+ (!isTarget && !isAchievment ? ' class="audible"' : '') +'>'+
          '<span class="value">'+
            setFormat(dataset.remaining) +
          '</span><br />'+
          '<span class="text">'+
            fixUndefined(dataset.remaining.text) +
          '</span>'+
        '</span>') +
      '</div>';
    } else {
      html.remaining = '<div class="target remaining bar" style="opacity: 0"></div>';
    }

    if (dataset.completed && isAchievment) {
      html.completed = ''+
      '<div class="completed bar '+ fixUndefined(dataset.completed.color) +'"></div>'+
        '<span class="completed-label" aria-hidden="true"'+ (!isTarget && !isAchievment ? ' class="audible"' : '') +'>'+
          '<span class="text">'+
            fixUndefined(dataset.completed.text) +
          '</span>'+
        '</span>';
    }

    if (dataset.completed && !isAchievment) {
      html.completed = ''+
      '<div class="completed bar '+ fixUndefined(dataset.completed.color) +'">'+
        '<span aria-hidden="true"'+ (!isTarget && !isAchievment ? ' class="audible"' : '') +'>'+
          '<span class="value">'+ setFormat(dataset.completed) + '</span><br />'+
          '<span class="text">'+
            fixUndefined(dataset.completed.text) +
          '</span>'+
        '</span></div>';
    }

    if (dataset.targetline) {
      html.targetline = ''+
      '<div class="target-line targetline bar">'+
        '<span aria-hidden="true"'+ (!isTarget && !isAchievment ? ' class="audible"' : '') +'>'+
          '<span class="value">'+
            setFormat(dataset.targetline) +
            '</span><br />'+
            '<span class="text">'+
              fixUndefined(dataset.targetline.text) +
            '</span>'+
        '</span>'+
      '</div>';
    }

    html.body.append(html.remaining, html.completed, html.targetline);
    $(container).append(html.label, html.body);

    // Caching elements
    var c = {
      name: $('.name', container),
      info: {
        value: $('.info .value', container),
        text: $('.info .text', container)
      },
      completed: {
        bar: $('.completed.bar', container),
        value: $('.completed .value', container),
        text: $('.completed .text', container)
      },
      remaining: {
        bar: $('.remaining.bar', container),
        value: $('.remaining .value', container),
        text: $('.remaining .text', container)
      },
      targetline: {
        bar: $('.targetline', container),
        value: $('.targetline .value', container),
        text: $('.targetline .text', container)
      },
      total: {
        bar: $('.total.bar', container),
        value: $('.total.value', container),
      }
    };

    // Set jsonData
    c.name.data('jsonData', {name: dataset.name});
    c.info.value.add(c.info.text).data('jsonData', {info: dataset.info});
    c.completed.bar.add(c.completed.value).add(c.completed.text)
      .data('jsonData', {completed: dataset.completed});
    c.remaining.bar.add(c.remaining.value).add(c.remaining.text)
      .data('jsonData', {remaining: dataset.remaining});
    c.targetline.bar.add(c.targetline.value).add(c.targetline.text)
      .data('jsonData', {targetline: dataset.targetline});
    c.total.bar.add(c.total.value).data('jsonData', {total: dataset.total});

    var w;
    // Update completed bar width
    if (dataset.completed) {
      w = fixPercent(dataset.completed.value);
      updateWidth(c.completed.bar, w);
    }

    // Update remaining bar width
    if (dataset.remaining) {
      w = fixPercent(dataset.completed.value) + fixPercent(dataset.remaining.value);
      updateWidth(c.remaining.bar, w);
      setOverlap();
    }

    // Update target line bar position
    if (dataset.targetline) {
      w = fixPercent(dataset.targetline.value);
      updateTargetline(c.targetline.bar, w);
    }
  };

  //Select the element and fire the event, make the inverse selector opace
  this.selectElement = function(elem, inverse, data) {
    var isSelected = elem.node() && elem.classed('is-selected');

    inverse.classed('is-not-selected', false)
      .classed('is-selected', false)
      .classed('is-not-selected', !isSelected);

     elem.classed('is-not-selected', false)
        .classed('is-selected', !isSelected);

    //Fire Events
     $(container).triggerHandler('selected', [elem, (!isSelected ? data : {})]);
  };

  // Make bars to be Selected or Unselected
  this.setSelectedElement = function (o) {
    var s = charts.settings,
      isPositiveNegative = s.type === 'column-positive-negative',
      isTypeHorizontalBar = s.chartType === 'HorizontalBar',
      isTypeColumn = s.chartType === 'Column',
      isTypePie = s.chartType === 'Pie',

      svg = s.svg,
      isSingle = s.isSingle,
      isGrouped = s.isGrouped,
      isStacked = s.isStacked,
      isSingular = s.isSingular,

      taskSelected = (o.task === 'selected'),
      selector = d3.select(o.selector),
      isPositive = selector.classed('positive'),
      ticksX = svg.selectAll('.axis.x .tick'),
      ticksY = svg.selectAll('.axis.y .tick'),
      pnPositiveText = svg.selectAll('.bartext.positive, .target-bartext.positive'),
      pnNegativeText = svg.selectAll('.bartext.negative, .target-bartext.negative'),
      thisGroup = d3.select(o.selector.parentNode),
      thisGroupId = parseInt((thisGroup.node() ? thisGroup.attr('data-group-id') : 0), 10),
      triggerData = [selector[0], o.d, (isGrouped ? thisGroupId : o.i)],
      selectedBars = [];

    ticksX.style('font-weight', 'normal');
    ticksY.style('font-weight', 'normal');
    pnPositiveText.style('font-weight', 'normal');
    pnNegativeText.style('font-weight', 'normal');
    svg.selectAll('.is-selected').classed('is-selected', false);

    // Task make selected
    if (taskSelected) {
      svg.selectAll('.bar, .target-bar').style('opacity', 0.6);

      // By legends only
      if (s.isByLegends) {
        if (isPositiveNegative) {
          s.svg.selectAll(isPositive ?
            '.bar.positive, .target-bar.positive': '.bar.negative, .target-bar.negative')
              .classed('is-selected', true).style('opacity', 1);

          (isPositive ? pnPositiveText : pnNegativeText).style('font-weight', 'bolder');

          svg.selectAll('.bar.is-selected').each(function(d, i) {
            selectedBars.push([d3.select(this)[0], d, i]);
          });
          triggerData.push(selectedBars);
        }
        // Grouped and stacked only -NOT singular-
        else if (isTypeColumn || isTypeHorizontalBar) {
          if (isGrouped || isSingular) {
            s.svg.selectAll('.series-'+ o.i).classed('is-selected', true).style('opacity', 1);
          }
          else {
            thisGroup.classed('is-selected', true)
              .selectAll('.bar').classed('is-selected', true).style('opacity', 1);
          }
          svg.selectAll('.bar.is-selected').each(function(d, i) {
            selectedBars.push([d3.select(this)[0], d, i]);
          });
          triggerData.push(selectedBars);
        }
      }

      // Single and stacked only -NOT grouped-
      else if (isSingular && isStacked && isTypeColumn) {
        selector.classed('is-selected', true).style('opacity', 1);
      }

      // Single or groups only -NOT stacked-
      else if ((isSingle || isGrouped) && !isStacked && (isTypeColumn || isTypeHorizontalBar)) {
        svg.selectAll((isTypeColumn ? '.axis.x' : '.axis.y') +' .tick:nth-child('+ ((isGrouped ? thisGroupId : o.i) + 1) +')')
          .style('font-weight', 'bolder');

        selector.classed('is-selected', true).style('opacity', 1);
        svg.select('.target-bar.series-'+ o.i).style('opacity', 1);
        d3.select(svg.selectAll('.bartext')[0][o.i]).style('font-weight', 'bolder');
        d3.select(svg.selectAll('.target-bartext')[0][o.i]).style('font-weight', 'bolder');

        if (isGrouped || isPositiveNegative) {
          if (!isPositiveNegative) {
            thisGroup.classed('is-selected', true)
              .selectAll('.bar').classed('is-selected', true).style('opacity', 1);
          }

          svg.selectAll('.bar.is-selected').each(function(d, i) {
            selectedBars.push([d3.select(this)[0], d, i]);
          });
          triggerData.push(selectedBars, thisGroup[0]);
        }
      }

      // Stacked Only
      else if (isTypeColumn || isTypeHorizontalBar) {
        svg.selectAll((isTypeColumn ? '.axis.x' : '.axis.y') +' .tick:nth-child('+ (o.i + 1) +')')
          .style('font-weight', 'bolder');

        svg.selectAll('.bar:nth-child('+ (o.i + 1) +')')
          .classed('is-selected', true).style('opacity', 1);

        svg.selectAll('.bar.is-selected').each(function(d, i) {
          selectedBars.push([d3.select(this)[0], d, i]);
        });
        triggerData.push(selectedBars);
      }

      // Pie
      else if (isTypePie) {
        var color = charts.chartColor(o.i, 'pie', o.d.data);
        selector.classed('is-selected', true)
          .style({'stroke': color, 'stroke-width': 0})
          .attr('transform', 'scale(1.025, 1.025)');
      }
    }
    // Task make unselected
    else {
      svg.selectAll('.bar, .target-bar').style('opacity', 1);
      pnPositiveText.style('font-weight', 'bolder');
      pnNegativeText.style('font-weight', 'bolder');

      if(isTypePie) {
        selector.classed('is-selected', false)
          .style('stroke', '#fff')
          .style('stroke-width', '1px')
          .attr('transform', '');
      }
    }

    if (s.isByLegends) {
      s.isByLegends = false;
    }

    if (o.isTrigger) {
      $(o.container).triggerHandler((taskSelected ? 'selected' : 'unselected'), triggerData);
    }
  };

  this.isHTML = function (str) {
    return /(<([^>]+)>)/i.test(str);
  };

  this.initChartType = function (options) {
    //default
    this.options = options;
    this.redrawOnResize = true;
    this.isRTL = Locale.isRTL();
    this.isIE = $('html').hasClass('ie');

    if (options.redrawOnResize !== undefined) {
      this.redrawOnResize = options.redrawOnResize;
    }
    if (options.format) {
      this.format = options.format;
    }
    if (options.tooltip) {
      this.tooltip = options.tooltip;
    }
    if (options.showLegend) {
      this.showLegend = options.showLegend;
    }
    if (options.legendformatter) {
      this.legendformatter = options.legendformatter;
    }
    // Prevent error from passed empty dataset
    if (!options.dataset || !options.dataset.length) {
      $.extend(true, options, {dataset: [{data: []}]});
    }
    if (options.type === 'pie') {
      this.Pie(options.dataset, false, options);
    }
    if (options.type === 'bar' || options.type === 'bar-stacked') {
      this.showLegend = typeof options.showLegend !== 'undefined' ? options.showLegend : true;
      this.HorizontalBar(options.dataset);
    }
    if (options.type === 'bar-normalized') {
      this.showLegend = typeof options.showLegend !== 'undefined' ? options.showLegend : true;
      this.HorizontalBar(options.dataset, true);
    }
    if (options.type === 'bar-grouped') {
      this.showLegend = typeof options.showLegend !== 'undefined' ? options.showLegend : true;
      this.HorizontalBar(options.dataset, true, false); //dataset, isNormalized, isStacked
    }
    if (options.type === 'column-stacked') {
      this.Column(options.dataset, true);
    }
    if (['column', 'column-grouped', 'column-positive-negative'].indexOf(options.type) > -1) {
      this.Column(options.dataset);
    }
    if (options.type === 'donut') {
      this.Pie(options.dataset, true, options);
    }
    if (options.type === 'sparkline') {
      this.Sparkline(options.dataset, options);
    }
    if (options.type === 'sparkline-dots') {
      this.Sparkline(options.dataset, {isDots: true});
    }
    if (options.type === 'sparkline-peak') {
      this.Sparkline(options.dataset, {isPeakDot: true});
    }
    if (options.type === 'sparkline-dots-n-peak') {
      this.Sparkline(options.dataset, {isDots: true, isPeakDot: true});
    }
    if (options.type === 'sparkline-minmax') {
      this.Sparkline(options.dataset, {isMinMax: true});
    }
    if (options.type === 'sparkline-medianrange') {
      this.Sparkline(options.dataset, {isMedianRange: true});
    }
    if (options.type === 'sparkline-medianrange-n-peak') {
      this.Sparkline(options.dataset, {isMedianRange: true, isPeakDot: true});
    }
    if (options.type === 'line') {
      this.showLegend = typeof options.showLegend !== 'undefined' ? options.showLegend : true;
      this.Line(options.dataset, options);
    }
    if (options.type === 'area') {
      this.showLegend = typeof options.showLegend !== 'undefined' ? options.showLegend : true;
      this.Line(options.dataset, options, true);
    }
    if (options.type === 'bubble') {
      this.showLegend = typeof options.showLegend !== 'undefined' ? options.showLegend : true;
      this.Line(options.dataset, options, false, true);
    }
    if (options.type === 'bullet') {
      this.Bullet(options.dataset);
    }
    if (options.type === 'completion' ||
        options.type === 'completion-target' || options.type === 'targeted-achievement') {
      this.redrawOnResize = false;
      this.Completion(options.dataset);
    }
  };

};

//Make it a plugin
$.fn.chart = function(options) {
  return this.each(function() {
    var instance = $.data(this, 'chart'),
      chartInst;

    if (instance) {
      $(window).off('resize.line');
      $(window).off('resize.pie');
      $(window).off('resize.charts load.charts');
      $(this).empty();
    }

    chartInst = new Chart(this, options);
    instance = $.data(this, 'chart', chartInst);
    instance.settings = options;

    if ($.isEmptyObject(chartInst)) {
     return;
    }

    setTimeout(function () {
      chartInst.initChartType(options);
      chartInst.handleResize();
    }, instance ? 0 : 300);

  });
};

  $.fn.colorpicker = function(options) {
    'use strict';

    // Settings and Options
    var pluginName = 'colorpicker',
        defaults = {

          // Theme key: MUST match with theme file name (ie: [filename: 'light-theme.css' -> 'light-theme'])

          // BORDERS
          // Use (,) commas to separate themes or single entry for border as:
          // colors[{label: 'Slate', number: '01', value: 'F0F0F0', border: 'light-theme, high-contrast-theme'}]
          // and assign which swatch theborder should apply ['all' or 'matched-only']
          // themes: { 'high-contrast-theme': {'border': 'all'} }

          // CHECKMARKS
          // checkmark: {'one': [1, 2], 'two': [3, 10]}
          // will add class as "checkmark-{key}", where current colors number is in range [{value[0]} to {value[1]}]
          // will add class "checkmark-one", where current colors number is in range [1 to 3]
          // and will add class "checkmark-two", where current colors number is in range [3 to 10]
          themes: {
            'light': {'border': 'matched-only', checkmark: {'one': [1, 2], 'two': [3, 10]} },
            'dark': {'border': 'matched-only', checkmark: {'one': [1, 2], 'two': [3, 10]} },
            'high-contrast': {'border': 'all', checkmark: {'one': [1, 3], 'two': [4, 10]} }
          },
          colors: [
            {label: 'Slate', number: '10', value: '1a1a1a'},
            {label: 'Slate', number: '09', value: '292929'},
            {label: 'Slate', number: '08', value: '383838', border: 'dark'},
            {label: 'Slate', number: '07', value: '454545', border: 'dark'},
            {label: 'Slate', number: '06', value: '5C5C5C'},
            {label: 'Slate', number: '05', value: '737373'},
            {label: 'Slate', number: '04', value: '999999'},
            {label: 'Slate', number: '03', value: 'BDBDBD'},
            {label: 'Slate', number: '02', value: 'D8D8D8'},
            {label: 'Slate', number: '01', value: 'F0F0F0', border: 'light, high-contrast'},
            {label: 'Amber', number: '10', value: 'D66221'},
            {label: 'Amber', number: '09', value: 'DE7223'},
            {label: 'Amber', number: '08', value: 'E68425'},
            {label: 'Amber', number: '07', value: 'EB9728'},
            {label: 'Amber', number: '06', value: 'EFAA30'},
            {label: 'Amber', number: '05', value: 'F2BC41'},
            {label: 'Amber', number: '04', value: 'F4C951'},
            {label: 'Amber', number: '03', value: 'F7D475'},
            {label: 'Amber', number: '02', value: 'F8E09C'},
            {label: 'Amber', number: '01', value: 'FBE9BF'},
            {label: 'Ruby', number: '10', value: '880E0E'},
            {label: 'Ruby', number: '09', value: '941E1E'},
            {label: 'Ruby', number: '08', value: 'A13030'},
            {label: 'Ruby', number: '07', value: 'AD4242'},
            {label: 'Ruby', number: '06', value: 'B94E4E'},
            {label: 'Ruby', number: '05', value: 'C65F5F'},
            {label: 'Ruby', number: '04', value: 'D26D6D'},
            {label: 'Ruby', number: '03', value: 'DE8181'},
            {label: 'Ruby', number: '02', value: 'EB9D9D'},
            {label: 'Ruby', number: '01', value: 'F4BCBC'},
            {label: 'Turquoise', number: '10', value: '0E5B52'},
            {label: 'Turquoise', number: '09', value: '206B62'},
            {label: 'Turquoise', number: '08', value: '317C73'},
            {label: 'Turquoise', number: '07', value: '448D83'},
            {label: 'Turquoise', number: '06', value: '579E95'},
            {label: 'Turquoise', number: '05', value: '69ADA3'},
            {label: 'Turquoise', number: '04', value: '7BBFB5'},
            {label: 'Turquoise', number: '03', value: '8ED1C6'},
            {label: 'Turquoise', number: '02', value: 'A9E1D6'},
            {label: 'Turquoise', number: '01', value: 'C0EDE3'},
            {label: 'Emerald', number: '10', value: '397514'},
            {label: 'Emerald', number: '09', value: '44831F'},
            {label: 'Emerald', number: '08', value: '56932E'},
            {label: 'Emerald', number: '07', value: '66A140'},
            {label: 'Emerald', number: '06', value: '76B051'},
            {label: 'Emerald', number: '05', value: '89BF65'},
            {label: 'Emerald', number: '04', value: '9CCE7C'},
            {label: 'Emerald', number: '03', value: 'AFDC91'},
            {label: 'Emerald', number: '02', value: 'C3E8AC'},
            {label: 'Emerald', number: '01', value: 'D5F6C0'},
            {label: 'Amethyst', number: '10', value: '4B2A5E'},
            {label: 'Amethyst', number: '09', value: '5A3A6F'},
            {label: 'Amethyst', number: '08', value: '6C4B81'},
            {label: 'Amethyst', number: '07', value: '7D5F92'},
            {label: 'Amethyst', number: '06', value: '8E72A4'},
            {label: 'Amethyst', number: '05', value: 'A189B8'},
            {label: 'Amethyst', number: '04', value: 'B59ECA'},
            {label: 'Amethyst', number: '03', value: 'C7B4DB'},
            {label: 'Amethyst', number: '02', value: 'DACCEC'},
            {label: 'Amethyst', number: '01', value: 'EDE3FC'},
            {label: 'Azure', number: '10', value: '133C59'},
            {label: 'Azure', number: '09', value: '134D71'},
            {label: 'Azure', number: '08', value: '1D5F8A'},
            {label: 'Azure', number: '07', value: '2876A8'},
            {label: 'Azure', number: '06', value: '368AC0'},
            {label: 'Azure', number: '05', value: '4EA0D1'},
            {label: 'Azure', number: '04', value: '69B5DD'},
            {label: 'Azure', number: '03', value: '8DC9E6'},
            {label: 'Azure', number: '02', value: 'ADD8EB'},
            {label: 'Azure', number: '01', value: 'CBEBF4'}
          ],
          placeIn: null // null|'editor'
        },
        settings = $.extend({}, defaults, options);

    /**
     * @constructor
     * @param {Object} options
     */
    function ColorPicker(element) {
      this.settings = $.extend({}, settings);
      this.element = $(element);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    // Plugin Methods
    ColorPicker.prototype = {

      init: function() {
        this.inlineLabel = this.element.closest('label');
        this.inlineLabelText = this.inlineLabel.find('.label-text');
        this.isInlineLabel = this.element.parent().is('.inline');
        this.build();
        this.handleEvents();
      },

      // Add the extra markup
      build: function() {
        this.isEditor = this.settings.placeIn === 'editor';
        var colorpicker = this.element,
          initialValue = this.isEditor ? this.element.attr('data-value') :  this.element.val();

        if (!this.isEditor) {
          //Add Button
          if (this.isInlineLabel) {
            this.inlineLabel.addClass('colorpicker-container');
          }
          else {
            this.container = $('<span class="colorpicker-container"></span>');
            colorpicker.wrap(this.container);
          }

          this.container = colorpicker.parent();
          this.swatch = $('<span class="swatch"></span>').prependTo(this.container);

          //Add Masking to show the #
          colorpicker.attr('data-mask', '*******').mask();
        }

        this.icon = $.createIconElement('dropdown')
          .appendTo(this.isEditor ? this.element : this.container);
        this.icon.wrap('<span class="trigger"></span>');

        if (initialValue && initialValue.substr(0,1) !== '#') {
          initialValue = '#' + initialValue;
          this.element.attr(this.isEditor ? 'data-value' : 'value', initialValue);
        }

        if (initialValue && initialValue.length === 7) {
          this.setColor(initialValue);
          this.element.attr(this.isEditor ? 'data-value' : 'value', initialValue);
        }

         if (this.element.is(':disabled')) {
          this.disable();
        }

        this.addAria();
      },

      // Add/Update Aria
      addAria: function () {
        this.element.attr('role', 'combobox').attr('aria-autocomplete', 'list');

        $('label[for="'+ this.element.attr('id') + '"]')
          .append('<span class="audible">' + Locale.translate('UseArrow') + '</span>');
      },

      // Attach Control Events
      handleEvents: function () {
        var self = this;
        this.icon.parent().onTouchClick().on('click.colorpicker', function () {
          self.toggleList();
        });

        this.element.on('focus.colorpicker', function () {
          $(this).parent().addClass('is-focused');
        })
        .on('blur.colorpicker', function () {
          $(this).parent().removeClass('is-focused');
        });

        this.element.on('keypress.colorpicker', function () {
          self.setColor($(this).val());
        }).on('change.colorpicker', function () {
          self.setColor($(this).val());
        });

        //Handle Key Down to open
        this.element.on('keydown.colorpicker', function (e) {
          if (e.keyCode === 38 || e.keyCode === 40) {
            self.toggleList();
          }
        });
      },

      // Toggle / Open the List
      toggleList: function () {
        var self = this,
          menu =  $('#colorpicker-menu');

        if (self.element.is(':disabled')) {
          return;
        }

        if (menu.length) {
          var isPickerOpen = self.isPickerOpen;
          $(document).trigger($.Event('keydown', {keyCode: 27, which: 27})); // escape

          if (isPickerOpen) {
            return;
          }
        }

        //Append Color Menu
        menu =  self.updateColorMenu();

        var popupmenuOpts = {
          ariaListbox: true,
          menuId: 'colorpicker-menu',
          trigger: 'immediate',
          placementOpts: {
            containerOffsetX: 10,
            containerOffsetY: 10,
            parentXAlignment: (Locale.isRTL() ? 'right': 'left'),
            strategies: ['flip', 'nudge', 'shrink']
          },
          offset: {
            x: 0,
            y: 10
          }
        };

        // Show Menu
        self.element
        .popupmenu(popupmenuOpts)
        .on('open.colorpicker', function () {
          self.element.parent().addClass('is-open');
          self.isPickerOpen = true;
        })
        .on('close.colorpicker', function () {
          menu.on('destroy.colorpicker', function () {
            $(this).off('destroy.colorpicker').remove();
          });
          self.element.parent().removeClass('is-open');
          self.isPickerOpen = false;
        })
        .on('selected.colorpicker', function (e, item) {
          if (!self.isEditor) {
            self.element.val('#'+item.data('value'));
            self.swatch[0].style.backgroundColor = '#' + item.data('value');
          }
          self.element.focus();
        });

        //Append Buttons
        this.menu = $('#colorpicker-menu');

        setTimeout(function () {
          self.menu.find('.is-selected').focus();
        }, 1);
      },

      // Set the Visible Color
      setColor: function (hex, text) {
        // Make sure there is always a hash
        if (hex.substr(0,1) !== '#') {
          hex = '#' + hex;
          this.element.attr(this.isEditor ? 'data-value' : 'value', hex);
        }

        if (hex.length !== 7) {
          return;
        }

        if (!this.isEditor) {
          this.swatch[0].style.backgroundColor = hex;
        }
        this.element.attr('aria-describedby', text);
      },

      // Refresh and Append the Color Menu
      updateColorMenu: function () {
        var isMenu =  !!($('#colorpicker-menu').length),
          menu = $('<ul id="colorpicker-menu" class="popupmenu colorpicker"></ul>'),
          currentTheme = Soho.theme;

        var isBorderAll = (settings.themes[currentTheme].border === 'all'),
          checkmark = settings.themes[currentTheme].checkmark,
          checkmarkClass = '';

        for (var i = 0, l = settings.colors.length; i < l; i++) {
          var li = $('<li></li>'),
            a = $('<a href="#"><span class="swatch"></span></a>').appendTo(li),
            number = settings.colors[i].number,
            num = parseInt(number, 10),
            text = (Locale.translate(settings.colors[i].label) || settings.colors[i].label) + (settings.colors[i].number || ''),
            value = settings.colors[i].value,
            isBorder = false,
            regexp = new RegExp('\\b'+ currentTheme +'\\b'),
            elemValue = this.isEditor ? this.element.attr('data-value') : this.element.val();

          // Set border to this swatch
          if (isBorderAll || regexp.test(settings.colors[i].border)) {
            isBorder = true;
          }

          if (elemValue && (elemValue + '').toLowerCase().replace('#', '') === (value + '').toLowerCase()) {
            // Set checkmark color class
            if (checkmark) {
              $.each(checkmark, function(k, v) {
                // checkmark: {'one': [1, 2], 'two': [3, 10]}
                // will add class "checkmark-one", where current colors number is in range [1 to 3]
                // and will add class "checkmark-two", where current colors number is in range [3 to 10]
                if ((num >= v[0]) && (num <= v[1])) {
                  checkmarkClass = ' checkmark-'+ k;
                }
              });
            }
            a.addClass('is-selected'+ checkmarkClass);
          }

          var swatch = a.find('.swatch');
          if (swatch[0]) {
            swatch[0].style.backgroundColor = '#'+ value;
          }
          swatch.addClass(isBorder ? 'is-border' : '');
          a.data('label', text)
            .data('value', value)
            .attr('title', text +' #'+ value)
            .tooltip();

          // menu.append(li);
          if (!isMenu) {
            menu.append(li);
          }
        }

        if (!isMenu) {
          $('body').append(menu);
        }

        return menu;
      },

      enable: function() {
        this.element.prop('disabled', false);
        this.element.parent().removeClass('is-disabled');
      },

      disable: function() {
        this.element.prop('disabled', true);
        this.element.parent().addClass('is-disabled');
      },

      isDisabled: function() {
        return this.element.prop('disabled');
      },

      decimal2rgb: function(n) {
        if (typeof n !== 'number') {
          return n;
        }
        return 'rgb('+
          (n & 0xFF) +', '+
          ((n & 0xFF00) >> 8) +', '+
          ((n & 0xFF0000) >> 16 ) +
        ')';
      },

      rgb2hex: function (rgb) {
        if (rgb.search('rgb') === -1) {
          return rgb;
        }
        else if (rgb === 'rgba(0, 0, 0, 0)') {
          return 'transparent';
        }
        else {
          var hex = function (x) {
            return ('0' + parseInt(x).toString(16)).slice(-2);
          };
          rgb = rgb.match(/^rgba?\((\d+),\s*(\d+),\s*(\d+)(?:,\s*(\d+))?\)$/);
          return '#' + hex(rgb[1]) + hex(rgb[2]) + hex(rgb[3]);
        }
      },

      // Teardown
      destroy: function() {
        this.swatch.remove();
        this.element.off('keypress.colorpicker');
        this.swatch.off('click.colorpicker');
        $.removeData(this.element[0], pluginName);
      }
    };

    // Initialize the plugin (Once)
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (instance) {
        instance.settings = $.extend({}, defaults, options);
      } else {
        instance = $.data(this, pluginName, new ColorPicker(this, settings));
      }
    });
  };


  //NOTE: Just this part will show up in SoHo Xi Builds.

  $.fn.compositeform = function(options) {
    'use strict';

    // Settings and Options
    var pluginName = 'compositeform',
        defaults = {
          trigger: null,
          expandedText: Locale.translate('ShowLess'),
          collapsedText: Locale.translate('ShowMore'),
        },
        settings = $.extend({}, defaults, options);

    /**
     * Composite Form Control
     * @constructor
     * @param {Object} element
     */
    function CompositeForm(element, settings) {
      this.settings = $.extend({}, settings);
      this.element = $(element);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    // Plugin Methods
    CompositeForm.prototype = {
      init: function() {
        return this
          .build()
          .handleEvents();
      },

      /**
       * Adds markup to the control and stores references to some sub-elements
       * @returns {this}
       */
      build: function() {
        var classList = this.element[0].classList;
        if (!classList.contains('composite-form')) {
          classList.add('composite-form');
        }

        // Get expandable area reference
        this.expandableArea = this.element.find('.expandable-area');
        this.expandableAreaAPI = this.expandableArea.data('expandablearea');
        if (!this.expandableAreaAPI) {
          this.expandableArea.expandablearea({ trigger: this.settings.trigger });
          this.expandableAreaAPI = this.expandableArea.data('expandablearea');
        }

        // Get expandable trigger
        this.expander = this.expandableAreaAPI.expander;
        this.setExpanderText(this.settings.expandedText);

        // Check size and append class, if necessary
        this.checkResponsive();

        return this;
      },

      /**
       * Sets up event handlers for this control and its sub-elements
       * @param {string} expanderText - the text content
       * @returns {undefined}
       */
      handleEvents: function() {
        var self = this;

        $('body').on('resize.' + pluginName, function(e) {
          self.checkResponsive(e);
        });

        this.element.on('updated.' + pluginName, function() {
          self.updated();
        });

        function changeExpanderText() {
          var isExpanded = self.expandableAreaAPI.isExpanded();
          self.setExpanderText(self.settings[isExpanded ? 'expandedText' : 'collapsedText']);
        }

        this.expandableArea
          .on('expand.' + pluginName, changeExpanderText)
          .on('collapse.' + pluginName, changeExpanderText);

        return this;
      },

      /**
       * Checks if we've passed the breakpoint for switching into Responsive mode.
       * @returns {undefined}
       */
      checkResponsive: function() {
        var cl = this.element[0].classList;

        if (Soho.breakpoints.isBelow('phone-to-tablet')) {
          cl.add('is-in-responsive-mode');
        } else {
          cl.remove('is-in-responsive-mode');
        }
      },

      /**
       * Sets the text content of the Composite Form's Expandable Area Expander.
       * @param {string} expanderText - the text content
       * @returns {undefined}
       */
      setExpanderText: function(expanderText) {
        if (!(expanderText instanceof String) || !expanderText.length) {
          return;
        }

        var textSpan = this.expander.find('span');
        if (!textSpan) {
          textSpan = this.expander;
        }
        textSpan.text(expanderText);
      },

      /**
       * Re-invokes the Composite Form
       * @returns {this}
       */
      updated: function() {
        return this
          .teardown()
          .init();
      },

      /**
       * Simple Teardown - remove events & rebuildable markup.
       * @returns {this}
       */
      teardown: function() {
        $('body').off('resize.' + pluginName);
        this.element.off('updated.' + pluginName);
        this.expandableArea.off('expand.' + pluginName + ' collapse.' + pluginName);
        return this;
      },

      /**
       * Destroys the component instance by removing it from its associated element.
       * @returns {this}
       */
      destroy: function() {
        this.teardown();
        $.removeData(this.element[0], pluginName);
      }
    };

    // Initialize the plugin (Once)
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (instance) {
        instance.settings = $.extend({}, instance.settings, options);
        instance.updated();
      } else {
        instance = $.data(this, pluginName, new CompositeForm(this, settings));
      }
    });
  };


  $.fn.contextualactionpanel = function(options) {

    // Settings and Options
    var pluginName = 'contextualactionpanel',
        defaults = {
          id: 'contextual-action-modal-' + (parseInt($('.modal').length, 10)+1),
          buttons: null, // List of buttons that will sit in the toolbar's Buttonset area
          title: 'Contextual Action Panel', // string that fits into the toolbar's Title field
          content: null, //Pass content through to modal
          initializeContent: true, // initialize content before opening
          trigger: 'click'
        },
        settings = $.extend({}, defaults, options);

    /**
     * @constructor
     * @param {Object} element
     */
    function ContextualActionPanel(element) {
      this.settings = $.extend({}, settings);
      this.element = $(element);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    // Plugin Methods
    ContextualActionPanel.prototype = {

      init: function() {
        this
          .setup()
          .build()
          .handleEvents();
      },

      setup: function() {
        this.panel = this.element.next('.contextual-action-panel');
        if (this.panel[0]) {
          this.panel[0].style.display = 'none';
        }
        this.panel.addClass('is-animating');
        return this;
      },

      build: function() {
        var self = this;

        // Build the Content
        if (this.panel.length === 0) {
          if (this.settings.content  instanceof jQuery) {

            if (this.settings.content.is('.contextual-action-panel')) {
              this.panel = this.settings.content;
            } else {
              this.settings.content.wrap('<div class="contextual-action-panel"></div>');
              this.panel = this.settings.content.parent();
            }

            this.panel.addClass('modal').appendTo('body');

            if (this.settings.content.is('iframe')) {
              this.settings.content.ready(function () {
                self.completeBuild();
                self.settings.content.show();
              });
              return self;
            }
            this.settings.content.show();

          } else {
            this.panel = $('<div class="contextual-action-panel">'+ this.settings.content +'</div>').appendTo('body');
            this.panel.addClass('modal').attr('id', this.settings.id);
          }

        }

        this.completeBuild();
        return this;
      },

      completeBuild: function() {
        var self = this,
          children,
          isIframe = false,
          contents;

        this.panel.find('svg').icon();

        if (this.panel.find('.modal-content').length === 0) {
          children = this.panel.children();
          if (children.is('iframe')) {
            contents = children.contents();
            this.toolbar = contents.find('.toolbar');
            isIframe = true;
          }

          if (!isIframe) {
            children.wrapAll('<div class="modal-content"></div>').wrapAll('<div class="modal-body"></div>');
            this.panel.addClass('modal');
          }
        }

        if (this.panel.find('.modal-header').length === 0) {
          this.header = $('<div class="modal-header"></div>');
          this.header.insertBefore(this.panel.find('.modal-body'));

          if (!this.toolbar) {
            this.toolbar = this.panel.find('.toolbar');
          }

          if (!this.toolbar.length) {
            this.toolbar = $('<div class="toolbar"></div>');
          }

          this.toolbar.appendTo(this.header);
          var toolbarTitle = this.toolbar.find('.title');
          if (!toolbarTitle.length) {
            toolbarTitle = $('<div class="title">' + this.settings.title + '</div>');
            this.toolbar.prepend(toolbarTitle);
          }

          var toolbarButtonset = this.toolbar.find('.buttonset');
          if (!toolbarButtonset.length) {
            toolbarButtonset = $('<div class="buttonset"></div>');
            toolbarButtonset.insertAfter(toolbarTitle);
          }
        }

        // Move to the body element to break stacking context issues.
        if (!isIframe) {
          this.panel.detach().appendTo('body');
        }

        this.element.attr('data-modal', this.settings.id);
        if (!this.panel.attr('id')) {
          this.panel.attr('id', this.settings.id);
        }

        this.panel.modal({
          buttons: self.settings.buttons,
          trigger: (self.settings.trigger ? self.settings.trigger : 'click')
        });

        this.buttons = this.panel.find('.buttonset').children('button');
        this.closeButton = this.buttons.filter('.btn-close, [name="close"], .icon-close');

        if (!this.toolbar) {
          this.toolbar = this.panel.find('.toolbar');
        }

        if (this.toolbar.length) {
          this.toolbar.toolbar();
        }

        Soho.utils.fixSVGIcons(this.element);
        return this;
      },

      handleEvents: function() {
        var self = this;

        // Convenience method that takes an event from the Modal control's panel element,
        // and triggers any listeners that may be looking at the Contextual Action Panel's trigger instead.
        function passEvent(e) {
          self.element.triggerHandler(e.type);
        }

        this.panel.addClass('is-animating').on('open.contextualactionpanel', function(e) {
          passEvent(e);
          self.panel.removeClass('is-animating');
        }).on('beforeclose.contextualactionpanel', function() {
          self.panel.addClass('is-animating');
        }).on('close.contextualactionpanel', function(e) {
          passEvent(e);
        }).on('beforeopen.contextualactionpanel', function(e) {
          if (self.settings.initializeContent) {
            $(this).initialize();
          }
          passEvent(e);
        }).on('afteropen.contextualactionpanel', function() {
          if (self.toolbar) {
            self.toolbar.trigger('recalculate-buttons');
          }

          // Select the proper element on the toolbar
          if (self.toolbar.length) {
            var selected = self.toolbar.find('.buttonset > .is-selected');
            if (!selected.length) {
              selected = self.toolbar.find('.buttonset > *:first-child');
              if (selected.is('.searchfield-wrapper')) {
                selected = selected.children('.searchfield');
              }
            }
            self.toolbar.data('toolbar').setActiveButton(selected, true);
          }

          // Focus the first focusable element inside the Contextual Panel's Body
          self.panel.find('.modal-body-wrapper').find(':focusable').first().focus();
          Soho.utils.fixSVGIcons(self.panel);
        }).on('beforedestroy.contextualactionpanel', function() {
          self.teardown();
        });

        if (this.toolbar)  {
          this.toolbar.children('.buttonset').children('.btn-close, [name="close"], .icon-close')
            .onTouchClick('contextualactionpanel').on('click.contextualactionpanel', function() {
            self.handleToolbarSelected();
          });
        }

        return this;
      },

      handleToolbarSelected: function() {
        this.close();
      },

      teardown: function() {
        var self = this,
          buttonset = self.toolbar.children('.buttonset');

        this.panel.off('open.contextualactionpanel close.contextualactionpanel ' +
          'beforeopen.contextualactionpanel afterclose.contextualactionpanel');

        buttonset.children('*:not(.searchfield)')
          .offTouchClick('contextualactionpanel').off('click.contextualactionpanel');

        var menuButtons = buttonset.children('.btn-menu');
        menuButtons.each(function() {
          var popup = $(this).data('popupmenu');
          if (popup) {
            popup.destroy();
          }
        });

        //self.panel.detach().insertAfter(self.element);
        self.toolbar.data('toolbar').destroy();

        if (self.header){
          self.header.remove();
        }

        var children = self.panel.find('.modal-body').children();
        children.first().unwrap().unwrap(); // removes $('.modal-body'), then $('.modal-content')

        self.element.removeAttr('data-modal');

        // Trigger an afterclose event on the Contextual Action Panel's trigger element (different from the panel, which is already removed).
        self.element.trigger('afterteardown');
      },

      close: function() {
        var destroy;
        if (this.settings.trigger === 'immediate') {
          destroy = true;
        }
        if (this.panel.data('modal')) {
          this.panel.data('modal').close(destroy);
        }
      },

      disable: function() {
        this.element.prop('disabled', true);
        if (this.panel.hasClass('is-visible')) {
          this.close();
        }
      },

      enable: function() {
        this.element.prop('disabled', false);
      },

      // Teardown - Remove added markup and events
      destroy: function() {
        this.panel.data('modal').destroy();
        $.removeData(this.element[0], pluginName);
      }
    };

    // Initialize the plugin (Once)
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (instance) {

        instance.settings = $.extend({}, instance.settings, options);
        if (settings.trigger === 'immediate') {
          instance = $.data(this, pluginName, new ContextualActionPanel(this, settings));
        }

      } else {
        instance = $.data(this, pluginName, new ContextualActionPanel(this, settings));
      }
    });
  };


  $.fn.datepicker = function(options) {
    'use strict';

    // Settings and Options
    var pluginName = 'datepicker',
        defaults = {
          showTime: false,
          timeFormat: undefined, // The time format
          minuteInterval: undefined, // Integer from 1 to 60. Multiples of this value are displayed as options in the minutes dropdown.
          mode: undefined, // options: 'standard', 'range',
          roundToInterval: undefined, // If a non-matching minutes value is entered, rounds the minutes value to the nearest interval when the field is blurred.
          dateFormat: 'locale', //or can be a specific format like 'yyyy-MM-dd' iso8601 format
          placeholder: false,
          /*  Disabling of dates
          **    dates: 'M/d/yyyy' or
          **      ['M/d/yyyy'] or
          **      ['M/d/yyyy', new Date('M/d/yyyy')] or
          **      ['M/d/yyyy', new Date('M/d/yyyy'), new Date(yyyy,(M-0),d)]
          **    minDate: 'M/d/yyyy'
          **    maxDate: 'M/d/yyyy'
          **    dayOfWeek: [2] or [0,6] - {0-sun, 1-mon, 2-tue, 3-wed, 4-thu, 5-fri, 6-sat}
          **    isEnable: false or true
          **/
          disable: {
            'dates'     : [],
            'minDate'   : '',
            'maxDate'   : '',
            'dayOfWeek' : [],
            'isEnable' : false
          },
          showLegend: false,
          legend: [
            //Legend Build up example
            //Color in level 6 - http://usmvvwdev53:424/controls/colors
            {name: 'Public Holiday', color: '#76B051', dates: []},
            {name: 'Weekends', color: '#EFA836', dayOfWeek: []}
          ]
        },
        settings = $.extend({}, defaults, options);

    /**
     * A component to support date entry.
     * Users can either manually enter a date or select a date from a calendar.
     * A secondary benefit is the ability to restrict the dates that are available for selection.
     * @class
     * @param {Object} [element=this] - The element to attach to (only when manually calling the constructor)
     * @param {Object} [options]
     * @param {string} [options.dateFormat='locale'] - The format in which to display the date. Defaults to the current locales format but can be set to a custom format like 'yyyy-MM-dd' (iso8601 format).
     */
    function DatePicker(element) {
      this.element = $(element);
      this.settings = settings;
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    // Plugin Methods
    DatePicker.prototype = {

      init: function() {
        this.build();
        this.handleEvents();
      },

      //Add any markup
      build: function() {

        // Add "is-disabled" css class to closest ".field" if element is disabled
        if (this.element.is(':disabled')) {
          this.element.closest('.field').addClass('is-disabled');
        }

        //Append a trigger button
        this.trigger = $.createIconElement('calendar').insertAfter(this.element);
        this.addAria();

        this.isIslamic = Locale.calendar().name === 'islamic-umalqura';
        this.conversions = Locale.calendar().conversions;
      },

      addAria: function () {
        this.label = $('label[for="'+ this.element.attr('id') + '"]');
        this.label.append('<span class="audible">' + Locale.translate('PressDown') + '</span>');
      },

      //Attach Events used by the Control
      handleEvents: function () {
        var self = this;

        this.trigger.on('click.datepicker', function () {
          if (self.isOpen()) {
            self.closeCalendar();
          } else {
            self.openCalendar();
          }
        });

        self.mask();
        this.handleKeys(this.element);
      },

      // Handle Keyboard Stuff
      handleKeys: function (elem) {
        var self = this;

        if (elem.is('#calendar-popup')) {
          elem.off('keydown.datepicker').on('keydown.datepicker', '.calendar-table', function (e) {
            var handled = false,
              key = e.keyCode || e.charCode || 0;

            //Arrow Down: select same day of the week in the next week
            if (key === 40) {
                handled = true;
                self.currentDate.setDate(self.currentDate.getDate() + 7);
                self.insertDate(self.currentDate);
            }

            //Arrow Up: select same day of the week in the previous week
            if (key === 38) {
              handled = true;
              self.currentDate.setDate(self.currentDate.getDate() - 7);
              self.insertDate(self.currentDate);
            }

            //Arrow Left
            if (key === 37) {
              handled = true;
              self.currentDate.setDate(self.currentDate.getDate() - 1);
              self.insertDate(self.currentDate);
            }

            //Arrow Right
            if (key === 39) {
              handled = true;
              self.currentDate.setDate(self.currentDate.getDate() + 1);
              self.insertDate(self.currentDate);
            }

            //Page Up Selects Same Day Next Month
            if (key === 33 && !e.altKey) {
              handled = true;
              self.currentDate.setMonth(self.currentDate.getMonth() + 1);
              self.insertDate(self.currentDate);
            }

            //Page Down Selects Same Day Prev Month
            if (key === 34 && !e.altKey) {
              handled = true;
              self.currentDate.setMonth(self.currentDate.getMonth() - 1);
              self.insertDate(self.currentDate);
            }

            //ctrl + Page Up Selects Same Day Next Year
            if (key === 33 && e.ctrlKey) {
              handled = true;
              self.currentDate.setFullYear(self.currentDate.getFullYear() + 1);
              self.insertDate(self.currentDate);
            }

            //ctrl + Page Down Selects Same Day Prev Year
            if (key === 34 && e.ctrlKey) {
              handled = true;
              self.currentDate.setFullYear(self.currentDate.getFullYear() - 1);
              self.insertDate(self.currentDate);
            }

            //Home Moves to End of the month
            if (key === 35) {
              handled = true;
              var lastDay =  new Date(self.currentDate.getFullYear(), self.currentDate.getMonth()+1, 0);
              self.currentDate = lastDay;
              self.insertDate(self.currentDate);
            }

            //End Moves to Start of the month
            if (key === 36) {
              var firstDay =  new Date(self.currentDate.getFullYear(), self.currentDate.getMonth(), 1);
              self.currentDate = firstDay;
              self.insertDate(self.currentDate);
            }

            // 't' selects today
            if (key === 84) {
              handled = true;
              self.setToday();
            }

            // Space or Enter closes Date Picker, selecting the Date
            if (key === 32 || key === 13) {
              self.closeCalendar();
              self.element.focus();
              handled = true;
            }

            // Tab closes Date Picker and goes to next field
            if (key === 9) {
              if (!self.settings.showTime) {
                self.element.focus();
                self.closeCalendar();
              }
            }

            // Esc closes Date Picker and goes back to field
            if (key === 27) {
              self.closeCalendar();
              self.element.focus();
            }

            if (handled) {
              e.stopPropagation();
              e.preventDefault();
              return false;
            }

          });
        }
        else {
          elem.off('keydown.datepicker').on('keydown.datepicker', function (e) {
            var handled = false,
              key = e.keyCode || e.charCode || 0,
              focused = $(':focus'),
              focusedlabel = focused.attr('aria-label');

            // Focus did not auto move from readonly
            if (key === 9 && self.element.is('[readonly]')) { //tab
              self.setFocusOnFocusableElement(self.element, (e.shiftKey ? 'prev' : 'next'));
              return;
            }

            if (focusedlabel) {
              var focusedDate = new Date(focusedlabel);
              self.currentDate = new Date(focusedDate.getTime());
            } else if (focused.hasClass('alternate')) {
                var year = parseInt(self.header.find('.year').text()),
                month = parseInt(self.header.find('.month').attr('data-month')),
                day = parseInt(focused.text());

              if (focused.hasClass('prev-month')) {
                if(month === 0) {
                  month = 11;
                  year--;
                }
                else {
                  month--;
                }
              } else if (focused.hasClass('next-month')) {
                if(month === 11) {
                  month = 0;
                  year++;
                }
                else {
                  month++;
                }
              }
              self.currentDate = new Date(year, month, day);
            }

           //Arrow Down or Alt first opens the dialog
            if (key === 40 && !self.isOpen()) {
              handled = true;
              self.openCalendar();

              setTimeout(function() {
                self.setFocusAfterOpen();
              }, 200);
            }

            // 't' selects today
            if (key === 84) {
              handled = true;
              self.setToday();
            }

            if (handled) {
              e.stopPropagation();
              e.preventDefault();
              return false;
            }

          });
        }

      },

      //Parse the Date Format Options
      setFormat: function () {
        var localeDateFormat = ((typeof Locale === 'object' && Locale.calendar().dateFormat) ? Locale.calendar().dateFormat : null),
          localeTimeFormat = ((typeof Locale === 'object' && Locale.calendar().timeFormat) ? Locale.calendar().timeFormat : null);

        if (this.settings.dateFormat === 'locale') {
          this.pattern = localeDateFormat.short + (this.settings.showTime ? ' ' + (this.settings.timeFormat || localeTimeFormat) : '');
        } else {
          this.pattern = this.settings.dateFormat + (this.settings.showTime && this.settings.timeFormat ? ' ' + this.settings.timeFormat : '');
        }

        this.show24Hours = (this.pattern.match('HH') || []).length > 0;
        this.isSeconds = (this.pattern.match('ss') || []).length > 0;
      },

      // Add masking with the mask function
      mask: function () {
        this.setFormat();

        var validation = 'date availableDate',
          events = {'date': 'blur', 'availableDate': 'blur'},
          customValidation = this.element.attr('data-validate'),
          customEvents = this.element.attr('data-validation-events'),
          mask = this.pattern.toLowerCase()
                   .replace(/yyyy/g,'####')
                   .replace(/mmmm/g,'*********')
                   .replace(/mmm/g,'***')
                   .replace(/mm/g,'##')
                   .replace(/dd/g,'##')
                   .replace(/hh/g,'##')
                   .replace(/ss/g,'##')
                   .replace(/[mdh]/g,'##')
                   .replace(/[a]/g,'am');

        //TO DO - Time seperator
        // '##/##/#### ##:## am' -or- ##/##/#### ##:##' -or- ##/##/####'
        // '##/##/#### ##:##:## am' -or- ##/##/#### ##:##:##'
        mask = (this.settings.showTime ?
          (this.show24Hours ? mask.substr(0, (this.isSeconds ? 19:16)) : mask) : mask);

        if (customValidation === 'required' && !customEvents) {
          validation = customValidation + ' ' + validation;
          $.extend(events, {'required': 'change blur'});
        } else if (!!customValidation && !!customEvents) {
          // Remove default validation, if found "no-default-validation" string in "data-validate" attribute
          if (customValidation.indexOf('no-default-validation') > -1) {
            validation = customValidation.replace(/no-default-validation/g, '');
            events = $.fn.parseOptions(this.element, 'data-validation-events');
          }
          // Keep default validation along custom validation
          else {
            validation = customValidation + ' ' + validation;
            $.extend(events, $.fn.parseOptions(this.element, 'data-validation-events'));
          }
        }

        this.element
          .attr({
            'data-mask': mask,
            'data-validate': validation,
            'data-validation-events': JSON.stringify(events),
            'data-mask-mode': 'date'
          }).mask().validate();

        if (this.settings.placeholder && (!this.element.attr('placeholder') ||  this.element.attr('placeholder') === 'M / D / YYYY')) {
          this.element.attr('placeholder', this.pattern);
        }
      },

      // Return whether or not the calendar div is open.
      isOpen: function () {
        return (this.popup && this.popup.is(':visible') &&
          !this.popup.hasClass('is-hidden'));
      },

      open: function() {
        return this.openCalendar();
      },

      activeTabindex: function(elem, isFocus) {
        $('td', this.days).removeAttr('tabindex');
        elem.attr('tabindex', 0);

        if (isFocus) {
          elem.focus();
        }
        return elem;
      },

      // Open the calendar in a popup
      openCalendar: function () {
        var self = this,
          timeOptions = {};


        if (this.element.is(':disabled') || this.element.attr('readonly')) {
          return;
        }

        $('#validation-tooltip').addClass('is-hidden');


        this.element.addClass('is-active').trigger('listopened');

        // Calendar Html in Popups
        var prevButton = '<button type="button" class="btn-icon prev">' + $.createIcon('caret-left') + '<span>'+ Locale.translate('PreviousMonth') +'</span></button>',
            nextButton = '<button type="button" class="btn-icon next">' + $.createIcon('caret-right') + '<span>'+ Locale.translate('NextMonth') +'</span></button>';

        this.table = $('<table class="calendar-table" aria-label="'+ Locale.translate('Calendar') +'" role="application"></table>');
        this.header = $('<div class="calendar-header"><span class="month">november</span><span class="year">2015</span>'+ (Locale.isRTL() ? prevButton + nextButton : prevButton + nextButton) +'</div>');
        this.dayNames = $('<thead><tr><th>SU</th> <th>MO</th> <th>TU</th> <th>WE</th> <th>TH</th> <th>FR</th> <th>SA</th> </tr> </thead>').appendTo(this.table);
        this.days = $('<tbody> <tr> <td class="alternate">26</td> <td class="alternate">27</td> <td class="alternate">28</td> <td class="alternate">29</td> <td class="alternate" >30</td> <td class="alternate">31</td> <td>1</td> </tr> <tr> <td>2</td> <td>3</td> <td>4</td> <td>5</td> <td>6</td> <td>7</td> <td>8</td> </tr> <tr> <td>9</td> <td>10</td> <td>11</td> <td>12</td> <td>13</td> <td>14</td> <td>15</td> </tr> <tr> <td>16</td> <td>17</td> <td>18</td> <td>19</td> <td class="is-today">20</td> <td>21</td> <td>22</td> </tr> <tr> <td>23</td> <td>24</td> <td>25</td> <td>26</td> <td>27</td> <td>28</td> <td class="alternate">1</td> </tr> <tr> <td class="alternate">2</td> <td class="alternate">3</td> <td class="alternate">4</td> <td class="alternate">5</td> <td class="alternate">6</td> <td class="alternate">7</td> <td class="alternate">8</td> </tr> </tbody>').appendTo(this.table);
        this.timepickerContainer = $('<div class="datepicker-time-container"></div>');
        this.footer = $('<div class="popup-footer"> <button type="button" class="cancel btn-tertiary">'+ Locale.translate('Clear') +'</button> <button type="button" class="is-today btn-tertiary">'+Locale.translate('Today')+'</button> </div>');

        // Timepicker options
        if (this.settings.showTime) {
          if (this.settings.timeFormat === undefined) {
            // Getting time-format from date-format (dateFormat: 'M/d/yyyy HH:mm:ss')
            timeOptions.timeFormat = this.pattern.slice(this.pattern.indexOf(' '));
          }
          else {
            timeOptions.timeFormat = this.settings.timeFormat;
          }
          if (this.settings.minuteInterval !== undefined) {
            timeOptions.minuteInterval = this.settings.minuteInterval;
          }
          if (this.settings.mode !== undefined) {
            timeOptions.mode = this.settings.mode;
          }
          if (this.settings.roundToInterval !== undefined) {
            timeOptions.roundToInterval = this.settings.roundToInterval;
          }

        }

        this.calendar = $('<div class="calendar'+ (this.settings.showTime ? ' is-timepicker' : '') +'"></div')
          .append(
            this.header,
            this.table,
            (this.settings.showTime ? this.timepickerContainer : ''),
            this.footer
          );

        var placementParent = this.element,
          placementParentXAlignment = (Locale.isRTL() ? 'right' : 'left'),
          parent = this.element.parent();

        if (parent.is('.datagrid-cell-wrapper')) {
          placementParentXAlignment = 'center';
          placementParent = this.element.next('.icon');
        }

        var popoverOpts = {
          content: this.calendar,
          placementOpts: {
            parent: placementParent,
            parentXAlignment: placementParentXAlignment,
            strategies: ['flip', 'nudge', 'shrink']
          },
          placement : 'bottom',
          popover: true,
          trigger: 'immediate',
          tooltipElement: '#calendar-popup'
        };

        this.trigger.popover(popoverOpts)
        .off('show.datepicker').on('show.datepicker', function () {
          if (Soho.env.os.name === 'ios') {
            $('head').triggerHandler('disable-zoom');
          }
          // Horizontal view on mobile
          if (window.innerHeight < 400) {
            self.popup.find('.arrow').hide();
            self.popup.css('min-height', (self.popupClosestScrollable[0].scrollHeight + 2) +'px');
            self.popupClosestScrollable.css('min-height', '375px');
          }
        })
        .off('hide.datepicker').on('hide.datepicker', function () {
          if (Soho.env.os.name === 'ios') {
            self.trigger.one('hide', function() {
              $('head').triggerHandler('enable-zoom');
            });
          }
          self.popupClosestScrollable.add(self.popup).css('min-height', 'inherit');
          self.closeCalendar();
        });

        this.handleKeys($('#calendar-popup'));
        $('.calendar-footer a', this.calendar).button();

        // Show Month
        this.setValueFromField();

        // Set timepicker
        if (this.settings.showTime) {
          timeOptions.parentElement = this.timepickerContainer;
          this.time = self.getTimeString(this.currentDate, self.show24Hours);
          this.timepicker = this.timepickerContainer.timepicker(timeOptions).data('timepicker');
          this.timepickerContainer.find('dropdown').dropdown();

          // Wait for timepicker to initialize
          setTimeout(function() {
            self.timepicker.initValues = self.timepicker.getTimeFromField(self.time);
            self.timepicker.afterShow(self.timepickerContainer);
            return;
          }, 1);
        }

        this.todayDate = new Date();
        this.todayMonth = this.todayDate.getMonth();
        this.todayYear = this.todayDate.getFullYear();
        this.todayDay = this.todayDate.getDate();

        if (this.isIslamic) {
          this.todayDateIslamic = this.conversions.fromGregorian(this.todayDate);
          this.todayYear = this.todayDateIslamic[0];
          this.todayMonth = this.todayDateIslamic[1];
          this.todayDay = this.todayDateIslamic[2];
        }

        this.showMonth(this.currentMonth, this.currentYear);
        this.popup = $('#calendar-popup');
        this.popupClosestScrollable = this.popup.closest('.scrollable');
        this.popup.attr('role', 'dialog');
        this.originalDate = this.element.val();

        // Calendar Day Events
        this.days.off('click.datepicker').on('click.datepicker', 'td', function () {
          var td = $(this);
          if (td.hasClass('is-disabled')) {
            self.activeTabindex(td, true);
          }
          else {
            self.days.find('.is-selected').removeClass('is-selected').removeAttr('aria-selected');

            var cell = $(this),
              year = parseInt(self.header.find('.year').text()),
              month = parseInt(self.header.find('.month').attr('data-month')),
              day = parseInt(cell.addClass('is-selected').attr('aria-selected', 'true').text());

            if (cell.hasClass('prev-month')) {
              if(month === 0) {
                month = 11;
                year--;
              }
              else {
                month--;
              }
            }
            else if (cell.hasClass('next-month')) {
              if(month === 11) {
                month = 0;
                year++;
              }
              else {
                month++;
              }
            }

            self.currentDate = new Date(year, month, day);

            if (self.isIslamic) {
              self.currentDateIslamic[0] = year;
              self.currentDateIslamic[1] = month;
              self.currentDateIslamic[2] = day;
              self.currentYear = self.currentDateIslamic[0];
              self.currentMonth = self.currentDateIslamic[1];
              self.currentDay = self.currentDateIslamic[2];
              self.currentDate = self.conversions.toGregorian(self.currentDateIslamic[0], self.currentDateIslamic[1], self.currentDateIslamic[2]);
            }

            self.insertDate(self.isIslamic ? self.currentDateIslamic : self.currentDate);
            self.closeCalendar();
            self.element.focus();
          }
        });

        // Calendar Footer Events
        this.footer.off('click.datepicker').on('click.datepicker', 'button', function (e) {
          var btn = $(this);

          if (btn.hasClass('cancel')) {
            self.element.val('').trigger('change').trigger('input');
            self.currentDate = null;
            self.closeCalendar();
          }

          if (btn.hasClass('is-today')) {
            self.setToday();
            self.closeCalendar();
          }
          self.element.focus();
          e.preventDefault();
        });

        // Change Month Events
        this.header.off('click.datepicker').on('click.datepicker', 'button', function () {
          self.showMonth(self.currentMonth + ($(this).hasClass('next') ? 1 : -1), self.currentYear);
        });

        setTimeout(function() {
          self.setFocusAfterOpen();
        }, 200);

      },

      // Alias for _closeCalendar()_ that works with the global "closeChildren" method
      close: function() {
        return this.closeCalendar();
      },

      // Close the calendar in a popup
      closeCalendar: function () {
        // Close timepicker
        if (this.settings.showTime && this.timepickerControl && this.timepickerControl.isOpen()) {
          this.timepickerControl.closeTimePopup();
        }

        if (this.popup && this.popup.length) {
          this.popup.hide().remove();
        }

        var popoverAPI = this.trigger.data('tooltip');
        if (popoverAPI) {
          popoverAPI.destroy();
        }

        if (this.element.hasClass('is-active')) {
          this.element.trigger('listclosed');
          this.element.removeClass('is-active');
        }
      },

      // Check through the options to see if the date is disabled
      isDateDisabled: function (year, month, date) {
        var d, i, l,
          self = this,
          d2 = new Date(year, month, date),
          min = (new Date(this.settings.disable.minDate)).setHours(0,0,0,0),
          max = (new Date(this.settings.disable.maxDate)).setHours(0,0,0,0);

        //dayOfWeek
        if(this.settings.disable.dayOfWeek.indexOf(d2.getDay()) !== -1) {
          return true;
        }

        d2 = d2.setHours(0,0,0,0);

        //min and max
        if ((d2 <= min) || (d2 >= max)) {
          return true;
        }

        //dates
        if (this.settings.disable.dates.length && typeof this.settings.disable.dates === 'string') {
          this.settings.disable.dates = [this.settings.disable.dates];
        }

        for (i=0, l=this.settings.disable.dates.length; i<l; i++) {
          d = new Date(self.settings.disable.dates[i]);
          if(d2 === d.setHours(0,0,0,0)) {
            return true;
          }
        }

        return false;
      },

      // Set disable Date
      setDisabled: function (elem, year, month, date) {
        var dateIsDisabled = this.isDateDisabled(year, month, date);
        elem.removeClass('is-disabled').removeAttr('aria-disabled');

        if ((dateIsDisabled && !this.settings.disable.isEnable) || (!dateIsDisabled && this.settings.disable.isEnable)) {
          elem
            .addClass('is-disabled').attr('aria-disabled','true')
            .removeClass('is-selected').removeAttr('aria-selected');
        }
      },

      //Add a Legend below the table
      addLegend: function () {
        if (!this.settings.showLegend) {
          return;
        }

        //Remove Legend
        if (this.legend && this.legend.length) {
          this.legend.remove();
        }

        this.legend = $('<div class="calendar-legend"></div>');

        for (var i = 0; i < this.settings.legend.length; i++) {
          var series = this.settings.legend[i],
            item = '<div class="calendar-legend-item">' +
              '<span class="calendar-legend-swatch" style="background-color:' + this.hexToRgba(series.color, 0.3) + '"></span>' +
              '<span class="calendar-legend-text">' + series.name + '</span></div>';

          this.legend.append(item);
        }

        this.table.after(this.legend);
      },

      // Set Color for the Legend settings
      setLegendColor: function (elem, year, month, date) {
        if (!this.settings.showLegend || !elem[0]) {
          return;
        }

        var hex = this.getLegendColor(year, month, date),
          self = this;

        elem[0].style.backgroundColor = '';

        if (hex) {
          //set color on elem at .3 of provided color as per design
          elem.addClass('is-colored');
          elem[0].style.backgroundColor = this.hexToRgba(hex, 0.3);

          var normalColor = self.hexToRgba(hex, 0.3),
            hoverColor = self.hexToRgba(hex, 0.7);

          //handle hover states
          elem.on('mouseenter', function () {
            var elem = $(this);
            elem[0].style.backgroundColor = hoverColor;
            elem.find('span')[0].style.backgroundColor = 'transparent';
          }).on('mouseleave', function () {
            var elem = $(this);
            elem[0].style.backgroundColor = normalColor;
            elem.find('span')[0].style.backgroundColor = '';
          });

        }
      },

      //This maybe can be later moved into a colors file along with getLuminousColorShade
      ///But convert the provided hex to an RGBA for states
      hexToRgba: function(hex, opacity) {
        var c;
        if (/^#([A-Fa-f0-9]{3}){1,2}$/.test(hex)) {
            c = hex.substring(1).split('');

            if (c.length === 3) {
              c= [c[0], c[0], c[1], c[1], c[2], c[2]];
            }

            c = '0x' + c.join('');
            return 'rgba(' + [(c>>16)&255, (c>>8)&255, c&255].join(',') + ',' + opacity.toString() +')';
        }
        return '';
      },

      // Process Color Options to get the date color
      getLegendColor: function (year, month, date) {
        if (!this.settings.showLegend) {
          return;
        }

        var checkDate = new Date(year, month, date),
          checkHours = checkDate.setHours(0,0,0,0);

        for (var i = 0; i < this.settings.legend.length; i++) {
          var series = this.settings.legend[i];

          //Check Day of week
          if (series.dayOfWeek && series.dayOfWeek.indexOf(checkDate.getDay()) !== -1) {
            return series.color;
          }

          //Check for dates that match
          if (series.dates) {
            for (var j = 0; j < series.dates.length; j++) {
              var d = new Date(series.dates[j]);
              if (checkHours === d.setHours(0,0,0,0)) {
                return series.color;
              }
            }
          }

        }

        return '';
      },

      // Set focus after opening the calendar
      setFocusAfterOpen: function () {
        if (!this.calendar) {
          return;
        }
        this.activeTabindex(this.calendar.find('.is-selected'), true);
      },

      // Update the calendar to show the month (month is zero based)
      showMonth: function (month, year) {
        var self = this;

        var elementDate = this.currentDate.getDate() ?
          this.currentDate : (new Date()).setHours(0,0,0,0);

        if (this.isIslamic) {
          elementDate = this.currentDateIslamic;
        }

        if (year.toString().length < 4) {
          year = new Date().getFullYear();
        }

        if (month === 12) {
          year ++;
          this.currentMonth = month = 0;
          this.currentYear = year;
          this.header.find('.year').text(' ' + year);
        }

        if (month < 0) {
          year --;
          this.currentMonth = month = 11;
          this.currentYear = year;
          this.header.find('.year').text(' ' + year);
        }

        var days = Locale.calendar().days.narrow || Locale.calendar().days.narrow || Locale.calendar().days.abbreviated,
          monthName = Locale.calendar().months.wide[month];

        this.currentMonth = month;
        this.currentYear = year;

        // Set the Days of the week
        var firstDayofWeek = (Locale.calendar().firstDayofWeek || 0);
        this.dayNames.find('th').each(function (i) {
          $(this).text(days[(i + firstDayofWeek) % 7]);
        });

        //Localize Month Name
        this.yearFist = Locale.calendar().dateFormat.year && Locale.calendar().dateFormat.year.substr(1, 1) === 'y';
        this.header.find('.month').attr('data-month', month).text(monthName + ' ');
        this.header.find('.year').text(' ' + year);

        if (this.yearFist) {
          var translation = Locale.formatDate(elementDate, {date: 'year'}),
            justYear = translation.split(' ')[0];

          this.header.find('.year').text(justYear + ' ');
          this.header.find('.year').insertBefore(this.header.find('.month'));
        }

        //Adjust days of the week
        //lead days
        var firstDayOfMonth = this.firstDayOfMonth(year, month),
          leadDays = (firstDayOfMonth - (Locale.calendar().firstDayofWeek || 0) + 7) % 7,
          lastMonthDays = this.daysInMonth(year, month+1),
          thisMonthDays = this.daysInMonth(year, month+0),
          dayCnt = 1, nextMonthDayCnt = 1, exYear, exMonth, exDay;

        this.days.find('td').each(function (i) {
          var th = $(this).removeClass('alternate prev-month next-month is-selected is-today');
          th.removeAttr('aria-selected');

          if (i < leadDays) {
            exDay = lastMonthDays - leadDays + 1 + i;
            exMonth = (month === 0) ? 11 : month - 1;
            exYear = (month === 0) ? year - 1 : year;

            self.setDisabled(th, exYear, exMonth, exDay);
            self.setLegendColor(th, exYear, exMonth, exDay);
            th.addClass('alternate prev-month').html('<span aria-hidden="true">' + exDay + '</span>');
          }

          if (i >= leadDays && dayCnt <= thisMonthDays) {
            th.html('<span aria-hidden="true">' + dayCnt + '</span>');

            //Add Selected Class to Selected Date
            if (self.isIslamic) {
              if (year === elementDate[0] && month === elementDate[1] && dayCnt === elementDate[2]) {
                th.addClass('is-selected').attr('aria-selected', 'true');
              }
            } else {
              var tHours = elementDate.getHours(),
                tMinutes = elementDate.getMinutes(),
                tSeconds = self.isSeconds ? elementDate.getSeconds() : 0;

              if ((new Date(year, month, dayCnt)).setHours(tHours, tMinutes, tSeconds,0) === elementDate.setHours(tHours, tMinutes, tSeconds, 0)) {
                th.addClass('is-selected').attr('aria-selected', 'true');
              }
            }

            if (dayCnt === self.todayDay && self.currentMonth === self.todayMonth &&
              self.currentYear === self.todayYear) {
              th.addClass('is-today');
            }

            th.attr('aria-label', Locale.formatDate(new Date(self.currentYear, self.currentMonth, dayCnt), {date: 'full'}));

            self.setDisabled(th, year, month, dayCnt);
            self.setLegendColor(th, year, month, dayCnt);

            th.attr('role', 'link');
            dayCnt++;
            return;
          }

          if (dayCnt >= thisMonthDays + 1) {
            exDay = nextMonthDayCnt;
            exMonth = (month === 11) ? 0 : month + 1;
            exYear = (month === 11) ? year + 1 : year;

            self.setDisabled(th, exYear, exMonth, exDay);
            self.setLegendColor(th, exYear, exMonth, exDay);

            th.addClass('alternate next-month').html('<span aria-hidden="true">' + nextMonthDayCnt + '</span>');
            nextMonthDayCnt++;
          }

        });

        //Hide 6th Row if all disabled
        var row = this.days.find('tr').eq(5);
        if (row.find('td.alternate').length === 7) {
          row.hide();
        } else {
          row.show();
        }

        //Add Legend
        self.addLegend();
      },

      // Put the date in the field and select on the calendar
      insertDate: function (date, isReset) {
        var month = (date instanceof Array ? date[1] : date.getMonth()),
            year  = (date instanceof Array ? date[0] : date.getFullYear()),
            day = (date instanceof Array ? date[2] : date.getDate()).toString();

        // Make sure Calendar is showing that month
        if (this.currentMonth !== month || this.currentYear !== year) {
          this.showMonth(month, year);
        }

        if (!this.isOpen()) {
          return;
        }

        // Show the Date in the UI
        var dateTd = this.days.find('td:not(.alternate)').filter(function() {
          return $(this).text().toLowerCase() === day;
        });

        if (dateTd.hasClass('is-disabled')) {
          this.activeTabindex(dateTd, true);
        } else {
          if (this.settings.showTime) {
            if (isReset) {
              this.time = this.getTimeString(date, this.show24Hours);

              if (this.settings.roundToInterval) {
                $('#timepicker-minutes').val('');
                date = this.setTime(date);
              }
            }
            else {
              date = this.setTime(date);
            }
          }

          this.setValue(date, true);
          this.days.find('.is-selected').removeClass('is-selected').removeAttr('aria-selected').removeAttr('tabindex');
          dateTd.addClass('is-selected').attr({'aria-selected': true});
          this.activeTabindex(dateTd, true);
        }
      },

      // Convert a string to boolean
      getBoolean: function(val) {
        var num = +val;
        return !isNaN(num) ? !!num : !!String(val).toLowerCase().replace(!!0, '');
      },

      // Find the day of the week of the first of a given month
      firstDayOfMonth: function (year, month) {

        if (this.isIslamic) {
		      var firstDay = this.conversions.toGregorian(year, month, 1);
			    return (firstDay === null ? 1 : firstDay.getDay());
        }
        return  (new Date(year, month, 1)).getDay();
      },

      islamicYearIndex: function (islamicYear) {
        var yearIdx = islamicYear - 1318;
        if (yearIdx < 0 || yearIdx >= this.conversions.yearInfo.length) {
          return 0; // for an out-of-range year, simply returns 0
        } else {
          return yearIdx;
        }
      },

      // Find the date of the Month (29, 30, 31 ect)
      daysInMonth: function (year, month) {

        if (this.isIslamic) {
		      var monthLengthBitmap = this.conversions.yearInfo[this.islamicYearIndex(year)][0];
    			var monthDayCount = 0;
    			for (var M = 0; M <= month; M++) {
    				monthDayCount = 29 + (monthLengthBitmap & 1);
    				if (M === month) {
    					return monthDayCount;
    				}
    				monthLengthBitmap = monthLengthBitmap >> 1;
    			}
    			return 0;
        }
        return  (new Date(year, month, 0)).getDate();
      },

      // Set the Formatted value in the input
      setValue: function(date, trigger) {
        //TODO Document this as the way to get the date
        this.currentDate = date;

        if (date instanceof Array) {
          this.currentIslamicDate = date;
          this.currentDate = this.conversions.toGregorian(date[0], date[1], date[2]);
          date = new Date(date[0], date[1], date[2]);
        }

        this.element.val(Locale.formatDate(date, {pattern: this.pattern}));

        if (trigger) {
          this.element.trigger('change').trigger('input');
        }

      },

      //Get the value from the field and set the internal variables or use current date
      setValueFromField: function() {
        var fieldValue = this.element.val(),
          gregorianValue = fieldValue;

        if (this.isIslamic && fieldValue) {
          var islamicValue = Locale.parseDate(this.element.val(), this.pattern);
          gregorianValue = this.conversions.toGregorian(islamicValue.getFullYear(), islamicValue.getMonth(),  islamicValue.getDate());
        }

        this.currentDate = gregorianValue || new Date();
        if (typeof this.currentDate === 'string') {
          this.currentDate = Locale.parseDate(this.currentDate, this.pattern, false);
        }
        this.currentDate = this.currentDate || new Date();
        this.currentMonth = this.currentDate.getMonth();
        this.currentYear = this.currentDate.getFullYear();
        this.currentDay = this.currentDate.getDate();

        if (this.isIslamic) {
          this.currentDateIslamic = this.conversions.fromGregorian(this.currentDate);
          this.currentYear = this.currentDateIslamic[0];
          this.currentMonth = this.currentDateIslamic[1];
          this.currentDay = this.currentDateIslamic[2];
        }
      },

      // Make input enabled
      enable: function() {
        this.element.removeAttr('disabled readonly').closest('.field').removeClass('is-disabled');
      },

      // Make input disabled
      disable: function() {
        this.enable();
        this.element.attr('disabled', 'disabled').closest('.field').addClass('is-disabled');
      },

      // Make input readonly
      readonly: function() {
        this.enable();
        this.element.attr('readonly', 'readonly');
      },

      // Set today
      setToday: function() {
        this.currentDate = new Date();

        if (this.isIslamic) {
          this.currentDateIslamic = this.conversions.fromGregorian(this.currentDate);
        }

        if (this.isOpen()) {
          this.insertDate(this.isIslamic ? this.currentDateIslamic : this.currentDate, true);
        } else {
          this.element.val(Locale.formatDate(this.currentDate, {pattern: this.pattern})).trigger('change').trigger('input');
        }

      },

      // Set time
      setTime: function(date) {
        var hours = $('#timepicker-hours').val(),
          minutes = $('#timepicker-minutes').val(),
          seconds = this.isSeconds ? $('#timepicker-seconds').val() : 0,
          period = $('#timepicker-period');


        hours = (period.length && period.val() === 'PM' && hours < 12) ? (parseInt(hours, 10) + 12) : hours;
        hours = (period.length && period.val() === 'AM' && parseInt(hours, 10) === 12) ? 0 : hours;

        date.setHours(hours, minutes, seconds);
        return date;
      },

      // Get Time String
      getTimeString: function (date, isHours24) {
        var twodigit = function (number) {
            return (number < 10 ? '0' : '') + number;
          },
          d = (date || new Date()),
          h = d.getHours(),
          m = twodigit(d.getMinutes()),
          s = twodigit(d.getSeconds()),
          h12 = (h % 12 || 12) +':'+ m + (this.isSeconds ? ':'+ s : '') +' ' + (h < 12 ? 'AM' : 'PM'),
          h24 = h + ':' + m + (this.isSeconds ? ':'+ s : '');

        return isHours24 ? h24 : h12;
      },

      // Change the order for execution jquery events were bound
      // http://stackoverflow.com/questions/2360655/jquery-event-handlers-always-execute-in-order-they-were-bound-any-way-around-t
      changeEventOrder: function (elements, names, newIndex) {
        // Allow for multiple events.
        $.each(names.split(' '), function (idx, name) {
          elements.each(function () {
            var handlers = $._data(this, 'events')[name.split('.')[0]];
            // Validate requested position.
            newIndex = Math.min(newIndex, handlers.length - 1);
            handlers.splice(newIndex, 0, handlers.pop());
          });
        });
      },

      // Set focus on (opt: next|prev) focusable element
      setFocusOnFocusableElement: function(element, opt) {
        var canfocus = $(':focusable'),
          index = canfocus.index(element);

        index = (opt === 'next') ?
          ((index+1) >= canfocus.length ? 0 : (index+1)) :
          ((index-1) < 0 ? canfocus.length : (index-1));

        canfocus.eq(index).focus();
      },

      updated: function() {
        return this
          .teardown()
          .init();
      },

      teardown: function() {
        if (this.isOpen()) {
          this.closeCalendar();
        }

        this.trigger.remove();
        this.element.attr('data-mask', '');

        if (this.calendar && this.calendar.length) {
          this.calendar.remove();
        }

        if (this.popup && this.popup.length) {
          this.popup.remove();
        }

        var api = this.element.data('mask');
        if (api) {
          api.destroy();
        }

        this.element.off('keydown.datepicker blur.validate change.validate keyup.validate focus.validate');

        return this;
      },

      destroy: function() {
        this.teardown();
        $.removeData(this.element[0], pluginName);
      }
    };

    // Initialize the plugin (Once)
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (instance) {
        instance.settings = $.extend({}, instance.settings, options);
        instance.updated();
      } else {
        instance = $.data(this, pluginName, new DatePicker(this, settings));
      }
    });
  };


window.Formatters = {

  Text: function(row, cell, value) {
    var str = ((value === null || value === undefined || value === '') ? '' : value.toString());
    return str;
  },

  Input: function(row, cell, value, col) {
    if (col.inlineEditor) {
      var html = '<label for="datagrid-inline-input-' + row + '-' + cell +'" class="audible">'+ col.name +'</label>'+
          '<input id="datagrid-inline-input-' + row + '-' + cell +'" class="'+ (col.align === 'right' ? 'is-number-mask': '') + '" value="'+ value +'">';

      return html;
    }

    var str = ((value === null || value === undefined || value === '') ? '' : value.toString());
    return str;
  },

  Ellipsis: function(row, cell, value, col) {
    var str = ((value === null || value === undefined || value === '') ? '' : value.toString());
    col.textOverflow = 'ellipsis';
    return str;
  },

  Password: function(row, cell, value) {
    var str = ((value === null || value === undefined || value === '') ? '' : value.toString());
    return str.replace(/./g, '*');
  },

  Readonly: function(row, cell, value) {
    return '<span class="is-readonly">' + ((value === null || value === undefined) ? '' : value) + '</span>';
  },

  Date: function(row, cell, value, col, isReturnValue) {
    var formatted = ((value === null || value === undefined) ? '' : value),
      value2;

    if (typeof value === 'string' && value) {

      if (value === '0000' || value === '000000' || value === '00000000') { //Means no date in some applications
        return '';
      }

      if (!col.sourceFormat) {
        value2 = Locale.parseDate(value, (typeof col.dateFormat === 'string' ? {pattern: col.dateFormat}: col.dateFormat));
      } else {
        value2 = Locale.parseDate(value, (typeof col.sourceFormat === 'string' ? {pattern: col.sourceFormat}: col.sourceFormat));
      }

      if (value2) {
        formatted = Locale.formatDate(value2, (typeof col.dateFormat === 'string' ? {pattern: col.dateFormat}: col.dateFormat));
      } else {
        formatted = Locale.formatDate(value, (typeof col.dateFormat === 'string' ? {pattern: col.dateFormat}: col.dateFormat));

        if (formatted === 'NaN/NaN/NaN') { //show invalid dates not NA/NA/NA
          formatted = value;
        }

      }
    } else if (value) {
      formatted = Locale.formatDate(value, (typeof col.dateFormat === 'string' ? {pattern: col.dateFormat}: col.dateFormat));
    }

    if (!col.editor || isReturnValue === true) {
      return formatted;
    }
    return '<span class="trigger">' + formatted + '</span>' + $.createIcon({ icon: 'calendar', classes: ['icon-calendar'] });
  },

  Time: function(row, cell, value, col) {
    var formatted = ((value === null || value === undefined) ? '' : value),
      localeDateFormat = ((typeof Locale === 'object' && Locale.calendar().dateFormat) ? Locale.calendar().dateFormat.short : null),
      localeTimeFormat = ((typeof Locale === 'object' && Locale.calendar().timeFormat) ? Locale.calendar().timeFormat : null),
      value2;

    var parseTime = function (timeString) {
      if (timeString === '') {
        return null;
      }
      var time = timeString.match(/(\d+)(?::(\d\d))(?::(\d\d))?\s*([pP]?)/i);
      if (time === null) {
        return null;
      }
      var d = new Date();
      d.setHours(parseInt(time[1]) + (time[4] ? 12 : 0));
      d.setMinutes(parseInt(time[2]) || 0);
      d.setSeconds(parseInt(time[3]) || 0);
      return d;
    };

    if (typeof value === 'string' && value) {
      value2 = Locale.formatDate(parseTime(value), { pattern: (localeDateFormat +' '+ (col.sourceFormat || col.timeFormat || localeTimeFormat)) });

      if (value2) {
        formatted = value2.slice(value2.indexOf(' '));
      }
    }

    // Remove extra space in begining
    formatted = formatted.replace(/^\s/, '');

    if (!col.editor) {
      return formatted;
    }
    return '<span class="trigger">' + formatted + '</span>' + $.createIcon({ icon: 'clock', classes: ['icon-clock'] });

  },

  Autocomplete: function(row, cell, value) {
    var formatted = ((value === null || value === undefined) ? '' : value);
    return formatted;
  },

  Lookup: function(row, cell, value, col, item) {
    var formatted = ((value === null || value === undefined) ? '' : value);

    if (!col.editor) {
      return formatted;
    }

    if (col.editorOptions && typeof col.editorOptions.field === 'function') {
      formatted = col.editorOptions.field(item, null, null);
    }

    return '<span class="trigger">' + formatted + '</span>' + $.createIcon({ icon: 'search-list', classes: ['icon-search-list'] });
  },

  Decimal:  function(row, cell, value, col) {
    var formatted = value;
    if (typeof Locale !== undefined &&
        formatted !== null && formatted !== undefined && formatted !== '') {
       formatted = Locale.formatNumber(+value, col.numberFormat);
    }
    return ((formatted === null || formatted === undefined) ? '' : formatted);
  },

  Integer:  function(row, cell, value, col) {
    var formatted = value;
    if (typeof Locale !== undefined &&
        formatted !== null && formatted !== undefined && formatted !== '') {
      formatted = Locale.formatNumber(+value, col.numberFormat || {style: 'integer'});
    }
    return (formatted === null || formatted === undefined) ? '' : formatted;
  },

  Hyperlink: function(row, cell, value, col, item, api) {
    var textValue,
      colHref = col.href || '#';

    //Support for dynamic links based on content
    if (col.href && typeof col.href === 'function') {
      colHref = col.href(row, cell, item, col);
      //Passing a null href will produce "just text" with no link
      if (colHref == null) {
        return col.text || value;
      }
    } else  {
      colHref = colHref.replace('{{value}}', value);
    }

    textValue = col.text || value;
    if (!textValue && !col.icon) {
      return '';
    }

    return col.icon ?
      ('<a href="'+ colHref +'" class="btn-icon row-btn '+ (col.cssClass || '') +'" ' + (!api.settings.rowNavigation ? '' : 'tabindex="-1"') + (col.hyperlinkTooltip ? ' title="'+ col.hyperlinkTooltip + '"': '') + '>'+
          $.createIcon({ icon: col.icon, file: col.iconFile }) +
          '<span class="audible">'+ textValue +'</span>'+
        '</a>') :
      ('<a href="'+ colHref +'" ' + (!api.settings.rowNavigation ? '' : 'tabindex="-1"') + ' role="presentation" class="hyperlink '+ (col.cssClass || '') + '"' + (col.target ? ' target="' + col.target + '"' : '') + (col.hyperlinkTooltip ? ' title="'+ col.hyperlinkTooltip + '"': '') + '>'+ textValue +'</a>');
  },

  Template: function(row, cell, value, col, item) {
    var tmpl = col.template,
      renderedTmpl = '';

    if (Tmpl && item && tmpl) {
      var compiledTmpl = Tmpl.compile('{{#dataset}}'+tmpl+'{{/dataset}}');
      renderedTmpl = compiledTmpl.render({dataset: item});
    }

    return renderedTmpl;
  },

  Drilldown: function () {
    var text = Locale.translate('Drilldown');

    if (text === undefined) {
      text = '';
    }

    return (
      '<button type="button" tabindex="-1" class="btn-icon small datagrid-drilldown">' +
         $.createIcon({icon: 'drilldown'}) +
        '<span>' + text + '</span>' +
      '</button>'
    );
  },

  RowReorder: function () {
    var text = Locale.translate('ReorderRows');

    if (text === undefined) {
      text = 'Reorder Rows';
    }

    return (
      '<div class="datagrid-reorder-icon">' +
         $.createIcon({icon: 'drag'}) +
        '<span class="audible">' + text + '</span>' +
      '</div>'
    );
  },

  Checkbox: function (row, cell, value, col, item, api) {
    var isChecked;

    // Use isChecked function if exists
    if (col.isChecked) {
      isChecked = col.isChecked(value);
    } else {
      //treat 1, true or '1' as checked
      isChecked = (value == undefined ? false : value == true); // jshint ignore:line
    }

    var animate = api.wasJustUpdated;
    api.wasJustUpdated = false;
    return '<div class="datagrid-checkbox-wrapper"><span role="checkbox" aria-label="'+ col.name +'" class="datagrid-checkbox ' +
     (isChecked ? 'is-checked ' + (!animate ? ' no-animation' : ' ') : '') +'" aria-checked="'+isChecked+'"></span></div>';
  },

  SelectionCheckbox: function (row, cell, value, col) {
    var isChecked = (value==undefined ? false : value == true); // jshint ignore:line
    return '<div class="datagrid-checkbox-wrapper"><span role="checkbox" aria-label="'+ col.name +'" class="datagrid-checkbox datagrid-selection-checkbox' +
     (isChecked ? 'is-checked' : '') +'" aria-checked="'+isChecked+'"></span></div>';
  },

  Actions: function (row, cell, value, col) {
    //Render an Action Formatter
    return (
      '<button type="button" class="btn-actions" aria-haspopup="true" aria-expanded="false" aria-owns="'+ col.menuId +'">' +
        '<span class="audible">'+ col.title +'</span>' +
        $.createIcon({ icon: 'more' }) +
      '</button>'
    );
  },

  // Multi Line TextArea
  Textarea: function (row, cell, value) {
    var formatted = ((value === null || value === undefined) ? '' : value);
    return '<span class="datagrid-multiline-text">'+ formatted + '</span>';
  },

  // Rich Text Editor
  Editor: function (row, cell, value, col) {
    var formatted = ((value === null || value === undefined) ? '' : value),
      classes = 'is-editor';
    classes += col.singleline ? '' : ' datagrid-multiline-text';
    classes += col.contentTooltip ? ' content-tooltip' : '';
    return '<div class="'+ classes +'">'+ $.unescapeHTML(formatted) +'</div>';
  },

  // Expand / Collapse Button
  Expander: function (row, cell, value) {
    var button = '<button type="button" aria-label="' + Locale.translate('ExpandCollapse') + '" class="btn-icon datagrid-expand-btn" tabindex="-1">'+
      '<span class="icon plus-minus"></span>' +
      '</button>' + ( value ? '<span> ' + value + '</span>' : '');

    return button;
  },

  // Datagrid Group Row
  GroupRow: function (row, cell, value, col, item, api) {
    var groupSettings = api.settings.groupable,
      groups = '',
      isOpen = groupSettings.expanded === undefined ? true : groupSettings.expanded;

    if (groupSettings.expanded && typeof groupSettings.expanded === 'function') {
      isOpen = groupSettings.expanded(row, cell, value, col, item, api);
    }

    for (var i = 0; i < groupSettings.fields.length ; i++) {
      groups += item[groupSettings.fields[i]] + (i === 0 ? '' : ',');
    }

    if (groupSettings.groupRowFormatter) {
      groups = groupSettings.groupRowFormatter(row, cell, value, col, item, api);
    }

    var button = '<button type="button" class="btn-icon datagrid-expand-btn'+ (isOpen ? ' is-expanded' : '') +'" tabindex="-1"' +'>'+
    '<span class="icon plus-minus'+ (isOpen ? ' active' : '') +'"></span>' +
    '<span class="audible">'+ Locale.translate('ExpandCollapse') +'</span>' +
    '</button>'+ '<span> '+ groups +'</span>';

    return button;
  },

  GroupFooterRow: function (row, cell, value, col, item, api) {
    var groupSettings = api.settings.groupable,
      isOpen = groupSettings.expanded === undefined ? true : groupSettings.expanded;

    if (groupSettings.expanded && typeof groupSettings.expanded === 'function') {
      isOpen = groupSettings.expanded(row, cell, value, col, item, api);
    }

    var idx = api.columnIdxById(groupSettings.aggregate),
        html = '<td role="gridcell" colspan=' + (idx) + '><div class="datagrid-cell-wrapper"></div></td><td role="gridcell"><div class="datagrid-cell-wrapper"> '+ item.sum +'</div></td>';

    if (groupSettings.groupFooterRowFormatter) {
      html = groupSettings.groupFooterRowFormatter(idx, row, cell, value, col, item, api);
    }

    return html;
  },

  SummaryRow: function (row, cell, value, col) {
    var afterText = '',
        beforeText = col.summaryText ||  '<b class="datagrid-summary-totals">' + Locale.translate('Total') + ' </b>';

    if (col.summaryTextPlacement === 'after') {
      afterText = beforeText;
      beforeText = '';
    }

    if (typeof Locale !== undefined && col.numberFormat &&
      value !== null && value !== undefined && value !== '') {
        value = Locale.formatNumber(+value, col.numberFormat);
    }

    return (beforeText + ((value === null || value === undefined || value === '') ? '' : value.toString()) + afterText);
  },

  // Tree Expand / Collapse Button and Paddings
  Tree: function (row, cell, value, col, item, api) {
    var isOpen = item.expanded,
      depth = api.settings.treeDepth[row].depth,
      button = '<button type="button" class="btn-icon datagrid-expand-btn'+ (isOpen ? ' is-expanded' : '') +'" tabindex="-1"'+ (depth ? ' style="margin-left: '+ (depth ? (30* (depth -1)) +'px' : '') +'"' : '') +'>'+
      '<span class="icon plus-minus'+ (isOpen ? ' active' : '') +'"></span>' +
      '<span class="audible">'+ Locale.translate('ExpandCollapse') +'</span>' +
      '</button>'+ ( value ? '<span> '+ value +'</span>' : ''),
      node = '<span class="datagrid-tree-node"'+ (depth ? ' style="margin-left: '+ (depth ? (30* (depth-1)) +'px' : '') +'"' : '') +'> '+ value +'</span>';

    return (item[col.children ? col.children : 'children'] ? button : node);
  },

  // Badge / Tags and Visual Indictors
  ClassRange: function (row, cell, value, col) {
    var ranges = col.ranges,
      classes = '', text='';

    if (!ranges) {
      return {};
    }

    for (var i = 0; i < ranges.length; i++) {
      if (value >= ranges[i].min && value <= ranges[i].max) {
        classes = ranges[i].classes;
        text = (ranges[i].text ? ranges[i].text : classes.split(' ')[0]);
      }

      if (value === ranges[i].value) {
        classes = ranges[i].classes;
        text = (ranges[i].text ? ranges[i].text : value);
      }
    }

    return {'classes': classes, 'text': text};
  },

  // Badge (Visual Indictors)
  Badge: function (row, cell, value, col) {
    var colorClasses = col.color,
      text = col.name;

    if (col.ranges) {
      var ranges = Formatters.ClassRange(row, cell, value, col);
      colorClasses = ranges.classes;
      text = ranges.text;
    }
    return '<span class="badge ' + colorClasses +'">' + value +' <span class="audible">'+ text+ '</span></span>';
  },

  Tag: function (row, cell, value, col) {
    var ranges = Formatters.ClassRange(row, cell, value, col);
    return '<span class="tag ' + ranges.classes +'">'+ value + '</span>';
  },

  Alert: function (row, cell, value, col) {
    var ranges = Formatters.ClassRange(row, cell, value, col);
    var icon = $.createIcon({
      icon: ranges.classes, classes: [
        'icon',
        'datagrid-alert-icon',
        'icon-' + ranges.classes
      ]
    });
    return icon + '<span class="datagrid-alert-text">' + (ranges.text === 'value' ? value : ranges.text) + '</span>';
  },

  Image: function (row, cell, value, col) {

    return '<img class="datagrid-img"' + ' src="' + value +'" alt= "' + (col.alt ? col.alt : Locale.translate('Image')) +
     '"' + (col.dimensions ? ' style="height:'+col.dimensions.height+';width:'+col.dimensions.height+'"' : '') + '/>';
  },

  Color: function (row, cell, value, col) {
    var ranges = Formatters.ClassRange(row, cell, value, col),
      text = ((value === null || value === undefined || value === '') ? '' : value.toString());

    return '<span class="' + ranges.classes + '">' + text + '</span>';
  },

  Button: function (row, cell, value, col, item, api) {
    var text = col.text ? col.text : ((value === null || value === undefined || value === '') ? '' : value.toString()),
      markup ='<button type="button" class="'+ ( col.icon ? 'btn-icon': 'btn-secondary') + ' row-btn ' + (col.cssClass ? col.cssClass : '') + '"' + (!api.settings.rowNavigation ? '' : ' tabindex="-1"') +' >';

      if (col.icon) {
        markup += $.createIcon({ icon: col.icon, file: col.iconFile });
      }
      markup += '<span>' + text + '</span></button>';

    return markup;
  },

  Dropdown: function (row, cell, value, col) {
    var formattedValue = value, compareValue, i, option, optionValue;

    if (col.options && value !== undefined) {
      compareValue = col.caseInsensitive && typeof value === 'string' ? value.toLowerCase() : value;

      for (i = 0; i < col.options.length; i++) {
        option = col.options[i];
        optionValue = col.caseInsensitive && typeof option.value === 'string' ? option.value.toLowerCase() : option.value;

        if (optionValue === compareValue) {
          formattedValue = option.label;
          break;
        }
      }
    }

    var html = '<span class="trigger dropdown-trigger">' + formattedValue + '</span>' + $.createIcon({ icon: 'dropdown' });

    if (col.inlineEditor) {
      html = '<label for="full-dropdown" class="audible">'+ col.name +'</label>'+
        '<select id="'+ 'datagrid-dropdown' + row +'" class="dropdown">';

      for (i = 0; i < col.options.length; i++) {
        var opt = col.options[i];
        html += '<option' + (opt.id === undefined ? '' : ' id="' + opt.id + '"') +
                  ' value="' + opt.value + '"' +
                  (opt.selected || opt.value === compareValue ? ' selected ' : '') +
                '>'+ (opt.label !== undefined ? opt.label : opt.value !== undefined ? opt.value : '') + '</option>';
      }

      html += '</select>'+
      '<div class="dropdown-wrapper is-inline">'+
        '<div class="dropdown"><span>'+ formattedValue +'</span></div>'+
        '<svg class="icon" focusable="false" aria-hidden="true" role="presentation">'+
          '<use xlink:href="#icon-dropdown"></use>'+
        '</svg>'+
      '</div>';
    }

    return html;
  },

  Spinbox: function (row, cell, value, col) {
    var html = ((value === null || value === undefined || value === '') ? '' : value.toString());

    if (col.inlineEditor) {
      html = '<label for="spinbox-' + cell + '" class="audible">Quantity</label>' +
        '<span class="spinbox-wrapper"><span class="spinbox-control down">-</span>' +
        '<input id="spinbox-' + cell + '" name="spinbox-' + cell + '" type="text" class="spinbox" value="'+ value +'">'+
        '<span class="spinbox-control up">+</span></span>';
    }

    return html;
  },

  Favorite: function (row, cell, value, col, item, api) {
    var isChecked;

    // Use isChecked function if exists
    if (col.isChecked) {
      isChecked = col.isChecked(value);
    } else {
      isChecked = (value == undefined ? false : value == true); // jshint ignore:line
    }

    var isEditable = col.editor && api.settings.editable;

    if (isChecked) {
      return '<span aria-label="'+ Locale.translate('Favorite') +'" class="icon-favorite'+ (isEditable ? ' is-editable': '') + '">' + $.createIcon({ icon: 'star-filled' }) + '</span>';
    } else {
      return col.showEmpty ? '<span aria-label="'+ Locale.translate('Favorite') +'" class="icon-favorite'+ (isEditable ? ' is-editable': '') + '">' + $.createIcon({ icon: 'star-outlined' }) + '</span>' : '';
    }
  },

  Status: function (row, cell, value, col, item) {

    if (!item.rowStatus) {
      return '<span></span>';
    }

    return $.createIcon({ icon: item.rowStatus.icon, classes: ['icon', 'icon-' + item.rowStatus.icon, 'datagrid-alert-icon'] }) + '<span class="audible">' + item.rowStatus.text + '</span>';
  },

  TargetedAchievement: function (row, cell, value, col) {
    var perc = (100*value),
      ranges = Formatters.ClassRange(row, cell, perc, col),
      target = col.target;

    var isWhite = perc > 55;  //Maybe implement this later perc > 60;
    return '<div class="total bar chart-completion-target chart-targeted-achievement"><div class="target remaining bar" style="width: '+ (target || 0) +'%;"></div><div class="completed bar ' + (col.ranges && ranges.classes ? ranges.classes : 'primary') + '" style="width: '+ perc +'%;"></div>' + (col.showPercentText ? '<div class="chart-targeted-text" '+ (isWhite ? 'style="color: white"' : '') +'>'+ perc +'%</div></div>' : '');
  },
  // TODO Possible future Formatters
    // Image?
  // Multi Select
  // Sparkline
  // Progress Indicator (n of 100%)
  // Process Indicator
  // Currency
  // File Upload (Simple)
  // Menu Button
  // Color Picker (Low)
};

window.Editors = {

  //Supports, Text, Numeric, Integer via mask
  Input: function(row, cell, value, container, column, e, api, item) {

    this.name = 'input';
    this.originalValue = value;
    this.useValue = column.inlineEditor ? true : false;

    this.init = function () {
      if (column.inlineEditor) {
        this.input = container.find('input');
      } else {
        this.input = $('<input type="'+ (column.inputType || 'text') +'"/>')
          .appendTo(container);
      }

      if (column.align) {
        this.input.addClass('l-'+ column.align +'-text');
      }

      if (column.maxLength) {
        this.input.attr('maxlength', column.maxLength);
      }

      if (column.mask && typeof column.mask === 'function') {
        var mask = column.mask(row, cell, value, column, item);
        this.input.mask({pattern: mask, mode: column.maskMode});
      } else if (column.mask) {
        this.input.mask({pattern: column.mask, mode: column.maskMode});
      }
    };

    this.val = function (value) {
      var thisValue;
      if (value) {
        this.input.val(value);
      }
      if (column && column.numberFormat && column.numberFormat.style === 'percent') {
        thisValue = this.input.val().trim().replace(/(\s%?|%)$/g, '');
        return Locale.parseNumber(thisValue) / 100;
      }
      return this.input.val();
    };

    this.focus = function () {
      this.input.focus().select();
    };

    this.destroy = function () {
      if (column.inlineEditor) {
        return;
      }

      var self = this;
      setTimeout(function() {
        self.input.remove();
      }, 0);
    };

    this.init();
  },

  Textarea: function(row, cell, value, container, column) {

    this.name = 'textarea';
    this.originalValue = value;

    this.init = function () {
      this.input = $('<textarea class="textarea"></textarea>').appendTo(container);

      if (column.maxLength) {
        this.input.attr('maxlength', column.maxLength);
      }

    };

    this.val = function (value) {
      if (value) {
        //note that focus will help move text to end of input.
        this.input.focus().val(value);
      }
      return this.input.val();
    };

    this.focus = function () {
      this.input.focus();
    };

    this.destroy = function () {
      var self = this;
      setTimeout(function() {
        self.input.remove();
      }, 0);
    };

    this.init();
  },

  // Rich Text Editor
  Editor: function(row, cell, value, container, column, e, api) {
    this.name = 'editor';
    this.originalValue = value;

    this.init = function () {
      var self = this,
        // Editor options
        editorOptions = $.extend({}, {
          buttons: { editor: ['bold','italic','underline','strikethrough','separator', 'foreColor'], source: [] },
          excludeButtons: { editor: [] }
        }, column.editorOptions);

      // Editor width
      this.editorWidth = api.setUnit(editorOptions.width || container.outerWidth());
      delete editorOptions.width;

      container.append(
        '<div class="editor-wrapper" style="width:'+ this.editorWidth +';">'+
          '<div class="editor" data-init="false">'+ $.unescapeHTML(value) +'</div>'+
        '</div>');
      this.td = container.closest('td');
      this.input = $('.editor', container);

      this.input
        .popover({
          content: $('.editor-wrapper', container),
          placementOpts: {
            x: 0,
            y: '-'+ (parseInt(container[0].style.height, 10) + 35),
            parent: this.td,
            parentXAlignment: Locale.isRTL() ? 'right' : 'left',
            strategies: ['flip', 'nudge', 'shrink'],
          },
          placement : 'bottom',
          popover: true,
          trigger: 'immediate',
          tooltipElement: '#editor-popup',
          extraClass: 'editor-popup'
        })
        .editor(editorOptions)
        .on('hide.editor', function () {
          api.commitCellEdit(self.input);
        })
        .on('keydown.editor', function (e) {
          var key = e.which || e.keyCode || e.charCode || 0;
          // Ctrl + Enter (Some browser return keyCode: 10, not 13)
          if ((e.ctrlKey || e.metaKey) && (key === 13 || key === 10)) {
            var apiPopover = self.input.data('tooltip');
            if (apiPopover) {
              apiPopover.hide();
              api.setNextActiveCell(e);
            }
          }
        });
      Soho.utils.fixSVGIcons($('#editor-popup'));
    };

    this.val = function () {
      return this.input.html();
    };

    this.focus = function () {
      var self = this;
      setTimeout(function() {
        self.input.focus();
      }, 0);
    };

    this.destroy = function () {
      var self = this;
      container.removeAttr('style');
      api.quickEditMode = false;
      self.input.off('hide.editor keydown.editor');
      setTimeout(function() {
        self.input.remove();
        // Reset tooltip
        var elem = self.td.find('.is-editor.content-tooltip');
        api.setupContentTooltip(elem, self.editorWidth);
      }, 0);
    };

    this.init();
  },

  Checkbox: function(row, cell, value, container, column, event, grid) {

    this.name = 'checkbox';
    this.originalValue = value;

    this.init = function () {

      this.input = $('<input type="checkbox" class="checkbox"/>').appendTo(container);
      this.input.after('<label class="checkbox-label"></label>');

      if (column.align) {
        this.input.addClass('l-'+ column.align +'-text');
      }

    };

    this.val = function (value) {
      var isChecked;

      if (value === undefined) {
        return this.input.prop('checked');
      }

      // Use isChecked function if exists
      if (column.isChecked) {
        isChecked = column.isChecked(value);
      } else {
        isChecked = value;
      }

      //just toggle it if we click right on it
      if ((event.type === 'click' || (event.type === 'keydown' && event.keyCode === 32)) && !$(event.target).is('.datagrid-checkbox-wrapper, .datagrid-cell-wrapper')) {
        isChecked = !isChecked;
        grid.setNextActiveCell(event);
      }

      this.input.prop('checked', isChecked);
    };

    this.focus = function () {
      this.input.trigger('focusout');
    };

    this.destroy = function () {
      var self = this;
      setTimeout(function() {
        self.input.next('.checkbox-label').remove();
        self.input.remove();
      }, 0);
    };

    this.init();
  },

  Dropdown: function(row, cell, value, container, column, event, grid, rowData) {

    this.name = 'dropdown';
    this.originalValue = value;
    this.useValue = true; //use the data set value not cell value
    this.cell = grid.activeCell;

    this.init = function () {
      if (column.inlineEditor) {
        this.input = container.find('select');
        return;
      }

      this.input = $('<select class="dropdown"></select>').appendTo(container);

      if (column.options) {
        var html, opt, optionValue;
        value = grid.fieldValue(rowData,column.field);

        var compareValue = column.caseInsensitive && typeof value === 'string' ? value.toLowerCase() : value;

        for (var i = 0; i < column.options.length; i++) {
          html = $('<option></<option>');
          opt = column.options[i];
          optionValue = column.caseInsensitive && typeof opt.value === 'string' ? opt.value.toLowerCase() : opt.value;

          if (opt.selected || compareValue === optionValue) {
            html.attr('selected', 'true');
            this.originalValue = optionValue;
          }

          html.attr('value', opt.value).attr('id', opt.id).attr('data-type', typeof opt.value);
          html.text(opt.label);
          this.input.append(html);
        }
      }

      var editorOptions = column.editorOptions || {};

      function hasEditingClass() {
        return editorOptions.cssClass && /is-editing/g.test(editorOptions.cssClass);
      }
      // Add the class to both the options being passed, as well as the column's original options
      if (!hasEditingClass()) {
        editorOptions.cssClass = editorOptions.cssClass || '';
        editorOptions.cssClass += ' is-editing';
      }

      // Append the Dropdown's sourceArguments with some row/col meta-data
      editorOptions.sourceArguments = $.extend({}, editorOptions.sourceArguments, {
        column: column,
        container: container,
        grid: grid,
        cell: cell,
        event: event,
        row: row,
        rowData: rowData,
        value: value
      });

      this.input.dropdown(editorOptions);
    };

    this.val = function (value) {

      if (value !== undefined) {
        var compareValue = column.caseInsensitive && typeof value === 'string' ? value.toLowerCase() : value;
        this.input.val(value);

        this.input.find('option').each(function () {
          var opt = $(this), valueAttr = opt.attr('value'), type = opt.attr('data-type');
          var optionValue = valueAttr;

          // Get option value in proper type before checking equality
          if (type === 'number') {
            optionValue = parseFloat(valueAttr);
          } else if (type === 'boolean') {
            optionValue = valueAttr === 'true';
          } else if (type === 'string' && column.caseInsensitive) {
            optionValue = valueAttr.toLowerCase();
          }

          if (optionValue === compareValue) {
            opt.attr('selected', 'true');
          }
        });
      }

      var selected = this.input.find(':selected'),
        val = selected.attr('value'), dataType = selected.attr('data-type');

      // For non-string option values (number, boolean, etc.), convert string attr value to proper type
      if (dataType === 'number') {
        val = parseFloat(val);
      } else if (dataType === 'boolean') {
        val = val === 'true';
      }

      if (val === undefined) {
        val = selected.text();
      }

      return val;
    };

    this.focus = function () {
      var self = this;

      //Check if isClick or cell touch and just open the list
      this.input.trigger('openlist');
      this.input.parent().find('div.dropdown').focus();

      this.input.off('listclosed').on('listclosed', function (e, type) {
        grid.commitCellEdit(self.input);

        if (type === 'select') {
          container.parent('td').focus();
          return;
        }

        if (type === 'tab') {
          setTimeout(function () {
            container.parent('td').focus();
          }, 100);
        }
      });

    };

    this.destroy = function () {
      //We dont need to destroy since it will when the list is closed
    };

    this.init();
  },

  Date: function(row, cell, value, container, column, event, grid) {

    this.name = 'date';
    this.originalValue = value;

    this.init = function () {
      this.input = $('<input class="datepicker"/>').appendTo(container);
      this.input.datepicker(column.editorOptions || { dateFormat: column.dateFormat });
    };

    this.val = function (value) {
      if (value) {
        //Note that the value should be formatted from the formatter.
        this.input.val(value);
      }
      return window.Formatters.Date(row, cell, this.input.val(), column, true);
    };

    this.focus = function () {
      var self = this;

      this.input.select().focus();

      //Check if isClick or cell touch and just open the list
      if (event.type === 'click' && $(event.target).is('.icon')) {
        this.input.parent().find('.icon').trigger('click');
        this.input.closest('td').addClass('is-focused');
      }

      this.input.on('listclosed', function () {
        self.input.closest('td').removeClass('is-focused');

        setTimeout(function () {
          self.input.trigger('focusout');
          container.parent().focus();
          grid.setNextActiveCell(event);
        }, 1);

      });

    };

    this.destroy = function () {
      var self = this;
      setTimeout(function() {
        grid.quickEditMode = false;
        self.input.remove();
      }, 0);
    };

    this.init();

  },

  Time: function(row, cell, value, container, column, event, grid) {
    this.name = 'time';
    this.originalValue = value;

    this.init = function () {
      this.input = $('<input class="timepicker"/>').appendTo(container);
      this.api = this.input.timepicker(column.editorOptions || '').data('timepicker');
    };

    this.val = function (value) {
      if (value) {
        //Note that the value should be formatted from the formatter.
        this.input.val(value);
      }

      return this.input.val();
    };

    this.focus = function () {
      var self = this;

      this.input.select().focus();

      //Check if isClick or cell touch and just open the list
      if (event.type === 'click' && $(event.target).is('.icon')) {
        this.input.parent().find('.icon').trigger('click');
        this.input.closest('td').addClass('is-focused');
      }

      this.api.trigger.on('hide.editortime', function () {
        self.input.closest('td').removeClass('is-focused');

        setTimeout(function () {
          self.input.trigger('focusout');
          container.parent().focus();
          grid.setNextActiveCell(event);
        }, 1);

      });

    };

    this.destroy = function () {
      var self = this;
      if (self.api && self.api.trigger) {
        self.api.trigger.off('hide.editortime');
      }

      setTimeout(function() {
        grid.quickEditMode = false;
        self.input.remove();
      }, 0);
    };

    this.init();

  },

  Lookup: function(row, cell, value, container, column, event, grid) {
    this.name = 'lookup';
    this.originalValue = value;

    this.init = function () {
      this.input = $('<input class="lookup" data-init="false" />').appendTo(container);

      if (column.maxLength) {
        this.input.attr('maxlength', column.maxLength);
      }

      this.input.lookup(column.editorOptions);
    };

    this.val = function (value) {
      var fieldValue = this.input.val();
      if (fieldValue && fieldValue.indexOf('|') > -1) {
        fieldValue = fieldValue.substr(0, fieldValue.indexOf('|'));
      }
      return value ? this.input.val(value) : fieldValue;
    };

    this.focus = function () {
      var self = this,
        api = self.input.data('lookup'),
        td = self.input.closest('td');

      // Using keyboard
      if (event.type === 'keydown') {
        self.input.select().focus();
        td.on('keydown.editorlookup', function (e) {
          if (e.keyCode === 40 && grid.quickEditMode) {
            e.preventDefault();
            e.stopPropagation();
          }
        });
      }

      //Check if isClick or cell touch and just open the list
      if (event.type === 'click') {
        if ($(event.target).is('svg')) {
          api.openDialog(event);
        } else {
          self.input.select().focus();
          td.on('touchcancel.editorlookup touchend.editorlookup', '.trigger', function() {
            api.openDialog();
          });
        }
      }

      // Update on change from lookup
      self.input.on('change', function () {
        setTimeout(function () {
          container.parent().focus();
          grid.setNextActiveCell(event);
          grid.quickEditMode = false;
        }, 1);
      });

    };

    this.destroy = function () {
      var self = this,
        td = this.input.closest('td');
      setTimeout(function() {
        grid.quickEditMode = false;
        td.off('keydown.editorlookup')
          .find('.trigger').off('touchcancel.editorlookup touchend.editorlookup');
        self.input.remove();
      }, 0);
    };

    this.init();
  },

  Autocomplete: function(ow, cell, value, container, column, event, grid) {
    this.name = 'autocomplete';
    this.originalValue = value;

    this.init = function () {
      this.input = $('<input class="autocomplete datagrid-autocomplete" data-autocomplete="source" />').appendTo(container);

      if (!column.editorOptions) {
        column.editorOptions = {};
      }
      column.editorOptions.width = container.parent().width();
      column.editorOptions.offset = {left: -1, top: (grid.settings.rowHeight ==='medium' ? 1 : 5)};

      if (column.maxLength) {
        this.input.attr('maxlength', column.maxLength);
      }

      this.input.autocomplete(column.editorOptions);
    };

    this.val = function (value) {
      return value ? this.input.val(value) : this.input.val();
    };

    this.focus = function () {
      grid.quickEditMode = true;
      this.input.select().focus();
    };

    this.destroy = function () {
      var self = this;
      setTimeout(function() {
        grid.quickEditMode = false;
        self.input.remove();
      }, 0);
    };

    this.init();
  },

  Spinbox: function(ow, cell, value, container, column, event, grid) {
    this.name = 'spinbox';
    this.originalValue = value;
    this.useValue = true; //use the data set value not cell value

    this.init = function () {
      if (column.inlineEditor) {
        this.input = container.find('input');
        return;
      }

      var markup = '<label for="spinbox-' + cell + '" class="audible">Quantity</label>' +
        '<span class="spinbox-wrapper"><span class="spinbox-control down">-</span>' +
        '<input id="spinbox-' + cell + '" name="spinbox-' + cell + '" type="text" class="spinbox" value="'+ value +'">'+
        '<span class="spinbox-control up">+</span></span>';

      container.append(markup);
      this.input = container.find('input');

      if (!column.editorOptions) {
        column.editorOptions = {};
      }

      this.input.spinbox(column.editorOptions);
    };

    this.val = function (value) {
      return value ? parseInt(this.input.val(value)) : parseInt(this.input.val());
    };

    this.focus = function () {
      grid.quickEditMode = true;
      this.input.select().focus();
    };

    this.destroy = function () {
      if (column.inlineEditor) {
        return;
      }

      var self = this;
      setTimeout(function() {
        grid.quickEditMode = false;
        self.input.remove();
      }, 0);
    };

    this.init();
  },

  Favorite: function(row, cell, value, container, column, event, grid) {
    this.name = 'favorite';
    this.useValue = true;
    this.originalValue = value;

    this.init = function () {
      this.input = $('<span class="icon-favorite">' +
            $.createIcon({ icon: value ? 'star-filled' : 'star-outlined' }) + '<input type="checkbox"></span>').appendTo(container);

      this.input = this.input.find('input');
    };

    this.val = function (value) {
      var isChecked;

      if (value === undefined) {
        return this.input.prop('checked');
      }

      // Use isChecked function if exists
      if (column.isChecked) {
        isChecked = column.isChecked(value);
      } else {
        isChecked = value;
      }

      //just toggle it when clicked
      if ((event.type === 'click' || (event.type === 'keydown' && event.keyCode === 32)) && (!$(event.target).is('.datagrid-cell-wrapper'))) {
        isChecked = !isChecked;
        grid.setNextActiveCell(event);
      }

      this.input.prop('checked', isChecked);
      this.input.find('use').attr('xlink:href', isChecked ? '#icon-star-filled' : '#icon-star-outlined');
    };

    this.focus = function () {
      this.input.trigger('focusout').focus();
    };

    this.destroy = function () {
      var self = this;
      setTimeout(function() {
        self.input.parent().remove();
      }, 0);
    };

    this.init();
  }
};

window.GroupBy = (function() {

  //Can also use in isEquals: function(obj1, obj2)  in datagrid.js
  var equals = window.Soho.utils.equals;

  //See if the object has these proprties or not
  var has = function(obj, target) {
    return obj.some(function(value) {
        return equals(value, target);
    });
  };

  //Return just the object properties matching the names
  var pick = function(obj, names) {
    var chosen = {};
    for (var i = 0; i < names.length; i++) {
      chosen[names[i]] = obj[names[i]];
    }
    return chosen;
  };

  //Return the specific keys from the object
  var keys = function(data, names) {
    return data.reduce(function(memo, item) {
      var key = pick(item, names);

      if (!has(memo, key)) {
        memo.push(key);
      }
      return memo;
    }, []);
  };

  //Look through each value in the list and return an array of all the values
  //that contain all of the key-value pairs listed in properties.
  var where = function (data, names) {
    var chosen = [];

    data.map(function(item) {
      var match = true;
      for (var prop in names) {
        if (names[prop] !== item[prop]) {
          match = false;
          return;
        }
      }
      chosen.push(item);
      return;
    });

    return chosen;
  };

  //Grouping Function with Plugins/Aggregator
  var group = function(data, names) {
    var stems = keys(data, names);

    return stems.map(function(stem) {
      return {
        key: stem,
        values: where(data, stem).map(function(item) {
          return item;
        })
      };
    });
  };

  //Register an aggregator
  group.register = function(name, converter) {
    return group[name] = function(data, names, extra) { // jshint ignore:line
      var that = this;
      that.extra = extra;
      return group(data, names).map(converter, that);
    };
  };

  return group;
}());

//Register built in aggregators
GroupBy.register('sum', function(item) {
  var extra = this.extra;
  return $.extend({}, item.key, {values: item.values}, {sum: item.values.reduce(function(memo, node) {
      return memo + Number(node[extra]);
  }, 0)});
});

GroupBy.register('max', function(item) {
  var extra = this.extra;
  return $.extend({}, item.key, {values: item.values}, {max: item.values.reduce(function(memo, node) {
      return Math.max(memo, Number(node[extra]));
  }, Number.NEGATIVE_INFINITY)});
});

GroupBy.register('list', function(item) {
  var extra = this.extra;

  return $.extend({}, item.key, {values: item.values}, {list: item.values.map(function(item) {
    var list = [];

    for (var i = 0; i < extra.list.length; i++) {
      var exclude = extra.exclude ? item[extra.exclude] : false;
      if (item[extra.list[i]] && !exclude) {
        list.push({value: item[extra.list[i]], key: extra.list[i]});
      }
    }
    return list;
  })});
});

//Simple Summary Row Accumlator
window.Aggregators = {};
window.Aggregators.aggregate = function (items, columns) {
    var totals = {}, self = this;

    for (var i = 0; i < columns.length; i++) {
        if (columns[i].aggregator) {
            var field = columns[i].field;

            self.sum = function (sum, node) {
                var value;
                if (field.indexOf('.') > -1) {
                    value = field.split('.').reduce(function (o, x) {
                        return (o ? o[x] : '');
                    }, node);
                }
                else {
                    value = node[field];
                }
                return sum + Number(value);
            };

            var total = items.reduce(self[columns[i].aggregator], 0);

            if (field.indexOf('.') > -1) {
                var currentObj = totals;
                for (var j = 0; j < field.split('.').length; j++) {
                    if (j === field.split('.').length - 1) {
                        currentObj[field.split('.')[j]] = total;
                    }
                    else {
                        if (!(field.split('.')[j] in currentObj)) {
                            currentObj[field.split('.')[j]] = {};
                        }

                        currentObj = currentObj[field.split('.')[j]];
                    }
                }
            }
            else {
                totals[field] = total;
            }
        }
    }

    return totals;
};

$.fn.datagrid = function(options) {

  // Settings and Options
  var pluginName = 'datagrid',
      defaults = {
        // F2 - toggles actionableMode "true" and "false"
        // If actionableMode is "true, tab and shift tab behave like left and right arrow key,
        // if the cell is editable it goes in and out of edit mode
        actionableMode: false,
        cellNavigation: true, // If cellNavigation is "false, will show border around whole row on focus
        rowNavigation: true, // If rowNavigation is "false, will NOT show border around the row
        alternateRowShading: false, //Sets shading for readonly grids
        columns: [],
        dataset: [],
        columnReorder: false, // Allow Column reorder
        saveColumns: false, //Save Column Reorder and resize
        saveUserSettings: {}, //Save one or all of the following to local storage : columns: true, rowHeight: true, sortOrder: true, pagesize: true, activePage: true, filter: true
        editable: false,
        isList: false, // Makes a readonly "list"
        menuId: null,  //Id to the right click context menu
        uniqueId: null, //Unique ID for local storage reference and variable names
        rowHeight: 'normal', //(short, medium or normal)
        selectable: false, //false, 'single' or 'multiple'
        groupable: null, //Use Data grouping fx. {fields: ['incidentId'], supressRow: true, aggregator: 'list', aggregatorOptions: ['unitName1']}
        clickToSelect: true,
        toolbar: false, // or features fx.. {title: 'Data Grid Header Title', results: true, keywordFilter: true, filter: true, rowHeight: true, views: true}
        initializeToolbar: true, // can set to false if you will initialize the toolbar yourself
        //Paging Options
        paging: false,
        pagesize: 25,
        pagesizes: [10, 25, 50, 75],
        indeterminate: false, //removed ability to go to a specific page.
        source: null, //callback for paging
        hidePagerOnOnePage: false, //If true, hides the pager if there's only one page worth of results.
        //Filtering Options
        filterable: false,
        disableClientFilter: false, //Disable Filter Logic client side and let your server do it
        disableClientSort: false, //Disable Sort Logic client side and let your server do it
        resultsText: null,  // Can provide a custom function to adjust results text
        virtualized: false, // Prevent Unused rows from being added to the DOM
        virtualRowBuffer: 10, //how many extra rows top and bottom to allow as a buffer
        rowReorder: false, //Allows you to reorder rows. Requires rowReorder formatter
        showDirty: false,
        allowOneExpandedRow: true, //Only allows one expandable row at a time
        enableTooltips: false,  //Process tooltip logic at a cost of performance
        disableRowDeactivation: false, // If a row is activated the user should not be able to deactivate it by clicking on the activated row
        sizeColumnsEqually: false //If true make all the columns equal width
      },
      settings = $.extend({}, defaults, options);

  /**
   * @constructor
   * @param {Object} element
   */
  function Datagrid(element) {
    this.element = $(element);
    Soho.logTimeStart(pluginName);
    this.init();
    Soho.logTimeEnd(pluginName);
  }

  // Actual Plugin Code
  Datagrid.prototype = {

    init: function() {
      var self = this, html = $('html');

      this.isTouch = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
      this.isFirefoxMac = (navigator.platform.indexOf('Mac') !== -1 && navigator.userAgent.indexOf(') Gecko') !== -1);
      this.isIe = html.is('.ie');
      this.isIe9 = html.is('.ie9');
      this.isSafari = html.is('.is-safari');
      this.isWindows = (navigator.userAgent.indexOf('Windows') !== -1);
      this.settings = settings;
      this.initSettings();
      this.originalColumns = self.columnsFromString(JSON.stringify(this.settings.columns));
      this.removeToolbarOnDestroy = false;
      this.nonVisibleCellErrors = [];

      this.restoreColumns();
      this.restoreUserSettings();
      this.appendToolbar();
      this.setTreeDepth();
      this.setRowGrouping();
      this.setTreeRootNodes();
      this.firstRender();
      this.handlePaging();
      this.handleEvents();
      this.handleKeys();

      setTimeout(function () {
        self.element.trigger('rendered', [self.element, self.headerRow, self.pagerBar]);
      }, 0);
    },

    initSettings: function () {

      this.sortColumn = {sortField: null, sortAsc: true};
      this.gridCount = $('.datagrid').length + 1;
      this.lastSelectedRow = 0;// Remember index to use shift key

      this.contextualToolbar = this.element.prev('.contextual-toolbar');
      this.contextualToolbar.addClass('datagrid-contextual-toolbar');
    },

    //Re render both header and rows
    render: function () {
      this.loadData(this.settings.dataset);
    },

    //Run First Render the Header and Rows
    firstRender: function () {
      var self = this;

      self.contentContainer = $('<div class="datagrid-body"></div>');

      if (this.settings.dataset === 'table') {
        self.table = $(this.element).addClass('datagrid');

        var wrapper = $(this.element).closest('.datagrid-container');
        if (wrapper.length === 0) {
          self.table.wrap('<div class="datagrid-container"></div>');
          this.element = self.table.closest('.datagrid-container');
        }

        self.settings.dataset = self.htmlToDataset();
        self.table.remove();
        self.table = $('<table></table>').addClass('datagrid').attr('role', 'grid').appendTo(self.contentContainer);

      } else {
        self.table = $('<table></table>').addClass('datagrid').attr('role', this.settings.treeGrid ? 'treegrid' : 'grid').appendTo(self.contentContainer);
        this.element.addClass('datagrid-container');
      }

      if (this.isWindows) {
        this.element.addClass('is-windows'); //need since scrollbars are visible
      }

      //initialize row height by a setting
      if (settings.rowHeight !== 'normal') {
        self.table.addClass(settings.rowHeight + '-rowheight');
        this.element.addClass(settings.rowHeight + '-rowheight');
      }

      //A treegrid is considered not editable unless otherwise specified.
      if (this.settings.treeGrid && !this.settings.editable) {
        self.table.attr('aria-readonly', 'true');
      }

      if (this.settings.isList) {
        $(this.element).addClass('is-gridlist');
      } else {
        $(this.element).removeClass('is-gridlist');
      }

      self.table.empty();
      self.renderRows();
      self.element.append(self.contentContainer);

      self.clearHeaderCache();
      self.renderHeader();
      self.container = self.element.closest('.datagrid-container');

      self.settings.buttonSelector = '.btn, .btn-secondary, .btn-primary, .btn-modal-primary, .btn-tertiary, .btn-icon, .btn-actions, .btn-menu, .btn-split';
      $(self.settings.buttonSelector, self.table).button();
    },

    htmlToDataset: function () {
      var rows = $(this.element).find('tbody tr'),
        self = this,
        specifiedCols = (self.settings.columns.length > 0),
        dataset = [];

      //Geneate the columns if not supplier
      if (!specifiedCols) {
        var headers = $(this.element).find('thead th'),
          firstRow = self.element.find('tbody tr:first()');

        headers.each(function (i, col) {
          var colSpecs = {},
            column = $(col),
            colName = 'column'+i;

          colSpecs.id  = column.text().toLowerCase();
          colSpecs.name = column.text();
          colSpecs.field = colName;

          var link = firstRow.find('td').eq(i).find('a');
          if (link.length > 0) {
            colSpecs.formatter = Formatters.Hyperlink;
            colSpecs.href = link.attr('href');
          }

          self.settings.columns.push(colSpecs);
        });
      }

      rows.each(function () {
        var cols = $(this).find('td'),
          newRow = {};

        cols.each(function (i, col) {
          var column = $(col),
            colName = 'column'+i;

          if (self.settings.columns[i].formatter) {
            newRow[colName] = column.text();
          } else {
            newRow[colName] = column.html();
          }

          if (specifiedCols) {
            self.settings.columns[i].field = colName;
          }

        });

        dataset.push(newRow);
      });

      return dataset;
    },

    // Add a Row
    addRow: function (data, location) {
      var self = this,
        isTop = false,
        row = 0,
        cell = 0,
        args,
        rowNode;

      if (!location || location === 'top') {
        location = 'top';
        isTop = true;
      }
      //Add row status
      data.rowStatus = {icon: 'new', text: 'New', tooltip: 'New'};

      // Add to array
      if (typeof location === 'string') {
        self.settings.dataset[isTop ? 'unshift' : 'push'](data);
      }
      else {
        self.settings.dataset.splice(location, 0, data);
      }

      // Add to ui
      self.renderRows();

      // Sync with others
      self.syncSelectedUI();
      self.updateSelected();

      // Set active and fire handler
      setTimeout(function () {
        row = isTop ? row : self.settings.dataset.length - 1;
        self.setActiveCell(row, cell);

        rowNode = self.tableBody.find('tr[aria-rowindex="'+ (row + 1) +'"]');
        args = {row: row, cell: cell, target: rowNode, value: data, oldValue: []};

        self.pagerRefresh(location);
        self.element.triggerHandler('addrow', args);
      }, 10);
    },

    pagerRefresh: function (location) {
      if (this.pager) {
        var activePage = this.pager.activePage;
        if (typeof location === 'string') {
          activePage = location === 'top' ? 1 : this.pager._pageCount;
        }
        else if (typeof location === 'number') {
          activePage = Math.floor(location / this.pager.settings.pagesize + 1);
        }

        this.pager.pagingInfo = $.extend({}, this.pager.pagingInfo, {
          activePage: activePage,
          total: this.settings.dataset.length,
          pagesize: this.settings.pagesize
        });

        this.renderPager(this.pager.pagingInfo);
      }
    },

    //Delete a Specific Row
    removeRow: function (row, nosync) {
      var rowNode = this.tableBody.find('tr[aria-rowindex="'+ (row + 1) +'"]'),
        rowData = this.settings.dataset[row];

      this.unselectRow(row, nosync);
      this.settings.dataset.splice(row, 1);
      this.renderRows();
      this.element.trigger('rowremove', {row: row, cell: null, target: rowNode, value: [], oldValue: rowData});
    },

    //Remove all selected rows
    removeSelected: function () {

      var self = this,
        selectedRows = this.selectedRows();

      for (var i = selectedRows.length-1; i >= 0; i--) {
        self.removeRow(selectedRows[i].idx, true);
        this.updateSelected();
      }
      this.pagerRefresh();
      this.syncSelectedUI();
    },

    //Method to Reload the data set
    updateDataset: function (dataset, pagerInfo) {
      this.loadData(dataset, pagerInfo);
    },

    triggerSource: function(pagerType) {

      this.pager.pagerInfo = this.pager.pagerInfo || {};
      this.pager.pagerInfo.type = pagerType;

      if (pagerType !== 'refresh') {
        this.pager.pagerInfo.activePage = 1;
      }
      this.renderPager(this.pager.pagerInfo);
    },

    loadData: function (dataset, pagerInfo, isResponse) {
      this.settings.dataset = dataset;

      if (this.pager) {
        this.pager.settings.dataset = dataset;
      }

      if (!pagerInfo) {
        pagerInfo = {};
      }

      if (!pagerInfo.activePage) {
        pagerInfo.activePage = 1;
        pagerInfo.pagesize = this.settings.pagesize;
        pagerInfo.total = -1;
        pagerInfo.type = 'initial';
      }

      //Update Paging and Clear Rows
      this.setTreeDepth();
      this.setRowGrouping();
      this.setTreeRootNodes();

      //Resize and re-render if have a new dataset (since automatic column sizing depends on the dataset)
      if (pagerInfo.type === 'initial') {
        this.clearHeaderCache();
        this.renderRows();
        this.renderHeader();
      } else {
        this.renderRows();
      }

      this.renderPager(pagerInfo, isResponse);

      if (pagerInfo && pagerInfo.preserveSelected) {
        this.updateSelected();
        this.syncSelectedUI();
      } else {
        this.unSelectAllRows();
      }
    },

    uniqueId: function (suffix) {
      var uniqueid = this.settings.uniqueId ?
        this.settings.uniqueId + '-' + suffix :
        (window.location.pathname.split('/').pop()
          .replace(/\.xhtml|\.shtml|\.html|\.htm|\.aspx|\.asp|\.jspx|\.jsp|\.php/g, '')
          .replace(/[^-\w]+/g, '')
          .replace(/\./g, '-')
          .replace(/ /g, '-')
          .replace(/%20/g, '-') +'-'+
            (this.element.attr('id') || 'datagrid') +'-'+ this.gridCount + suffix);

      return uniqueid.replace(/--/g, '-');
    },

    visibleColumns: function (skipBuiltIn) {
      var visible = [];
      for (var j = 0; j < this.settings.columns.length; j++) {
        var column = settings.columns[j];

        if (column.hidden) {
          continue;
        }

        if (skipBuiltIn && column.id === 'selectionCheckbox') {
          continue;
        }
        visible.push(column);
      }
      return visible;
    },

    lastColumnIdx: function () {
      var last = 0;
      for (var j = 0; j < this.settings.columns.length; j++) {
        var column = settings.columns[j];

        if (column.hidden) {
          continue;
        }

        last = j;
      }
      return last;
    },

    getColumnGroup: function(idx) {
      var total = 0,
        colGroups = this.settings.columnGroups;

      for (var l = 0; l < colGroups.length; l++) {
        total += colGroups[l].colspan;

        if (total >= idx) {
          return this.uniqueId('-header-group-' + l);
        }
      }
    },

    headerText: function (col) {
      var text = col.name ? col.name : '';

      if (!text && col.id === 'drilldown') {
        text = Locale.translate('Drilldown');
        return '<span class="audible">'+ text + '</span>';
      }

      return text;
    },

    //Render the Header
    renderHeader: function() {
      var self = this,
        headerRow = '',
        headerColGroup = '<colgroup>',
        cols= '',
        uniqueId;

      var colGroups = this.settings.columnGroups;

      if (colGroups) {

        var total = 0;

        headerRow += '<tr role="row" class="datagrid-header-groups">';

        for (var k = 0; k < colGroups.length; k++) {

          total += parseInt(colGroups[k].colspan);
          uniqueId = self.uniqueId('-header-group-' + k);

          headerRow += '<th colspan="' + colGroups[k].colspan + '" id="' + uniqueId + '"' + '><div class="datagrid-column-wrapper "><span class="datagrid-header-text">'+ colGroups[k].name +'</span></div></th>';
        }

        if (total < this.visibleColumns().length) {
          headerRow += '<th colspan="' + (this.visibleColumns().length - total) + '"></th>';
        }
        headerRow += '</tr><tr>';
      } else {
        headerRow += '<tr role="row">';
      }

      for (var j = 0; j < this.settings.columns.length; j++) {
        var column = settings.columns[j],
          id = self.uniqueId('-header-' + j),
          isSortable = (column.sortable === undefined ? true : column.sortable),
          isResizable = (column.resizable === undefined ? true : column.resizable),
          isSelection = column.id === 'selectionCheckbox',
          alignmentClass = (column.align === 'center' ? ' l-'+ column.align +'-text' : '');// Disable right align for now as this was acting wierd

        headerRow += '<th scope="col" role="columnheader" class="' + (isSortable ? 'is-sortable' : '') + (isResizable ? ' is-resizable' : '') + (column.hidden ? ' is-hidden' : '') + (column.filterType ? ' is-filterable' : '') + (alignmentClass ? alignmentClass : '') + '"' +
         ' id="' + id + '" data-column-id="'+ column.id + '"' + (column.field ? ' data-field="'+ column.field +'"' : '') +
         (column.headerTooltip ? 'title="' + column.headerTooltip + '"' : '') +
         (column.reorderable === false ? ' data-reorder="false"' : '') +
         (colGroups ? ' headers="' + self.getColumnGroup(j) + '"' : '') + '>';

        headerRow += '<div class="' + (isSelection ? 'datagrid-checkbox-wrapper ': 'datagrid-column-wrapper') + (column.align === undefined ? '' : ' l-'+ column.align +'-text') + '"><span class="datagrid-header-text'+ (column.required ? ' required': '') + '">' + self.headerText(settings.columns[j]) + '</span>';
        cols += '<col' + this.calculateColumnWidth(column, j) + (column.hidden ? ' class="is-hidden"' : '') + '>';

        if (isSelection) {
          headerRow += '<span aria-checked="false" class="datagrid-checkbox" aria-label="Selection" role="checkbox"></span>';
        }

        if (isSortable) {
          headerRow += '<div class="sort-indicator">' +
            '<span class="sort-asc">' + $.createIcon({ icon: 'dropdown' }) + '</span>' +
            '<span class="sort-desc">' + $.createIcon({ icon: 'dropdown' }) + '</div>';
        }

        headerRow += '</div></th>';
      }
      headerRow += '</tr>';

      headerColGroup += cols + '</colgroup>';

      if (self.headerRow === undefined) {
        self.headerContainer = $('<div class="datagrid-header"><table role="grid" '+ this.headerTableWidth() + '></table></div>');
        self.headerTable = self.headerContainer.find('table');
        self.headerColGroup = $(headerColGroup).appendTo(self.headerTable);
        self.headerRow = $('<thead>' + headerRow + '</thead>').appendTo(self.headerContainer.find('table'));
        self.element.prepend(self.headerContainer);
      } else {
        self.headerContainer.find('table').css('width', this.totalWidth);
        self.headerRow.html(headerRow);
        self.headerColGroup.html(cols);
      }

      if (this.settings.enableTooltips) {
        self.headerRow.find('th[title]').tooltip();
      }

      if (self.settings.columnReorder) {
        self.createDraggableColumns();
      }

      this.renderFilterRow();

      if (this.restoreSortOrder) {
        this.setSortIndicator(this.sortColumn.sortId, this.sortColumn.sortAsc);
        this.restoreSortOrder = false;
      }

      if (this.restoreFilter) {
        this.applyFilter(this.savedFilter);
        this.restoreFilter = false;
        this.savedFilter = null;
      }
    },

    filterRowRendered: false,

    //Render the Filter Row
    renderFilterRow: function () {
      var self = this;

      if (!this.settings.filterable) {
        return;
      }

      this.element.addClass('has-filterable-columns');
      this.headerRow.find('.datagrid-filter-wrapper').remove();

      //Loop the columns looking at the filter types and generate the markup for the various Types
      //Supported Filter Types: text, integer, date, select, decimal, lookup, percent, checkbox, contents
      for (var j = 0; j < this.settings.columns.length; j++) {
        if (this.settings.columns[j].filterType) {
          var col = this.settings.columns[j],
            id = self.uniqueId('-header-' + j),
            header = this.headerRow.find('#'+id),
            filterId = self.uniqueId('-header-filter-' + j),
            filterMarkup = '<div class="datagrid-filter-wrapper">'+ this.renderFilterButton(col) +'<label class="audible" for="'+ filterId +'">' +
              col.name + '</label>';

          switch (col.filterType) {
            case 'checkbox':
              //just the button
              break;
            case 'date':
              filterMarkup += '<input ' + (col.filterDisabled ? ' disabled' : '') + ' type="text" class="datepicker" id="'+ filterId +'"/>';
              break;
            case 'decimal':
              filterMarkup += '<input ' + (col.filterDisabled ? ' disabled' : '') + ' type="text" id="'+ filterId +'" data-mask-mode="number" data-mask="'+ (col.mask ? col.mask : '####.00') + '">';
              break;
            case 'percent':
              col.maskOptions = {
                showSymbol: 'percent',
                pattern: col.mask || (((col.name + '').toLowerCase() === 'decimal') ? '####.00' : '')
              };
              filterMarkup += '<input' + (col.filterDisabled ? ' disabled' : '') + ' type="text" id="'+ filterId +'" data-mask-mode="number" data-mask="'+ col.maskOptions.pattern +'"/>';
              break;
            case 'contents':
            case 'select':
              filterMarkup += '<select ' + (col.filterDisabled ? ' disabled' : '') + (col.filterType ==='select' ? ' class="dropdown"' : ' multiple class="multiselect"') + 'id="'+ filterId +'">';
              if (col.options) {
                if (col.filterType ==='select') {
                  filterMarkup += '<option></option>';
                }

                for (var i = 0; i < col.options.length; i++) {
                  var option = col.options[i],
                  optionValue = col.caseInsensitive && typeof option.value === 'string' ? option.value.toLowerCase() : option.value;
                  filterMarkup += '<option value = "' +optionValue + '">' + option.label + '</option>';
                }
              }
              filterMarkup += '</select>';

              break;
            default:
              filterMarkup += '<input' + (col.filterDisabled ? ' disabled' : '') + ' type="text" id="'+ filterId +'"/>';
              break;
          }

          filterMarkup += '</div>';
          header.find('.datagrid-column-wrapper').after(filterMarkup);
          header.find('.datepicker').datepicker(col.editorOptions ? col.editoroptions : {dateFormat: col.dateFormat});
          header.find('select.dropdown').dropdown(col.editorOptions);
          header.find('.multiselect').multiselect(col.editorOptions);
          header.find('[data-mask]').mask(col.maskOptions);
        }
      }

      //Attach Keyboard support
      var popupOpts = {attachToBody: $('html').hasClass('ios'), offset: {y: 15}, placementOpts: {strategies: ['flip', 'nudge']}};

      this.headerRow.addClass('is-filterable');
      this.headerRow.find('.btn-filter').popupmenu(popupOpts).on('selected.datagrid', function () {
        self.applyFilter();
      });

      this.headerRow.on('keydown.datagrid', '.datagrid-filter-wrapper input', function (e) {
        e.stopPropagation();

        if (e.which === 13) {
          e.preventDefault();
          $(this).trigger('change');
        }

      }).on('change.datagrid', '.datagrid-filter-wrapper input', function () {
        self.applyFilter();
      });

      this.headerRow.find('.dropdown, .multiselect').on('selected.datagrid', function () {
        self.applyFilter();
      });

      self.filterRowRendered = true;
    },

    //Render one filter item as used in renderFilterButton
    renderFilterItem: function (icon, text, checked) {
      var iconMarkup = $.createIcon({ classes: 'icon icon-filter', icon: 'filter-' + icon });
      return '<li '+ (checked ? 'class="is-checked"' : '') +'><a href="#">'+ iconMarkup +'<span>'+ Locale.translate(text) +'</span></a></li>';
    },

    //Render the Filter Button and Menu based on filterType - which determines the options
    renderFilterButton: function (col) {
      var self = this,
        filterType = col.filterType,
        isDisabled = col.filterDisabled,
        filterConditions = $.isArray(col.filterConditions) ? col.filterConditions : [],
        inArray = function (s, array) {
          array = array || filterConditions;
          return ($.inArray(s, array) > -1);
        },
        render = function (icon, text, checked) {
          return filterConditions.length && !inArray(icon) ?
            '' : self.renderFilterItem(icon, text, checked);
        },
        btnMarkup = '<button type="button" class="btn-menu btn-filter" data-init="false" ' + (isDisabled ? ' disabled' : '') + ' type="button"><span class="audible">Filter</span>' + $.createIcon({icon: 'dropdown' , classes: 'icon-dropdown'}) +'</button>' +
        '<ul class="popupmenu has-icons is-translatable is-selectable">';

      //Just the dropdown
      if (filterType === 'contents' || filterType === 'select') {
        return '';
      }

      if (filterType === 'text') {
        btnMarkup += ''+
          render('contains', 'Contains', true) +
          render('does-not-contain', 'DoesNotContain', false);
      }

      if (filterType === 'checkbox') {
        btnMarkup += ''+
          render('selected-notselected', 'All', true) +
          render('selected', 'Selected') +
          render('not-selected', 'NotSelected');
      }

      if (filterType !== 'checkbox') {
        btnMarkup += ''+
          render('equals', 'Equals', (filterType === 'integer' || filterType === 'date')) +
          render('does-not-equal', 'DoesNotEqual') +
          render('is-empty', 'IsEmpty') +
          render('is-not-empty', 'IsNotEmpty');
      }

      if (/\b(integer|decimal|date|percent)\b/g.test(filterType)) {
        btnMarkup += ''+
          render('less-than', 'LessThan') +
          render('less-equals', 'LessOrEquals') +
          render('greater-than', 'GreaterThan') +
          render('greater-equals', 'GreaterOrEquals');
      }

      if (filterType === 'text') {
        btnMarkup += ''+
          render('end-with', 'EndsWith') +
          render('does-not-end-with', 'DoesNotEndWith') +
          render('start-with', 'StartsWith') +
          render('does-not-start-with', 'DoesNotStartWith');
      }

      btnMarkup += '</ul>';
      return btnMarkup ;
    },

    toggleFilterRow: function () {

      if (this.settings.filterable) {
        this.headerRow.removeClass('is-filterable');
        this.headerRow.find('.is-filterable').removeClass('is-filterable');
        this.headerRow.find('.datagrid-filter-wrapper').hide();
        this.settings.filterable = false;
      } else {
        this.settings.filterable = true;

        if (!this.filterRowRendered) {
          this.renderFilterRow();
        }

        this.headerRow.addClass('is-filterable');
        this.headerRow.find('.is-filterable').addClass('is-filterable');
        this.headerRow.find('.datagrid-filter-wrapper').show();
      }

    },

    //Except conditions from outside or pull from filter row
    applyFilter: function (conditions) {
      var self = this;
      this.filteredDataset = null;

      if (conditions) {
        this.setFilterConditions(conditions);
      } else {
        conditions = this.filterConditions();
      }

      var checkRow = function (rowData) {
        var isMatch = true;

        for (var i = 0; i < conditions.length; i++) {
          var columnDef = self.columnById(conditions[i].columnId)[0],
            field = columnDef.field,
            rowValue = self.fieldValue(rowData, field),
            rowValueStr = rowValue.toString().toLowerCase(),
            conditionValue = conditions[i].value.toString().toLowerCase();

          //Percent filter type
          if (columnDef.filterType === 'percent') {
            conditionValue = (conditionValue / 100).toString();
            if ((columnDef.name + '').toLowerCase() === 'decimal') {
              rowValue = window.Formatters.Decimal(false, false, rowValue, columnDef);
              conditionValue = window.Formatters.Decimal(false, false, conditionValue, columnDef);
            } else if ((columnDef.name + '').toLowerCase() === 'integer') {
              rowValue = window.Formatters.Integer(false, false, rowValue, columnDef);
              conditionValue = window.Formatters.Integer(false, false, conditionValue, columnDef);
            }
          }

          //Run Data over the formatter
          if (columnDef.filterType === 'text') {
            rowValue = self.formatValue(columnDef.formatter, i , conditions[i].columnId, rowValue, columnDef, rowData, self);

            //Strip any html markup that might be in the formatters
            var rex = /(<([^>]+)>)|(&lt;([^>]+)&gt;)/ig;
            rowValue = rowValue.replace(rex , '').toLowerCase();

            rowValueStr = rowValue.toString().toLowerCase();
          }

          if (columnDef.filterType === 'contents' || columnDef.filterType === 'select') {
            rowValue = rowValue.toLowerCase();
          }

          if (rowValue instanceof Date) {
            rowValue = rowValue.getTime();
            conditionValue = Locale.parseDate(conditions[i].value, conditions[i].format).getTime();
          }

          if (typeof rowValue === 'number') {
            rowValue =  parseFloat(rowValue);
            conditionValue = parseFloat(conditionValue);
          }

          switch (conditions[i].operator) {
            case 'equals':

              //This case is multiselect
              if (conditions[i].value instanceof Array) {
                isMatch = false;

                for (var k = 0; k < conditions[i].value.length; k++) {
                  var match = conditions[i].value[k].toLowerCase().indexOf(rowValue) >= 0 && rowValue.toString() !== '';
                  if (match) {
                    isMatch = true;
                  }
                }
              } else {
                isMatch = (rowValue === conditionValue && rowValue !== '');
              }

              break;
            case 'does-not-equal':
              isMatch = (rowValue !== conditionValue);
              break;
            case 'contains':
              isMatch = (rowValueStr.indexOf(conditionValue) > -1 && rowValue.toString() !== '');
              break;
            case 'does-not-contain':
              isMatch = (rowValueStr.indexOf(conditionValue) === -1);
              break;
            case 'end-with':
              isMatch = (rowValueStr.lastIndexOf(conditionValue) === (rowValueStr.length - conditionValue.toString().length)  && rowValueStr !== '' && (rowValueStr.length >= conditionValue.toString().length));
              break;
            case 'start-with':
              isMatch = (rowValueStr.indexOf(conditionValue) === 0 && rowValueStr !== '');
              break;
            case 'does-not-end-with':
              isMatch = (rowValueStr.lastIndexOf(conditionValue) === (rowValueStr.length - conditionValue.toString().length)  && rowValueStr !== '' && (rowValueStr.length >= conditionValue.toString().length));
              isMatch = !isMatch;
              break;
            case 'does-not-start-with':
              isMatch = !(rowValueStr.indexOf(conditionValue) === 0 && rowValueStr !== '');
              break;
            case 'is-empty':
              isMatch = (rowValue === '');
              break;
            case 'is-not-empty':
              isMatch = (rowValue !== '');
              break;
            case 'less-than':
              isMatch = (rowValue < conditionValue && rowValue !== '');
              break;
            case 'less-equals':
              isMatch = (rowValue <= conditionValue && rowValue !== '');
              break;
            case 'greater-than':
              isMatch = (rowValue > conditionValue && rowValue !== '');
              break;
            case 'greater-equals':
              isMatch = (rowValue >= conditionValue && rowValue !== '');
              break;
            case 'selected':

              if (columnDef && columnDef.isChecked) {
                 isMatch = columnDef.isChecked(rowValue);
                 break;
              }
              isMatch = (rowValueStr === '1' || rowValueStr ==='true' || rowValue === true || rowValue === 1) && rowValueStr !== '';
              break;
           case 'not-selected':
              if (columnDef && columnDef.isChecked) {
                 isMatch = !columnDef.isChecked(rowValue);
                 break;
              }
              isMatch = (rowValueStr === '0' || rowValueStr ==='false' || rowValue === false || rowValue === 0) && rowValueStr !== '';
              break;
            case 'selected-notselected':
              isMatch = true;
              break;
            default:
          }

          if (!isMatch) {
            return false;
          }
        }
        return isMatch;
      };

      if (!this.settings.disableClientFilter) {
        var dataset, isFiltered, i, len;

        if (this.settings.treeGrid) {
          dataset = this.settings.treeDepth;
          for (i = 0, len = dataset.length; i < len; i++) {
            isFiltered = !checkRow(dataset[i].node);
            dataset[i].node.isFiltered = isFiltered;
          }
        }
        else {
          dataset = this.settings.dataset;
          for (i = 0, len = dataset.length; i < len; i++) {
            isFiltered = !checkRow(dataset[i]);
            dataset[i].isFiltered = isFiltered;
          }
        }
      }
      this.renderRows();
      this.resetPager('filtered');
      this.element.trigger('filtered', {op: 'apply', conditions: conditions});
      this.saveUserSettings();
    },

    //Clear and reset the filter
    clearFilter: function () {
      this.renderFilterRow();
      this.applyFilter();
      this.element.trigger('filtered', {op: 'clear', conditions: []});
    },

    // Set the filter row from passed data / settings
    setFilterConditions: function (conditions) {
      for (var i = 0; i < conditions.length; i++) {
        //Find the filter row
        var rowElem = this.headerRow.find('th[data-column-id="'+ conditions[i].columnId +'"]'),
          input = rowElem.find('input, select'),
          btn = rowElem.find('.btn-filter');

        if (conditions[i].value === undefined) {
          conditions[i].value = '';
        }

        input.val(conditions[i].value);

        if (input.is('select') && conditions[i].value instanceof Array) {
          for (var j = 0; j < conditions[i].value.length; j++) {
            input.find('option[value="'+ conditions[i].value[j] + '"]').prop('selected', true);
          }
          input.trigger('updated');
        }

        btn.find('svg:first > use').attr('xlink:href', '#icon-filter-' + conditions[i].operator);
      }
    },

    //Get filter conditions in array form from the UI
    filterConditions: function () {
      var self = this;
      this.filterExpr = [];

      //Create an array of objects with: field, id, filterType, operator, value
      this.headerRow.find('th').each(function () {
        var rowElem = $(this),
          btn = rowElem.find('.btn-filter'),
          input = rowElem.find('input, select'),
          isDropdown = input.is('select'),
          svg = btn.find('.icon-dropdown:first'),
          op;

        if (!btn.length && !isDropdown) {
          return;
        }

        op = isDropdown ? 'equals' : svg.getIconName().replace('filter-', '');

        if (op === 'selected-notselected') {
          return;
        }

        if (input.val() === '' && ['is-not-empty', 'is-empty', 'selected', 'not-selected'].indexOf(op) === -1) {
          return;
        }

        if (input.val() instanceof Array && input.val().length ===0) {
          return;
        }

        var condition = {columnId: rowElem.attr('data-column-id'),
          operator: op,
          value: input.val() ? input.val() : ''};

        if (input.data('datepicker')) {
          var format = input.data('datepicker').settings.dateFormat;
          if (format === 'locale') {
            format = Locale.calendar().dateFormat.short;
          }
          condition.format = format;
        }

        self.filterExpr.push(condition);

      });

      return self.filterExpr;
    },

    // Create draggable columns
    createDraggableColumns: function () {
      var self = this,
        headers = self.headerNodes().not('[data-column-id="selectionCheckbox"]').not('[data-reorder="false"]'),
        showTarget = $('.drag-target-arrows', self.element);

      if (!showTarget.length) {
        self.element.prepend('<span class="drag-target-arrows"></span>');
        showTarget = $('.drag-target-arrows', self.element);
      }

      headers.prepend('<span class="is-draggable-target"></span><span class="handle">&#8286;</span>');
      headers.last().append('<span class="is-draggable-target last"></span>');
      self.element.addClass('has-draggable-columns');

      // Initialize Drag api
      $('.handle', headers).each(function() {
        var clone, headerPos, offPos,
          handle = $(this),
          header = handle.parent();

        handle.on('mousedown.datagrid', function(e) {
          e.preventDefault();

          header.drag({clone: true, cloneAppendTo: headers.first().parent().parent(), clonePosIsFixed: true})
            .on('dragstart.datagrid', function (e, pos, thisClone) {
              var index;

              clone = thisClone;

              clone.removeAttr('id').addClass('is-dragging-clone')
                .css({left: pos.left, top: pos.top});
              $('.is-draggable-target', clone).remove();

              self.setDraggableColumnTargets();

              headerPos = header.position();
              offPos = {top: (pos.top - headerPos.top), left: (pos.left - headerPos.left)};

              index = self.targetColumn(headerPos);
              self.draggableStatus.startIndex = index;
              e.stopImmediatePropagation();
            })
            .on('drag.datagrid', function (e, pos) {
              clone[0].style.left = parseInt(pos.left) + 'px';
              clone[0].style.top =  parseInt(pos.top) + 'px';
              headerPos = {top: (pos.top - offPos.top), left: (pos.left - offPos.left)};

              var i, l, n, target, rect,
                index = self.targetColumn(headerPos);

              $('.is-draggable-target', headers).add(showTarget).removeClass('is-over');

              if (index !== -1) {
                for (i=0, l=self.draggableColumnTargets.length; i<l; i++) {
                  target = self.draggableColumnTargets[i];
                  n = i + 1;

                  if (target.index === index && target.index !== self.draggableStatus.startIndex) {
                    if (target.index > self.draggableStatus.startIndex && (n < l)) {
                      target = self.draggableColumnTargets[n];
                    }

                    target.el.addClass('is-over');
                    showTarget.addClass('is-over');
                    rect = target.el[0].getBoundingClientRect();
                    showTarget[0].style.left = parseInt(rect.left) + 'px';
                    showTarget[0].style.top =  (parseInt(rect.top) + 1) + 'px';

                  }
                }
              }

              e.stopImmediatePropagation();
            })
            .on('dragend.datagrid', function (e, pos) {
              clone[0].style.left = parseInt(pos.left) + 'px';
              clone[0].style.top =  parseInt(pos.top) + 'px';

              headerPos = {top: (pos.top - offPos.top), left: (pos.left - offPos.left)};

              var index = self.targetColumn(headerPos),
               dragApi = header.data('drag'),
               tempArray = [],
               i, l, indexFrom, indexTo, target;

              // Unbind drag from header
              if (dragApi && dragApi.destroy) {
                dragApi.destroy();
              }

              self.draggableStatus.endIndex = index;
              $('.is-draggable-target', headers).add(showTarget).removeClass('is-over');

              if (self.draggableStatus.endIndex !== -1) {
                if (self.draggableStatus.startIndex !== self.draggableStatus.endIndex) {
                  target = self.draggableColumnTargets[index];


                  //Swap columns
                  for (i=0, l=self.settings.columns.length; i < l; i++) {
                      if (!self.settings.columns[i].hidden &&
                          self.settings.columns[i].id !== 'selectionCheckbox') {
                        tempArray.push(i);
                      }
                    }

                    indexFrom = tempArray[self.draggableStatus.startIndex] || 0;
                    indexTo = tempArray[self.draggableStatus.endIndex] || 0;

                    self.arrayIndexMove(self.settings.columns, indexFrom, indexTo);
                    self.updateColumns(self.settings.columns);

                  }
              }

            });
        });
      });
    },

    // Set draggable columns target
    setDraggableColumnTargets: function () {
      var self = this,
        headers = self.headerNodes()
          .not('.is-hidden').not('[data-column-id="selectionCheckbox"]'),
        target, pos, extra;

      self.draggableColumnTargets = [];
      self.draggableStatus = {};

      // Move last target if not found in last header
      if (!$('.is-draggable-target.last', headers.last()).length) {
        headers.last().append($('.is-draggable-target.last', self.headerNodes()));
      }

      $('.is-draggable-target', headers).each(function (index) {
        var idx = ($(this).is('.last')) ? index - 1 : index; // Extra target for last header th
        target = headers.eq(idx);
        pos = target.position();
        // Extra space around, if dropped item bit off from drop area
        extra = 20;

        self.draggableColumnTargets.push({
          el: $(this),
          index: idx,
          pos: pos,
          width: target.outerWidth(),
          height: target.outerHeight(),
          dropArea: {
            x1: pos.left - extra, x2: pos.left + target.outerWidth() + extra,
            y1: pos.top - extra, y2: pos.top + target.outerHeight() + extra
          }
        });
      });
    },

    // Get column index
    targetColumn: function (pos) {
      var self = this,
        index = -1,
        target, i, l;

      for (i=0, l=self.draggableColumnTargets.length-1; i<l; i++) {
        target = self.draggableColumnTargets[i];
        if (pos.left > target.dropArea.x1 && pos.left < target.dropArea.x2 &&
            pos.top > target.dropArea.y1 && pos.top < target.dropArea.y2) {
          index = target.index;
        }
      }
      return index;
    },

    // Move an array element position
    arrayIndexMove: function(arr, from, to) {
      arr.splice(to, 0, arr.splice(from, 1)[0]);
    },

    // Attach Drag Events to Rows
    createDraggableRows: function () {
      var self = this;

      if (!this.settings.rowReorder) {
        return;
      }

      // Attach the Drag API
      this.tableBody.arrange({
          placeholder: '<tr class="datagrid-reorder-placeholder"><td colspan="'+ this.visibleColumns().length +'"></td></tr>',
          handle: '.datagrid-reorder-icon'
        })
        .on('beforearrange.datagrid', function(e, status) {
          if (self.isSafari) {
            status.start.css({'display': 'inline-block'});
          }
        })
        .on('arrangeupdate.datagrid', function(e, status) {
          if (self.isSafari) {
            status.end.css({'display': ''});
          }
          // Move the elem in the data set
          self.settings.dataset.splice(status.endIndex, 0, self.settings.dataset.splice(status.startIndex, 1)[0]);
          // Fire an event
          self.element.trigger('rowreorder', [status]);
        });

    },

    //Return Value from the Object handling dotted notation
    fieldValue: function (obj, field) {
      if (!field || !obj) {
        return '';
      }

      if (field.indexOf('.') > -1) {
        return field.split('.').reduce(function(o, x) {
          return (o ? o[x] : '');
        }, obj);
      }

      var rawValue = obj[field],
        value = (rawValue || rawValue === 0 || rawValue === false ? rawValue : '');

      value = $.escapeHTML(value);
      return value;
    },

    // Set tree root nodes
    setTreeRootNodes: function() {
      this.settings.treeRootNodes = this.settings.treeDepth
        .filter(function(node) {
          return node.depth === 1;
        });
    },

    // Set tree depth
    setTreeDepth: function(dataset) {
      var self = this,
        idx = 0,
        iterate = function(node, depth) {
          idx++;
          self.settings.treeDepth.push({idx: idx, depth: depth, node: node});
          var children = node.children || [];
          for (var i = 0, len = children.length; i < len; i++) {
            iterate(children[i], depth + 1);
          }
        };

      dataset = dataset || this.settings.dataset;
      self.settings.treeDepth = [];

      for (var i = 0, len = dataset.length; i < len; i++) {
        iterate(dataset[i], 1);
      }
    },

    setRowGrouping: function () {
      var groupSettings = this.settings.groupable;
      if (!groupSettings) {
        return;
      }

      this.originalDataset = this.settings.dataset.slice();

      if (groupSettings.aggregator === 'sum') {
        this.settings.dataset = GroupBy.sum(this.settings.dataset , groupSettings.fields, groupSettings.aggregate);
        return;
      }

      if (groupSettings.aggregator === 'max') {
        this.settings.dataset = GroupBy.max(this.settings.dataset , groupSettings.fields, groupSettings.aggregate);
        return;
      }

      if (groupSettings.aggregator === 'list') {
        this.settings.dataset = GroupBy.list(this.settings.dataset , groupSettings.fields, groupSettings.aggregatorOptions);
        return;
      }

      this.settings.dataset = window.GroupBy(this.settings.dataset , groupSettings.fields);
    },

    //Render the Rows
    renderRows: function() {
      var tableHtml = '',
        self = this, i,
        s = self.settings,
        activePage = self.pager ? self.pager.activePage : 1,
        pagesize = s.pagesize,
        dataset = s.dataset;

      var body = self.table.find('tbody');
      self.bodyColGroupHtml = '<colgroup>';

      if (body.length === 0) {
        self.tableBody = $('<tbody></tbody>');
        self.table.append(self.tableBody);
      }

      self.recordCount = 0;
      self.filteredCount = 0;

      // Reset recordCount for paging
      if (s.treeGrid && s.paging && !s.source && activePage > 1) {
        self.recordCount = s.treeRootNodes[(pagesize * activePage) - pagesize].idx-1;
      }

      if (this.restoreSortOrder) {
        this.sortDataset();
      }

      for (i = 0; i < dataset.length; i++) {

        //For better performance dont render out of page
        if (s.paging && !s.source) {

          if (activePage === 1 && (i - this.filteredCount) >= pagesize){
            if (!dataset[i].isFiltered) {
              this.recordCount++;
            }
            continue;
          }

          if (activePage > 1 && !((i - this.filteredCount) >= pagesize*(activePage-1) && (i - this.filteredCount) < pagesize*activePage)) {
            if (!dataset[i].isFiltered) {
              this.recordCount++;
            } else {
              this.filteredCount++;
            }
            continue;
          }
        }

        if (s.virtualized) {
          if (!this.isRowVisible(this.recordCount)) {
            this.recordCount++;
            continue;
          }
        }

        //Exclude Filtered Rows
        if ((s.treeGrid ? s.treeRootNodes[i].node : dataset[i]).isFiltered) {
          this.filteredCount++;
          continue;
        }

        //Handle Grouping
        if (this.settings.groupable) {
          //First push group row
          if (!this.settings.groupable.suppressGroupRow) {
            //Show the grouping row
            tableHtml += self.rowHtml(dataset[i], this.recordCount, i, true);
          }

          if (this.settings.groupable.showOnlyGroupRow && dataset[i].values[0]) {
            var rowData = dataset[i].values[0];

            if (dataset[i].list) {
              rowData.list = dataset[i].list;
            }

            rowData.values = dataset[i].values;

            tableHtml += self.rowHtml(rowData, this.recordCount, i);
            this.recordCount++;
            continue;
          }

          //Now Push Groups
          for (var k = 0; k < dataset[i].values.length; k++) {
            tableHtml += self.rowHtml(dataset[i].values[k], this.recordCount, i);
            this.recordCount++;
          }

          // Now Push summary rowHtml
          if (this.settings.groupable.groupFooterRow) {
            tableHtml += self.rowHtml(dataset[i], this.recordCount, i, true, true);
          }

          continue;
        }

        tableHtml += self.rowHtml(dataset[i], s.treeGrid ? this.recordCount : i, i);
        this.recordCount++;
      }

      //Append a Summary Row
      if (this.settings.summaryRow) {
        tableHtml += self.rowHtml(self.calculateTotals(), this.recordCount, null, false, true);
      }

      if (self.bodyColGroupHtml !== '<colgroup>') {
        self.bodyColGroupHtml += '</colgroup>';

        if (self.bodyColGroup) {
          self.bodyColGroup.remove();
        }

        self.bodyColGroup = $(self.bodyColGroupHtml);
        self.tableBody.before(self.bodyColGroup);
      }

      self.tableBody.html(tableHtml);
      self.setVirtualHeight();
      self.setScrollClass();
      self.setupTooltips();
      self.afterRender();

    },

    afterRender: function() {
      var self = this;

      //Init Inline Elements
      self.tableBody.find('select.dropdown').dropdown();

      //Commit Edits for inline editing
      self.tableBody.find('.dropdown-wrapper.is-inline').prev('select')
        .on('listclosed', function () {
           var elem = $(this),
            newValue = elem.val(),
            row = elem.closest('tr');

            self.updateCellNode(row.attr('aria-rowindex'), elem.closest('td').index(), newValue, false, true);
         });

      self.tableBody.find('.spinbox').spinbox();

      //Set UI elements after dataload
      setTimeout(function () {

        if (!self.settings.source) {
          self.displayCounts();
        }

        self.setAlternateRowShading();
        self.createDraggableRows();

        if (!self.activeCell || !self.activeCell.node) {
          self.activeCell = {node: self.cellNode(0, 0, true).attr('tabindex', '0'), isFocused: false, cell: 0, row: 0};
        }

        if (self.activeCell.isFocused) {
          self.setActiveCell(self.activeCell.row, self.activeCell.cell);
        }

        //Update Selected Rows Across Page
        if (self.settings.paging && self.settings.source) {
          self._selectedRows = [];
          self.syncSelectedUI();
        }

        self.element.trigger('afterrender', {body: self.tableBody, header: self.headerRow, pager: self.pagerBar});
      }, 0);

    },

    cacheVirtualStats: function () {
      var containerHeight = this.element[0].offsetHeight,
        scrollTop = this.contentContainer[0].scrollTop,
        headerHeight = this.settings.rowHeight === 'normal' ? 40 : (this.settings.rowHeight === 'medium' ? 30 : 25),
        bodyHeight = containerHeight-headerHeight,
        rowHeight = this.settings.rowHeight === 'normal' ? 50 : (this.settings.rowHeight === 'medium' ? 40 : 30);

      this.virtualRange = {rowHeight: rowHeight,
                         top: Math.max(scrollTop - ((this.settings.virtualRowBuffer-1) * rowHeight), 0),
                         bottom: scrollTop + bodyHeight + ((this.settings.virtualRowBuffer-1) * rowHeight),
                         totalHeight: rowHeight * this.settings.dataset.length,
                         bodyHeight: bodyHeight};
    },

    // Check if the row is in the visble scroll area + buffer
    // Just call renderRows() on events that change
    isRowVisible: function(rowIndex) {
      if (!this.settings.virtualized) {
        return true;
      }

      if (rowIndex === 0) {
        this.cacheVirtualStats();
      }

      //determine if the row is in view
      var pos = rowIndex * this.virtualRange.rowHeight;

      if (pos >= this.virtualRange.top && pos < this.virtualRange.bottom) {
        return true;
      }

      return false;
    },

    // Set the heights on top or bottom based on scroll position
    setVirtualHeight: function () {
      if (!this.settings.virtualized || !this.virtualRange) {
        return;
      }

      var bottom = this.virtualRange.totalHeight - this.virtualRange.bottom,
        top = this.virtualRange.top;

      this.topSpacer = this.tableBody.find('.datagrid-virtual-row-top');
      this.bottomSpacer = this.tableBody.find('.datagrid-virtual-row-bottom');

      if (top > 0 && !this.topSpacer.length) {
        this.topSpacer = $('<tr class="datagrid-virtual-row-top" style="height: '+ top + 'px"><td colspan="'+ this.visibleColumns().length +'"></td></tr>');
        this.tableBody.prepend(this.topSpacer);
      }

      if (top > 0 && this.topSpacer.length) {
        this.topSpacer.css('height', top + 'px');
      }

      if (top ===0 && this.topSpacer.length || this.virtualRange.topRow <= 1) {
        this.topSpacer.remove();
      }

      if (bottom > 0 && !this.bottomSpacer.length) {
        this.bottomSpacer = $('<tr class="datagrid-virtual-row-bottom" style="height: '+ bottom + 'px"><td colspan="'+ this.visibleColumns().length +'"></td></tr>');
        this.tableBody.append(this.bottomSpacer);
      }

      if (bottom > 0 && this.bottomSpacer.length) {
        this.bottomSpacer.css('height', bottom + 'px');
      }

      if (bottom <= 0 && this.bottomSpacer.length || (this.virtualRange.bottomRow >= this.settings.dataset.length)) {
        this.bottomSpacer.remove();
      }
    },

    // Set the alternate shading for tree
    setAlternateRowShading: function() {
      if (this.settings.alternateRowShading && this.settings.treeGrid) {
        $('tr[role="row"]:visible', this.tableBody)
          .removeClass('alt-shading').filter(':odd').addClass('alt-shading');
      }
    },

    formatValue: function (formatter, row, cell, fieldValue, columnDef, rowData, api) {
      var formattedValue;
      api = api || this;

      //Use default formatter if undefined
      if (formatter === undefined) {
        formatter = this.defaultFormatter;
      }

      if (typeof formatter ==='string') {
        formattedValue = window.Formatters[formatter](row, cell, fieldValue, columnDef, rowData, api).toString();
      } else {
        formattedValue = formatter(row, cell, fieldValue, columnDef, rowData, api).toString();
      }
      return formattedValue;
    },

    recordCount: 0,

    rowHtml: function (rowData, dataRowIdx, actualIndex, isGroup, isFooter) {
      var isEven = false,
        self = this,
        isSummaryRow = this.settings.summaryRow && !isGroup && isFooter,
        activePage = self.pager ? self.pager.activePage : 1,
        pagesize = self.settings.pagesize,
        rowHtml = '',
        d = self.settings.treeDepth[dataRowIdx],
        depth, d2, i, l, isHidden;

      if (!rowData) {
        return '';
      }

      // Default
      d = d ? d.depth : 0;
      depth = d;

      // Setup if this row will be hidden or not
      for (i = dataRowIdx; i >= 0 && d > 1 && !isHidden; i--) {
        d2 = self.settings.treeDepth[i];
        if (d !== d2.depth && d > d2.depth) {
          d = d2.depth;
          isHidden = !d2.node.expanded;
        }
      }

      if (this.settings.groupable) {
        var groupSettings = this.settings.groupable;
        isHidden  = (groupSettings.expanded === undefined ? false : !groupSettings.expanded);

        if (groupSettings.expanded && typeof groupSettings.expanded === 'function') {
          isHidden = !groupSettings.expanded(dataRowIdx, 0, null, null, rowData, this);
        }
      }

      //Group Rows
      if (this.settings.groupable && isGroup && !isFooter) {
        rowHtml = '<tr class="datagrid-rowgroup-header ' + (isHidden ? '' : 'is-expanded') + '" role="rowgroup"><td role="gridcell" colspan="'+ this.visibleColumns().length +'">' +
          Formatters.GroupRow(dataRowIdx, 0, null, null, rowData, this) +
          '</td></tr>';
        return rowHtml;
      }

      if (this.settings.groupable && isGroup && isFooter) {
        rowHtml = '<tr class="datagrid-row datagrid-rowgroup-footer ' + (isHidden ? '' : 'is-expanded') + '" role="rowgroup">' +
          Formatters.GroupFooterRow(dataRowIdx, 0, null, null, rowData, this) +
          '</tr>';
        return rowHtml;
      }

      var ariaRowindex = ((dataRowIdx + 1) + (self.settings.source  ? ((activePage-1) * pagesize) : 0));
      if (this.settings.indeterminate) {
        ariaRowindex = (dataRowIdx + 1);
      }

      isEven = (this.recordCount % 2 === 0);

      rowHtml = '<tr role="row" aria-rowindex="' + ariaRowindex + '"' +
                ' data-index="' + actualIndex + '"' +
                (self.settings.treeGrid && rowData.children ? ' aria-expanded="' + (rowData.expanded ? 'true"' : 'false"') : '') +
                (self.settings.treeGrid ? ' aria-level= "' + depth + '"' : '') +
                ' class="datagrid-row'+
                (isHidden ? ' is-hidden' : '') +
                (self.settings.alternateRowShading && !isEven ? ' alt-shading' : '') +
                (isSummaryRow ? ' datagrid-summary-row' : '') +
                (!self.settings.cellNavigation ? ' is-clickable' : '' ) +
                (self.settings.treeGrid ? (rowData.children ? ' datagrid-tree-parent' : (depth > 1 ? ' datagrid-tree-child' : '')) : '') +
                 '"' + '>';

      for (var j = 0; j < self.settings.columns.length; j++) {
        var col = self.settings.columns[j],
          cssClass = '',
          formatter = isSummaryRow ? col.summaryRowFormatter || col.formatter || self.defaultFormatter : col.formatter || self.defaultFormatter,
          formatted = self.formatValue(
            formatter,
            dataRowIdx,
            j,
            self.fieldValue(rowData, self.settings.columns[j].field),
            self.settings.columns[j],
            rowData,
            self
          );

        if (formatted.indexOf('<span class="is-readonly">') === 0) {
          col.readonly = true;
        }

        if (formatted.indexOf('datagrid-checkbox') > -1 ||
          formatted.indexOf('btn-actions') > -1) {
          cssClass += ' l-center-text';
        }

        if (formatted.indexOf('trigger') > -1) {
          cssClass += ' datagrid-trigger-cell';
        }

        if (col.expanded) {
          self.treeExpansionField = col.expanded;
        }

        if (col.align) {
          cssClass += ' l-'+ col.align +'-text';
        }

        if (col.textOverflow === 'ellipsis') {
          cssClass += ' text-ellipsis';
        }

        // Add Column Css Classes

        //Add a readonly class if set on the column
        cssClass += (col.readonly ? ' is-readonly' : '');
        cssClass += (col.hidden ? ' is-hidden' : '');

        //Run a function that helps check if editable
        if (col.isEditable && !col.readonly) {
          var canEdit = col.isEditable(ariaRowindex - 1, j, self.fieldValue(rowData, self.settings.columns[j].field), col, rowData);

          if (!canEdit) {
            cssClass += ' is-readonly';
          }
        }

        //Run a function that helps check if readonly
        var ariaReadonly = (col.id !== 'selectionCheckbox' &&
          (col.readonly || col.editor === undefined)) ?
          'aria-readonly="true"': '';

        if (col.isReadonly && !col.readonly && col.id !== 'selectionCheckbox') {
          var isReadonly = col.isReadonly(this.recordCount, j, self.fieldValue(rowData, self.settings.columns[j].field), col, rowData);

          if (isReadonly) {
            cssClass += ' is-cell-readonly';
            ariaReadonly = 'aria-readonly="true"';
          }
        }

        var cellValue = self.fieldValue(rowData, self.settings.columns[j].field);

        //Run a function that dynamically adds a class
        if (col.cssClass && typeof col.cssClass === 'function') {
          cssClass += ' ' + col.cssClass(this.recordCount, j, cellValue, col, rowData);
        }

        cssClass += (col.focusable ? ' is-focusable' : '');

        var rowspan = this.calculateRowspan(cellValue, dataRowIdx, col);

        if (rowspan === '') {
          continue;
        }

        //Set Width of table col / col group elements
        var colWidth = '';
        if (this.recordCount === 0 || this.recordCount - ((activePage-1) * pagesize) === 0) {
          colWidth = this.calculateColumnWidth(col, j);
          self.bodyColGroupHtml += '<col' + colWidth + (col.hidden ? ' class="is-hidden"' : '') + '></col>';
        }

        rowHtml += '<td role="gridcell" ' + ariaReadonly + ' aria-colindex="' + (j+1) + '" '+
            ' aria-describedby="' + self.uniqueId('-header-' + j) + '"' +
           (cssClass ? ' class="' + cssClass + '"' : '') +
           (col.tooltip && typeof col.tooltip === 'string' ? ' title="' + col.tooltip.replace('{{value}}', cellValue) + '"' : '') +
           (col.id === 'rowStatus' && rowData.rowStatus && rowData.rowStatus.tooltip ? ' title="' + rowData.rowStatus.tooltip + '"' : '') +
           (self.settings.columnGroups ? 'headers = "' + self.uniqueId('-header-' + j) + ' ' + self.getColumnGroup(j) + '"' : '') +
           (rowspan ? rowspan : '' ) +
           '><div class="datagrid-cell-wrapper">';

        if (col.contentVisible) {
          var canShow = col.contentVisible(dataRowIdx + 1, j, cellValue, col, rowData);
          if (!canShow) {
            formatted = '';
          }
        }

        rowHtml += formatted + '</div></td>';
      }

      rowHtml += '</tr>';

      if (self.settings.rowTemplate) {
        var tmpl = self.settings.rowTemplate,
          item = rowData,
          renderedTmpl = '';

        if (Tmpl && item) {
          var compiledTmpl = Tmpl.compile('{{#dataset}}'+tmpl+'{{/dataset}}');
          renderedTmpl = compiledTmpl.render({dataset: item});
        }

        rowHtml += '<tr class="datagrid-expandable-row"><td colspan="'+ this.visibleColumns().length +'">' +
          '<div class="datagrid-row-detail"><div class="datagrid-row-detail-padding">'+ renderedTmpl + '</div></div>' +
          '</td></tr>';
      }

      //Render Tree Children
      if (rowData.children) {
        for (i=0, l=rowData.children.length; i<l; i++) {
          this.recordCount++;
          rowHtml += self.rowHtml(rowData.children[i], this.recordCount, i);
        }
      }

      return rowHtml;
    },

    canvas:  null,
    totalWidth: 0,

    //This Function approximates the table auto widthing
    //Except use all column values and compare the text width of the header as max
    calculateTextWidth: function (columnDef) {
      var max = 0,
        self = this,
        field = columnDef.field,
        maxText = '',
        title = columnDef.name || '',
        chooseHeader = false;

      //Get max cell value length for this column
      for (var i = 0; i < this.settings.dataset.length; i++) {
        var val = this.fieldValue(this.settings.dataset[i], field),
           len = 0;

        //Get formatted value (without html) so we have accurate string that will display for this cell
        val = self.formatValue(columnDef.formatter, i, null, val, columnDef, this.settings.dataset[i], self);
        val = val.replace(/<\/?[^>]+(>|$)/g, '');

        len = val.toString().length;

        if (len > max) {
          max = len;
          maxText = val;
        }
      }

      //Use header text length as max if bigger than all data cells
      if (title.length > max) {
        max = title.length;
        maxText = title;
        chooseHeader = true;
      }

      if (maxText === '' || this.settings.dataset.length === 0) {
        maxText = columnDef.name || ' Default ';
        chooseHeader = true;
      }

      // if given, use cached canvas for better performance, else, create new canvas
      this.canvas = this.canvas || (this.canvas = document.createElement('canvas'));
      var context = this.canvas.getContext('2d');
      context.font = '14px arial';
      var metrics = context.measureText(maxText);
      return Math.round(metrics.width + (chooseHeader ? 60 : 52));  //Add padding and borders
    },

    headerWidths: [], //Cache

    headerTableWidth: function () {
      var cacheWidths = this.headerWidths[this.settings.columns.length-1];

      if (!cacheWidths) {
        return '';
      }
      this.setScrollClass();

      if (cacheWidths.widthPercent) {
        return 'style = "width: 100%"';
      } else if (!isNaN(this.totalWidth)) {
        return 'style = "width: ' + parseFloat(this.totalWidth) + 'px"';
      }

      return '';
    },

    setScrollClass: function () {
      var height = parseInt(this.contentContainer[0].offsetHeight),
          hasScrollBar = parseInt(this.contentContainer[0].scrollHeight) > height + 2;

      this.element.removeClass('has-vertical-scroll has-less-rows');

      if (hasScrollBar) {
        this.element.addClass('has-vertical-scroll');
      }

      if (!hasScrollBar && this.tableBody[0].offsetHeight <  height) {
        this.element.addClass('has-less-rows');
      }

    },

    clearHeaderCache: function () {
      this.headerWidths = [];
      this.totalWidth = 0;
      this.elemWidth = 0;
    },

    //Calculate the width for a column (upfront with no rendering)
    //https://www.w3.org/TR/CSS21/tables.html#width-layout
    calculateColumnWidth: function (col, index) {
      var visibleColumns, colPercWidth;
      visibleColumns = this.visibleColumns(true);

      if (!this.elemWidth) {
        this.elemWidth = this.element.outerWidth();

        if (this.elemWidth === 0) { // handle on invisible tab container
          this.elemWidth = this.element.closest('.tab-container').outerWidth();
        }
        if (!this.elemWidth || this.elemWidth === 0) { // handle on invisible modal
          this.elemWidth = this.element.closest('.modal-contents').outerWidth();
        }

        this.widthSpecified = false;
        this.widthPixel = false;
      }

        // use cache
      if (this.headerWidths[index]) {
        var cacheWidths = this.headerWidths[index];

        if (cacheWidths.width === 'default') {
          return '';
        }

        if (this.widthSpecified && !cacheWidths.width) {
          return '';
        }

        return ' style="width: '+ cacheWidths.width + (cacheWidths.widthPercent ? '%' :'px') + '"';
      }

      //A column element with a value other than 'auto' for the 'width' property sets the width for that column.
      if (col.width) {
        this.widthSpecified = true;
        this.widthPercent = false;
      }

      if (!this.widthPixel && col.width) {
        this.widthPixel = typeof col.width !== 'string';
      }

      var colWidth = col.width;

      if (typeof col.width === 'string' && col.width.indexOf('px') === -1) {
        this.widthPercent = true;
        colPercWidth = col.width.replace('%', '');
      }

      var textWidth = this.calculateTextWidth(col);  //reasonable default on error

      if (!this.widthSpecified || !colWidth) {
        colWidth = Math.max(textWidth, colWidth || 0);
      }

      var lastColumn = index === this.lastColumnIdx() && this.totalWidth !== colWidth;

      // Simulate Auto Width Algorithm
      if ((!this.widthSpecified || col.width === undefined) && this.settings.sizeColumnsEqually &&
        (['selectionCheckbox', 'expander', 'drilldown', 'rowStatus', 'favorite'].indexOf(col.id) === -1)) {

        var percentWidth = Math.round(this.elemWidth / visibleColumns.length);
        colWidth = percentWidth - (lastColumn ? 2 : 0); //borders causing scroll

        //Handle Columns where auto width is bigger than the percent width
        if (percentWidth < textWidth) {
          colWidth = textWidth;
        }

      }

      //Some Built in columns
      if (col.id === 'selectionCheckbox' || col.id === 'favorite') {
        colWidth = 43;
        col.width = colWidth;
      }

      if (col.id === 'expander') {
        colWidth = 55;
        col.width = colWidth;
      }

      if (col.id === 'rowStatus') {
        colWidth = 62;
        col.width = colWidth;
      }

      if (col.id === 'drilldown') {
        colWidth = 78;
        col.width = colWidth;
      }

      // cache the header widths
      this.headerWidths[index] = {id: col.id, width: (this.widthPercent ? colPercWidth : colWidth), widthPercent: this.widthPercent};
      this.totalWidth += col.hidden || lastColumn ? 0 : colWidth;

      //For the last column stretch it if it doesnt fit the area
      if (lastColumn) {
        var diff = this.elemWidth - this.totalWidth;

        if ((diff > 0) && diff  > colWidth && !this.widthPercent && !this.headerRow) {
          colWidth = diff - 2;
          this.headerWidths[index] = {id: col.id, width: colWidth, widthPercent: this.widthPercent};
          col.width = colWidth;
          this.totalWidth =  this.elemWidth -2;
        }

        if (this.widthPercent) {
          this.table.css('width', '100%');
        } else if (!isNaN(this.totalWidth)) {
          this.table.css('width', this.totalWidth);
        }
      }

      if (!this.widthPercent && !colWidth) {
        return '';
      }

      return ' style="width: '+ (this.widthPercent ? colPercWidth + '%' : colWidth + 'px') + '"';
    },

    widthPercent: false,
    rowSpans: [],

    calculateRowspan: function (value, row, col) {
      var cnt = 0, min = null;

      if (!col.rowspan) {
        return;
      }

      for (var i = 0; i < this.settings.dataset.length; i++) {
        if (value === this.settings.dataset[i][col.field]) {
          cnt++;
          if (min === null) {
            min = i;
          }
        }
      }

      if (row === min) {
        return ' rowspan ="'+ cnt + '"';
      }
      return '';
    },

    //Summary Row Totals use the aggregators
    calculateTotals: function() {
      this.settings.totals = Aggregators.aggregate(this.settings.dataset, this.settings.columns);
      return this.settings.totals;
    },

    // Set unit type (pixel or percent)
    setUnit: function(v) {
      return v + (/(px|%)/i.test(v + '') ? '' : 'px');
    },

    // Content tooltip for rich text editor
    setupContentTooltip: function (elem, width, td) {
      if (elem.text().length > 0) {
        var content = elem.clone();

        elem.tooltip({
          content: content,
          extraClass: 'alternate content-tooltip',
          placementOpts: {
            parent: elem,
            parentXAlignment: 'center',
            strategies: ['flip', 'nudge', 'shrink']
          }
        });

        if (width) {
          content[0].style.width = width;
        } else {
          elem.on('beforeshow.datagrid', function () {
            elem.off('beforeshow.datagrid');
            content[0].style.width = td[0].offsetWidth + 'px';
          });
        }
      }
    },

    setupTooltips: function () {
      if (!this.settings.enableTooltips) {
        return;
      }

      var self = this;
      // Implement Tooltip on cells with title attribute
      this.tableBody.find('td[title]').tooltip({placement: 'left', offset: {left: -5, top: 0}});
      this.tableBody.find('a[title]').tooltip();

      // Implement Tooltip on cells with ellipsis
      this.table.find('td.text-ellipsis').tooltip({content: function() {
        var cell = $(this),
          text = cell.text(),
          inner = cell.children('.datagrid-cell-wrapper');

        if (cell[0] && inner[0] && (inner[0].offsetWidth)< inner[0].scrollWidth && cell.data('tooltip')) {
          var w = inner.width();
          cell.data('tooltip').settings.maxWidth = w;
          return text;
        }

        return '';
      }});

      // Rich text editor content tooltip
      this.table.find('td .is-editor.content-tooltip').each(function() {
        var elem = $(this),
          td = elem.closest('td'),
          cell = td.attr('aria-colindex') - 1,
          col = self.columnSettings(cell),
          width = col.editorOptions && col.editorOptions.width ? self.setUnit(col.editorOptions.width) : false;

        self.setupContentTooltip(elem, width, td);
      });
    },

    //Returns all header nodes (not the groups)
    headerNodes: function () {
      return this.headerRow.find('tr:not(.datagrid-header-groups) th');
    },

    //Refresh one row in the grid
    updateRow: function (idx, data) {
      var rowData = (data ? data : this.settings.dataset[idx]);

      for (var j = 0; j < this.settings.columns.length; j++) {
        var col = this.settings.columns[j];

        if (col.hidden) {
          continue;
        }

        if (col.id && ['selectionCheckbox', 'expander'].indexOf(col.id) > -1) {
          continue;
        }

        this.updateCellNode(idx, j, this.fieldValue(rowData, col.field), true);
      }

    },

    //given a new column set update the rows and reload
    updateColumns: function(columns, columnGroups) {
      this.settings.columns = columns;

      if (columnGroups) {
        this.settings.columnGroups = columnGroups;
      }

      this.clearHeaderCache();
      this.renderRows();
      this.renderHeader();
      this.resetPager('updatecolumns');
      this.element.trigger('columnchange', [{type: 'updatecolumns', columns: this.settings.columns}]);
      this.saveColumns();
      this.saveUserSettings();
    },

    saveColumns: function () {
      if (!this.settings.saveColumns) {
        return;
      }

      //Save to local storage
      if (this.canUseLocalStorage()) {
        localStorage[this.uniqueId('columns')] = JSON.stringify(this.settings.columns);
      }
    },

    // Omit events and save to local storage for supported settings
    saveUserSettings: function () {

      // Emit Event
      this.element.trigger('settingschanged', [{rowHeight: this.settings.rowHeight,
        columns: this.settings.columns,
        sortOrder: this.sortColumn,
        pagesize: this.settings.pagesize,
        activePage: this.pager ? this.pager.activePage : 1,
        filter: this.filterConditions()}]);

      // Save to Local Storage if the options are set
      var options = this.settings.saveUserSettings;
      if ($.isEmptyObject(options) || !this.canUseLocalStorage()) {
        return;
      }

      // Save Columns
      if (options.columns) {
        localStorage[this.uniqueId('usersettings-columns')] = JSON.stringify(this.settings.columns);
      }

      // Save Row Height
      if (options.rowHeight) {
        localStorage[this.uniqueId('usersettings-row-height')] = this.settings.rowHeight;
      }

      // Save Sort Order
      if (options.sortOrder) {
        localStorage[this.uniqueId('usersettings-sort-order')] = JSON.stringify(this.sortColumn);
      }

      // Save Page Size
      if (options.pagesize) {
        localStorage[this.uniqueId('usersettings-pagesize')] = this.settings.pagesize;
      }

      // Save Page Num
      if (options.activePage && this.pager) {
        localStorage[this.uniqueId('usersettings-active-page')] = this.pager.activePage;
      }

      // Filter Conditions
      if (options.filter) {
        localStorage[this.uniqueId('usersettings-filter')] = JSON.stringify(this.filterConditions());
      }

    },

    canUseLocalStorage: function () {
      try {
        if (localStorage.getItem) {
          return true;
        }
      } catch (exception) {
        return false;
      }
    },

    columnsFromString: function(columnStr) {
      if (!columnStr) {
        return;
      }

      var self = this,
        columns = JSON.parse(columnStr);

      if (!columns) {
        return [];
      }

      //Map back the missing functions/objects
      for (var i = 0; i < columns.length; i++) {
        var isHidden,
          orgCol = self.columnById(columns[i].id);

        if (orgCol) {
          orgCol = orgCol[0];
          isHidden = columns[i].hidden;

          $.extend(columns[i], orgCol);

          if (isHidden !== undefined) {
            columns[i].hidden = isHidden;
          }
        }
      }

      return columns;
    },

    // Restore the columns from a saved list or local storage
    restoreColumns: function (cols) {
      if (!this.settings.saveColumns || !this.canUseLocalStorage()) {
        return;
      }

      if (cols) {
        this.updateColumns(cols);
        return;
      }

      //Done on load as apposed to passed in
      var lsCols = localStorage[this.uniqueId('columns')];

      if (!cols && lsCols) {
        this.originalColumns = this.settings.columns;
        this.settings.columns = this.columnsFromString(lsCols);
        return;
      }

    },

    restoreUserSettings: function (settings) {
      var options = this.settings.saveUserSettings;

      if (!settings && ($.isEmptyObject(options) || !this.canUseLocalStorage())) {
        return;
      }

      // Restore The data thats passed in
      if (settings) {

        if (settings.columns) {
          this.updateColumns(settings.columns);
        }

        if (settings.rowHeight) {
          this.rowHeight(settings.rowHeight);
        }

        if (settings.sortOrder) {
          this.setSortColumn(settings.sortOrder.sortId, settings.sortOrder.sortAsc);
        }

        if (settings.pagesize) {
          this.settings.pagesize = parseInt(settings.pagesize);
          this.pager.settings.pagesize = parseInt(settings.pagesize);
          this.pager.setActivePage(1, true);
        }

        if (settings.activePage) {
          this.pager.setActivePage(parseInt(settings.activePage), true);
        }

        if (settings.filter) {
          this.applyFilter(settings.filter);
        }
        return;
      }

      // Restore Column Width and Order
      if (options.columns) {
        var savedColumns = localStorage[this.uniqueId('usersettings-columns')];
        this.originalColumns = this.settings.columns;

        if (savedColumns) {
          this.settings.columns = this.columnsFromString(savedColumns);
        }
      }

      // Restore Row Height
      if (options.rowHeight) {
        var savedRowHeight = localStorage[this.uniqueId('usersettings-row-height')];

        if (savedRowHeight) {
          this.settings.rowHeight = savedRowHeight;
        }
      }

      // Restore Sort Order
      if (options.sortOrder) {
        var savedSortOrder = localStorage[this.uniqueId('usersettings-sort-order')];
        if (savedSortOrder) {
          this.sortColumn = JSON.parse(savedSortOrder);
          this.restoreSortOrder = true;
        }
      }

      // Restore Page Size
      if (options.pagesize) {
        var savedPagesize = localStorage[this.uniqueId('usersettings-pagesize')];
        if (savedPagesize) {
          this.settings.pagesize = parseInt(savedPagesize);
        }
      }

      // Restore Active Page
      if (options.activePage) {
        var savedActivePage = localStorage[this.uniqueId('usersettings-active-page')];
        if (savedActivePage) {
          this.savedActivePage = parseInt(savedActivePage);
          this.restoreActivePage = true;
        }
      }

      if (options.filter) {
        var savedFilter = localStorage[this.uniqueId('usersettings-filter')];
        if (savedFilter) {
          this.savedFilter = JSON.parse(savedFilter);
          this.restoreFilter = true;
        }
      }

    },

    // Reset Columns from the Menu Option
    resetColumns: function () {
      if (this.canUseLocalStorage()) {
        localStorage.removeItem(this.uniqueId('columns'));
        localStorage[this.uniqueId('columns')] = '';
      }

      if (this.originalColumns) {
        this.updateColumns(this.originalColumns);
        this.originalColumns = this.columnsFromString(JSON.stringify(this.settings.columns));
      }
    },

    // Hide a column
    hideColumn: function(id) {
      var idx = this.columnIdxById(id);

      if (idx === -1) {
        return;
      }

      this.settings.columns[idx].hidden = true;
      this.headerRow.find('th').eq(idx).addClass('is-hidden');
      this.tableBody.find('td:nth-child('+ (idx+1) +')').addClass('is-hidden');
      this.headerColGroup.find('col').eq(idx).addClass('is-hidden');
      if (this.bodyColGroup) {
        this.bodyColGroup.find('col').eq(idx).addClass('is-hidden');
      }

      this.element.trigger('columnchange', [{type: 'hidecolumn', index: idx, columns: this.settings.columns}]);
      this.saveColumns();
      this.saveUserSettings();
    },

    //Show a hidden column
    showColumn: function(id) {
      var idx = this.columnIdxById(id);

      if (idx === -1) {
        return;
      }

      this.settings.columns[idx].hidden = false;
      this.headerRow.find('th').eq(idx).removeClass('is-hidden');
      this.tableBody.find('td:nth-child('+ (idx+1) +')').removeClass('is-hidden');
      this.headerColGroup.find('col').eq(idx).removeClass('is-hidden');
      if (this.bodyColGroup) {
        this.bodyColGroup.find('col').eq(idx).removeClass('is-hidden');
      }

      this.element.trigger('columnchange', [{type: 'showcolumn', index: idx, columns: this.settings.columns}]);
      this.saveColumns();
      this.saveUserSettings();
    },

    // Export To Excel
    exportToExcel: function (fileName, worksheetName, customDs) {
      var self = this,
        template = ''+
          '<html xmlns:o="urn:schemas-microsoft-com:office:office" xmlns:x="urn:schemas-microsoft-com:office:excel" xmlns="http://www.w3.org/TR/REC-html40">'+
            '<head>'+
              '<!--[if gte mso 9]>'+
                '<xml>'+
                  '<x:ExcelWorkbook>'+
                    '<x:ExcelWorksheets>'+
                      '<x:ExcelWorksheet>'+
                        '<x:Name>{worksheet}</x:Name>'+
                        '<x:WorksheetOptions>'+
                          '<x:Panes></x:Panes>'+
                          '<x:DisplayGridlines></x:DisplayGridlines>'+
                        '</x:WorksheetOptions>'+
                      '</x:ExcelWorksheet>'+
                    '</x:ExcelWorksheets>'+
                  '</x:ExcelWorkbook>'+
                '</xml>'+
              '<![endif]-->'+
              '<meta http-equiv="content-type" content="text/plain; charset=UTF-8"/>'+
            '</head>'+
            '<body>'+
              '<table border="1px solid #999999">{table}</table>'+
            '</body>'+
          '</html>',

        cleanExtra = function(table) {
          $('tr, th, td, div, span', table).each(function () {
            var el = this,
              elm = $(this);

            if (elm.is('.is-hidden')) {
              elm.remove();
              return;
            }

            $('.is-hidden, .is-draggable-target, .handle, .sort-indicator, .datagrid-filter-wrapper', el).remove();
            while(el.attributes.length > 0) {
              el.removeAttribute(el.attributes[0].name);
            }

            // White Hat Security Violation. Remove Excel formulas
            // Excel Formulas Start with =SOMETHING
            var text = elm.text();
            if (text.substr(0, 1) === '=' && text.substr(1, 1) !== '') {
              elm.text('\'' + elm.text());
            }
          });
          return table;
        },

        base64 = function(s) {
          if (window.btoa) {
            return 'data:application/vnd.ms-excel;base64,' + window.btoa(unescape(encodeURIComponent(s)));
          } else {
            return 'data:application/vnd.ms-excel;,' + unescape(encodeURIComponent(s));
          }
        },

        format = function(s, c) {
          return s.replace(/{(\w+)}/g, function(m, p) {
            return c[p];
          });
        },

        appendRows = function(dataset, table) {
          var tableHtml,
            body = table.find('tbody').empty();

          for (var i = 0; i < dataset.length; i++) {
            if (!dataset[i].isFiltered) {
              tableHtml += self.rowHtml(dataset[i], i, i);
            }
          }

          body.append(tableHtml);
          return table;
        };

      var table = self.table.clone();
      table = appendRows(customDs || this.settings.dataset, table);

      if (!table.find('thead').length) {
        self.headerRow.clone().insertBefore(table.find('tbody'));
      }

      table = cleanExtra(table);
      var ctx = { worksheet: (worksheetName || 'Worksheet'), table: table.html() };

      fileName = (fileName ||
        self.element.closest('.datagrid-container').attr('id') ||
        'datagrid') +'.xls';

      if (this.isIe) {
        if (this.isIe9) {
          var IEwindow = window.open();
          IEwindow.document.write('sep=,\r\n' + format(template, ctx));
          IEwindow.document.close();
          IEwindow.document.execCommand('SaveAs', true, fileName);
          IEwindow.close();
        }
        else if (window.navigator.msSaveBlob) {
          var blob = new Blob([format(template, ctx)], {
            type: 'application/csv;charset=utf-8;'
          });
          navigator.msSaveBlob(blob, fileName);
        }
      }
      else {
        var link = document.createElement('a');
        link.href = base64(format(template, ctx));
        link.download = fileName;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
      }
    },

    //Open Column Personalization Dialog
    personalizeColumns: function () {
      var self = this,
        markup = '<div class="listview-search alternate-bg"><label class="audible" for="gridfilter">Search</label><input class="searchfield" placeholder="'+ Locale.translate('SearchColumnName') +'" name="searchfield" id="gridfilter"></div>';

        markup += '<div class="listview alternate-bg" id="search-listview"><ul>';

        for (var i = 0; i < this.settings.columns.length; i++) {
          var col = this.settings.columns[i],
            name = col.name;

          if (name) {
            name = name.replace('<br>', ' ').replace('<br/>', ' ').replace('<br />', ' ');
            markup += '<li><a href="#" target="_self" tabindex="-1"> <label class="inline"><input tabindex="-1" ' + (col.hideable ===false ? 'disabled' : '') + ' type="checkbox" class="checkbox" '+ (col.hidden ? '' : ' checked') +' data-column-id="'+ (col.id || i) +'"><span class="label-text">' + name + '</span></label></a></li>';
          }
        }
        markup += '</ul></div>';

        $('body').modal({
          title: Locale.translate('PersonalizeColumns'),
          content: markup,
          cssClass: 'full-width datagrid-columns-dialog',
          buttons: [{
              text: Locale.translate('Close'),
              click: function(e, modal) {
                modal.close();
                $('body').off('open.datagrid');
              }
            }]
        }).on('beforeopen.datagrid', function () {
          self.isColumnsChanged = false;
        }).on('open.datagrid', function (e, modal) {
          modal.element.find('.searchfield').searchfield({clearable: true});
          modal.element.find('.listview').listview({searchable: true, selectOnFocus: false})
            .on('selected', function (e, args) {
              var chk = args.elem.find('.checkbox'),
                  id = chk.attr('data-column-id'),
                  isChecked = chk.prop('checked');

              args.elem.removeClass('is-selected hide-selected-color');

              if (chk.is(':disabled')) {
                return;
              }
              self.isColumnsChanged = true;

              if (!isChecked) {
                self.showColumn(id);
                chk.prop('checked', true);
              } else {
                self.hideColumn(id);
                chk.prop('checked', false);
              }
            });

          modal.element.on('close.datagrid', function () {
            self.isColumnsChanged = false;
          });

      });
    },

    // Explicitly Set the Width of a column
    setColumnWidth: function(idOrNode, width, diff) {
      var self = this,
        percent = parseFloat(width),
        columnNode = idOrNode,
        columnSettings = this.columnById(typeof idOrNode === 'string' ? idOrNode : idOrNode.attr('data-column-id'));

      if (!percent) {
        return;
      }

      if (typeof idOrNode === 'string') {
        self.headerNodes().each(function () {
          var col = $(this);

          if (col.attr('data-column-id') === idOrNode) {
            columnNode = col;
          }

        });
      }

      //Handles min width on some browsers
      if ((columnSettings.minWidth && width > parseInt(columnSettings.minWidth))) {
        return;
      }

      //calculate percentage
      if (typeof width !=='number') {
        width = percent / 100 * self.element.width();
      }

      //Prevent Sub Pixel Thrashing
      if (Math.abs(width - columnSettings[0].width) < 2) {
        return;
      }

      // Save the column back in settings for later
      if (columnSettings[0]) {
        columnSettings[0].width = width;
      }

      var idx = columnNode.index();
      self.headerColGroup.find('col').eq(idx)[0].style.width = (width + 'px');

      if (self.settings.dataset.length > 0) {
        self.bodyColGroup.find('col').eq(idx)[0].style.width = (width + 'px');
      }

      if (self.tableWidth && diff) {
        self.headerTable.css('width', parseInt(self.tableWidth) + diff);
        self.table.css('width', parseInt(self.tableWidth) + diff);
      }

      this.element.trigger('columnchange', [{type: 'resizecolumn', index: idx, columns: this.settings.columns}]);
      this.saveColumns();
      this.saveUserSettings();
      this.clearHeaderCache();
    },

    //Generate Resize Handles
    createResizeHandle: function() {
      var self = this;
      if (this.resizeHandle) {
        return;
      }

      this.resizeHandle = $('<div class="resize-handle" aria-hidden="true"></div>');
      if (this.settings.columnGroups) {
        this.resizeHandle[0].style.height = '80px';
      }

      if (this.settings.filterable) {
        this.resizeHandle[0].style.height = '62px';
      }

      this.headerContainer.find('table').before(this.resizeHandle);

      var columnId, startingLeft, columnStartWidth, columnDef;

      this.resizeHandle.drag({axis: 'x', containment: 'parent'})
        .on('dragstart.datagrid', function () {
          if (!self.currentHeader) {
            return;
          }

          self.dragging = true;

          columnId = self.currentHeader.attr('data-column-id');
          columnDef = self.columnById(columnId)[0];

          startingLeft = self.currentHeader.position().left + self.table.scrollLeft() - 10;
          self.tableWidth = self.table[0].offsetWidth;
          columnStartWidth = self.currentHeader[0].offsetWidth;

        })
        .on('drag.datagrid', function (e, ui) {
          if (!self.currentHeader) {
            return;
          }

          var width = (ui.left - startingLeft -1),
            minWidth = columnDef.minWidth || 12,
            maxWidth = columnDef.maxWidth || 1000;

          if (width < minWidth || width> maxWidth) {
            self.resizeHandle.css('cursor', 'inherit');
            return;
          }

          width = Math.round(width);
          self.setColumnWidth(self.currentHeader, width, width - columnStartWidth);
        })
        .on('dragend.datagrid', function () {
          self.dragging = false;
        });
    },

    //Show Summary and any other count info
    displayCounts: function(totals) {
      var self = this,
        count = self.tableBody.find('tr:visible').length,
        isClientSide = self.settings.paging && !(self.settings.source);

      if (isClientSide || (!totals && !self.settings.paging)) {
        count = self.recordCount;
      }

      //Update Selected
      if (self.contextualToolbar && self.contextualToolbar.length) {
        self.contextualToolbar.find('.selection-count').text(self._selectedRows.length + ' ' + Locale.translate('Selected'));
      }

      if (self.settings.source && !totals) {
        return;
      }

      if (totals && totals !== -1) {
        count = totals;
      }

      var countText = '(' + count + ' ' + Locale.translate(count === 1 ? 'Result' : 'Results') + ')';
      if (self.settings.resultsText) {
        if (typeof self.settings.resultsText === 'function') {
          countText = self.settings.resultsText(self, count);
        } else {
          countText = self.settings.resultsText;
        }
      }

      if (self.toolbar) {
        self.toolbar.find('.datagrid-result-count').html(countText);
        self.toolbar.attr('aria-label',  self.toolbar.find('.title').text());
        self.toolbar.find('.datagrid-row-count').text(count);
      }
      self.element.closest('.modal').find('.datagrid-result-count').html(countText);

    },

    //Trigger event on parent and compose the args
    triggerRowEvent: function (eventName, e, stopPropagation) {
      var self = this,
          cell = $(e.target).closest('td').index(),
          row = $(e.target).closest('tr').index(),
          item = self.settings.dataset[row];

      if ($(e.target).is('a')) {
        stopPropagation = false;
      }

      if (stopPropagation) {
        e.stopPropagation();
        e.preventDefault();
      }

      self.element.trigger(eventName, [{row: row, cell: cell, item: item, originalEvent: e}]);
      return false;
    },

    //Returns a cell node
    cellNode: function (row, cell, includeGroups) {
      var cells,
        rowNode = this.tableBody.find('tr:not(.datagrid-expandable-row)[aria-rowindex="'+ (row + 1) +'"]');

      if (row instanceof jQuery) {
        rowNode = row;
      }

      if (includeGroups && this.settings.groupable) {
        rowNode = this.tableBody.prevAll('.datagrid-rowgroup-header').eq(row);
        if (rowNode) {
          rowNode = this.tableBody.find('.datagrid-rowgroup-header').eq(row);
        }
      }

      if (cell === -1) {
        return $();
      }

      cells = rowNode.find('td');
      return cells.eq(cell >= cells.length ? cells.length-1 : cell);
    },

    scrollLeft: 0,
    scrollTop: 0,
    handleScroll: function() {
      var left = this.contentContainer[0].scrollLeft;

      if (left !== this.scrollLeft && this.headerContainer) {
        this.scrollLeft = left;
        this.headerContainer[0].scrollLeft = this.scrollLeft;
      }

    },

    // Attach All relevant events
    handleEvents: function() {
      var self = this,
        isMultiple = this.settings.selectable === 'multiple',
        isMixed = this.settings.selectable === 'mixed';

      // Set Focus on rows
      if (!self.settings.cellNavigation && self.settings.rowNavigation) {
        self.table
        .on('focus.datagrid', 'tbody > tr', function () {
            $(this).addClass('is-active-row');
        })
        .on('blur.datagrid', 'tbody > tr', function () {
          $('tbody > tr', self.table).removeClass('is-active-row');
        });
      }

      //Sync Header and Body During scrolling
      self.contentContainer
        .on('scroll.table',function () {
          self.handleScroll();
        });

      if (this.settings.virtualized) {
        var oldScroll = 0, oldHeight = 0;

      self.contentContainer
        .on('scroll.vtable', Soho.utils.debounce(function () {

          var scrollTop = this.scrollTop,
            buffer = 25,
            hitBottom = scrollTop > (self.virtualRange.bottom - self.virtualRange.bodyHeight - buffer),
            hitTop = scrollTop < (self.virtualRange.top + buffer);

          if (scrollTop !== oldScroll && (hitTop || hitBottom)) {
            oldScroll = this.scrollTop;
            self.renderRows();
            return;
          }
        }, 0));

        $('body').on('resize.vtable', function () {
          var height = this.offsetHeight;

          if (height !== oldHeight) {
            oldHeight = this.scrollTop;
            self.renderRows();
          }

        });
      }

      //Handle Sorting
      this.element
        .off('click.datagrid')
        .on('click.datagrid', 'th.is-sortable', function (e) {
          if ($(e.target).parent().is('.datagrid-filter-wrapper')) {
            return;
          }

          self.setSortColumn($(this).attr('data-column-id'));
        });

      //Prevent redirects
      this.table
        .off('mouseup.datagrid touchstart.datagrid')
        .on('mouseup.datagrid touchstart.datagrid', 'a', function (e) {
        e.preventDefault();
      });

      //Handle Row Clicking
      var tbody = this.table.find('tbody');
      tbody.off('click.datagrid').on('click.datagrid', 'td', function (e) {
        var rowNode, dataRowIdx,
          target = $(e.target);

        if (target.closest('.datagrid-row-detail').length === 1) {
          return;
        }

        self.triggerRowEvent('click', e, true);
        self.setActiveCell(target.closest('td'));

        //Dont Expand rows or make cell editable when clicking expand button
        if (target.is('.datagrid-expand-btn') || (target.is('.datagrid-cell-wrapper') && target.find('.datagrid-expand-btn').length)) {
          rowNode = $(this).closest('tr');
          dataRowIdx = self.dataRowIndex(rowNode);

          self.toggleRowDetail(dataRowIdx);
          self.toggleGroupChildren(rowNode);
          self.toggleChildren(e, dataRowIdx);
          return false;
        }

        var isSelectionCheckbox = target.is('.datagrid-selection-checkbox') ||
                                  target.find('.datagrid-selection-checkbox').length === 1,
          canSelect = self.settings.clickToSelect ? true : isSelectionCheckbox;

        if (target.is('.datagrid-drilldown')) {
          canSelect = false;
        }

        if (isMixed) {
          canSelect = isSelectionCheckbox;

          //Then Activate
          if (!canSelect) {
            self.toggleRowActivation(target.closest('tr'));
          }
        }

        if (canSelect && isMultiple && e.shiftKey) {
          self.selectRowsBetweenIndexes([self.lastSelectedRow, target.closest('tr').index()]);
          e.preventDefault();
        } else if (canSelect) {
          self.toggleRowSelection(target.closest('tr'));
        }

        self.lastClicked = target;
        self.makeCellEditable(self.activeCell.row, self.activeCell.cell, e);

        //Handle Cell Click Event
        var elem = $(this).closest('td'),
          cell = elem.parent().children(':visible').index(elem),
          col = self.columnSettings(cell, true);

        if (col.click && typeof col.click === 'function' && (target.is('button, input[checkbox], a') || target.parent().is('button'))) {

          var rowElem = $(this).closest('tr'),
            rowIdx = self.dataRowIndex(rowElem),
            item = self.settings.treeGrid ?
              self.settings.treeDepth[rowIdx].node :
              self.settings.dataset[self.pager && self.settings.source ? rowElem.index() : rowIdx];

          if (elem.hasClass('is-focusable')) {
            if (!target.is(self.settings.buttonSelector)) {
              if (!target.parent('button').is(self.settings.buttonSelector)) {
                return;
              }
            }
          }

          if (!elem.hasClass('is-cell-readonly') && (target.is('button, input[checkbox], a') || target.parent().is('button'))) {
            col.click(e, [{row: rowIdx, cell: self.activeCell.cell, item: item, originalEvent: e}]);
          }
        }

        //Handle Context Menu on Some
        if (col.menuId) {
          var btn = $(this).find('button');
          btn.popupmenu({attachToBody: true, autoFocus: false, mouseFocus: true,  menuId: col.menuId, trigger: 'immediate', offset: { y: 5 }});

          if (col.selected) {
            btn.on('selected.datagrid', col.selected);
          }
        }

        // Apply Quick Edit Mode
        if (self.isCellEditable(dataRowIdx, cell)) {
          setTimeout(function() {
            if ($('textarea, input', elem).length &&
                (!$('.dropdown,' +
                '[type=image],' +
                '[type=button],' +
                '[type=submit],' +
                '[type=reset],' +
                '[type=checkbox],' +
                '[type=radio]', elem).length)) {
              self.quickEditMode = true;
            }
          }, 0);
        }

      });

      tbody.off('dblclick.datagrid').on('dblclick.datagrid', 'tr', function (e) {
        self.triggerRowEvent('dblclick', e, true);
      });

      //Handle Context Menu Option
      tbody.off('contextmenu.datagrid').on('contextmenu.datagrid', 'tr', function (e) {

        if (!self.isSubscribedTo(e, 'contextmenu')) {
          return;
        }

        self.triggerRowEvent('contextmenu', e, (self.settings.menuId ? true : false));
        e.preventDefault();

        if (self.settings.menuId) {
          $(e.currentTarget).popupmenu({menuId: self.settings.menuId, eventObj: e, trigger: 'immediate'});
        }

        return false;
      });

      // Move the drag handle to the end or start of the column
      this.headerRow
        .off('mousemove.datagrid')
        .on('mousemove.datagrid', 'th', function (e) {
          if (self.dragging) {
            return;
          }

          self.currentHeader = $(e.target).closest('th');

          if (!self.currentHeader.hasClass('is-resizable')) {
            return;
          }

          var headerDetail = self.currentHeader.closest('.header-detail'),
            extraMargin = headerDetail.length ? parseInt(headerDetail.css('margin-left'), 10) : 0,
            leftEdge = parseInt(self.currentHeader.position().left) - (extraMargin || 0) + self.element.scrollLeft(),
            rightEdge = leftEdge + self.currentHeader.outerWidth(),
            alignToLeft = (e.pageX - leftEdge > rightEdge - e.pageX),
            leftPos = 0;

          //TODO: Test Touch support - may need handles on each column
          leftPos = (alignToLeft ? (rightEdge - 6): (leftEdge - 6));

          //Ignore First Column
          if (self.currentHeader.index() === 0 && !alignToLeft) {
            leftPos = '-999';
          }

          if (!alignToLeft) {
            self.currentHeader = self.currentHeader.prevAll().not('.is-hidden').first();
          }

          if (!self.currentHeader.hasClass('is-resizable')) {
            return;
          }

          self.createResizeHandle();
          self.resizeHandle[0].style.left = leftPos +'px';
          self.resizeHandle[0].style.cursor = '';
        });

      // Handle Clicking Header Checkbox
      this
        .headerRow
        .off('click.datagrid')
        .on('click.datagrid', 'th .datagrid-checkbox', function () {
          var checkbox = $(this);

          if (!checkbox.hasClass('is-checked')) {
            checkbox.addClass('is-checked').attr('aria-checked', 'true');

            self.selectAllRows();

          } else {
            checkbox.removeClass('is-checked').attr('aria-checked', 'true');
            self.unSelectAllRows();
          }
        });

      // Implement Editing Auto Commit Functionality
      tbody.off('focusout.datagrid').on('focusout.datagrid', 'td input, td textarea, div.dropdown', function (e) {

        // Keep icon clickable in edit mode
        var target = e.target;

        if ($(target).is('input.lookup, input.timepicker, input.datepicker, input.spinbox')) {
          // Wait for modal popup, if did not found modal popup means
          // icon was not clicked, then commit cell edit
          setTimeout(function() {
            if (!$('.lookup-modal.is-visible, #timepicker-popup, #calendar-popup').length &&
                !!self.editor && self.editor.input.is(target)) {

              if ($('*:focus').is('.spinbox')) {
                return;
              }
              self.commitCellEdit(self.editor.input);
            }

          }, 150);

          return;
        }

        //Popups are open
        if ($('#dropdown-list, .autocomplete.popupmenu.is-open, #timepicker-popup').is(':visible')) {
          return;
        }

        if (self.editor && self.editor.input) {
          self.lastClicked = null;
          self.commitCellEdit(self.editor.input);
        }

      });

    },

    //Check if the event is subscribed to
    isSubscribedTo: function (e, eventName) {
      var self = this;

      for (var event in $._data(self.element[0]).events) {
        if (event === eventName) {
          return true;
        }
      }

      return false;
    },

    // Adjust to set a changed row height
    refreshSelectedRowHeight: function () {
      var toolbar = this.element.parent().find('.toolbar:not(.contextual-toolbar)'),
        short = toolbar.find('[data-option="row-short"]'),
        med = toolbar.find('[data-option="row-medium"]'),
        normal = toolbar.find('[data-option="row-normal"]');

        if (this.settings.rowHeight === 'short') {
          short.parent().addClass('is-checked');
          med.parent().removeClass('is-checked');
          normal.parent().removeClass('is-checked');
        }

        if (this.settings.rowHeight === 'medium') {
          short.parent().removeClass('is-checked');
          med.parent().addClass('is-checked');
          normal.parent().removeClass('is-checked');
        }

        if (this.settings.rowHeight === 'normal') {
          short.parent().removeClass('is-checked');
          med.parent().removeClass('is-checked');
          normal.parent().addClass('is-checked');
        }

    },

     appendToolbar: function () {
      var toolbar, title = '', more, self = this;

      if (!settings.toolbar) {
        return;
      }

      //Allow menu to be added manually
      if (this.element.parent().find('.toolbar:not(.contextual-toolbar)').length === 1) {
        toolbar = this.element.parent().find('.toolbar:not(.contextual-toolbar)');
        this.refreshSelectedRowHeight();
      } else {
        toolbar = $('<div class="toolbar" role="toolbar"></div>');
        this.removeToolbarOnDestroy = true;

        if (settings.toolbar.title) {
          title = $('<div class="title">' + settings.toolbar.title + '  </div>');
        }

        if (!title) {
          title = toolbar.find('.title');
        }
        toolbar.append(title);

        if (settings.toolbar.results) {
          //Actually value filled in displayResults
          title.append('<span class="datagrid-result-count"></span>');
        }

        var buttonSet = $('<div class="buttonset"></div>').appendTo(toolbar);

        if (settings.toolbar.keywordFilter) {
          var labelMarkup = $('<label class="audible" for="gridfilter">'+ Locale.translate('Keyword') +'</label>'),
            searchfieldMarkup = $('<input class="searchfield" name="searchfield" placeholder="' + Locale.translate('Keyword') + '" id="gridfilter">');

          buttonSet.append(labelMarkup);

          if (!settings.toolbar.collapsibleFilter) {
            searchfieldMarkup.attr('data-options', '{ collapsible: false }');
          }

          buttonSet.append(searchfieldMarkup);
        }

        if (settings.toolbar.dateFilter) {
          buttonSet.append('<button class="btn" type="button">' + $.createIcon({ icon: 'calendar' }) + '<span>' + Locale.translate('Date') + '</span></button>');
        }

        if (settings.toolbar.actions) {
          more = $('<div class="more"></div>').insertAfter(buttonSet);
          more.append('<button class="btn-actions" title="More" type="button">' + $.createIcon({ icon: 'more' }) + '<span class="audible">Grid Features</span></button>');
          toolbar.addClass('has-more-button');
        }

        var menu = $('<ul class="popupmenu"></ul>');

        if (settings.toolbar.personalize) {
          menu.append('<li><a href="#" data-option="personalize-columns">' + Locale.translate('PersonalizeColumns') + '</a></li>');
        }

        if (settings.toolbar.resetLayout) {
          menu.append('<li><a href="#" data-option="reset-layout">' + Locale.translate('ResetDefault') + '</a></li>');
        }

        if (settings.toolbar.exportToExcel) {
          menu.append('<li><a href="#" data-option="export-to-excel">' + Locale.translate('ExportToExcel') + '</a></li>');
        }

        if (settings.toolbar.advancedFilter) {
          menu.append('<li><a href="#">' + Locale.translate('AdvancedFilter') + '</a></li>');
        }

        if (settings.toolbar.views) {
          menu.append('<li><a href="#">' + Locale.translate('SaveCurrentView') + '</a></li> ' +
            '<li class="separator"></li> ' +
            '<li class="heading">' + Locale.translate('SavedViews') + '</li>' +
            '<li><a href="#">View One</a></li>');
        }

        if (settings.toolbar.rowHeight) {
          menu.append('<li class="separator single-selectable-section"></li>' +
            '<li class="heading">' + Locale.translate('RowHeight') + '</li>' +
            '<li class="is-selectable' + (this.settings.rowHeight === 'short' ? ' is-checked' : '') + '"><a data-option="row-short">' + Locale.translate('Short') + '</a></li>' +
            '<li class="is-selectable' + (this.settings.rowHeight === 'medium' ? ' is-checked' : '') + '"><a data-option="row-medium">' + Locale.translate('Medium') + '</a></li>' +
            '<li class="is-selectable' + (this.settings.rowHeight === 'normal' ? ' is-checked' : '') + '"><a data-option="row-normal">' + Locale.translate('Normal') + '</a></li>');
        }

        if (settings.toolbar.filterRow) {
          menu.append('<li class="separator"></li>' +
            '<li class="heading">' + Locale.translate('Filter') + '</li>' +
            '<li class="' + (settings.filterable ? 'is-checked ' : '') + 'is-toggleable"><a data-option="show-filter-row">' + Locale.translate('ShowFilterRow') + '</a></li>' +
            '<li class="is-indented"><a data-option="run-filter">' + Locale.translate('RunFilter') + '</a></li>' +
            '<li class="is-indented"><a data-option="clear-filter">' + Locale.translate('ClearFilter') + '</a></li>');
        }

        if (settings.toolbar.actions) {
          more.append(menu);
        }

        if (this.element.prev().is('.contextual-toolbar')) {
          this.element.prev().before(toolbar);
        } else {
          this.element.before(toolbar);
        }
      }

      toolbar.find('.btn-actions').popupmenu().on('selected', function(e, args) {
        var action = args.attr('data-option');
        if (action === 'row-short' || action === 'row-medium' || action === 'row-normal') {
          self.rowHeight(action.substr(4));
        }

        if (action === 'personalize-columns') {
          self.personalizeColumns();
        }

        if (action === 'reset-layout') {
          self.resetColumns();
        }

        if (action === 'export-to-excel') {
          self.exportToExcel();
        }

        //Filter actions
        if (action === 'show-filter-row') {
          self.toggleFilterRow();
        }
        if (action === 'run-filter') {
          self.applyFilter();
        }
        if (action === 'clear-filter') {
          self.clearFilter();
        }
      });

      if (settings.initializeToolbar && !toolbar.data('toolbar')) {
        var opts = $.fn.parseOptions(toolbar);

        if (settings.toolbar.fullWidth) {
          opts.rightAligned = true;
        }

        toolbar.toolbar(opts);
      }

      toolbar.find('.searchfield').off('keypress.datagrid').on('keypress.datagrid', function (e) {
        if (e.keyCode === 13 || e.type==='change') {
          e.preventDefault();
          self.keywordSearch($(this).val());
        }
      });

      this.toolbar = toolbar;
      this.element.addClass('has-toolbar');
    },

    //Get or Set the Row Height
    rowHeight: function(height) {
      if (height) {
        settings.rowHeight = height;
      }

      this.element.add(this.table)
        .removeClass('short-rowheight medium-rowheight normal-rowheight')
        .addClass(settings.rowHeight + '-rowheight');

      if (this.virtualRange && this.virtualRange.rowHeight) {
        this.virtualRange.rowHeight = (height === 'normal' ? 40 : (height === 'medium' ? 30 : 25));
      }

      this.saveUserSettings();
      this.refreshSelectedRowHeight();
      return settings.rowHeight;
    },

    //Search a Term across all columns
    keywordSearch: function(term) {
      this.tableBody.find('tr[role="row"]').removeClass('is-filtered').show();
      this.filterExpr = [];

        this.tableBody.find('.datagrid-expandable-row').each(function () {
          var row = $(this);
          //Collapse All rows
          row.prev().find('.datagrid-expand-btn').removeClass('is-expanded');
          row.prev().find('.plus-minus').removeClass('active');
          row.removeClass('is-expanded').css('display', '');
          row.find('.datagrid-row-detail').css('height', '');
        });

      this.tableBody.find('.search-mode').each(function () {
        var cell = $(this),
          text = cell.text();
        cell.text(text.replace('<i>','').replace('</i>',''));
      });

      if (!term || term.length === 0) {
        this.displayCounts();

        if (this.pager) {
          this.resetPager('sorted');
        }

        return;
      }

      term = term.toLowerCase();
      this.filterExpr.push({column: 'all', operator: 'contains', value: term});

      this.highlightSearchRows(term);
      this.displayCounts();

      if (this.pager) {
        this.pager.setActivePage(1, true);
      }
    },

    highlightSearchRows: function (term) {
      // Move across all visible cells and rows, highlighting
      this.tableBody.find('tr').each(function () {
        var found = false,
          row = $(this);

          row.find('td').each(function () {
            var cell =  $(this),
              cellText = cell.text().toLowerCase();

            if (cellText.indexOf(term) > -1) {
              found = true;
              cell.find('*').each(function () {
                if (this.innerHTML === this.textContent) {
                  var contents = this.textContent,
                    node = $(this),
                    exp = new RegExp('(' + term + ')', 'i');

                  node.addClass('search-mode').html(contents.replace(exp, '<i>$1</i>'));
                }
              });
            }

          });

          // Hide non matching rows
          if (!found) {
            row.addClass('is-filtered').hide();
          } else if (found && row.is('.datagrid-expandable-row')) {
            row.prev().show();
            row.prev().find('.datagrid-expand-btn').addClass('is-expanded');
            row.prev().find('.plus-minus').addClass('active');
            row.addClass('is-expanded').css('display', 'table-row');
            row.find('.datagrid-row-detail').css('height', 'auto');
          }

      });

    },

    //Get or Set Selected Rows
    _selectedRows: [],

    selectAllRows: function () {
      var rows = [],
        self = this,
        dataset = this.settings.treeGrid ?
          this.settings.treeDepth : this.settings.dataset;

      for (var i = 0, l = dataset.length; i < l; i++) {
        if (this.filterRowRendered) {
          if (!dataset[i].isFiltered) {
            rows.push(self.settings.paging && self.settings.source ? i  : i);
          }
        } else {
          rows.push(i);
        }
      }

      this.dontSyncUi = true;
      this.selectedRows(rows, true, true);
      this.dontSyncUi = false;
      this.syncSelectedUI();
      this.element.triggerHandler('selected', [this._selectedRows , 'selectall']);
    },

    unSelectAllRows: function () {
      this.dontSyncUi = true;
      this.selectedRows([], true, true);
      this.dontSyncUi = false;
      this.syncSelectedUI();
      this.element.triggerHandler('selected', [this._selectedRows, 'deselectall']);
    },

    //Toggle selection on a single row
    selectRow: function (idx, selectAll) {
      var rowNode, dataRowIndex,
        self = this,
        checkbox = null,
        s = this.settings;

      if (idx === undefined || idx === -1 || !s.selectable) {
        return;
      }

      rowNode = this.visualRowNode(idx);
      dataRowIndex = this.dataRowIndex(rowNode);

      if (isNaN(dataRowIndex)) {
        dataRowIndex = idx;
      }

      if (!rowNode) {
        return;
      }

      if (s.selectable === 'single' && this._selectedRows.length > 0) {
        this.unselectRow(this._selectedRows[0].idx);
      }

      if (!rowNode.hasClass('is-selected')) {
        var rowData,
          // Select it
          selectNode = function(elem, index, data) {
            checkbox = self.cellNode(elem, self.columnIdxById('selectionCheckbox'));
            elem.addClass('is-selected' + (self.settings.selectable === 'mixed' ? ' hide-selected-color' : '')).attr('aria-selected', 'true')
              .find('td').attr('aria-selected', 'true');
            checkbox.find('.datagrid-cell-wrapper .datagrid-checkbox')
              .addClass('is-checked').attr('aria-checked', 'true');
            self._selectedRows.push({idx: index, data: data, elem: elem});
          };

        if (s.treeGrid) {
          if (rowNode.is('.datagrid-tree-parent') && s.selectable === 'multiple') {
            // Select node and node-children
            rowNode.add(rowNode.nextUntil('[aria-level="1"]')).each(function() {
              var elem = $(this),
                index = elem.attr('aria-rowindex') -1,
                data = s.treeDepth[index].node;
              selectNode(elem, index, data);
            });
          }
          // Single element selection
          else {
            rowData = s.treeDepth[self.pager && s.source ? rowNode.index() : dataRowIndex].node;
            selectNode(rowNode, dataRowIndex, rowData);
          }
          self.setNodeStatus(rowNode);
        }
        else {
          rowData = s.dataset[self.pager && s.source ? rowNode.index() : dataRowIndex];
          selectNode(rowNode, dataRowIndex, rowData);
          self.lastSelectedRow = idx;// Rememeber index to use shift key
        }
      }

      this.syncSelectedUI();

      if (!selectAll) {
        this.element.triggerHandler('selected', [this._selectedRows, 'select']);
      }
    },

    dontSyncUi: false,

    // Select rows between indexes
    selectRowsBetweenIndexes: function(indexes) {
      indexes.sort(function(a, b) { return a-b; });
      for (var i = indexes[0]; i <= indexes[1]; i++) {
        this.selectRow(i);
      }
    },

    //Set ui elements based on selected rows
    syncSelectedUI: function () {
      var s = this.settings,
        dataset = s.treeGrid ? s.treeDepth : s.dataset,
        headerCheckbox = this.headerRow.find('.datagrid-checkbox'),
        rows = dataset;

      if (this.filterRowRendered) {
        rows = [];
        for (var i = 0, l = dataset.length; i < l; i++) {
          if (!dataset[i].isFiltered) {
            rows.push(i);
          }
        }
      }

      //Sync the header checkbox
      if (this._selectedRows.length > 0) {
        headerCheckbox.addClass('is-checked is-partial');
      }

      if (this._selectedRows.length === rows.length) {
        headerCheckbox.addClass('is-checked').removeClass('is-partial');
      }

      if (this._selectedRows.length === 0) {
        headerCheckbox.removeClass('is-checked is-partial');
      }

      //Open or Close the Contextual Toolbar.
      if (this.contextualToolbar.length !== 1 || this.dontSyncUi) {
        return;
      }

      if (this._selectedRows.length === 0) {
        this.contextualToolbar.animateClosed();
      }

      if (this._selectedRows.length > 0 && this.contextualToolbar.height() === 0) {
        this.contextualToolbar.css('display', 'block').one('animateopencomplete.datagrid', function() {
          $(this).triggerHandler('recalculate-buttons');
        }).animateOpen();
      }

    },

    // activate a row when in mixed selection mode
    activateRow: function(idx) {
      if (this.activatedRow().length === 0 || this.activatedRow()[0].row !== idx) {
        this.toggleRowActivation(idx);
      }
    },

    // deactivate the currently activated row
    deactivateRow: function() {
      this.toggleRowActivation(this.activatedRow()[0].row);
    },

    // Gets the currently activated row
    activatedRow: function() {
      var activatedRow = this.tableBody.find('tr.is-rowactivated');

      if (activatedRow.length) {
        var rowIndex = this.dataRowIndex(activatedRow);
        return [{ row: rowIndex, item: this.settings.dataset[rowIndex], elem: activatedRow }];
      } else {
        return [{ row: -1, item: undefined, elem: activatedRow }];
      }
    },

    toggleRowActivation: function (idx) {
      var row = (typeof idx === 'number' ? this.tableBody.find('tr[aria-rowindex="'+ (idx + 1) +'"]') : idx),
        rowIndex = (typeof idx === 'number' ? idx : this.dataRowIndex(row)),
        isActivated = row.hasClass('is-rowactivated');

      if (isActivated) {
        if (!this.settings.disableRowDeactivation) {
          row.removeClass('is-rowactivated');
          this.element.triggerHandler('rowdeactivated', [{row: rowIndex, item: this.settings.dataset[rowIndex]}]);
        }
      } else {
        //Deselect old row
        var oldActivated = this.tableBody.find('tr.is-rowactivated');
        if (oldActivated.length) {
          oldActivated.removeClass('is-rowactivated');

          var oldIdx = this.dataRowIndex(oldActivated);
          this.element.triggerHandler('rowdeactivated', [{row: oldIdx, item: this.settings.dataset[oldIdx]}]);
        }
        row.addClass('is-rowactivated');
        this.element.triggerHandler('rowactivated', [{row: rowIndex, item: this.settings.dataset[rowIndex]}]);
      }

    },

    toggleRowSelection: function (idx) {
      var row = (typeof idx === 'number' ? this.tableBody.find('tr[aria-rowindex="'+ (idx + 1) +'"]') : idx),
        isSingle = this.settings.selectable === 'single',
        rowIndex = (typeof idx === 'number' ? idx : this.actualArrayIndex(row));

      if (this.settings.selectable === false) {
        return;
      }

      if (this.editor && row.hasClass('is-selected')) {
        return;
      }

      if (isSingle && row.hasClass('is-selected')) {
        this.unselectRow(rowIndex);
        this._selectedRows = [];
        this.displayCounts();
        return this._selectedRows;
      }

      if (row.hasClass('is-selected')) {
        this.unselectRow(rowIndex);
      } else {
        this.selectRow(rowIndex);
      }

      this.displayCounts();

      return this._selectedRows;
    },

    unselectRow: function (idx, nosync, selectAll) {
      var self = this,
        s = self.settings,
        rowNode = self.visualRowNode(idx),
        checkbox = null,
        selIdx;

      if (!rowNode || idx === undefined) {
        return;
      }

      selIdx = undefined;
      for (var i = 0; i < self._selectedRows.length; i++) {
        if (self._selectedRows[i].idx === idx) {
          selIdx = idx;
        }
      }

      // Unselect it
      var unselectNode = function(elem, index) {
        checkbox = self.cellNode(elem, self.columnIdxById('selectionCheckbox'));
        elem.removeClass('is-selected hide-selected-color').removeAttr('aria-selected')
          .find('td').removeAttr('aria-selected');
        checkbox.find('.datagrid-cell-wrapper .datagrid-checkbox')
          .removeClass('is-checked').attr('aria-checked', 'false');

        var selIdx;
        for (var i = 0; i < self._selectedRows.length; i++) {
          if (self._selectedRows[i].idx === index) {
            selIdx = i;
          }
        }
        if (selIdx !== undefined) {
          self._selectedRows.splice(selIdx, 1);
        }
      };

      if (s.treeGrid) {
        if (rowNode.is('.datagrid-tree-parent') && s.selectable === 'multiple') {
          // Select node and node-children
          rowNode.add(rowNode.nextUntil('[aria-level="1"]')).each(function() {
            var elem = $(this),
              index = elem.attr('aria-rowindex') -1;
            unselectNode(elem, index);
          });
        }
        // Single element unselection
        else {
          unselectNode(rowNode, selIdx);
        }
        self.setNodeStatus(rowNode);
      }
      else {
        unselectNode(rowNode, selIdx);
      }

      if (!nosync) {
        self.syncSelectedUI();
      }

      if (!selectAll) {
        self.element.triggerHandler('selected', [self._selectedRows, 'deselect']);
      }
    },

    setNodeStatus: function(node) {
      var self = this,
        isMultiselect = self.settings.selectable === 'multiple',
        checkbox = self.cellNode(node, self.columnIdxById('selectionCheckbox')),
        nodes;

      // Not multiselect
      if (!isMultiselect) {
        checkbox.find('.datagrid-cell-wrapper .datagrid-checkbox')
          .removeClass('is-checked is-partial').attr('aria-checked', 'false');

        if (node.is('.is-selected')) {
          checkbox.find('.datagrid-cell-wrapper .datagrid-checkbox')
            .addClass('is-checked').attr('aria-checked', 'true');
        }
        return;
      }

      var setStatus = function (nodes, isFirstSkipped) {
        nodes.each(function() {
          var node = $(this),
            checkbox = self.cellNode(node, self.columnIdxById('selectionCheckbox')),
            status = self.getSelectedStatus(node, isFirstSkipped);

          checkbox.find('.datagrid-cell-wrapper .datagrid-checkbox')
            .removeClass('is-checked is-partial').attr('aria-checked', 'false');

          if (status === 'mixed') {
            checkbox.find('.datagrid-cell-wrapper .datagrid-checkbox')
              .addClass('is-checked is-partial').attr('aria-checked', 'mixed');
          }
          else if (status) {
            checkbox.find('.datagrid-cell-wrapper .datagrid-checkbox')
              .addClass('is-checked').attr('aria-checked', 'true');
          }
        });
      };

      // Multiselect
      nodes = node.add(node.nextUntil('[aria-level="1"]')).filter('.datagrid-tree-parent');
      setStatus(nodes);

      nodes = node;
      if (+node.attr('aria-level') > 1) {
        nodes = nodes.add(node.prevUntil('[aria-level="1"]'))
        .add(node.prevAll('[aria-level="1"]:first'));
      }
      nodes = nodes.filter('.datagrid-tree-parent');
      setStatus(nodes);
    },

    getSelectedStatus: function(node) {
      var status,
        total = 0,
        selected = 0,
        unselected = 0;

      node.add(node.nextUntil('[aria-level="1"]')).each(function() {
        total++;
        if ($(this).is('.is-selected')) {
          selected++;
        } else {
          unselected++;
        }
      });

      status = ((total === selected) ? true : ((total === unselected) ? false : 'mixed'));
      return status;
    },

    //Set the selected rows by passing the row index or an array of row indexes
    selectedRows: function (row, nosync, selectAll) {
      var idx = -1,
          isSingle = this.settings.selectable === 'single',
          isMultiple = this.settings.selectable === 'multiple' || this.settings.selectable === 'mixed',
          dataset = this.settings.treeGrid ?
            this.settings.treeDepth : this.settings.dataset;

      if (!row) {
        return this._selectedRows;
      }

      if (row.length === 0 && this._selectedRows.length === 0) {
        return;
      }

      if (isSingle) {
        //Unselect
        if (this._selectedRows[0]) {
          this.unselectRow(this._selectedRows[0].idx, nosync, selectAll);
        }

        //Select - may be passed array or int
        idx = ((Object.prototype.toString.call(row) === '[object Array]' ) ? row[0] : row.index());
        this.selectRow(idx, selectAll);
      }

      if (isMultiple) {
        if (Object.prototype.toString.call(row) === '[object Array]' ) {
          for (var i = 0; i < row.length; i++) {
            this.selectRow(row[i], selectAll);
          }

          if (row.length === 0) {
            for (var j=0, l=dataset.length; j < l; j++) {
              this.unselectRow(j, nosync, selectAll);
            }
            this._selectedRows = [];
          }

        } else {
          this.selectRow(row.index(), selectAll);
        }
      }

      this.displayCounts();

      return this._selectedRows;
    },

    //Set the row status
    rowStatus: function(idx, status, tooltip) {
      var rowStatus;

      if (!status) {
        delete this.settings.dataset[idx].rowStatus;
        this.updateRow(idx);
        return;
      }

      if (!this.settings.dataset[idx]) {
        return;
      }

      this.settings.dataset[idx].rowStatus = {};
      rowStatus = this.settings.dataset[idx].rowStatus;

      rowStatus.icon = status;
      status = status.charAt(0).toUpperCase() + status.slice(1);
      status = status.replace('-progress', 'Progress');
      rowStatus.text = Locale.translate(status);

      tooltip = tooltip ? tooltip.charAt(0).toUpperCase() + tooltip.slice(1) : rowStatus.text;
      rowStatus.tooltip = tooltip;

      this.updateRow(idx);
    },

    //Get the column object by id
    columnById: function(id) {
      return $.grep(this.settings.columns, function(e) { return e.id === id; });
    },

    //Get the column index from the col's id
    columnIdxById: function(id) {
      var cols = this.settings.columns,
        idx = -1;

      for (var i = 0; i < cols.length; i++) {
       if (cols[i].id === id) {
        idx = i;
       }
      }
      return idx;
    },

    // Current Active Cell
    activeCell: {node: null, cell: null, row: null},

    // Handle all keyboard behavior
    handleKeys: function () {
      var self = this,
        isMultiple = self.settings.selectable === 'multiple',
        checkbox = $('th .datagrid-checkbox', self.headerRow);

      // Handle header navigation
      self.headerTable.on('keydown.datagrid', 'th', function (e) {
        var key = e.which || e.keyCode || e.charCode || 0,
          th = $(this),
          index = th.siblings(':visible').addBack().index(th),
          last = self.visibleColumns().length -1,
          triggerEl, move;

        if ($(e.target).closest('.popupmenu').length > 0) {
          return;
        }

        // Enter or Space
        if (key === 13 || key === 32) {
          triggerEl = (isMultiple && index === 0) ? $('.datagrid-checkbox', th) : th;
          triggerEl.trigger('click.datagrid').focus();

          if (key === 32) { // Prevent scrolling with space
            e.preventDefault();
          }
        }

        //Press Home, End, Left and Right arrow to move to first, last, previous or next
        if ([35, 36, 37, 39].indexOf(key) !== -1) {
          move = index;

          //Home, End or Ctrl/Meta + Left/Right arrow to move to the first or last
          if (/35|36/i.test(key) || ((e.ctrlKey || e.metaKey) && /37|39/i.test(key))) {
            if (Locale.isRTL()) {
              move = (key === 36 || ((e.ctrlKey || e.metaKey) && key === 37)) ? last : 0;
            } else {
              move = (key === 35 || ((e.ctrlKey || e.metaKey) && key === 39)) ? last : 0;
            }
          }

          // Left and Right arrow
          else {
            if (Locale.isRTL()) {
              move = key === 39 ? (index > 0 ? index-1 : index) : (index < last ? index+1 : last);
            } else {
              move = key === 37 ? (index > 0 ? index-1 : index) : (index < last ? index+1 : last);
            }
          }
          // Update active cell
          self.activeCell.cell = move;

          // Making move
          th.removeAttr('tabindex').removeClass('is-active');
          $('th:not(.is-hidden)', this.header).eq(move).attr('tabindex', '0').addClass('is-active').focus();
          e.preventDefault();
        }

        // Down arrow
        if (key === 40) {
          th.removeAttr('tabindex');
          self.activeCell.node = self.cellNode(0, self.settings.groupable ? 0 : self.activeCell.cell, true).attr('tabindex', '0').focus();
          e.preventDefault();
        }

      });

      //Handle Editing / Keyboard
      self.table.on('keydown.datagrid', 'td, input', function (e) {
        var key = e.which || e.keyCode || e.charCode || 0,
          handled = false;

        // F2 - toggles actionableMode "true" and "false"
        if (key === 113) {
          self.settings.actionableMode = self.settings.actionableMode ? false : true;
          handled = true;
        }

        if (handled) {
          e.preventDefault();
          e.stopPropagation();
          return false;
        }
      });

      //Press PageUp or PageDown to open the previous or next page and set focus to the first row.
      //Press Alt+Up or Alt+Down to set focus to the first or last row on the current page.
      //Press Alt+PageUp or Alt+PageDown to open the first or last page and set focus to the first row.

      //Handle rest of the keyboard
      self.table.on('keydown.datagrid', 'td', function (e) {
        var key = e.which || e.keyCode || e.charCode || 0,
          handled = false,
          isRTL = Locale.isRTL(),
          node = self.activeCell.node,
          rowNode = $(this).parent(),
          prevRow = rowNode.prevAll(':not(.is-hidden, .datagrid-expandable-row)').first(),
          nextRow = rowNode.nextAll(':not(.is-hidden, .datagrid-expandable-row)').first(),
          row = self.activeCell.row,
          cell = self.activeCell.cell,
          col = self.columnSettings(cell),
          isGroupRow = rowNode.is('.datagrid-rowgroup-header, .datagrid-rowgroup-footer'),
          item = self.settings.dataset[self.dataRowIndex(node)],
          visibleRows = self.tableBody.find('tr:visible'),
          getVisibleRows = function(index) {
            var row = visibleRows.filter('[aria-rowindex="'+ (index + 1) +'"]');
            if (row.is('.datagrid-rowgroup-header')) {
              return row.index();
            }
            return self.dataRowIndex(row);
          },
          getGroupCell = function(currentCell, lastCell, prev) {
            var n = self.activeCell.groupNode || node;
            var nextCell = currentCell + (prev ? -1 : +1);

            if (nextCell > lastCell) {
              nextCell = prev ?
                n.prevAll(':visible').last() : n.nextAll(':visible').last();
            } else {
              nextCell = prev ?
                n.prevAll(':visible').first() : n.nextAll(':visible').first();
            }
            return nextCell;
          },
          getNextVisibleCell = function(currentCell, lastCell, prev) {
            if (isGroupRow) {
              return getGroupCell(currentCell, lastCell, prev);
            }
            var nextCell = currentCell + (prev ? -1 : +1);
            if (nextCell > lastCell) {
             return lastCell;
            }
            while (self.settings.columns[nextCell] && self.settings.columns[nextCell].hidden) {
              nextCell = prev ? nextCell-1 : nextCell+1;
            }
            return nextCell;
          },
          isSelectionCheckbox = !!($('.datagrid-selection-checkbox', node).length),
          lastRow, lastCell;

        lastCell = self.settings.columns.length-1;
        lastRow = visibleRows.last();

        //Tab, Left and Right arrow keys.
        if ([9, 37, 39].indexOf(key) !== -1) {
          if (key === 9 && !self.settings.actionableMode) {
            return;
          }

          if (key !== 9 && e.altKey) {
            //[Alt + Left/Right arrow] to move to the first or last cell on the current row.
            cell = ((key === 37 && !isRTL) || (key === 39 && isRTL)) ? 0 : lastCell;
            self.setActiveCell(row, cell);
          }
          //Tab, Shift-tab, Left and Right arrow keys to navigate by cell.
          else if (!self.quickEditMode || (key === 9)) {
            if ((!isRTL && (key === 37 || key === 9 && e.shiftKey)) ||
                (isRTL && (key === 39 || key === 9))) {
              cell = getNextVisibleCell(cell, lastCell, true);
            } else {
              cell = getNextVisibleCell(cell, lastCell);
            }
            if (cell instanceof jQuery) {
              self.setActiveCell(cell);
            } else {
              self.setActiveCell(row, cell);
            }
            self.quickEditMode = false;
            handled = true;
          }
        }

        //Up arrow key
        if (key === 38 && !self.quickEditMode) {
          //Press [Control + Up] arrow to move to the first row on the first page.
          if (e.altKey || e.metaKey) {
            self.setActiveCell(getVisibleRows(0), cell);
            handled = true;
          } else { //Up arrow key to navigate by row.

            if (row === 0 && !prevRow.is('.datagrid-rowgroup-header')) {
              node.removeAttr('tabindex');
              self.headerRow.find('th').eq(cell).attr('tabindex', '0').focus();
              return;
            }
            self.setActiveCell(prevRow, cell);
            handled = true;
          }
        }

        //Down arrow key
        if (key === 40 && !self.quickEditMode) {
          //Press [Control + Down] arrow to move to the last row on the last page.
          if (e.altKey|| e.metaKey) {
            self.setActiveCell(lastRow, cell);
            handled = true;
          } else { //Down arrow key to navigate by row.
            self.setActiveCell(nextRow, cell);
            handled = true;
          }
        }

        //Press Control+Spacebar to announce the current row when using a screen reader.
        if (key === 32 && e.ctrlKey && node) {
          var string = '';
          row = node.closest('tr');

          row.children().each(function () {
            var cell = $(this);
            //Read Header
            //string += $('#' + cell.attr('aria-describedby')).text() + ' ' + cell.text() + ' ';
            string += cell.text() + ' ';
          });

          $('body').toast({title: '', audibleOnly: true, message: string});
          handled = true;
        }

        //Press Home or End to move to the first or last cell on the current row.
        if (key === 36) {
          self.setActiveCell(row, 0);
          handled = true;
        }

        //Home to Move to the end of the current row
        if (key === 35) {
          self.setActiveCell(row, lastCell);
          handled = true;
        }

        //End to Move to last row of current cell
        if (key === 34) {
          self.setActiveCell(lastRow, cell);
          handled = true;
        }

        //End to Move to first row of current cell
        if (key === 33) {
          self.setActiveCell(getVisibleRows(0), cell);
          handled = true;
        }

        // For mode 'Selectable':
        // Press Space to toggle row selection, or click to activate using a mouse.
        if (key === 32 && (!self.settings.editable || isSelectionCheckbox)) {
          row = node.closest('tr');

          if ($(e.target).closest('.datagrid-row-detail').length === 1) {
            return;
          }
          e.preventDefault();

          // Toggle datagrid-expand with Space press
          var btn = $(e.target).find('.datagrid-expand-btn, .datagrid-drilldown');
          if (btn && btn.length) {
            btn.trigger('click.datagrid');
            e.preventDefault();
            return;
          }

          if (isMultiple && e.shiftKey) {
            self.selectRowsBetweenIndexes([self.lastSelectedRow, row.index()]);
          } else {
            self.toggleRowSelection(row);
          }

        }

        // For Editable mode - press Enter or Space to edit or toggle a cell, or click to activate using a mouse.
        if (self.settings.editable && key === 32) {
          if (!self.editor) {
            self.makeCellEditable(row, cell, e);
          }
        }

        // if column have click function to fire [ie. action button]
        if (key === 13 && col.click && typeof col.click === 'function') {
          if (!node.hasClass('is-cell-readonly')) {
            col.click(e, [{row: row, cell: cell, item: item, originalEvent: e}]);
          }
        }

        if (self.settings.editable && key === 13) {
          //Allow shift to add a new line
          if ($(e.target).is('textarea') && e.shiftKey) {
            return;
          }

          if (self.editor) {
            self.quickEditMode = false;
            self.commitCellEdit(self.editor.input);
            self.setNextActiveCell(e);
          }
          else {
            self.makeCellEditable(row, cell, e);
            if (self.isContainTextfield(node) && self.notContainTextfield(node)) {
              self.quickEditMode = true;
            }
          }
          handled = true;
        }

        //Any printable character - well make it editable
        if ([9, 13, 32, 35, 36, 37, 38, 39, 40, 113].indexOf(key) === -1 &&
          !e.altKey && !e.shiftKey && !e.ctrlKey && !e.metaKey && self.settings.editable) {
          if (!self.editor) {
            self.makeCellEditable(row, cell, e);
          }
        }

        // If multiSelect is enabled, press Control+A to toggle select all rows
        if (isMultiple && !self.editor && ((e.ctrlKey || e.metaKey) && key === 65)) {
          checkbox
            .addClass('is-checked')
            .removeClass('is-partial')
            .attr('aria-checked', 'true');
          self.selectAllRows();
          handled = true;
        }

        if (handled) {
          e.preventDefault();
          e.stopPropagation();
          return false;
        }

      });
    },

    isContainTextfield: function(container) {
      var noTextTypes = ['image', 'button', 'submit', 'reset', 'checkbox', 'radio'],
        selector = 'textarea, input',
        l = noTextTypes.length, i;

      selector += l ? ':not(' : '';
      for(i = 0; i < l; i++) {
        selector += '[type='+ noTextTypes[i] +'],';
      }
      selector = l ? (selector.slice(0, -1) + ')') : '';

      return !!($(selector, container).length);
    },

    notContainTextfield: function(container) {
      var selector = '.dropdown, .datepicker';
      return !($(selector, container).length);
    },

    //Current Cell Editor thats in Use
    editor: null,

    isCellEditable: function(row, cell) {
      if (!this.settings.editable) {
        return false;
      }

      var col = this.columnSettings(cell);
      if (col.readonly) {
        return false;
      }

      //Check if cell is editable via hook function
      var cellNode = this.activeCell.node.find('.datagrid-cell-wrapper'),
        cellValue = (cellNode.text() ? cellNode.text() : this.fieldValue(this.settings.dataset[row], col.field));

      if (col.isEditable) {
        var canEdit = col.isEditable(row, cell, cellValue, col, this.settings.dataset[row]);

        if (!canEdit) {
          return false;
        }
      }

      if (!col.editor) {
        return false;
      }

      return true;
    },

    // Invoked in three cases: 1) a row click, 2) keyboard and enter, 3) In actionable mode and tabbing
    makeCellEditable: function(row, cell, event) {
      if (this.editor && this.editor.input) {
        if (this.editor.input.is('.timepicker, .datepicker, .lookup, .spinbox') && !$(event.target).prev().is(this.editor.input)) {
          this.commitCellEdit(this.editor.input);
        }
      }

      //Locate the Editor
      var col = this.columnSettings(cell);

      //Select the Rows if the cell is editable
      if (!col.editor) {
        if (event.keyCode === 32 && !$(event.currentTarget).find('.datagrid-selection-checkbox').length) {
          this.toggleRowSelection(this.activeCell.node.closest('tr'));
        }
        return;
      }

      var dataRowIndex = this.dataRowIndex(this.dataRowNode(row)),
        rowData = this.settings.treeGrid ?
          this.settings.treeDepth[dataRowIndex].node :
          this.settings.dataset[dataRowIndex],
        cellNode = this.activeCell.node.find('.datagrid-cell-wrapper'),
        cellParent = cellNode.parent('td'),
        cellWidth = cellParent.outerWidth(),
        isEditor = $('.is-editor', cellParent).length > 0,
        cellValue = (cellNode.text() ?
          cellNode.text() : this.fieldValue(rowData, col.field));

      if (isEditor) {
        cellValue = this.fieldValue(rowData, col.field);
      }

      if (!this.isCellEditable(dataRowIndex, cell)) {
        return;
      }

      if (cellParent.hasClass('is-editing') || cellParent.hasClass('is-editing-inline')) {
        //Already in edit mode
        cellNode.find('input').focus();
        return false;
      }

      // In Show Ediitor mode the editor is on form already
      if (!col.inlineEditor) {

        if (isEditor) {
          cellNode.css({'position': 'static', 'height': cellNode.outerHeight()});
        }
        //Editor.init
        cellParent
          .addClass('is-editing')
          .css({'max-width': cellWidth, 'min-width': cellWidth, 'width': cellWidth});

        cellNode.empty();
      } else {
        cellParent.addClass('is-editing-inline');
      }

      this.editor = new col.editor(dataRowIndex, cell, cellValue, cellNode, col, event, this, rowData);

      if (this.editor.useValue) {
        cellValue = this.fieldValue(rowData, col.field);
      }
      this.editor.val(cellValue);
      this.editor.focus();
      this.element.triggerHandler('entereditmode', [{editor: this.editor}]);
    },

    commitCellEdit: function(input) {
      var newValue, cellNode,
        isEditor = input.is('.editor'),
        isUseActiveRow = !(input.is('.timepicker, .datepicker, .lookup, .spinbox'));

      if (!this.editor) {
        return;
      }

      //Editor.getValue
      newValue = this.editor.val();

      if (isEditor) {
        cellNode = this.editor.td;
      } else {
        cellNode = input.closest('td');
        newValue = $.escapeHTML(newValue);
      }

      //Format Cell again
      var isInline = cellNode.hasClass('is-editing-inline');
      cellNode.removeClass('is-editing is-editing-inline');

      //Editor.destroy
      this.editor.destroy();
      this.editor = null;

      var rowIndex;
      if (this.settings.source !== null && isUseActiveRow) {
        rowIndex = this.activeCell.row;
      } else {
        rowIndex = this.dataRowIndex(cellNode.parent());
      }

      //Save the Cell Edit back to the data set
      this.updateCellNode(rowIndex, cellNode.index(), newValue, false, isInline);
      this.element.triggerHandler('exiteditmode', [{editor: this.editor}]);
    },

    //Validate a particular cell if it has validation on the column and its visible
    validateCell: function (row, cell) {
      var self = this,
        column = this.columnSettings(cell),
        validate = column.validate;

      if (!validate) {
        return;
      }

      var rules = column.validate.split(' '),
        validator = $.fn.validation,
        cellValue = this.fieldValue(this.settings.dataset[row], column.field),
        isValid = true,
        messages = '';

      for (var i = 0; i < rules.length; i++) {
        var rule = validator.rules[rules[i]],
          gridInfo = {row: row, cell: cell, item: this.settings.dataset[row], column: column, grid: self},
          ruleValid = rule.check(cellValue, $('<input>').val(cellValue), gridInfo);

        if (!ruleValid) {
          if (messages) {
            messages = ((/^\u2022/.test(messages)) ? '' : '\u2022 ') + messages;
            messages += '<br>' + '\u2022 ' + rule.message;
          } else {
            messages = rule.message;
          }
          isValid = false;
        }
      }

      if (!isValid) {
		self.showCellError(row, cell, messages);
        self.element.trigger('cellerror', {row: row, cell: cell, message: messages, target: this.cellNode(row, cell), value: cellValue, column: column});
      } else {
        self.clearCellError(row, cell);
      }

    },

    showCellError: function (row, cell, errorMessage) {
      var node = this.cellNode(row, cell);

	  // clear the table nonVisibleCellErrors for the row and cell
	  this.clearNonVisibleCellErrors(row, cell);

      if (!node.length) {
		// Store the nonVisibleCellError
	    this.nonVisibleCellErrors.push({ row: row, cell: cell, errorMessage: errorMessage });
		this.showNonVisibleCellErrors();
        return;
      }

      //Add icon and classes
      node.addClass('error').attr('data-errormessage', errorMessage);
      var icon = $($.createIcon({ classes: ['icon-error'], icon: 'error' }));

      //Add and show tooltip
      if (node.find('.icon-error').length === 0) {
        node.find('.datagrid-cell-wrapper').append(icon);
        icon.tooltip({placement: 'bottom', isErrorColor: true, content: errorMessage});
        icon.data('tooltip').show();
      }

    },

	showNonVisibleCellErrors: function () {
      var messages, tableerrors, icon;

	  // Create empty toolbar
	  if (!this.toolbar) {
		settings.toolbar = { title: '' };
		this.appendToolbar();
	  }

	  if (this.toolbar.parent().find('.tableerrors').length === 1) {
        tableerrors = this.element.parent().find('.tableerrors');
      }

	  if (!this.nonVisibleCellErrors.length) {
		// clear the displayed error
		if (tableerrors && tableerrors.length) {
		  icon = tableerrors.find('.icon-error');
          var tooltip = icon.data('tooltip');
          if (tooltip) {
            tooltip.hide();
          }
          tableerrors.find('.icon-error').remove();
		}
		return;
	  }

	  for (var i = 0; i < this.nonVisibleCellErrors.length; i++) {
		   messages = (messages ? messages + '<br>' : '') + this.nonVisibleCellErrors[i].errorMessage;
	  }

	  if (this.element.parent().find('.tableerrors').length === 0) {
        tableerrors = $('<div class="tableerrors"></div>');
	  }
	  icon = tableerrors.find('.icon-error');
	  if (!icon.length) {
		icon = $($.createIcon({ classes: ['icon-error'], icon: 'error' }));
		tableerrors.append(icon);
	  }
	  if (this.element.hasClass('has-toolbar')) {
		//Add Error to the Toolbar
		this.toolbar.append(tableerrors);
	  }
      icon.tooltip({placement: 'bottom', isErrorColor: true, content: messages});
      icon.data('tooltip').show();

    },

    clearCellError: function (row, cell) {
	  this.clearNonVisibleCellErrors(row, cell);
      var node = this.cellNode(row, cell);

      if (!node.length) {
        return;
      }

      this.clearNodeErrors(node);
    },

	clearNonVisibleCellErrors: function (row, cell) {

	  if (!this.nonVisibleCellErrors.length) {
        return;
	  }

	  this.nonVisibleCellErrors = $.grep(this.nonVisibleCellErrors, function (error) {
        if (!(error.row === row && error.cell === cell)) {
          return error;
        }
      });

	  if (!this.nonVisibleCellErrors.length) {
		this.showNonVisibleCellErrors();
	  }
    },

    clearRowError: function (row) {
      var rowNode = this.dataRowNode(row);

      rowNode.removeClass('error alert');
      this.rowStatus(row, '', '');
    },

    clearAllErrors: function () {
      var self = this;

      this.tableBody.find('td.error').each(function () {
        var node = $(this);
        self.clearNodeErrors(node);
      });
    },

    clearNodeErrors: function (node) {
      node.removeClass('error').removeAttr('data-errormessage');

      var icon = node.find('.icon-error');
      var tooltip = icon.data('tooltip');
      if (tooltip) {
        tooltip.hide();
      }
      node.find('.icon-error').remove();
    },

    resetRowStatus: function () {
      for (var i = 0; i < this.settings.dataset.length; i++) {
        this.rowStatus(i, '');
      }
    },

    dirtyRows: function () {
      var rows = [],
        data = this.settings.dataset;

      for (var i = 0; i < data.length; i++) {
        if (data[i].rowStatus && data[i].rowStatus.icon === 'dirty') {
          rows.push(data[i]);
        }
      }
      return rows;
    },

    //Validate all visible cells in a row if they have validation on the column
    //Row Id, Error Text and 'error' or 'alert' (default alert)
    showRowError: function (row, message, type) {
      var messageType = type || 'error',
        rowNode = this.dataRowNode(row);

      rowNode.addClass('error');
      this.rowStatus(row, messageType, message);
    },

    //Validate all visible cells in a row if they have validation on the column
    //Row Id, Error Text and 'error' or 'alert' (default alert)
    validateRow: function (row) {
      for (var i = 0; i < this.settings.columns.length; i++) {
        this.validateCell(row, i);
      }
    },

    //Validate all rows and cells with validation on them
    validateAll: function () {
      for (var j = 0; j < this.settings.dataset.length; j++) {
        for (var i = 0; i < this.settings.columns.length; i++) {
          this.validateCell(j, i);
        }
      }
    },

    columnSettings: function (cell, onlyVisible) {
      var column = settings.columns[cell];

      if (onlyVisible) {
        column = this.visibleColumns()[cell];
      }

      return column || {};
    },

    //Attempt to serialize the value back into the dataset
    coerceValue: function (value, oldVal, col, row, cell) {
      var newVal;

      if (col.serialize) {
        newVal = col.serialize(value, oldVal, col, row, cell, this.settings.dataset[row]);
        return newVal;
      }

      return newVal;
    },

    updateCell: function(row, cell, value) {
      var col = this.columnSettings(cell);

      if (value === undefined) {
        value = this.fieldValue(this.settings.dataset[row], col.field);
      }

      this.updateCellNode(row, cell, value, true);
    },

    updateCellNode: function (row, cell, value, fromApiCall, isInline) {
      var coercedVal, escapedVal,
        rowNode = this.visualRowNode(row),
        cellNode = rowNode.find('td').eq(cell),
        col = this.settings.columns[cell] || {},
        formatted = '',
        formatter = (col.formatter ? col.formatter : this.defaultFormatter),
        isEditor = $('.editor', cellNode).length > 0,
        isTreeGrid = this.settings.treeGrid,
        rowData = isTreeGrid ?
          this.settings.treeDepth[row].node :
          this.settings.dataset[row];

      var oldVal = (col.field ? rowData[col.field] : '');

      //Coerce/Serialize value if from cell edit
      if (!fromApiCall) {
        coercedVal = this.coerceValue(value, oldVal, col, row, cell);

        //coerced value may be coerced to empty string, null, or 0
        if (coercedVal === undefined) {
          coercedVal = value;
        }
      } else {
        coercedVal = value;
      }

      //Setup/Sync tooltip
      if (cellNode.data('tooltip')){
        cellNode.data('tooltip').destroy();
      }

      //Update the value in the dataset
      if (col.id === 'rowStatus' && rowData.rowStatus && rowData.rowStatus.tooltip) {
        cellNode.attr('title', rowData.rowStatus.tooltip);
        cellNode.tooltip({placement: 'right',
          isErrorColor: rowData.rowStatus.icon === 'error'
        });
      }

      coercedVal = $.unescapeHTML(coercedVal);

      if (col.field && coercedVal !== oldVal) {
        if (col.field.indexOf('.') > -1 ) {
          var parts = col.field.split('.');
          if (parts.length === 2) {
            rowData[parts[0]][parts[1]] = coercedVal;
          }

          if (parts.length === 3) {
            rowData[parts[0]][parts[1]][parts[2]] = coercedVal;
          }

        } else {
          rowData[col.field] = coercedVal;
        }
      }

      //update cell value
      escapedVal = $.escapeHTML(coercedVal);
      formatted = this.formatValue(formatter, (isTreeGrid ? row+1 : row), cell, (isEditor ? coercedVal : escapedVal), col, rowData);

      if (col.contentVisible) {
        var canShow = col.contentVisible(row, cell, escapedVal, col, rowData);
        if (!canShow) {
          formatted = '';
        }
      }

      if (!isInline) {
        cellNode.find('.datagrid-cell-wrapper').html(formatted);
      }

	  if (!fromApiCall) {
	    //Validate the cell
        this.validateCell(row, cell);
	  }

      if (coercedVal !== oldVal && !fromApiCall) {
        var args = {row: row, cell: cell, target: cellNode, value: coercedVal, oldValue: oldVal, column: col};
        args.rowData = isTreeGrid && this.settings.treeDepth[row] ?
          this.settings.treeDepth[row].node : rowData;

        this.element.trigger('cellchange', args);
        this.wasJustUpdated = true;

        if (this.settings.showDirty) {
          this.rowStatus(row, 'dirty');
        }
      }

    },

    //For the row node get the index - adjust for paging / invisible rowsCache
    visualRowIndex: function (row) {
      return this.tableBody.find('tr:visible').index(row);
    },

    visualRowNode: function (idx) {
      var rowIdx = idx;

      if (this.settings.paging && this.settings.source) {
        rowIdx = rowIdx + ((this.pager.activePage -1) * this.settings.pagesize);
      }

      return this.tableBody.find('tr[aria-rowindex="'+ (rowIdx + 1) +'"]');
    },

    dataRowNode: function (idx) {
      return this.tableBody.find('tr[aria-rowindex="'+ (idx + 1) +'"]');
    },

    dataRowIndex: function (row) {
     return row.attr('aria-rowindex') - 1;
    },

    actualArrayIndex: function (rowElem) {
     return parseInt(rowElem.attr('data-index'));
    },

    // Update a specific Cell
    setActiveCell: function (row, cell) {
      var self = this,
        prevCell = self.activeCell,
        rowElem = row, rowNum, dataRowNum,
        isGroupRow = row instanceof jQuery && row.is('.datagrid-rowgroup-header, .datagrid-rowgroup-footer');

      if (row instanceof jQuery && row.length === 0) {
        return;
      }

      if (typeof row === 'number') {
        rowNum = row;
        rowElem = this.tableBody.find('tr:visible').eq(row);
        dataRowNum = this.dataRowIndex(rowElem);
      }

      //Support passing the td in
      if (row instanceof jQuery && row.is('td')) {
        isGroupRow = row.parent().is('.datagrid-rowgroup-header, .datagrid-rowgroup-footer');
        if (isGroupRow) {
          rowElem = row.parent();
        }
        cell = row.index();
        rowNum = this.visualRowIndex(row.parent());
		    dataRowNum = this.dataRowIndex(row.parent());
        rowElem = row.parent();
      }

      if (row instanceof jQuery && row.is('tr')) {
        rowNum = this.visualRowIndex(row);
		    dataRowNum = this.dataRowIndex(row);
        rowElem = row;
      }

      if (rowNum < 0 || cell < 0) {
        return;
      }

      //Remove previous tab index
      if (prevCell.node && prevCell.node.length ===1) {
        self.activeCell.node.removeAttr('tabindex');
      }

      //Hide any cell tooltips (Primarily for validation)
      if (prevCell.cell !== cell || prevCell.row !== row) {
        $('#tooltip').hide();
      }

      //Find the cell if it exists
      self.activeCell.node = self.cellNode((isGroupRow ? rowElem : (dataRowNum > -1 ? dataRowNum : rowNum)), (cell)).attr('tabindex', '0');

      if (self.activeCell.node && prevCell.node.length === 1) {
        self.activeCell.row = rowNum;
        self.activeCell.cell = cell;
		    dataRowNum = this.dataRowIndex(self.activeCell.node.parent());
      } else {
        self.activeCell = prevCell;
      }

      if (!$('input, button:not(.btn-secondary, .row-btn, .datagrid-expand-btn, .datagrid-drilldown, .btn-icon)', self.activeCell.node).length) {
        self.activeCell.node.focus();
        if (isGroupRow) {
          self.activeCell.groupNode = self.activeCell.node;
        }
      }
      if (self.activeCell.node.hasClass('is-focusable')) {
        self.activeCell.node.find('button').focus();
      }

      if (dataRowNum !== undefined) {
        self.activeCell.dataRow = dataRowNum;
      }
      var colSpan = +rowElem.find('td[colspan]').attr('colspan');

      if (isGroupRow && self.activeCell.node && prevCell.node && !(row instanceof jQuery && row.is('td'))) {
        if (cell < colSpan) {
          rowElem.find('td[colspan]').attr('tabindex', '0').focus();
          self.activeCell.groupNode = rowElem.find('td[colspan]');
        }
        else if (cell >= colSpan) {
          rowElem.find('td').eq(cell-colSpan + 1).attr('tabindex', '0').focus();
          self.activeCell.groupNode = rowElem.find('td').eq(cell-colSpan + 1);
        } else {
          rowElem.find('td').eq(cell).attr('tabindex', '0').focus();
          self.activeCell.groupNode = rowElem.find('td').eq(cell);
        }
      }

      if (isGroupRow && row instanceof jQuery && row.is('td')) {
        self.activeCell.cell = (colSpan - 1) + cell;
        if (row.is('[colspan]')) {
          self.activeCell.cell = cell;
        }
      }

      if (this.settings.cellNavigation) {
        var headers = self.headerNodes();
        headers.removeClass('is-active');
        headers.eq(cell).addClass('is-active');
      }
      this.activeCell.isFocused = true;

      self.element.trigger('activecellchange', [{node: this.activeCell.node, row: this.activeCell.row, cell: this.activeCell.cell}]);
    },

    setNextActiveCell: function (e) {
      if (e.type === 'keydown') {
        if (this.settings.actionableMode) {
          var evt = $.Event('keydown.datagrid');
          evt.keyCode = 40; // move down
          this.activeCell.node.trigger(evt);
        }
        else {
          this.setActiveCell(this.activeCell.row, this.activeCell.cell);
        }
      }
    },

    // Add children to treegrid dataset
    addChildren: function(parent, data) {
      if (!data || (data && !data.length) || parent < 0) {
        return;
      }
      var node = this.settings.treeDepth[parent].node;
      node.children = node.children || [];

      // Make sure it's not reference pointer to data object, make copy of data
      data = JSON.parse(JSON.stringify(data));

      for (var i = 0, len = data.length; i < len; i++) {
        node.children.push(data[i]);
      }
      this.updateDataset(this.settings.dataset);
    },

    // Set expanded property in Dataset
    setExpandedInDataset: function(dataRowIndex, isExpanded) {
      this.settings.treeDepth[dataRowIndex].node.expanded = isExpanded;
    },

    //expand the tree rows
    toggleChildren: function(e, dataRowIndex) {
      var self = this,
        rowElement = this.visualRowNode(dataRowIndex),
        expandButton = rowElement.find('.datagrid-expand-btn'),
        level = rowElement.attr('aria-level'),
        children = rowElement.nextUntil('[aria-level="1"]'),
        isExpanded = expandButton.hasClass('is-expanded'),
        restCollapsed = false,
        args = [{grid: self, row: dataRowIndex, item: rowElement, children: children}];

      if (self.settings.treeDepth[dataRowIndex]) {
        args[0].rowData = self.settings.treeDepth[dataRowIndex].node;
      }

      if (!rowElement.hasClass('datagrid-tree-parent') ||
          (!$(e.target).is(expandButton) &&
            (self.settings.editable || self.settings.selectable))) {
        return;
      }

      var toggleExpanded = function() {
        rowElement = self.visualRowNode(dataRowIndex);
        expandButton = rowElement.find('.datagrid-expand-btn');
        children = rowElement.nextUntil('[aria-level="1"]');

        if (isExpanded) {
          rowElement.attr('aria-expanded', false);
          expandButton.removeClass('is-expanded')
            .find('.plus-minus').removeClass('active');
        } else {
          rowElement.attr('aria-expanded', true);
          expandButton.addClass('is-expanded')
            .find('.plus-minus').addClass('active');
        }
        self.setExpandedInDataset(dataRowIndex, !isExpanded);

        children.each(function () {
          var node = $(this);

          if (node.hasClass('datagrid-tree-parent') &&
            node.attr('aria-level') > level) {
            restCollapsed = node.find('.datagrid-expand-btn.is-expanded').length === 0;
            node[isExpanded ? 'addClass' : 'removeClass']('is-hidden');
            return true;
          }

          if (restCollapsed && node.attr('aria-level') > level) {
            node.addClass('is-hidden');
            return true;
          }

          if (node.attr('aria-level') > level) {
            node[isExpanded ? 'addClass' : 'removeClass']('is-hidden');
          }

          if (node.attr('aria-level') === level) {
            return false;
          }
        });
        self.setAlternateRowShading();
      };

      $.when(self.element.triggerHandler(isExpanded ? 'collapserow' : 'expandrow', args)).done(function() {
        toggleExpanded();
      });
    },

    //Expand Detail Row Or Tree Row
    toggleRowDetail: function(dataRowIndex) {

      var self = this,
        rowElement = self.visualRowNode(dataRowIndex),
        expandRow = rowElement.next(),
        expandButton = rowElement.find('.datagrid-expand-btn'),
        detail = expandRow.find('.datagrid-row-detail'),
        item = self.settings.dataset[self.actualArrayIndex(rowElement)];

      if (rowElement.hasClass('datagrid-tree-parent')) {
        return;
      }

      if (self.settings.allowOneExpandedRow && self.settings.groupable === null) {
        //collapse any other expandable rows
        var prevExpandRow = self.tableBody.find('tr.is-expanded'),
          parentRow = prevExpandRow.prev(),
          parentRowIdx = parentRow.attr('aria-rowindex');

        if (prevExpandRow.length && expandRow.index() !== prevExpandRow.index()) {
          var prevDetail = prevExpandRow.find('.datagrid-row-detail');

          prevExpandRow.removeClass('is-expanded');
          parentRow.removeClass('is-rowactivated');
          parentRow.find('.plus-minus').removeClass('active');
          prevDetail.animateClosed().on('animateclosedcomplete', function () {
            prevExpandRow.css('display', 'none').removeClass('is-expanded');
            self.element.triggerHandler('collapserow', [{grid: self, row: parentRowIdx, detail: prevDetail, item: self.settings.dataset[parentRowIdx] }]);
          });

          var prevActionBtn = prevExpandRow.prev().find('.btn-primary');
          prevActionBtn.attr('class', prevActionBtn.attr('class').replace('btn-primary','btn-secondary'));
        }

        //Toggle the button to make it primary
        var isExpanded = !expandRow.hasClass('is-expanded'),
          actionButton = expandRow.prev().find(isExpanded ? '.btn-secondary' : '.btn-primary');

        if (parentRow && actionButton) {
          actionButton.attr('class', actionButton.attr('class').replace(isExpanded ? 'btn-secondary' : 'btn-primary',
              isExpanded ? 'btn-primary' : 'btn-secondary') );
        }
      }

      if (expandRow.hasClass('is-expanded')) {
        expandRow.removeClass('is-expanded');
        expandButton.removeClass('is-expanded')
          .find('.plus-minus').removeClass('active');

        if (self.settings.allowOneExpandedRow) {
          rowElement.removeClass('is-rowactivated');
        }

        detail.animateClosed().on('animateclosedcomplete', function () {
          expandRow.css('display', 'none');
          self.element.triggerHandler('collapserow', [{grid: self, row: dataRowIndex, detail: detail, item: item}]);
        });

      } else {
        expandRow.addClass('is-expanded');
        expandButton.addClass('is-expanded')
          .find('.plus-minus').addClass('active');

        expandRow.css('display', 'table-row');

        //Optionally Contstrain the width
        expandRow.find('.constrained-width').css('max-width', this.element.outerWidth());

        if (self.settings.allowOneExpandedRow) {
          rowElement.addClass('is-rowactivated');
        }

        detail.animateOpen();
        self.element.triggerHandler('expandrow', [{grid: self, row: dataRowIndex, detail: detail, item: item}]);
      }
    },

    toggleGroupChildren: function(rowElement) {
      if (!this.settings.groupable) {
        return;
      }

      var self = this,
        children = rowElement.nextUntil('.datagrid-rowgroup-header'),
        expandButton = rowElement.find('.datagrid-expand-btn');

      if (rowElement.hasClass('is-expanded')) {
        expandButton.removeClass('is-expanded')
          .find('.plus-minus').removeClass('active');

        children.hide();
        children.addClass('is-hidden');
        self.element.triggerHandler('collapserow', [{grid: self, row: rowElement.index(), detail: children, item: {}}]);

        rowElement.removeClass('is-expanded');
      } else {
      expandButton.addClass('is-expanded')
        .find('.plus-minus').addClass('active');

        children.show();
        children.removeClass('is-hidden');
        self.element.triggerHandler('expandrow', [{grid: self, row: rowElement.index(), detail: children, item: {}}]);

        rowElement.addClass('is-expanded');
      }

    },

    //Api Event to set the sort Column
    setSortColumn: function(id, ascending) {
      //Set Direction based on if passed in or toggling existing field
      if (ascending !== undefined) {
        this.sortColumn.sortAsc = ascending;
      } else {
        if (this.sortColumn.sortId === id) {
          this.sortColumn.sortAsc = !this.sortColumn.sortAsc;
        } else {
           this.sortColumn.sortAsc = true;
        }
        ascending = this.sortColumn.sortAsc;
      }

      this.sortColumn.sortId = id;
      this.sortColumn.sortField = (this.columnById(id)[0] ? this.columnById(id)[0].field : id);
      this.sortColumn.sortAsc = ascending;

      //Do Sort on Data Set
      this.setSortIndicator(id, ascending);
      this.sortDataset();

      var wasFocused = this.activeCell.isFocused;
      this.setTreeDepth();
      this.setRowGrouping();
      this.setTreeRootNodes();
      this.renderRows();
      // Update selected and Sync header checkbox
      this.updateSelected();
      this.syncSelectedUI();

      if (wasFocused && this.activeCell.node.length === 1) {
        this.setActiveCell(this.activeCell.row, this.activeCell.cell);
      }

      this.resetPager('sorted');
      this.tableBody.removeClass('is-loading');
      this.saveUserSettings();
      this.element.trigger('sorted', [this.sortColumn]);
    },

    sortDataset: function() {
      if (this.originalDataset) {
        this.settings.dataset = this.originalDataset;
      }
      var sort = this.sortFunction(this.sortColumn.sortId, this.sortColumn.sortAsc);

      if (!this.settings.disableClientSort) {
        settings.dataset.sort(sort);
      }
    },

    setSortIndicator: function(id, ascending) {
      if (!this.headerRow) {
        return;
      }

      //Set Visual Indicator
      this.headerRow.find('.is-sorted-asc, .is-sorted-desc').removeClass('is-sorted-asc is-sorted-desc').attr('aria-sort', 'none');
      this.headerRow.find('[data-column-id="' +id + '"]')
        .addClass(ascending ? 'is-sorted-asc' : 'is-sorted-desc')
        .attr('aria-sort', ascending ? 'ascending' : 'descending');
    },

    //Overridable function to conduct sorting
    sortFunction: function(id, ascending) {
      var column = this.columnById(id),
        field = column.length === 0 ? id : column[0].field; //Assume the field and id match if no column found

      var key, self = this,
      primer = function(a) {
        a = (a === undefined || a === null ? '' : a);

        if (typeof a === 'string') {
          a = a.toUpperCase();

          if ($.isNumeric(a)) {
            a = parseFloat(a);
          }

        }
        return a;
      };

      key = function(x) { return primer(self.fieldValue(x, field)); };

      ascending = !ascending ? -1 : 1;

      return function (a, b) {
        a = key(a);
        b = key(b);

        if (typeof a !== typeof b) {
          a = a.toString().toLowerCase();
          b = b.toString().toLowerCase();
        }

        return ascending * ((a > b) - (b > a));
      };
    },

    // Update Selection
    updateSelected: function() {
      var self = this;

      $('tr[role="row"]', self.tableBody).each(function() {
        var row = $(this),
          newIdx = self.dataRowIndex(row),
          checkbox = self.cellNode(row, self.columnIdxById('selectionCheckbox'));

        $.each(self._selectedRows, function(index, val) {
          if (self.isEquals(val.data, self.settings.dataset[newIdx])) {
            val.idx = newIdx;
            val.elem = row;
            checkbox.find('.datagrid-cell-wrapper .datagrid-checkbox').addClass('is-checked').attr('aria-checked', 'true');
            row.addClass('is-selected' + (self.settings.selectable === 'mixed' ? ' hide-selected-color' : '')).attr('aria-selected', 'true').find('td').attr('aria-selected', 'true');
            return false;
          }
        });
      });
    },

    // Determine equality for two JavaScript objects
    isEquals: function(obj1, obj2) {
      function _equals(obj1, obj2) {
        return JSON.stringify(obj1) === JSON.stringify($.extend(true, {}, obj1, obj2));
      }
      return _equals(obj1, obj2) && _equals(obj2, obj1);
    },

    //Default formatter just plain text style
    defaultFormatter: function(row, cell, value) {
      return ((value === null || value === undefined || value === '') ? '' : value.toString());
    },

    //Handle Adding Paging
    handlePaging: function () {
      var self = this;

      if (!this.settings.paging) {
        return;
      }

      var pagerElem = this.tableBody;
      this.element.addClass('paginated');
      pagerElem.pager({
        componentAPI: this,
        dataset: this.settings.dataset,
        hideOnOnePage: this.settings.hidePagerOnOnePage,
        source: this.settings.source,
        pagesize: this.settings.pagesize,
        indeterminate: this.settings.indeterminate,
        rowTemplate: this.settings.rowTemplate,
        pagesizes: this.settings.pagesizes,
        activePage: this.restoreActivePage ? parseInt(this.savedActivePage) : 1
      });

      if (this.restoreActivePage) {
        this.savedActivePage = null;
        this.restoreActivePage = false;
      }

      this.pager = pagerElem.data('pager');

      pagerElem.on('afterpaging', function (e, args) {

        self.displayCounts(args.total);

        //Handle row selection across pages
        self.updateSelected();
        self.syncSelectedUI();

        if (self.filterExpr && self.filterExpr[0] && self.filterExpr[0].column === 'all') {
          self.highlightSearchRows(self.filterExpr[0].value);
        }
      });

    },

    renderPager: function (pagingInfo, isResponse) {
      var api = this.pager;

      if (!api) {
        return;
      }

      api.updatePagingInfo(pagingInfo);

      if (!isResponse) {
        api.renderPages(pagingInfo.type);
      }

      // Update selected and Sync header checkbox
      this.updateSelected();
      this.syncSelectedUI();
    },

    //Reset the pager to page 1
    resetPager: function(type) {
      if (!this.pager) {
        return;
      }

      if (!this.pager.pagingInfo) {
        this.pager.pagingInfo = {};
      }

      this.pager.pagingInfo.type = type;
      this.pager.pagingInfo.activePage = 1;
      this.renderPager(this.pager.pagingInfo);
    },

    destroy: function() {
      //Remove the toolbar, clean the div out and remove the pager
      this.element.off().empty().removeClass('datagrid-container');
      if (this.removeToolbarOnDestroy) {
        // only remove toolbar if it was created by this datagrid
        this.element.prev('.toolbar').remove();
      }
      this.element.next('.pager-toolbar').remove();
      $.removeData(this.element[0], pluginName);

      //TODO Test Memory Leaks in Chrome - null out fx this.table
      $(document).off('touchstart.datagrid touchend.datagrid touchcancel.datagrid click.datagrid touchmove.datagrid');
      this.contentContainer.off().remove();
      $('body').off('resize.vtable');

    }

  };

  // Initialize the plugin (Once) or set settings
  return this.each(function() {
    var instance = $.data(this, pluginName);
    if (instance) {
      instance.settings = $.extend({}, defaults, options);
    } else {
      instance = $.data(this, pluginName, new Datagrid(this, settings));
    }
  });

};

  $.fn.dropdown = function(options) {

    'use strict';

    // Dropdown Settings and Options
    var pluginName = 'dropdown',
        defaults = {
          closeOnSelect: true, // When an option is selected, the list will close if set to "true".  List stays open if "false".
          cssClass: null,  //Append a css class to dropdown-list
          filterMode: 'contains',  // startsWith and contains Supported - false will not client side filter
          maxSelected: undefined, //If in multiple mode, sets a limit on the number of items that can be selected
          moveSelected: 'none', //If set to "all" When the menu is opened, displays all selected options at the top of the list.  If set to "group", move each section to the top of it's designated optgroup
          moveSelectedToTop: undefined, //(Deprecated - see the 'moveSelected' setting)
          multiple: false, //Turns the dropdown into a multiple selection box
          noSearch: false, //If true, disables the ability of the user to enter text in the Search Input field in the open combo box
          showEmptyGroupHeaders: false, // If true, displays <optgroup> headers in the list even if no selectable options are present underneath.
          showSelectAll: false, // If true, on Multiselect dropdowns, will show an additional option at the top of the list labeled "select all".
          source: undefined, //A function that can do an ajax call.
          sourceArguments: {}, // If a source method is defined, this flexible object can be passed into the source method, and augmented with parameters specific to the implementation.
          reloadSourceOnOpen: false, // If set to true, will always perform an ajax call whenever the list is opened.  If false, the first AJAX call's results are cached.
          empty: false, //Initialize Empty Value
          delay: 300 //Typing Buffer Delay
        },
        moveSelectedOpts = ['none', 'all', 'group'],
        settings = $.extend({}, defaults, options);

    /**
     * @constructor
     * @param {Object} element
     */
    function Dropdown(element) {
      this.settings = $.extend({}, settings);
      this.element = $(element);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    // Actual DropDown Code
    Dropdown.prototype = {
      init: function() {
        var orgId = this.element.attr('id');

        this.isIe10 = (Soho.env.browser.name === 'ie' && Soho.env.browser.version === '10');
        this.isIe11 = (Soho.env.browser.name === 'ie' && Soho.env.browser.version === '11');

        this.inlineLabel = this.element.closest('label');
        this.inlineLabelText = this.inlineLabel.find('.label-text');
        this.isInlineLabel = this.element.parent().is('.inline');

        if (orgId === undefined) {
          orgId = this.element.uniqueId('dropdown');
          this.element.attr('id', orgId);
          this.element.parent().find('label').first().attr('for', orgId);
        }

        // convert <select> tag's size css classes for the pseudo element
        var elemClassList = this.element[0].classList;
        var pseudoClassString = elemClassList.contains('dropdown-xs') ? 'dropdown input-xs' :
            elemClassList.contains('dropdown-sm') ? 'dropdown input-sm' :
            elemClassList.contains('dropdown-lg') ? 'dropdown input-lg' : 'dropdown';

        //Detect Inline Styles
        var style = this.element.attr('style');
        this.isHidden = style && style.indexOf('display: none') >= 0;

        // Build the wrapper if it doesn't exist
        var baseElement = this.isInlineLabel ? this.inlineLabel : this.element;
        this.wrapper = baseElement.next('.dropdown-wrapper');
        this.isWrapped = this.wrapper.length > 0;

        if (!this.isWrapped) {
          this.wrapper = $('<div class="dropdown-wrapper"></div>').insertAfter(baseElement);
        }

        if (this.isWrapped) {
          this.pseudoElem = this.wrapper.find('.' + pseudoClassString);
          this.trigger = this.wrapper.find('.trigger');
        } else {
          this.pseudoElem = $('div#'+ orgId + '-shdo');
        }

        if(elemClassList.contains('text-align-reverse')) {
          pseudoClassString += ' text-align-reverse';
        } else if (elemClassList.contains('text-align-center')){
          pseudoClassString += ' text-align-center';
        }

        // Build sub-elements if they don't exist
        this.label = $('label[for="'+ orgId +'"]');

        if (!this.pseudoElem.length) {
          this.pseudoElem = $('<div class="'+ pseudoClassString + '">');
        } else {
          this.pseudoElem[0].setAttribute('class', pseudoClassString);
        }

        if (!this.isWrapped) {
          this.pseudoElem.append($('<span></span>'));
        }

        this.pseudoElem.attr({'role': 'combobox',
          'aria-autocomplete': 'list',
          'aria-controls': 'dropdown-list',
          'aria-readonly': 'true',
          'aria-expanded': 'false',
          'aria-label': this.label.text()});

        // Pass disabled/readonly from the original element, if applicable
        // "disabled" is a stronger setting than "readonly" - should take precedent.
        function handleStates(self) {
          var disabled = self.element.prop('disabled'),
            readonly = self.element.prop('readonly');

          if (disabled) {
            return self.disable();
          }

          if (readonly) {
            return self.readonly();
          }

          return self.enable();
        }
        handleStates(this);

        if (!this.isWrapped) {
          this.wrapper.append(this.pseudoElem, this.trigger);
        }

        // Check for and add the icon
        this.icon = this.wrapper.find('.icon');
        if (!this.icon.length) {
          this.icon = $.createIconElement('dropdown');
          this.wrapper.append(this.icon);
        }

        // Setup the incoming options that can be set as properties/attributes
        if (this.element.prop('multiple') && !this.settings.multiple) {
          this.settings.multiple = true;
        }
        var dataSource = this.element.attr('data-source');
        if (dataSource && dataSource !== 'source') {
          this.settings.source = dataSource;
        }
        var dataMaxselected = this.element.attr('data-maxselected');
        if (dataMaxselected && !isNaN(dataMaxselected)) {
          this.settings.maxSelected = parseInt(dataMaxselected, 10);
        }

        // TODO: deprecate "moveSelectedToTop" in favor of "moveSelected"
        // _getMoveSelectedSetting()_ converts the old setting to the new text type.
        function getMoveSelectedSetting(incomingSetting, useText) {
          switch (incomingSetting) {
            case (useText ? 'true' : true):
              return 'all';
            case (useText ? 'false' : false):
              return 'none';
            default:
              if (moveSelectedOpts.indexOf(incomingSetting) > -1) {
                return incomingSetting;
              }
              return 'none';
          }
        }

        // Backwards compatibility for deprecated "moveSelectedToTop" setting.
        if (this.settings.moveSelectedToTop !== undefined) {
          this.settings.moveSelected = this.settings.moveSelectedToTop;
        }

        var dataMoveSelected = this.element.attr('data-move-selected');
        if (dataMoveSelected) {
          this.settings.moveSelected = getMoveSelectedSetting(dataMoveSelected, true);
        } else {
          this.settings.moveSelected = getMoveSelectedSetting(this.settings.moveSelected);
        }

        var dataCloseOnSelect = this.element.attr('data-close-on-select');
        if (dataCloseOnSelect && !this.settings.closeOnSelect) {
          this.settings.closeOnSelect = dataCloseOnSelect === 'true';
        }
        var dataNoSearch = this.element.attr('data-no-search');
        if (dataNoSearch && !this.settings.noSearch) {
          this.settings.noSearch = dataNoSearch === 'true';
        }

        // Persist sizing defintions
        var sizingStrings = ['-xs', '-sm', '-md', '-lg'],
          classString = this.element.attr('class'),
          s;

        for (var i = 0; i < sizingStrings.length; i++) {
          s = sizingStrings[i];
          if (classString.match(s)) {
            this.pseudoElem.addClass('dropdown' + s);
          }
        }

        // Cached dataset (from AJAX, if applicable)
        this.dataset = [];

        this.listfilter = new ListFilter({
          filterMode: this.settings.filterMode
        });

        this.setValue();
        this.setInitial();
        this.setWidth();

        this.element.triggerHandler('rendered');

        return this.handleEvents();
      },

      // Used for preventing menus from popping open/closed when they shouldn't.
      // Gets around the need for timeouts everywhere
      inputTimer: function() {
        if (this.inputTimeout) {
          return false;
        }

        var self = this;

        this.inputTimeout = setTimeout(function inputTimeout(){
          clearTimeout(self.inputTimeout);
          self.inputTimeout = null;
        }, 100);

        return true;
      },

      // Set Field Width
      setWidth: function() {
        var style = this.element[0].style;

        if (style.width) {
          this.pseudoElem[0].style.width = style.width;
        }
        if (style.position === 'absolute') {
          this.pseudoElem[0].style.position = 'absolute';
          this.pseudoElem[0].style.left = style.left;
          this.pseudoElem[0].style.top = style.top;
          this.pseudoElem[0].style.bottom = style.bottom;
          this.pseudoElem[0].style.right = style.right;
        }
      },

      // Keep a generated list of items and update as needed
      updateList: function() {
        var self = this,
          isMobile = self.isMobile(),
          listExists = self.list !== undefined && self.list !== null && self.list.length > 0,
          listContents = '',
          ulContents = '',
          upTopOpts = 0,
          hasOptGroups = this.element.find('optgroup').length,
          reverseText = '',
          isMultiselect = this.settings.multiple === true,
          moveSelected = '' + this.settings.moveSelected,
          showSelectAll = this.settings.showSelectAll === true;

        if(this.element[0].classList.contains('text-align-reverse')){
          reverseText = ' text-align-reverse';
        } else if (this.element[0].classList.contains('text-align-center')){
          reverseText = ' text-align-center';
        }

        if (!listExists) {
          listContents = '<div class="dropdown-list' + reverseText +
            (isMobile ? ' mobile' : '') +
            (this.settings.multiple ? ' multiple' : '') + '" id="dropdown-list" role="application" ' + (this.settings.multiple ? 'aria-multiselectable="true"' : '') + '>' +
            '<label for="dropdown-search" class="audible">' + Locale.translate('Search') + '</label>' +
            '<input type="text" class="dropdown-search' + reverseText +
            '" role="combobox" aria-expanded="true" id="dropdown-search" aria-autocomplete="list">' +
            '<span class="trigger">' +
              (isMobile ? $.createIcon({ icon: 'close', classes: ['close'] }) : $.createIcon('dropdown')) +
              '<span class="audible">' + (isMobile ? Locale.translate('Close') : Locale.translate('Collapse')) + '</span>' +
            '</span>' +
            '<ul role="listbox">';
        }

        // Get a current list of <option> elements
        // If none are available, simply return out
        var opts = this.element.find('option');
        var groups = this.element.find('optgroup');
        var selectedOpts = opts.filter(':selected');
        var groupsSelectedOpts = [];

        function buildLiHeader(textContent) {
          return '<li role="presentation" class="group-label" focusable="false">' +
              textContent +
            '</li>';
        }

        function buildLiOption(option, index) {
          var liMarkup = '',
            attributes = Soho.DOM.getAttributes(option),
            text = option.innerHTML,
            value = attributes.getNamedItem('value'),
            title = attributes.getNamedItem('title'),
            badge = attributes.getNamedItem('data-badge'),
            badgeColor = attributes.getNamedItem('data-badge-color'),
            isSelected = option.selected,
            isDisabled = option.disabled,
            cssClasses = option.className;

          var trueValue = value && value.value ? value.value : text;
          if (trueValue === 'clear') {
            if (text === '') {
              text = Locale.translate('ClearSelection');
            }
          }

          // Set attributes need to be copy over
          var attrToCopy = {
            str: '',
            isExclude: function(attr) {
              var toExclude = ['data-badge', 'data-badge-color', 'data-val'];
              return $.inArray(attr, toExclude) > -1;
            }
          };
          for (var key in attributes) {
            if (!attributes.hasOwnProperty(key)) {
              continue;
            }
            attrToCopy.name = attributes[key].name + '';
            attrToCopy.isData = attrToCopy.name.substr(0, 5) === 'data-';
            if (attrToCopy.isData && !attrToCopy.isExclude(attrToCopy.name)) {
              attrToCopy.str += ' '+
                attrToCopy.name +'="'+ attributes[key].value +'"';
            }
          }

          liMarkup += '<li role="presentation" class="dropdown-option'+ (isSelected ? ' is-selected' : '') +
                        (isDisabled ? ' is-disabled' : '') +
                        (cssClasses ? ' ' + cssClasses.value : '' ) + '"' +
                        attrToCopy.str +
                        ' data-val="' + trueValue.replace('"', '/quot/') + '"' +
                        ' tabindex="' + (index && index === 0 ? 0 : -1) + '">' +
                        (title ? '" title="' + title.value + '"' : '') +
                        '<a role="option" href="#" class="' +
                        (trueValue === 'clear' ? ' clear-selection' : '' ) + '"' +
                        'id="list-option'+ index +'">' +
                          text +
                        '</a>' +
                        (badge ? '<span class="badge "' + (badgeColor ? badgeColor.value : 'azure07') + '"> '+ badge.value + '</span>' : '') +
                      '</li>';

          return liMarkup;
        }

        // In multiselect scenarios, shows an option at the top of the list that will
        // select all available options if checked.
        if (isMultiselect && showSelectAll) {
          var allSelected = opts.not('[disabled], .hidden').length === selectedOpts.not('[disabled], .hidden').length;

          ulContents += '<li role="presentation" class="dropdown-select-all-list-item'+ (allSelected ? ' is-selected' : '') + '">' +
            '<a role="option" href="#" id="dropdown-select-all-anchor" class="dropdown-select-all-anchor">' +
              Locale.translate('SelectAll') +
            '</a>' +
          '</li>';
        }

        // Move selected options in each group to just underneath their corresponding group headers.
        if (moveSelected === 'group') {
          // If no optgroups exist, change to "all" and skip this part.
          if (!groups || !groups.length) {
            moveSelected = 'all';
          } else {

            // Break apart selectedOpts into groups.
            // These selected items are applied when the header is generated.
            groups.each(function(i, g) {
              var els = selectedOpts.filter(function() {
                return $.contains(g, this);
              });
              groupsSelectedOpts.push(els);
            });

          }
        }

        // Move all selected options to the top of the list if the setting is true.
        // Also adds a group heading if other option groups are found in the <select> element.
        if (moveSelected === 'all') {
          opts = opts.not(selectedOpts);

          // Show a "selected" header if there are selected options
          if (selectedOpts.length > 0) {
            ulContents += buildLiHeader(Locale.translate('Selected') + ' ' + (self.isInlineLabel ? self.inlineLabelText.text() : this.label.text()));
          }

          selectedOpts.each(function(i) {
            ulContents += buildLiOption(this, i);
            upTopOpts++;
          });

          // Only show the "all" header beneath the selected options if there are no other optgroups present
          if (!hasOptGroups && opts.length > 0) {
            ulContents += buildLiHeader(Locale.translate('All') + ' ' + (self.isInlineLabel ? self.inlineLabelText.text() : this.label.text()));
          }
        }

        opts.each(function(i) {
          var count = i + upTopOpts,
            option = $(this),
            parent = option.parent(),
            optgroupIsNotDrawn,
            optgroupIndex;

          // Add Group Header if this is an <optgroup>
          // Remove the group header from the queue.
          if (parent.is('optgroup') && groups.length) {
            optgroupIndex = parent.index();
            optgroupIsNotDrawn = groups.index(parent) > -1;

            if (optgroupIsNotDrawn) {
              groups = groups.not(parent);
              ulContents += buildLiHeader('' + parent.attr('label'));

              // Add all selected items for this group
              if (moveSelected === 'group') {
                groupsSelectedOpts[optgroupIndex].each(function(i) {
                  ulContents += buildLiOption(this, i);
                  upTopOpts++;
                });
              }
            }
          }

          if (moveSelected !== 'none' && option.is(':selected')) {
            return;
          }

          ulContents += buildLiOption(this, count);
        });

        // Render the new list contents to the page.
        // Build the entire thing and set references if this is the first opening.
        // Otherwise, simply replace the elements inside the <ul>.
        if (!listExists) {
          listContents += ulContents + '</ul>' +
            '</div>';

          // Append markup to the DOM
          this.list = $(listContents);

          // Get references
          this.listUl = this.list.find('ul');
          this.searchInput = this.list.find('#dropdown-search');
        } else {
          this.listUl.html(ulContents);
        }
      },

      // Set the value based on selected options
      setValue: function () {
        var opts = this.element.find('option:selected'),
          text = this.getOptionText(opts);
          if (opts.attr('value') === 'clear') {
            text = '';
          }
        if (this.settings.empty && opts.length === 0) {
          this.pseudoElem.find('span').text('');
          return;
        }

        //Set initial values for the edit box
        this.setPseudoElemDisplayText(text);
        if (this.element.attr('maxlength')) {
           this.setPseudoElemDisplayText(text.substr(0, this.element.attr('maxlength')));
        }

        //Set the "previousActiveDescendant" to the first of the items
        this.previousActiveDescendant = opts.first().val();

        this.setBadge(opts);
      },

      // Sets only the display text of the Dropdown/Mutliselect
      // Can be used for setting a pre-populated value when working with an AJAX call.
      setPseudoElemDisplayText: function(text) {
        this.pseudoElem.find('span').text(text);
      },

      copyClass: function(from, to, prop) {
        if (from.hasClass(prop)) {
          to.addClass(prop);
        }
      },

      // Copy initial stuff from the drop down.
      setInitial: function() {

        if (this.element.is(':disabled')) {
          this.disable();
        }
        if (this.element.is('[readonly]')) {
          this.readonly();
        }
        if (this.isHidden) {
          this.pseudoElem.hide().prev('label').hide();
          this.pseudoElem.next('svg').hide();
        }

        if (this.element.attr('placeholder')) {
          this.pseudoElem.attr('placeholder', this.element.attr('placeholder'));
          this.element.removeAttr('placeholder');
        }
      },

      //Bind mouse and key events
      handleEvents: function() {
        var self = this;

        this.pseudoElem.on('keydown.dropdown', function(e) {
          self.ignoreKeys($(this), e);
          self.handleKeyDown($(this), e);
        }).on('keypress.dropdown', function(e) {
          if (e.keyCode === 9) {
            return;
          }
          self.ignoreKeys($(this), e);

          if (!self.settings.noSearch) {
            self.toggleList();
          }
          self.handleAutoComplete(e);
        }).on('click.dropdown', function(e) {
          e.stopPropagation();
        }).on('mouseup.dropdown', function(e) {
          if (e.button === 2) {
            return;
          }
          self.toggleList();
        }).on('touchend.dropdown touchcancel.dropdown', function(e) {
          e.stopPropagation();
          self.toggleList();
          e.preventDefault();
        });

        self.element.on('activated.dropdown', function () {
          self.label.trigger('click');
        }).on('updated.dropdown', function (e) {
          e.stopPropagation();
          self.updated();
        }).on('openlist.dropdown', function() {
          self.toggleList();
        });

        //for form resets.
        self.element.closest('form').on('reset.dropdown', function() {
          setTimeout(function () {
            self.element.triggerHandler('updated');
          }, 1);
        });

        //Handle Label click
        this.label.onTouchClick().on('click', function () {
          self.pseudoElem.focus();
        });

      },

      ignoreKeys: function (input, e) {
        var charCode = e.which;

        //Needed for browsers that use keypress events to manipulate the window.
        if (e.altKey && (charCode === 38 || charCode === 40)) {
          e.stopPropagation();
          e.preventDefault();
          return false;
        }

        if (charCode === 8 && input.hasClass('dropdown')) {
          e.stopPropagation();
          e.preventDefault();
          return false;
        }

        if (input.is(':disabled') || input.hasClass('is-readonly')) {
          return;
        }

        return true;
      },

      //handle events while search is focus'd
      handleSearchEvents: function () {
        var self = this, timer;

        if (this.settings.noSearch) {
          this.searchInput.prop('readonly', true);
        }

        // Used to determine how spacebar should function.  False means space will select/deselect.  True means
        // Space will add a space inside the search input.
        this.searchKeyMode = false;

        this.searchInput.on('keydown.dropdown', function(e) {
          var searchInput = $(this);

          if (!self.ignoreKeys(searchInput, e)) {
            return;
          }

          if (!self.handleKeyDown(searchInput, e)) {
            return;
          }

          if (self.settings.noSearch === false && !self.settings.source) {
            clearTimeout(timer);
            timer = setTimeout(function () {
              if (searchInput.val() === '') {
                self.resetList();
              } else {
                self.filterList(searchInput.val().toLowerCase());
              }
            }, 100);
          }
        }).on('keypress.dropdown', function (e) {
          self.isFiltering = true;
          self.handleAutoComplete(e);
        });

      },

      filterList: function(term) {
        var self = this,
          selected = false,
          list = $('.dropdown-option', this.listUl),
          headers = $('.group-label', this.listUl),
          results;

        if (!list.length || !this.list || this.list && !this.list.length) {
          return;
        }

        if (!term) {
          term = '';
        }

        if (term && term.length) {
          results = this.listfilter.filter(list, term);
        }

        this.list.addClass('search-mode');
        this.list.find('.icon').attr('class', 'icon search').changeIcon('search');
        this.searchInput.removeAttr('aria-activedescendant');

        this.unhighlightOptions();

        if (!results || !results.length && !term) {
          this.resetList();
          return;
        }

        list.not(results).add(headers).addClass('hidden');
        list.filter(results).each(function(i) {
          var li = $(this);
          li.attr('tabindex', i === 0 ? '0' : '-1');

          if (!selected) {
            self.highlightOption(li);
            selected = true;
          }

          //Highlight Term
          var exp = new RegExp('(' + term + ')', 'i');
          var text = li.text().replace(exp, '<i>$1</i>');
          li.removeClass('hidden').children('a').html(text);
        });

        headers.each(function() {
          var children = $(this).nextUntil('.group-label, .selector').not('.hidden');
          if (self.settings.showEmptyGroupHeaders || children.length) {
            $(this).removeClass('hidden');
          }
        });

        term = '';
        this.position();
      },

      // Removes filtering from an open Dropdown list and turns off "search mode"
      resetList: function() {
        if (!this.list || this.list && !this.list.length) {
          return;
        }
        var isMobile = this.isMobile(),
          cssClass = 'icon' + (isMobile ? ' close' : ''),
          icon = $.getBaseURL(isMobile ? 'close' : 'dropdown');

        this.list.removeClass('search-mode');
        this.list.find('.icon').attr('class', cssClass) // needs to be 'attr' here because .addClass() doesn't work with SVG
          .changeIcon(icon);

        function stripHtml(obj) {
          if (!obj[0]) {
            return '';
          }

          return obj[0].textContent || obj[0].innerText;
        }

        var lis = this.listUl.find('li');
        lis.removeAttr('style').each(function() {
          var a = $(this).children('a');
          a.text(stripHtml(a));
        });

        //Adjust height / top position
        if (this.list.hasClass('is-ontop')) {
          this.list[0].style.top = (this.pseudoElem.offset().top - this.list.height() + this.pseudoElem.outerHeight() - 2) +'px';
        }

        if (this.settings.multiple) {
          this.updateList();
        }
      },

      selectBlank: function() {
        var blank = this.element.find('option').filter(function() {
          return !this.value || $.trim(this.value).length === 0;
        });

        if (blank.length > 0) {
          blank[0].selected = true;
          this.element.triggerHandler('updated').triggerHandler('change');
        }

      },

      handleKeyDown: function(input, e) {
        var selectedIndex = this.element[0].selectedIndex || -1,
            options = this.element[0].options,
            key = e.which,
            self = this,
            excludes = 'li:visible:not(.separator):not(.group-label):not(.is-disabled)',
            next;

        if (this.isLoading()) {
          return;
        }

        //Down arrow, Up arrow, or Spacebar to open
        if (!self.isOpen() && (key === 38 || key === 40 || key === 32)) {
          self.toggleList();
          return;
        }

        if (self.isOpen()) {
          options = this.listUl.find(excludes);
          selectedIndex = -1;
          $(options).each(function(index) {
            if ($(this).is('.is-focused')) {
              selectedIndex = index;
            }
          });
        }

        switch (key) {
          case 37: //backspace
          case 8: //del & backspace
          case 46: { //del

            if (!self.isOpen()) {
              self.selectBlank();
              // Prevent Backspace from returning to the previous page.
              e.stopPropagation();
              e.preventDefault();
              return false;
            }
            break;
          }
          case 9: {  //tab - save the current selection
            // If "search mode" is currently off, Tab should turn this mode on and place focus back
            // into the SearchInput.  If search mode is on, Tab should 'select' the currently highlighted
            // option in the list, update the SearchInput and close the list.
            if (self.isOpen()) {
              self.selectOption($(options[selectedIndex])); // store the current selection
              self.closeList('tab');
              this.activate();
            }
            // allow tab to propagate otherwise
            return true;
          }
          case 27: { //Esc - Close the Combo and Do not change value
            if (self.isOpen()) {
              // Close the option list
              self.closeList('cancel');
              self.activate();
              e.stopPropagation();
              return false;
            }
            // Allow Esc to propagate if the menu was closed, since some other Controls
            // that rely on dropdown may need to trigger routines when the Esc key is pressed.
            break;
          }
          case 32: // spacebar // TODO: Figure Out what to do about using Spacebar.
          case 13: { //enter
            if (self.isOpen()) {
              if (key === 32 && self.searchKeyMode === true) {
                break;
              }

              e.preventDefault();

              self.selectOption($(options[selectedIndex])); // store the current selection
              if (self.settings.closeOnSelect) {
                self.closeList('select');  // Close the option list
                self.activate();
              }
            }
            e.stopPropagation();
            return false;
          }
          case 38: {  //up
            if (e.shiftKey) {
              return;
            }
            this.searchKeyMode = false;

            if (selectedIndex > 0) {
              next = $(options[selectedIndex - 1]);
              this.highlightOption(next);
              // NOTE: Do not also remove the ".is-selected" class here!  It's not the same as ".is-focused"!
              // Talk to ed.coyle@infor.com if you need to know why.
              next.parent().find
              ('.is-focused').removeClass('is-focused');
              next.addClass('is-focused');
            }

            e.stopPropagation();
            e.preventDefault();
            return false;
          }
          case 40: {  //down
            if (e.shiftKey) {
              return;
            }
            this.searchKeyMode = false;

            if (selectedIndex < options.length - 1) {
              next = $(options[selectedIndex + 1]);
              this.highlightOption(next);
              // NOTE: Do not also remove the ".is-selected" class here!  It's not the same as ".is-focused"!
              // Talk to ed.coyle@infor.com if you need to know why.
              next.parent().find('.is-focused').removeClass('is-focused');
              next.addClass('is-focused');
            }

            e.stopPropagation();
            e.preventDefault();
            return false;
          }
          case 35: { //end
            this.searchKeyMode = false;

            var last = $(options[options.length - 1]);
            this.highlightOption(last);

            e.stopPropagation();
            return false;
          }
          case 36: {  //home
            this.searchKeyMode = false;

            var first = $(options[0]);
            this.highlightOption(first);

            e.stopPropagation();
            return false;
          }
        }

        if (self.isOpen() && self.isControl(key) && key !== 8) {
          return false;
        }

        var isSearchInput = self.searchInput && self.searchInput.length;

        self.initialFilter = false;

        if (!self.isOpen() && !self.isControl(key) && !this.settings.source && !this.settings.noSearch) {
          //Make this into Auto Complete
          self.initialFilter = true;
          self.isFiltering = true;
          self.filterTerm = $.actualChar(e);
          if (isSearchInput) {
            self.searchInput.val($.actualChar(e));
          }
          self.toggleList();
        }

        this.searchKeyMode = true;
        if (self.searchInput) {
          self.searchInput.attr('aria-activedescendant', '');
        }
        return true;
      },

      timer: null,
      filterTerm: '',

      handleAutoComplete: function(e) {
        if (this.isLoading()) {
          return;
        }

        var self = this;
        clearTimeout(this.timer);

        if (!self.settings.source) {
          return;
        }

        self.initialFilter = true;
        self.filterTerm += $.actualChar(e);

        this.timer = setTimeout(function () {
          if (!self.isOpen()) {
            self.searchInput.val(self.filterTerm);
            self.toggleList();
          } else {
            self.filterList(self.searchInput.val().toLowerCase());
          }
        }, self.settings.delay);
      },

      isControl: function(keycode) {
        var valid =
          (keycode > 7 && keycode < 48)   || // control chars
          (keycode > 90 && keycode < 94)   || // windows keys
          (keycode > 111 && keycode < 146);  // function keys

          return valid;
      },

      // Focus the Element
      activate: function (useSearchInput) {
        var self = this,
          input = this.pseudoElem;

        if (useSearchInput || self.isMobile()) {
          input = this.searchInput;
        }

        if (useSearchInput && (input.hasClass('is-readonly') || input.prop('readonly') === true)) {
          return;
        }

        function selectText() {
          if (self.isMobile()) {
            return;
          }

          if (input[0].setSelectionRange) {
            input[0].setSelectionRange(0, input[0].value.length);  //scroll to left
          } else {
            if (input[0].tagName === 'INPUT') { // using Search Input instead of Pseudo Div
              input[0].select();
            }
          }
        }

        selectText();

        if (document.activeElement !== input[0] &&
          $(document.activeElement).is('body, .dropdown.is-open')) {
          input[0].focus();
        }

        if (self.isIe10 || self.isIe11) {
          setTimeout(function() {
            input[0].focus();
          }, 0);
        }
      },

      // Retrieves a string containing all text for currently selected options delimited by commas
      getOptionText: function(opts) {
        var text = '';

        if (!opts) {
          opts = this.element.find('option:selected');
        }

        opts.each(function() {
          if (text.length > 0) {
            text += ', ';
          }
          text += $(this).text();
        });

        return text;
      },

      // Prep for opening list,make ajax call ect...
      open: function() {
        var self = this;

        if (!this.inputTimer()) {
          return;
        }

        if (this.element.is(':disabled') || this.pseudoElem.hasClass('is-disabled') || this.pseudoElem.hasClass('is-readonly')) {
          return;
        }

        if (!self.callSource(function () {
          self.updateList();
          self.openList();
        })) {
          self.updateList();
          this.openList();
        }
      },

      // Actually Show The List
      openList: function () {
        var current = this.previousActiveDescendant ? this.list.find('.dropdown-option[data-val="'+ this.previousActiveDescendant.replace('"', '/quot/') +'"]') : this.list.find('.is-selected'),
          self =  this,
          touchPrevented = false,
          threshold = 10,
          isEmpty = true,
          pos;

        if (current.length > 0) {
          isEmpty = true;
        }

        if (Soho.env.os.name === 'ios') {
          $('head').triggerHandler('disable-zoom');
        }

        // Persist the "short" input field
        var isShort = (this.element.closest('.field-short').length === 1);

        this.pseudoElem
          .attr('aria-expanded', 'true')
          .addClass('is-open');

        this.pseudoElem.attr('aria-label', this.label.text());
        this.searchInput.attr('aria-activedescendant', current.children('a').attr('id'));

        //Close any other drop downs.
        $('select').each(function () {
          var data = $(this).data();
          if (data.dropdown) {
            data.dropdown.closeList('cancel');
          }
        });

        this.list.appendTo('body').show();

        //In a grid cell
        this.isInGrid = this.pseudoElem.closest('.datagrid-row').length === 1;
        if (this.pseudoElem.parent().hasClass('is-inline')) {
          this.isInGrid = false;
        }

        if (this.isInGrid) {
          var rowHeight = this.pseudoElem.closest('.datagrid').attr('class').replace('datagrid', '');
          this.list.addClass('datagrid-dropdown-list ' + rowHeight);
        }

        if (this.pseudoElem.closest('.datagrid-filter-wrapper').length === 1) {
          this.list.addClass('datagrid-filter-dropdown');
        }

        var cssClass = this.settings.cssClass;
        if (cssClass && typeof cssClass === 'string') {
          this.list.addClass(cssClass);
        }

        this.position();

        if (!this.settings.multiple && this.initialFilter) {
          setTimeout(function () {
            self.searchInput.val(self.filterTerm);
            self.filterList(self.searchInput.val());
          }, 0);
          this.initialFilter = false;
        } else {
          // Change the values of both inputs and swap out the active descendant
          this.searchInput.val(this.pseudoElem.find('span').text());
        }

        var noScroll = this.settings.multiple;
        this.highlightOption(current, noScroll);
        if (this.settings.multiple && this.listUl.find('.is-selected').length > 0) {
          this.highlightOption(this.listUl.find('.dropdown-option').eq(0));
          setTimeout(function() {
            self.listUl.scrollTop(0);
          }, 0);
        }

        if (!this.settings.multiple && !isEmpty) {
          this.searchInput.val(current.find('a').text());
        }

        this.handleSearchEvents();
        this.activate(true); // Focus the Search Input
        this.element.trigger('listopened');

        if (this.isMobile()) {
          // iOS-specific keypress event that listens for when you click the "done" button
          self.searchInput.on('keypress.dropdown', function(e) {
            if (e.which === 13) {
              self.closeList('select');
            }
          });
        }

        function listItemClickHandler(e) {
          var target = $(e.target),
            ddOption = target.closest('li');

          if (ddOption.length) {
            // Do nothing for group labels or separators
            if (ddOption.is('.separator, .group-label')) {
              return;
            }

            target = ddOption;
          }

          if (target.is('.dropdown-select-all-anchor')) {
            target = target.parent();
          }

          // If this is the Select All option, select/deselect all.
          if (self.settings.multiple && target.is('.dropdown-select-all-list-item')) {
            var doSelectAll = !(target.is('.is-selected'));
            if (doSelectAll) {
              target.addClass('is-selected');
              self.selectOptions(self.element.find('option:not(:selected)'), true);
            } else {
              target.removeClass('is-selected');
              self.selectOptions(self.element.find('option:selected'), true);
            }

            return true;
          }

          e.preventDefault();
          e.stopPropagation();

          var val = target.attr('data-val').replace('"','/quot/'),
            cur = self.element.find('option[value="'+ val +'"]');
          //Try matching the option's text if 'cur' comes back empty or overpopulated.
          //Supports options that don't have a 'value' attribute
          //And also some special &quote handling
          if (cur.length === 0 || cur.length > 1) {
            cur = self.element.find('option').filter(function() {
              var elem = $(this),
                attr = elem.attr('value');
              return elem.text() === val || (attr && attr.replace('"','/quot/') === val);
            });
          }

          //Select the clicked item
          if (cur.is(':disabled')) {
            return false;
          }

          self.selectOption(cur);

          if (self.settings.closeOnSelect) {
            self.closeList('select');
          }

          if (self.isMobile()) {
            return true;
          }

          self.activate(!self.settings.closeOnSelect);
          return true;
        }

        self.list
          .removeClass('dropdown-tall')
          .addClass(isShort ? 'dropdown-short' : '')
          .onTouchClick('list', 'li')
          .on('click.list', 'li', listItemClickHandler)
          .on('mouseenter.list', 'li', function() {
            var target = $(this);

            if (target.is('.separator, .group-label')) {
              return;
            }

            self.list.find('li').removeClass('is-focused');
            target.addClass('is-focused');
          });

        // Some list-closing events are on a timer to prevent immediate list close
        // There would be several things to check with a setTimeout, so this is done with a CSS
        // class to keep things a bit cleaner
        setTimeout(function delayedListCloseEvents() {
          self.list.addClass('is-closable');
        }, 100);

        // Is the jQuery Element a component of the current Dropdown list?
        function isDropdownElement(target) {
          return target.closest('.dropdown, .multiselect').length > 0 ||
            target.closest('.dropdown-list').length > 0 ||
            self.touchmove === true;
        }

        // Triggered when the user scrolls the page.
        // Ignores Scrolling on Mobile, and will not close the list if accessing an item within the list
        function scrollDocument(e) {
          if (touchPrevented || isDropdownElement($(e.target))) {
            return;
          }
          self.closeList('cancel');
        }

        // Triggered when the user clicks anywhere in the document
        // Will not close the list if the clicked target is anywhere inside the dropdown list.

        function clickDocument(e) {
          var target = $(e.target);
          if (touchPrevented || (isDropdownElement(target) && !target.is('.icon'))) {
            e.preventDefault();

            touchPrevented = false;
            return;
          }

          self.closeList('cancel');
        }

        function touchStartCallback(e) {
          touchPrevented = false;

          pos = {
            x: e.originalEvent.touches[0].pageX,
            y: e.originalEvent.touches[0].pageY
          };

          $(document).on('touchmove.dropdown', function touchMoveCallback(e) {
            var newPos = {
              x: e.originalEvent.touches[0].pageX,
              y: e.originalEvent.touches[0].pageY
            };

            if ((newPos.x >= pos.x + threshold) || (newPos.x <= pos.x - threshold) ||
                (newPos.y >= pos.y + threshold) || (newPos.y <= pos.y - threshold)) {
              touchPrevented = true;
            }
          });
        }

        function touchEndCallback(e) {
          $(document).off('touchmove.dropdown');
          e.preventDefault();

          if (touchPrevented) {
            return false;
          }

          clickDocument(e);
        }

        // Need to detect whether or not scrolling is happening on a touch-capable device
        // The dropdown list should not close on mobile if scrolling is occuring, but should close
        // if the user is simply tapping outside the list.
        $(document)
          .on('touchstart.dropdown', touchStartCallback)
          .on('touchend.dropdown touchcancel.dropdown', touchEndCallback)
          .on('click.dropdown', clickDocument);

        var parentScroll = self.element.closest('.scrollable').length ? self.element.closest('.scrollable') : $(document);
        parentScroll = self.element.closest('.scrollable-y').length ? self.element.closest('.scrollable-y') : parentScroll;
        parentScroll.on('scroll.dropdown', scrollDocument);

        $('body').on('resize.dropdown', function() {
          self.position();

          // in desktop environments, close the list on viewport resize
          if (window.orientation === undefined) {
            self.closeList('cancel');
          }
        });

        // In mobile environments, close the list on an orientation change.
        // Don't do this on mobile against a resize because of the software keyboard's potential
        // to cause a "resize" event to fire.
        if (window.orientation !== undefined) {
          $(window).on('orientationchange.dropdown', function() {
            self.closeList('cancel');
          });
        }

        if (Soho.env.os.name === 'ios') {
          $('head').triggerHandler('enable-zoom');
        }
      },

      /**
       * Set size and positioning of the list
       * @returns {undefined}
       */
      position: function() {
        var self = this,
          positionOpts = {
            parentXAlignment: 'left',
            placement: 'bottom',
            strategies: ['flip', 'shrink-y']
          };

        function dropdownAfterPlaceCallback(e, placementObj) {
          // Turn upside-down if flipped to the top of the pseudoElem
          if (placementObj.wasFlipped === true) {
            self.list.addClass('is-ontop');
            self.listUl.prependTo(self.list);
          }

          // Set the <UL> height to 100% of the `.dropdown-list` minus the size of the search input
          var ulHeight = parseInt(window.getComputedStyle(self.listUl[0]).height),
            listHeight = parseInt(window.getComputedStyle(self.list[0]).height),
            searchInputHeight = 34;
          if (ulHeight + searchInputHeight > listHeight) {
            self.listUl[0].style.height = (listHeight - searchInputHeight) + 'px';
          }

          return placementObj;
        }

        // Reset styles that may have been appended to the list
        this.list[0].removeAttribute('style');
        this.listUl[0].removeAttribute('style');

        var parentElement = this.pseudoElem;
        if (this.isInGrid) {
          parentElement = this.element.closest('.datagrid-cell-wrapper');
        }

        // If the list would end up being wider parent,
        // use the list's width instead of the parent's width
        var listDefaultWidth, useParentWidth,
          parentElementStyle = window.getComputedStyle(parentElement[0]),
          parentElementWidth = Math.round(parseInt(parentElement[0].clientWidth + parentElementStyle.borderLeftWidth + parentElementStyle.borderRightWidth));

        this.searchInput[0].style.cssText = 'width:'+ parentElementWidth +'px !important';
        listDefaultWidth = Math.round(this.list.width());
        useParentWidth = listDefaultWidth <= parentElementWidth;
        this.searchInput[0].style.width = '';

        // Add parent info to positionOpts
        positionOpts.parent = parentElement;
        positionOpts.useParentWidth = useParentWidth;

        // use negative height of the pseudoElem to get the Dropdown list to overlap the input.
        positionOpts.y = parseInt(parentElementStyle.height + parentElementStyle.borderTopWidth + parentElementStyle.borderBottomWidth) * -1;
        if (Soho.env.browser.name === 'ie' && Soho.env.browser.version === '11') {
          positionOpts.y = (positionOpts.y * 2);
        }

        this.list.one('afterplace.dropdown', dropdownAfterPlaceCallback).place(positionOpts);
        this.list.data('place').place(positionOpts);
      },

      // Alias that works with the global "closeChildren" method.  See "js/lifecycle.js"
      close: function() {
        return this.closeList('cancel');
      },

      //Close list and detach events
      closeList: function(action) {
        if (!this.list || !this.list.is(':visible') || !this.isListClosable()) {
          return;
        }

        if (!this.inputTimer()) {
          return;
        }

        if (this.touchmove) {
          this.touchmove = false;
        }

        this.filterTerm = '';
        this.searchInput.off('keydown.dropdown keypress.dropdown keypress.dropdown');

        this.list
          .off('click.list touchmove.list touchend.list touchcancel.list mousewheel.list mouseenter.list')
          .remove();

        this.pseudoElem
          .removeClass('is-open')
          .attr('aria-expanded', 'false');

        this.searchInput
          .removeAttr('aria-activedescendant');

        $(document)
          .off('click.dropdown scroll.dropdown touchmove.dropdown touchend.dropdown touchcancel.dropdown');

        $('body').off('resize.dropdown');
        $(window).off('orientationchange.dropdown');
        this.element.trigger('listclosed', action);
        this.activate();
        this.list = null;
        this.searchInput = null;
        this.listUl = null;
      },

      //Set option into view
      scrollToOption: function(current) {
        var self = this;
        if (!current) {
          return;
        }
        if (current.length === 0) {
          return;
        }
        // scroll to the currently selected option
        self.listUl.scrollTop(0);
        self.listUl.scrollTop(current.offset().top - self.listUl.offset().top - self.listUl.scrollTop() - 40);
      },

      //Blur and Close List
      handleBlur: function() {
        var self = this;

        if (this.isOpen()) {
          this.timer = setTimeout(function() {
            self.closeList('cancel');
          }, 40);
        }

        return true;
      },

      // returns true if the field is attempting to load via AJAX.
      isLoading: function() {
        return this.element.is('.is-loading') &&  this.element.is('.is-blocked') ;
      },

      // Return true/false if the list is open
      isOpen: function() {
        return (this.list && this.list.is(':visible')) ? true : false;
      },

      // Hide or Show list
      toggleList: function() {
        if (this.isOpen() || this.isLoading()) {
          this.closeList('cancel');
          return;
        }
        this.open();
      },

      highlightOption: function(listOption, noScroll) {
        if (!listOption) {
          return listOption;
        }

        if (listOption.length === 0) {
          listOption = this.list.find('.dropdown-option').eq(0);
        }

        // Get corresponding option from the list
        var option = this.element.find('option[value="' + listOption.attr('data-val') + '"]');

        if (option.hasClass('.is-disabled') || option.is(':disabled')) {
          return;
        }

        if (this.isOpen()) {
          this.list.find('.is-focused').removeClass('is-focused').attr({'tabindex':'-1'});
          if (option.val() !== 'clear') {
            listOption.addClass('is-focused').attr({'tabindex': '0'});
          }

          // Set activedescendent for new option
          //this.pseudoElem.attr('aria-activedescendant', listOption.attr('id'));
          this.searchInput.attr('aria-activedescendant', listOption.children('a').attr('id'));

          if (!noScroll || noScroll === false || noScroll === undefined) {
            this.scrollToOption(listOption);
          }
        }

        return;
      },

      unhighlightOptions: function(listOptions, noScroll) {
        if (!listOptions || !listOptions.length) {
          listOptions = this.list.find('.is-selected');
        }

        listOptions.removeClass('is-focused').attr({'tabindex': '-1'});

        this.searchInput.removeAttr('aria-activedescendant');

        if (!noScroll || noScroll === false || noScroll === undefined) {
          this.scrollToOption(listOptions.first());
        }
      },

      /**
       * Convenience method for running _selectOption()_ on a set of list options.
       * Accepts an array or jQuery selector containing valid list options and selects/deselects them.
       * @param {Array|jQuery[]} options - incoming options
       * @param {boolean} noTrigger - if true, causes the 'selected' and 'change' events not to fire on each list item.
       * @return {undefined}
       */
      selectOptions: function(options, noTrigger) {
        // Use a jQuery selector if the incoming options are inside an array
        if (Array.isArray(options)) {
          options = $(options);
        }

        var self = this;
        options.each(function() {
          self.selectOption($(this), noTrigger);
        });
      },

      /**
       * Select an option and conditionally trigger events.
       * Accepts an array or jQuery selector containing valid list options and selects/deselects them.
       * @param {jQuery} option - the incoming option
       * @param {boolean} noTrigger - if true, causes the 'selected' and 'change' events not to fire on the list item.
       * @return {undefined}
       */
      selectOption: function(option, noTrigger) {
        if (!option) {
          return option;
        }
        var li;
        if (option.is('li')) {
          li = option;
          option = this.element.find('option[value="' + option.attr('data-val') + '"]');

          //Try matching the option's text if 'cur' comes back empty.
          //Supports options that don't have a 'value' attribute.
          if (option.length === 0) {
            option = this.element.find('option').filter(function() {
              return $(this).text() === li.attr('data-val');
            });
          }
        }

        var value = option.val();
        if (!value) {
          return value;
        }

        if (!li) {
          li = this.listUl.find('li[data-val="'+ option.val().replace('"', '/quot/') +'"]');
        }

        if (option.hasClass('is-disabled') || option.is(':disabled')) {
          return;
        }

        var code = option.val(),
          val = this.element.val(),
          oldText = this.pseudoElem.text(),
          text = '',
          trimmed = '',
          clearSelection = false,
          isAdded = true; // Sets to false if the option is being removed from a multi-select instead of added

        if (option.val() === 'clear') {
          clearSelection = true;
        }

        if (this.settings.multiple) {
          // Working with a select multiple allows for the "de-selection" of items in the list
          if (!val) {
            val = [];
          }
          if ($.inArray(code, val) !== -1) {
            val = $.grep(val, function(optionValue) {
              return optionValue !== code;
            });
            li.removeClass('is-selected');
            this.previousActiveDescendant = undefined;
            isAdded = false;
          } else {
            if (!isNaN(this.settings.maxSelected) && this.element.find('option:selected').length >= this.settings.maxSelected) {
              return;
            }

            val = typeof val === 'string' ? [val] : val;
            val.push(code);
            li.addClass('is-selected');
            this.previousActiveDescendant = option.val();
          }

          var newOptions = this.element.find('option').filter(function() {
            return $.inArray($(this)[0].value, val) !== -1;
          });
          text = this.getOptionText(newOptions);
        } else {
          // Working with a single select
          val = code;
          this.listUl.find('li.is-selected').removeClass('is-selected');
          if (!clearSelection) {
            li.addClass('is-selected');
          }
          this.previousActiveDescendant = option.val();
          text = option.text();
        }
        if (!clearSelection) {
          this.element.find('option').each(function () {
            if (this.value === code) {
              this.selected = true;
              return false;
            }
          });
        }
        // If we're working with a single select and the value hasn't changed, just return without
        // firing a change event
        if (text === oldText) {
          return;
        }

        // Change the values of both inputs and swap out the active descendant
        if (!clearSelection) {
          this.pseudoElem.find('span').text(text);
          this.searchInput.val(text);
        } else {
          this.pseudoElem.find('span').text('');
          this.searchInput.val('');
        }

        if (this.element.attr('maxlength')) {
          trimmed = text.substr(0, this.element.attr('maxlength'));
          this.pseudoElem.find('span').text(trimmed);
          this.searchInput.val(trimmed);
        }

        // Set the new value on the <select>
        this.element.val(val);

        // Fire the change event with the new value if the noTrigger flag isn't set
        if (!noTrigger) {
          this.element.trigger('change').triggerHandler('selected', [option, isAdded]);
        }

        // If multiselect, reset the menu to the unfiltered mode
        if (this.settings.multiple) {
          if (this.list.hasClass('search-mode')) {
            this.resetList();
          }
          this.activate(true);
        }

        this.setBadge(option);
      },

      setBadge: function (option) {
        //Badge Support
        if (this.badges) {
          var badge = this.element.parent().find('.badge');

          if (badge.length === 0) {
            this.element.parent().find('.dropdown-wrapper').append('<span class="badge">1</span>');
            badge = this.element.parent().find('.badge');
          }

          badge.attr('class', 'badge ' + (option.attr('data-badge-color') ? option.attr('data-badge-color') : 'azure07'))
            .text(option.attr('data-badge'));
        }
      },

      // Execute the source ajax option
      callSource: function(callback) {
        var self = this, searchTerm = '';

        if (this.settings.source) {
          this.isFiltering = false;

          var sourceType = typeof this.settings.source,
            response = function (data, isManagedByTemplate) {
            //to do - no results back do not open.
            var list = '',
              val = self.element.val();

            function replaceDoubleQuotes(content) {
              return content.replace('"', '\'');
            }

            function buildOption(option) {
              if (option === null || option === undefined) {
                return;
              }

              var isString = typeof option === 'string',
                stringContent = option;

              if (isString) {
                option = {
                  value: stringContent
                };
              }
              option.value = replaceDoubleQuotes(option.value);

              if (option.id !== undefined) {
                if (!isNaN(option.id)) {
                  option.id = '' + option.id;
                }
                option.id = replaceDoubleQuotes(option.id);
              }

              if (option.label !== undefined) {
                option.label = replaceDoubleQuotes(option.label);
              }

              if (!option.selected && option.value === val) {
                option.selected = true;
              }

              list += '<option' + (option.id === undefined ? '' : ' id="' + option.id + '"') +
                        ' value="' + option.value + '"' +
                        (option.selected ? ' selected ' : '') +
                      '>'+ (option.label !== undefined ? option.label : option.value !== undefined ? option.value : '') + '</option>';
            }

            // If the incoming dataset is different than the one we started with,
            // replace the contents of the list, and rerender it.
            if (!self.isFiltering && !Soho.utils.equals(data, self.dataset)) {
              self.dataset = data;

              if (!isManagedByTemplate) {
                self.element.empty();
                for (var i=0; i < data.length; i++) {
                  var opts;

                  if (data[i].group) {
                    opts = data[i].options;
                    list += '<optgroup label="' + data[i].group + '">';
                    for (var ii = 0; ii < opts.length; ii++) {
                      buildOption(opts[ii]);
                    }
                    list += '</optgroup>';
                  } else {
                    buildOption(data[i]);
                  }
                }

                self.element.append(list);
              }
              self.updateList();
            }

            self.element.triggerHandler('complete'); // For Busy Indicator
            self.element.trigger('requestend', [searchTerm, data]);
            callback();
            return;
          };

          self.element.triggerHandler('start'); // For Busy Indicator
          self.element.trigger('requeststart');

          if (sourceType === 'function') {
            // Call the 'source' setting as a function with the done callback.
            this.settings.source(response, searchTerm, this.settings.sourceArguments);
          } else if (sourceType === 'object') {
            // Use the 'source' setting as pre-existing data.
            // Sanitize accordingly.
            var sourceData = $.isArray(this.settings.source) ? this.settings.source : [this.settings.source];
            response(sourceData);
          } else {
            // Attempt to resolve source as a URL string.  Do an AJAX get with the URL
            var sourceURL = this.settings.source.toString(),
              request = $.getJSON(sourceURL);

            request.done(function(data) {
              response(data);
            }).fail(function() {
              response([]);
            });
          }

          return true;
        }
        return false;
      },

      // External Facing function to set value by code - Depricated set on select and trigger updated
      setCode: function(code) {
        var self = this,
          doSetting = function ()  {
            self.element.val(code);
            self.updated();
          };

        if (!self.callSource(doSetting)) {
          doSetting();
        }
      },

      isMobile: function() {
        return ['ios', 'android'].indexOf(Soho.env.os.name) > -1;
      },

      isListClosable: function() {
        return this.list.hasClass('is-closable');
      },

      disable: function() {
        this.element
          .prop('disabled', true)
          .prop('readonly', false);

        if (this.pseudoElem.is($(document.activeElement))) {
          this.pseudoElem.blur();
        }

        this.pseudoElem
          .addClass('is-disabled')
          .removeClass('is-readonly')
          .attr('tabindex', '-1')
          .prop('readonly', false)
          .prop('disabled', true);
        this.closeList('cancel');
      },

      enable: function() {
        this.element
          .prop('disabled', false)
          .prop('readonly', false);
        this.pseudoElem
          .prop('disabled', false)
          .prop('readonly', false)
          .attr('tabindex', '0')
          .removeClass('is-disabled')
          .removeClass('is-readonly');
      },

      readonly: function() {
        this.element
          .prop('disabled', false)
          .prop('readonly', true);
        this.pseudoElem
          .removeClass('is-disabled')
          .addClass('is-readonly')
          .attr('tabindex', '0')
          .prop('disabled', false)
          .prop('readonly', true);
        this.closeList('cancel');
      },

      // Triggered whenever the plugin's settings are changed
      updated: function() {
        this.closeList('cancel');

        // Update the 'multiple' property
        if (this.settings.multiple && this.settings.multiple === true) {
          this.element.prop('multiple', true);
        } else {
          this.element.prop('multiple', false);
        }

        // update "readonly" prop
        if (this.element.prop('readonly') === true) {
          this.readonly();
        } else {
          this.pseudoElem.removeClass('is-readonly');
        }

        // update "disabled" prop
        this.pseudoElem[ this.element.prop('disabled') ? 'addClass' : 'removeClass' ]('is-disabled');

        // update the list and set a new value, if applicable
        this.updateList();
        this.setValue();

        this.element.trigger('has-updated');

        return this;
      },

      destroy: function() {
        $.removeData(this.element[0], pluginName);
        this.closeList('cancel');
        this.label.remove();
        this.pseudoElem.off().remove();
        this.icon.remove();
        this.wrapper.remove();
        this.listfilter.destroy();
        this.element.removeAttr('style');
      }

    };

    // Keep the Chaining and Init the Controls or Settings
    return this.each(function() {
      var instance = $.data(this, pluginName);

      if (instance) {
        instance.settings = $.extend({}, settings, instance.settings);
        instance.updated();
      } else {
        instance = $.data(this, pluginName, new Dropdown(this, settings));
      }
    });
  };


  $.fn.drag = function(options) {
    //TODO: Resize: http://stackoverflow.com/questions/8258232/resize-an-html-element-using-touches
    // Similar: https://github.com/desandro/draggabilly
    'use strict';

    // Settings and Options
    var pluginName = 'drag',
      defaults = {
        axis: null, //Constrains dragging to either axis. Possible values: 'x', 'y'
        clone: false, //Clone the object - Useful so you dont have to abs position
        cloneCssClass: 'is-clone', // Css class added to clone element
        clonePosIsFixed: false, //Clone object use as css style "position: fixed"
        cloneAppendTo: null, //AppentTo selector for clone ['body'|'parent'|'jquery object'] default:'body'
        containment: false, //Constrains dragging to within the bounds of the specified element or region. Possible values: "parent", "document", "window".
        obstacle: false, //Selector of object(s) that you cannot drag into,
        containmentOffset: {left: 0, top: 0}
      },
      settings = $.extend({}, defaults, options);

    /**
     * Drag and Drop Functions with Touch Support
     * @constructor
     * @param {Object} element
     */
    function Drag(element) {
      this.element = $(element);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    // Plugin Methods
    Drag.prototype = {

      init: function() {
        this.handleEvents();
      },

      // Handle Touch/Mouse Drag Drop
      handleEvents: function() {
        var self = this;
        self.offset = null;

        //Touch and Drag Support
        self.element.attr('draggable', false);

        if ('onpointerdown' in window || 'onmspointerdown' in window) {
          // Setup pointer events
          // TODO: Setup Pointer Events for IE10/11
          /*
          self.element.on('pointerdown MSPointerDown', function(e) {

          })
          .on('pointermove MSPointerMove', function(e) {

          })
          .on('pointerup MSPointerUp', function(e) {

          });
          */
        }
        else {

          //Touch-only Drag Support
          self.element.on('touchstart.draggable gesturestart.draggable', function(e) {
            var pos = $(this).position(),
                orig = e.originalEvent;

            self.offset = {
              x:  orig.changedTouches[0].pageX - pos.left,
              y:  orig.changedTouches[0].pageY - pos.top
            };

            self.originalPos = pos;
            self.element.addClass('is-dragging');
            self.element.trigger('dragstart', pos);
          })

          // Move
          .on('touchmove.draggable gesturechange.draggable', function(e) {
            e.preventDefault();
            var orig = e.originalEvent;

            // do now allow two touch points to drag the same element
            if (orig.targetTouches.length > 1) {
              return;
            }
            self.move(orig.changedTouches[0].pageX - self.offset.x, orig.changedTouches[0].pageY - self.offset.y);
          })

          //Finish Touch Dragging
          .on('touchend.draggable gestureend.draggable touchcancel.draggable', function (e) {
            e.preventDefault();
            var touch = e.originalEvent.changedTouches[0];
            self.finish(touch.pageX - self.offset.x, touch.pageY - self.offset.y);
          });

        }

        // Always bind mousedown in either scenario, in the event that a mouse is used
        self.element.on('mousedown.draggable', function(e) {
          e.preventDefault();


          var pos = settings.clonePosIsFixed ?
            self.element[0].getBoundingClientRect() : self.element.position();

          //Save offset
          self.offset = {
            x: e.pageX - pos.left,
            y: e.pageY - pos.top
          };

          self.originalPos = pos;

          //Prevent Text Selection
          $('body').addClass('disable-select');

          //Handle Mouse Press over draggable element
          $(document).on('mousemove.draggable', function (e) {
            e.preventDefault();
            self.move(e.pageX - self.offset.x, e.pageY - self.offset.y);
          });

          //Handle Mouse release over draggable element close out events and trigger
          $(document).on('mouseup.draggable', function (e) {
            e.preventDefault();
            self.finish(e.pageX - self.offset.x, e.pageY - self.offset.y);
          });

          self.element.on('mouseup.draggable', function (e) {
            e.preventDefault();
            self.finish(e.pageX - self.offset.x, e.pageY - self.offset.y);
          });

          //Trigger dragging
          //Clone
          if (!self.clone && settings.clone) {
            self.clone = self.element.clone(true);
            if (settings.cloneAppendTo === 'parent') {
              settings.cloneAppendTo = self.element.parent();
            }
            self.clone
              .addClass(settings.cloneCssClass)
              .appendTo(settings.cloneAppendTo || 'body');

          }

          self.element.addClass('is-dragging');
          self.element.trigger('dragstart', [pos, self.clone]);
        });

      },

      //Trigger events and remove clone
      finish: function (left, top) {
        var pos = {top: top, left: left};

        this.element.off('mouseup.draggable');
        $(document).off('mousemove.draggable mouseup.draggable');

        this.element.trigger('dragend', pos);
        this.element.removeClass('is-dragging');

        if (this.clone) {
          if (settings.axis === 'x') {
            delete pos.top;
          }

          if (settings.axis === 'y') {
            delete pos.left;
          }
          //this.element.css(pos);
          this.clone.remove();
          this.clone = null;
        }

        //Clear Cached Sizes
        if (this.obstacle) {
          this.obstacle = null;
        }
        if (this.upperYLimit) {
          this.upperYLimit = null;
        }
        if (this.upperXLimit) {
          this.upperXLimit = null;
        }
        $('body').removeClass('disable-select');
      },

      //Move the object from the event coords
      move: function(left, top) {
        var self = this;

        var css = {
          left: left,
          top: top
        };

        //X-Y Axis
        if (settings.axis === 'x') {
          delete css.top;
        }

        if (settings.axis === 'y') {
          delete css.left;
        }

        if (settings.containment) {

          if (settings.containment === 'parent') {
            this.container = this.element.parent();
          } else if (settings.containment === 'window') {
            this.container = $(window);
          } else if (settings.containment === 'container') {
            this.container = this.element.closest('.page-container');
          } else {
            this.container = $(document);
          }

          if (!this.upperXLimit) {
            this.upperXLimit = this.container.width() - this.element.outerWidth() + settings.containmentOffset.left;
          }
          if (!this.upperYLimit) {
            this.upperYLimit = this.container.height() - this.element.outerHeight() + settings.containmentOffset.top;
          }
          if (css.top > this.upperYLimit) {
            css.top = this.upperYLimit;
          }

          if (css.left > this.upperXLimit) {
            css.left = this.upperXLimit;
          }

          if (css.top < 0) {
            css.top = 0;
          }

          if (css.left < 0) {
            css.left = 0;
          }

          if (settings.containment === 'container' && css.left <= 1) {
            css.left = 1;
          }
        }

        if (settings.obstacle) {
          var elemOffset = (this.clone ? this.clone.offset() : this.element.offset()),
            elemWidth = (this.clone ? this.clone.outerWidth() : this.element.outerWidth()),
            movingRight = css.left > elemOffset.left;

          // Caching this so drag is not jaggie
          if (!this.obstacle) {
            var obstacleOffset = this.obstacle.offset();
            this.obstacle = $(settings.obstacle).not(this.element);

            this.constraints = {
              top: obstacleOffset.top,
              left: obstacleOffset.left,
              bottom: obstacleOffset.top + this.obstacle.outerHeight(),
              right: obstacleOffset.left + this.obstacle.outerWidth()
            };
          }

          if (!movingRight && self.originalPos.left > this.constraints.left && css.left <= this.constraints.right) {
            css.left = this.constraints.right;
          }

          if (movingRight && self.originalPos.left + elemWidth <= this.constraints.left && css.left + elemWidth >= this.constraints.left) {
            css.left = (this.constraints.left - this.obstacle.outerWidth());
          }

          //TODO: Moving Down
        }

        var applyCssStyle = function(el, css, prop) {
          if (typeof css[prop] !== 'undefined') {
            el[0].style[prop] = css[prop] +'px';
          }
        };
        applyCssStyle((this.clone || this.element), css, 'top');
        applyCssStyle((this.clone || this.element), css, 'left');

        this.element.trigger('drag', css);
      },

      // Teardown
      destroy: function() {
        $.removeData(this.element[0], pluginName);
        this.element.off('touchstart.draggable MSPointerDown.draggable pointerdown.draggable touchmove.draggable touchend.draggable touchcancel.draggable mousedown.draggable');
      }
    };

    // Initialize the plugin (Once)
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (instance) {
        instance.settings = $.extend({}, defaults, options);
      } else {
        instance = $.data(this, pluginName, new Drag(this, settings));
      }
    });
  };


  $.fn.editor = function(options) {
    'use strict';

    // Settings and Options
    var pluginName = 'editor',
      defaults = {
        buttons: {
          editor: [
            'header1', 'header2',
            'separator', 'bold', 'italic', 'underline', 'strikethrough',
            'separator', 'foreColor', 'backColor',
            'separator', 'justifyLeft', 'justifyCenter', 'justifyRight',
            'separator', 'quote', 'orderedlist', 'unorderedlist',
            'separator', 'anchor',
            'separator', 'image',
            'separator', 'source'
          ],
          source: [
            'visual'
          ]
        },
        excludeButtons: {
          editor: ['backColor'],
          source: []
        },
        delay: 200,
        firstHeader: 'h3',
        secondHeader: 'h4',
        placeholder: null,
        pasteAsPlainText: false,
        // anchor > target: 'Same window'|'New window'| any string value
        anchor: {url: 'http://www.example.com', class: 'hyperlink', target: 'New window'},
        image: {url: 'http://lorempixel.com/output/cats-q-c-300-200-3.jpg'}
      },
      settings = $.extend({}, defaults, options);

    /**
     * Html Editor
     * @constructor
     * @param {Object} element
     */
    function Editor(element) {
      this.settings = $.extend({}, settings);
      this.element = $(element);

      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    // Actual Plugin Code
    Editor.prototype = {

      init: function() {
        this.isIE = $('html').is('.ie');
        this.isMac = $('html').is('.is-mac');
        this.isIeEdge = $('html').is('.ie-edge');
        this.isFirefox = $('html').is('.is-firefox');
        this.parentElements = ['p', 'h1', 'h2', 'h3', 'h4', 'h5', 'h6', 'blockquote', 'pre'];
        this.id = $('.editor-toolbar').length + 1;
        this.container = this.element.parent('.field, .field-short').addClass('editor-container');
        settings.anchor.defaultUrl = settings.anchor.url;
        settings.anchor.defaultClass = settings.anchor.class;
        settings.anchor.defaultTargetText = settings.anchor.target;

        settings.anchor.targets = {
          'Same window': '',
          'New window': '_blank'
        };
        $.each(settings.anchor.targets, function(key, val) {
          if ((settings.anchor.defaultTargetText).toLowerCase() === (key).toLowerCase()) {
            settings.anchor.target = val;
            settings.anchor.defaultTarget = val;
          }
        });
        if (!settings.anchor.defaultTarget) {
          if(settings.anchor.target && $.trim(settings.anchor.target).length) {
            settings.anchor.defaultTarget = settings.anchor.target;
          } else {
            settings.anchor.defaultTargetText = 'Same window';
            settings.anchor.defaultTarget = settings.anchor.targets[settings.anchor.defaultTargetText];
          }
        }
        return this.setup();
      },

      setup: function () {
        this.isActive = true;
        this.modals = {};
        this.initElements()
          .bindSelect()
          .bindPaste()
          .setPlaceholders()
          .bindWindowActions()
          .setupKeyboardEvents()
          .onPasteTriggered();
      },

      initElements: function () {
        var i,
          elem = this.element;

        //Make it an editor
        elem.attr({'contentEditable': true, 'aria-multiline': true, 'role': 'textbox'});

        //Bind functionality for Pre elements. We dont use this yet but could if we want to edit code blocks.
        elem.attr('data-editor', true);
        this.bindParagraphCreation(i).bindTab(i);

        this.initToolbar()
          .bindButtons()
          .bindModals()
          .bindAnchorPreview();

        //Build the textarea that will be used as source view and for content serialization
        this.initTextarea();
        return this;
      },

      // Returns true if the source view is currently active.
      sourceViewActive: function() {
        return this.element.hasClass('source-view-active');
      },

      //Bind Events for the place holder
      setPlaceholders: function () {
        var self = this;

        self.element.on('blur.editor', function () {
          self.togglePlaceHolder();
        }).on('keypress', function () {
          self.togglePlaceHolder();
        });

        self.togglePlaceHolder();
        return this;
      },

      togglePlaceHolder: function () {
        var self = this.element;

        if (self.text().trim() === '') {
          self.addClass('editor-placeholder');
        } else {
          self.removeClass('editor-placeholder');
        }
      },

      // Returns the currently visible element - either the main editor window, or the source-view textarea
      getCurrentElement: function() {
        return this.sourceViewActive() ? this.textarea : this.element;
      },

      bindParagraphCreation: function () {
        var self = this,
          currentElement = self.getCurrentElement();

        currentElement.on('keyup.editor', function (e) {
          var node = self.getSelectionStart(),
              tagName;

          if (node && node.getAttribute('data-editor') && node.children.length === 0) {
            document.execCommand('formatBlock', false, 'p');
          }

          if (e.which === 13) {
            node = self.getSelectionStart();
            tagName = node.tagName.toLowerCase();

            if (tagName !== 'li' && !self.isListItemChild(node)) {
              if (!e.shiftKey) {
                  document.execCommand('formatBlock', false, 'p');
              }
              if (tagName === 'a') {
                  document.execCommand('unlink', false, null);
              }
            }
          }
        });
        return this;
      },

      bindTab: function () {
        var self = this,
          currentElement = self.getCurrentElement();

        currentElement.on('keydown.editor', function (e) {
          if (e.which === 9) {
            // Override tab only for pre nodes
            var tag = self.getSelectionStart().tagName.toLowerCase();
            if (tag === 'pre') {
              e.preventDefault();
              document.execCommand('insertHtml', null, '    ');
            }
            // Tab to indent list structures!
            if ( tag === 'li' ) {
              // If Shift is down, outdent, otherwise indent
              if ( e.shiftKey ) {
                document.execCommand('outdent', e);
              } else {
                document.execCommand('indent', e);
              }
            }
          }
        });
        return this;
      },

      // Builds a fake element and gets the name of the event that will be used for "paste"
      // Used for cross-browser compatability.
      getPasteEvent: function() {
        var el = document.createElement('input'),
            name = 'onpaste';
        el.setAttribute(name, '');
        return ((typeof el[name] === 'function') ? 'paste' : 'input') + '.editor';
      },

      initToolbar: function () {
        if (this.toolbar) {
            return this;
        }
        this.toolbar = this.createToolbar();
        this.toolbarActions = this.toolbar;
        this.toolbar.toolbar();
        return this;
      },

      // Set excluded buttons
      setExcludedButtons: function() {
        var self = this,
          excludeButtons = function(elements, toExclude) {
            var separatorIndex = -1,
              numOfExcluded = 0;

            return elements.filter(function(x, i) {
              var r = true;
              // Exclude matching buttons but keep separator/s
              if (toExclude.indexOf(x) > -1 && x !== 'separator') {
                numOfExcluded++;
                r = false;
              }
              // Exclude extra separator/s
              else if (x === 'separator' && ((i - numOfExcluded - 1) === separatorIndex)) {
                numOfExcluded = 0;
                r = false;
              }
              if (x === 'separator') {
                separatorIndex = i;
              }
              return r;
            });
          },

          // Run only if it needs (excludeButtons)
          setButtons = function() {
            var s = self.settings,
              btns = s.buttons,
              exBtns = s.excludeButtons;
            return (self.sourceViewActive()) ?
              (exBtns && exBtns.source && exBtns.source.length ?
                excludeButtons(btns.source, exBtns.source) : btns.source) :
              (exBtns && exBtns.editor && exBtns.editor.length ?
                excludeButtons(btns.editor, exBtns.editor) : btns.editor);
          };

        return setButtons();
      },

      createToolbar: function () {
        var toolbar = $('<div class="toolbar editor-toolbar formatter-toolbar"></div>').attr('id', 'editor-toolbar-' + this.id);
        this.toolbarButtons(toolbar);
        toolbar.insertBefore(this.sourceViewActive() ? this.element.prev() : this.element);
        toolbar.find('button').tooltip();
        return toolbar;
      },

      toolbarButtons: function (toolbar) {
        var btns = this.setExcludedButtons(),
            buttonset = toolbar.find('.buttonset'),
            i, btn;

        if (!buttonset.length) {
          buttonset = $('<div class="buttonset"></div>').appendTo(toolbar);
        }

        for (i = 0; i < btns.length; i += 1) {
          btn = this.buttonTemplate(btns[i]);

          if (btn) {
            buttonset.append(btn);
          }
        }
        // Invoke colorpicker
        var cpElements = $('[data-action="foreColor"], [data-action="backColor"]', buttonset);
        cpElements.colorpicker({placeIn: 'editor'});
        $('.trigger', cpElements).off('click.colorpicker');
      },

      switchToolbars: function() {
        this.destroyToolbar();

        // Rebind everything to the new element
        this.setupTextareaEvents().initToolbar().bindButtons().bindModals().bindAnchorPreview();
        this.bindSelect().bindPaste().setupKeyboardEvents();
        this.toolbar.find('button').button();
      },

      initTextarea: function() {
        var self = this;
        if (this.textarea) {
          return this;
        }
        this.textarea = this.createTextarea();

        // fill the text area with any content that may already exist within the editor DIV
        this.textarea.text(this.element.html().toString());

        this.element.on('input.editor keyup.editor', function() {
          self.textarea.val(self.element.html().toString());
        });

        this.setupTextareaEvents();
        return this.textarea;
      },

      createTextarea: function() {
        this.sourceView = $('<div></div>').attr({
          'class' : 'editor-source editable hidden',
          'id' : 'editor-source-' + this.id
        }).insertBefore(this.element);

        $('<ul></ul>').addClass('line-numbers').appendTo(this.sourceView);
        var textareaContainer = $('<div class="text-container"></div>').appendTo(this.sourceView),
          newTextareaID = 'source-textarea-' + ($('[id^="source-textarea-"]').length+1),
          labelContents = this.element.prev('.label').addClass('audible').text() + ' - HTML Source View';

        $('<label class="audible" for="'+ newTextareaID +'">'+ labelContents +'</label>').appendTo(textareaContainer);
        var textarea = $('<textarea id="'+ newTextareaID +'" class="editable"></textarea>').appendTo(textareaContainer);
        return textarea;
      },

      triggerClick: function(e, btn) {
        $('button[data-action="'+ btn +'"]', this.toolbar).trigger('click.editor');
      },

      setupKeyboardEvents: function() {
        var self = this,
          currentElement = this.getCurrentElement(),
          keys = {
            b  : 66, // {Ctrl + B} bold
            e  : 69, // {Ctrl + E} justifyCenter
            h  : 72, // {Ctrl + H} anchor
            i  : 73, // {Ctrl + I} italic --------with SHIFT: {Ctrl + Shift + I} image
            l  : 76, // {Ctrl + L} justifyLeft
            bl : 55, // {Ctrl + + Shift + 7} bullet list
            n  : 56, // {Ctrl + Shift + 8} numbered list
            q  : 81, // {Ctrl + Q} blockquotes
            r  : 82, // {Ctrl + R} justifyRight
            u  : 85, // {Ctrl + U} underline
            h3 : 51, // {Ctrl + 3} h3
            h4 : 52, // {Ctrl + 4} h4
            sv : 192 // {Ctrl + ~} toggle source -or- visualview
          };

        currentElement.on('keydown.editor', function(e) {
          e = (e) ? e : window.event;
          keys.charCode = (e.which) ? e.which : ((e.keyCode) ? e.keyCode : false);

          switch (e.ctrlKey && keys.charCode) {
            case keys.h3:
              self.triggerClick(e, 'append-' + settings.firstHeader);
              break;
            case keys.h4:
              self.triggerClick(e, 'append-' + settings.secondHeader);
              break;
            case keys.b:
              self.triggerClick(e, 'bold');
              e.preventDefault();
              break;
            case keys.e:
              self.triggerClick(e, 'justifyCenter');
              break;
            case keys.h:
              self.triggerClick(e, 'anchor');
              e.preventDefault();
              break;
            case keys.i:
              self.triggerClick(e, e.shiftKey ? 'image' : 'italic');
              if (!e.shiftKey) {
                e.preventDefault();
              }
              break;
            case keys.bl:
              if (e.shiftKey) {
                self.triggerClick(e, 'insertunorderedlist');
              }
              e.preventDefault();
              break;
            case keys.l:
              if (!e.shiftKey) {
                self.triggerClick(e, 'justifyLeft');
              }
              e.preventDefault();
              break;
            case keys.n:
              if (e.shiftKey) {
                self.triggerClick(e, 'insertorderedlist');
              }
              break;
            case keys.q:
              self.triggerClick(e, 'append-blockquote');
              break;
            case keys.r:
              self.triggerClick(e, 'justifyRight');
              break;
            case keys.u:
              self.triggerClick(e, 'underline');
              e.preventDefault();
              break;
            case keys.sv:
              self.triggerClick(e, currentElement === self.element ? 'source' : 'visual');
              break;
          }
        });

        // Open link in new windows/tab, if clicked with command-key(for mac) or ctrl-key(for windows)
        self.element.on('mousedown.editor', 'a', function(e) {
          var href = $(this).attr('href');
          if(!self.isFirefox && ((self.isMac && e.metaKey) || (!self.isMac && e.ctrlKey))) {
            window.open(href, '_blank');
            e.preventDefault();
          }
        });

        return self;
      },

      setupTextareaEvents: function() {
        var self = this;
        // Adjust line numbers on input
        this.textarea.on('input.editor keyup.editor', function() {
          if (!(self.sourceView.hasClass('hidden'))) {
            self.adjustSourceLineNumbers();
          }
        }).on('focus.editor', function() {
          self.sourceView.addClass('is-focused');
        }).on('blur.editor', function(e) {
          self.sourceView.removeClass('is-focused');
          self.element.empty().html($.sanitizeHTML(self.textarea.val()));

          if (self.element.data('validate')) {
            self.element.data('validate').validate(self.element, true, e);
          }
        });

        return this;
      },

      adjustSourceLineNumbers: function() {

        var container = this.textarea.parent(),
          lineHeight = parseInt(getComputedStyle(this.textarea[0]).lineHeight),
          YPadding = (this.textarea.innerHeight() - this.textarea.height());

        this.textarea[0].style.height = '';

        var scrollHeight = this.textarea[0].scrollHeight,
          lineNumberCount = Math.floor((scrollHeight - YPadding) / lineHeight),
          numberList = this.sourceView.find('.line-numbers'),
          lastIdx = numberList.find('li').length,
          list = '',
          i = 0;

        if (!this.lineNumbers || lineNumberCount !== this.lineNumbers) {
          if (!this.lineNumbers) {
            // Build the list of line numbers from scratch
            this.lineNumbers = lineNumberCount;
            while (i < this.lineNumbers) {
              list += '<li role="presentation"><span>'+ (i + 1) +'</span></li>';
              i++;
            }
            numberList.append(list);
          } else if (this.lineNumbers < lineNumberCount) {
            // Add extra line numbers to the bottom
            while (i < (lineNumberCount - this.lineNumbers)) {
              list += '<li role="presentation"><span>'+ (lastIdx + i + 1) +'</span></li>';
              i++;
            }
            numberList.append(list);
          } else if (this.lineNumbers > lineNumberCount) {
            // Remove extra line numbers from the bottom
            i = this.lineNumbers - lineNumberCount;
            numberList.find('li').slice(-(i)).remove();
          }
          this.lineNumbers = lineNumberCount;
          container[0].style.width = 'calc(100% - ' + (numberList.outerWidth() + 1) + 'px)';
        }
        if (scrollHeight !== this.textarea[0].scrollHeight) {
          this.adjustSourceLineNumbers();
          return;
        }

        this.textarea[0].style.height = numberList[0].scrollHeight + 'px';
      },

      wrapTextInTags: function(insertedText, selectedText, action) {
        var tags,
          finalText;
        switch(action) {
          case 'bold':
            tags = ['<b>','</b>'];
            break;
          case 'italic':
            tags = ['<i>','</i>'];
            break;
          case 'underline':
            tags = ['<u>','</u>'];
            break;
          case 'strikethrough':
            tags = ['<strike>', '</strike>'];
            break;
          case 'append-blockquote':
            tags = ['<blockquote>', '</blockquote>'];
            break;
          default:
            tags = ['',''];
        }

        if (action === 'anchor') {
          var alink = $('<a href="'+ insertedText +'">' + selectedText + '</a>');

          if(settings.anchor.class && $.trim(settings.anchor.class).length) {
            alink.addClass(settings.anchor.class);
          }
          if(settings.anchor.target && $.trim(settings.anchor.target).length) {
            alink.attr('target', settings.anchor.target);
          }

          finalText = alink[0].outerHTML;
        }
        else {
          finalText = tags[0] + insertedText + selectedText + tags[1];
        }
        return finalText;
      },

      insertTextAreaContent: function(text, action) {
        var el = this.textarea[0],
          val = el.value,
          sel, startPos, endPos, scrollTop;

        // Always have empty text
        text = text ? text : '';

        if (document.selection && el.tagName === 'TEXTAREA') {
          //IE textarea support
          $(el).focus();
          sel = document.selection.createRange();
          sel.text = this.wrapTextInTags(text, sel.text, action);
          $(el).focus();
        } else if (el.selectionStart || el.selectionStart === '0') {
          //MOZILLA/NETSCAPE support
          startPos = el.selectionStart;
          endPos = el.selectionEnd;
          scrollTop = el.scrollTop;
          sel = this.wrapTextInTags(text, val.substring(startPos, endPos), action);
          el.value = val.substring(0, startPos) + sel + val.substring(endPos, val.length);
          $(el).focus();
          el.selectionStart = startPos + sel.length;
          el.selectionEnd = startPos + sel.length;
          el.scrollTop = scrollTop;
        } else {
          // IE input[type=text] and other browsers
          el.value += this.wrapTextInTags(text, el.value, action);
          $(el).focus();
          el.value = el.value;    // forces cursor to end
        }
      },

      buttonTemplate: function (btnType) {
        var buttonLabels = this.getButtonLabels(settings.buttonLabels),
          buttonTemplates = {
            'bold': '<button type="button" class="btn" title="'+ Locale.translate('ToggleBold') + '" data-action="bold" data-element="b">' + buttonLabels.bold + '</button>',
            'italic': '<button type="button" class="btn" title="'+ Locale.translate('ToggleItalic') + '" data-action="italic" data-element="i">' + buttonLabels.italic + '</button>',
            'underline': '<button type="button" class="btn underline" title="'+ Locale.translate('ToggleUnderline') + '" data-action="underline" data-element="u">' + buttonLabels.underline + '</button>',
            'strikethrough': '<button type="button" class="btn" title="'+ Locale.translate('StrikeThrough') + '" data-action="strikethrough" data-element="strike">' + buttonLabels.strikethrough + '</button>',
            'foreColor': '<button type="button" class="btn colorpicker-editor-button" title="'+ Locale.translate('TextColor') + '" data-action="foreColor" data-element="foreColor">' + buttonLabels.foreColor + '</button>',
            'backColor': '<button type="button" class="btn colorpicker-editor-button" title="'+ Locale.translate('BackgroundColor') + '" data-action="backColor" data-element="backColor">' + buttonLabels.backColor + '</button>',
            'superscript': '<button type="button" class="btn" title="'+ Locale.translate('Superscript') + '" data-action="superscript" data-element="sup">' + buttonLabels.superscript + '</button>',
            'subscript': '<button type="button" class="btn" title="'+ Locale.translate('Subscript') + '" data-action="subscript" data-element="sub">' + buttonLabels.subscript + '</button>',
            'separator': '<div class="separator"></div>',
            'anchor': '<button type="button" class="btn" title="'+ Locale.translate('InsertAnchor') + '" data-action="anchor" data-modal="editor-modal-url" data-element="a">' + buttonLabels.anchor + '</button>',
            'image': '<button type="button" class="btn" title="'+ Locale.translate('InsertImage') + '" data-action="image" data-modal="editor-modal-image" data-element="img">' + buttonLabels.image + '</button>',
            'header1': '<button type="button" class="btn" title="'+ Locale.translate('ToggleH3') + '" data-action="append-' + settings.firstHeader + '" data-element="' + settings.firstHeader + '">' + buttonLabels.header1 + '</button>',
            'header2': '<button type="button" class="btn" title="'+ Locale.translate('ToggleH4') + '" data-action="append-' + settings.secondHeader + '" data-element="' + settings.secondHeader + '">' + buttonLabels.header2 + '</button>',
            'quote': '<button type="button" class="btn" title="'+ Locale.translate('Blockquote') + '" data-action="append-blockquote" data-element="blockquote">' + buttonLabels.quote + '</button>',
            'orderedlist': '<button type="button" class="btn" title="'+ Locale.translate('OrderedList') + '" data-action="insertorderedlist" data-element="ol">' + buttonLabels.orderedlist + '</button>',
            'unorderedlist': '<button type="button" class="btn" title="'+ Locale.translate('UnorderedList') + '" data-action="insertunorderedlist" data-element="ul">' + buttonLabels.unorderedlist + '</button>',
            'justifyLeft': '<button type="button" class="btn" title="'+ Locale.translate('JustifyLeft') + '" data-action="justifyLeft" >' + buttonLabels.justifyLeft + '</button>',
            'justifyCenter': '<button type="button" class="btn" title="'+ Locale.translate('JustifyCenter') + '" data-action="justifyCenter">' + buttonLabels.justifyCenter + '</button>',
            'justifyRight': '<button type="button" class="btn" title="'+ Locale.translate('JustifyRight') + '" data-action="justifyRight" >' + buttonLabels.justifyRight + '</button>',
            'source': '<button type="button" class="btn" title="'+ Locale.translate('ViewSource') + '" data-action="source" >' + buttonLabels.source + '</button>',
            'visual': '<button type="button" class="btn" title="'+ Locale.translate('ViewVisual') + '" data-action="visual" >' + buttonLabels.visual + '</button>'
          };
       return buttonTemplates[btnType] || false;
      },

      getIcon: function(textName, iconName, className) {
        return '<span class="audible">'+ Locale.translate(textName) +'</span>' + $.createIcon({ classes: (className || ''), icon: iconName });
      },

      getButtonLabels: function (buttonLabelType) {
        var customButtonLabels,
          attrname,
          buttonLabels = {
            'bold': this.getIcon('Bold', 'bold'),
            'italic': this.getIcon('Italic', 'italic'),
            'underline': this.getIcon('Underline', 'underline'),
            'superscript': '<span aria-hidden="true"><b>x<sup>1</sup></b></span>',
            'subscript': '<span aria-hidden="true"><b>x<sub>1</sub></b></span>',
            'strikethrough': this.getIcon('StrikeThrough', 'strike-through'),
            'foreColor': this.getIcon('TextColor', 'fore-color'),
            'backColor': this.getIcon('BackgroundColor', 'back-color'),
            'anchor': this.getIcon('InsertAnchor', 'link'),
            'image': this.getIcon('InsertImage', 'insert-image'),
            'header1': this.getIcon('ToggleH3', 'h3'),
            'header2': this.getIcon('ToggleH4', 'h4'),
            'quote': this.getIcon('Blockquote', 'quote'),
            'orderedlist': this.getIcon('OrderedList', 'number-list'),
            'unorderedlist': this.getIcon('UnorderedList', 'bullet-list'),
            'pre': '<span aria-hidden="true"><b>0101</b></span>',
            'indent': '<span aria-hidden="true"><b>&rarr;</b></span>',
            'outdent': '<span aria-hidden="true"><b>&larr;</b></span>',
            'justifyLeft': this.getIcon('JustifyLeft', 'left-text-align'),
            'justifyCenter': this.getIcon('JustifyCenter', 'center-text'),
            'justifyRight': this.getIcon('JustifyRight', 'right-text-align'),
            'source': this.getIcon('ViewSource', 'html', 'html-icon'),
            'visual': this.getIcon('ViewSource', 'visual', 'visual-icon')
          };

        if (typeof buttonLabelType === 'object') {
          customButtonLabels = buttonLabelType;
        }
        if (typeof customButtonLabels === 'object') {
          for (attrname in customButtonLabels) {
            if (customButtonLabels.hasOwnProperty(attrname)) {
              buttonLabels[attrname] = customButtonLabels[attrname];
            }
          }
        }
        return buttonLabels;
      },

      //Show the Buttons
      activateButton: function (tag) {
        this.toolbar.find('[data-element="' + tag + '"]').addClass('is-active');
      },

      //Bind Events to Toolbar Buttons
      bindButtons: function () {
        var self = this;

        this.toolbar.on('touchstart.editor click.editor', 'button', function (e) {
          var btn = $(this),
            action = btn.attr('data-action');

          // Don't do anything if it's the More Button
          if (btn.is('.btn-actions')) {
            return;
          }

          e.preventDefault();
          self.getCurrentElement().focus();

          if (self.selection === undefined) {
            self.checkSelection();
          }

          if (!self.sourceViewActive()) {
            btn.toggleClass('is-active');
          }

          if (action) {
            self.execAction(action, e);
          }

          return false;
        });

        return this;
      },

      bindModals: function() {
        var self = this;

        self.modals = {
          url: self.createURLModal(),
          image: self.createImageModal()
        };

        $('[name="em-target"]').dropdown();

        $('#editor-modal-url, #editor-modal-image').modal()
          .on('beforeopen', function () {
            self.savedSelection = self.saveSelection();

            if ($(this).attr('id') === 'editor-modal-url') {

              if (!self.selectionRange) {
                return undefined;
              }
            }
          })
          .off('open')
          .on('open', function () {
            var isTouch = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent),
              id = $(this).attr('id'),
              input = $('input:first', this),
              button = $('.modal-buttonset .btn-modal-primary', this);

            $('[name="em-url"]').val(settings.anchor.url);
            $('[name="em-class"]').val(settings.anchor.class);
            $('[name="em-target"]').val(settings.anchor.target).trigger('updated');

            // $('[id="em-target-shdo"]').val($('[name="em-target"] option:selected').text());

            setTimeout(function () {
              if (isTouch && id === 'editor-modal-image') {
                button.focus();
              } else {
                input.focus().select();
              }
            }, 10);

          })
          .off('close')
          .on('close', function (e, isCancelled) {
            self.restoreSelection(self.savedSelection);

            if (isCancelled) {
              return;
            }

            //insert image or link
            if ($(this).attr('id') === 'editor-modal-url') {
              var currentLink = $(self.findElementInSelection('a', self.element[0]));
              if (currentLink.length) {
                self.updateCurrentLink(currentLink);
              } else {
                self.createLink($('[name="em-url"]', this));
              }
            } else {
              self.insertImage($('#image').val());
            }
          });

        return this;
      },

      createURLModal: function() {
        var targetOptions = '',
          isTargetCustom = true,
          urlModal = $('#editor-modal-url');

        if (urlModal.length > 0) {
          return urlModal;
        }

        $.each(settings.anchor.targets, function(key, val) {
          targetOptions += '<option value="'+ val +'">'+ key +'</option>';
          if ((settings.anchor.defaultTargetText).toLowerCase() === (key).toLowerCase()) {
            isTargetCustom = false;
          }
        });
        if (isTargetCustom) {
          targetOptions += '<option value="'+ settings.anchor.target +'">'+ settings.anchor.target +'</option>';
        }

        return $('<div class="modal editor-modal-url" id="editor-modal-url"></div>')
          .html('<div class="modal-content">' +
            '<div class="modal-header">' +
              '<h1 class="modal-title">' + Locale.translate('InsertAnchor') + '</h1>' +   //TODO: Rename to link when you get strings
            '</div>' +
            '<div class="modal-body">' +
              '<div class="field">' +
                '<label for="em-url">' + Locale.translate('Url') + '</label>' +
                '<input id="em-url" name="em-url" type="text" value="'+ settings.anchor.url +'">' +
              '</div>' +
              '<div class="field">' +
                '<label for="em-class">' + Locale.translate('CssClass') + '</label>' +
                '<input id="em-class" name="em-class" type="text" value="'+ settings.anchor.class +'">' +
              '</div>' +
              '<div class="field">' +
                '<label for="em-target" class="label">' + Locale.translate('Target') + '</label>' +
                '<select id="em-target" name="em-target" class="dropdown">' +
                  targetOptions +
                '</select>' +
              '</div>' +
              '<div class="modal-buttonset">' +
                '<button type="button" class="btn-modal btn-cancel">' + Locale.translate('Cancel') + '</button>' +
                '<button type="button" class="btn-modal-primary">' + Locale.translate('Insert') + '</button>' +
              '</div>' +
            '</div>' +
          '</div>').appendTo('body');
      },

      createImageModal: function() {
        var imageModal = $('#editor-modal-image');
        if (imageModal.length > 0) {
          return imageModal;
        }
        return $('<div class="modal editor-modal-image" id="editor-modal-image"></div>')
          .html('<div class="modal-content">' +
            '<div class="modal-header">' +
              '<h1 class="modal-title">' + Locale.translate('InsertImage') + '</h1>' +
            '</div>' +
            '<div class="modal-body">' +
              '<div class="field">' +
                '<label for="image">' + Locale.translate('Url') + '</label>' +
                '<input id="image" name="image" type="text" value="'+ settings.image.url +'">' +
              '</div>' +
              '<div class="modal-buttonset">' +
                '<button type="button" class="btn-modal btn-cancel">' + Locale.translate('Cancel') + '</button>' +
                '<button type="button" class="btn-modal-primary">' + Locale.translate('Insert') + '</button>' +
              '</div>' +
            '</div>' +
          '</div>').appendTo('body');
      },

      bindAnchorPreview: function () {
        this.element.find('a').tooltip({content: function() {
          return $(this).attr('href');
        }});
        return;
      },

      updateCurrentLink: function (alink) {
        var emUrl = $('[name="em-url"]').val(),
          emClass = $('[name="em-class"]').val(),
          emTarget = $('[name="em-target"]').val();

        alink.attr('href', (emUrl && $.trim(emUrl).length ? emUrl : settings.anchor.defaultUrl));
        alink.attr('class', (emClass && $.trim(emClass).length ? emClass : settings.anchor.defaultClass));

        if (emTarget && $.trim(emTarget).length) {
          alink.attr('target', emTarget);
        } else {
          alink.removeAttr('target');
        }
      },

      createLink: function (input) {
        var alink;

        //Restore Selection in the Editor and Variables
        this.restoreSelection(this.savedSelection);

        //Fix and Format the Link
        input.val(this.fixLinkFormat(input.val()));

        // Set selection ur/class/target for Link
        settings.anchor.url = input.val();
        settings.anchor.class = $('[name="em-class"]').val();
        settings.anchor.target = $('[name="em-target"]').val();

        alink = $('<a href="'+ input.val() +'">' + input.val() + '</a>');

        if(settings.anchor.class && $.trim(settings.anchor.class).length) {
          alink.addClass(settings.anchor.class);
        }
        if(settings.anchor.target && $.trim(settings.anchor.target).length) {
          alink.attr('target', settings.anchor.target);
        }

        if (this.sourceViewActive()) {
          this.insertTextAreaContent(input.val(), 'anchor');
        }
        else {
          var sel, range;

          if (!this.selection.isCollapsed) {
            //document.execCommand('createLink', false, input.val());

            //get example from: http://jsfiddle.net/jwvha/1/
            //and info: http://stackoverflow.com/questions/6690752/insert-html-at-caret-in-a-contenteditable-div
            if (window.getSelection) {
              // IE9 and non-IE
              sel = window.getSelection();
              if (sel.getRangeAt && sel.rangeCount) {
                range = sel.getRangeAt(0);
                alink.html(range + '');
                range.deleteContents();

                // Range.createContextualFragment() would be useful here but is
                // only relatively recently standardized and is not supported in
                // some browsers (IE9, for one)
                var el = document.createElement('div');
                el.innerHTML = alink[0].outerHTML;
                var frag = document.createDocumentFragment(), node, lastNode;

                while ((node = el.firstChild)) {
                  lastNode = frag.appendChild(node);
                }
                range.insertNode(frag);

                // Preserve the selection
                if (lastNode) {
                  range = range.cloneRange();
                  range.setStartAfter(lastNode);
                  range.collapse(true);
                  sel.removeAllRanges();
                  sel.addRange(range);
                }
              }
            }
          }
          else {
            var self = this;
            document.execCommand('insertHtml', null, alink[0].outerHTML);
            setTimeout(function () {
              self.getCurrentElement().focus();
            }, 1);
          }
          this.bindAnchorPreview();
        }
      },

      fixLinkFormat: function (value) {
        var re = /^https?:\/\//;
        if (value.match(re)) {
          return value;
        }
        return 'http://' + value;
      },

      //Setup Events For Text Selection
      bindSelect: function () {
        var self = this,
            selectionTimer = '';

        this.selectionHandler = function () {
          clearTimeout(selectionTimer);
          selectionTimer = setTimeout(function () {
            self.checkSelection();
          }, settings.delay);
        };

        var currentElement = self.getCurrentElement();

        currentElement.off('mouseup.editor keyup.editor')
          .on('mouseup.editor keyup.editor', this.selectionHandler);

        return this;
      },

      checkSelection: function () {
        var newSelection,
            selectionElement;

        if (this.selection === undefined) {
          if (this.sourceViewActive()) {
            newSelection = this.textarea.val().substring( this.textarea[0].selectionStart, this.textarea[0].selectionEnd ).toString().trim();
            this.hideToolbarActions();
            return;
          }
        }

        newSelection = window.getSelection();
        selectionElement = this.getSelectionElement();
        if (!selectionElement) {
            this.hideToolbarActions();
        } else {
          this.checkSelectionElement(newSelection, selectionElement);
        }
        return this;
      },

      getSelectionElement: function () {
        var selection = window.getSelection(),
          range, current, parent,
          result,
          getElement = function (e) {
            var localParent = e;
            try {
                while (!localParent.getAttribute('data-editor')) {
                    localParent = localParent.parentNode;
                }
            } catch (errb) {
                return false;
            }
            return localParent;
          };

        // First try on current node
        try {
          range = selection.getRangeAt(0);
          current = range.commonAncestorContainer;
          parent = current.parentNode;

          if (current.getAttribute('data-editor')) {
              result = current;
          } else {
              result = getElement(parent);
          }
          // If not search in the parent nodes.
        } catch (err) {
          result = getElement(parent);
        }
        return result;
      },

      //See if the Editor is Selected and Show Toolbar
      checkSelectionElement: function (newSelection, selectionElement) {
        var currentElement = this.sourceViewActive() ? this.sourceView[0] : this.element[0];

        this.selection = newSelection;
        this.selectionRange = this.selection.getRangeAt(0);
        if (currentElement === selectionElement) {
          this.setToolbarButtonStates();
          return;
        }
        this.hideToolbarActions();
      },

      //See if the Editor is Selected and Show Toolbar
      setToolbarButtonStates: function () {
        var buttons = this.toolbarActions.find('button');

        buttons.removeClass('is-active');
        this.checkActiveButtons();
        return this;
      },

      checkActiveButtons: function () {
        this.checkButtonState('bold');
        this.checkButtonState('italic');
        this.checkButtonState('underline');

        var self = this,
            parentNode = this.getSelectedParentElement();

        while (parentNode.tagName !== undefined && this.parentElements.indexOf(parentNode.tagName.toLowerCase) === -1) {
          this.activateButton(parentNode.tagName.toLowerCase());

          // we can abort the search upwards if we leave the contentEditable element
          if (self.element.is(parentNode)) {
            break;
          }
          parentNode = parentNode.parentNode;
        }
      },

      checkButtonState: function(command) {
        if (!document.queryCommandState) {
          return;
        }

        if (document.queryCommandState(command)) {
          this.toolbar.find('[data-action="' + command + '"]').addClass('is-active');
        } else {
          this.toolbar.find('[data-action="' + command + '"]').removeClass('is-active');
        }
      },

      rangeSelectsSingleNode: function (range) {
        var startNode = range.startContainer;
        return startNode === range.endContainer &&
            startNode.hasChildNodes() &&
            range.endOffset === range.startOffset + 1;
      },

      getSelectedParentElement: function () {
        var selectedParentElement = null,
            range = this.selectionRange;
        if (this.rangeSelectsSingleNode(range)) {
            selectedParentElement = range.startContainer.childNodes[range.startOffset];
        } else if (range.startContainer.nodeType === 3) {
            selectedParentElement = range.startContainer.parentNode;
        } else {
            selectedParentElement = range.startContainer;
        }
        return selectedParentElement;
      },

      //Hide Toolbar
      hideToolbarActions: function () {
        if (this.toolbar !== undefined) {
          this.toolbar.removeClass('is-active');
        }
      },

      //Handle Pasted In Text
      bindPaste: function () {
        var self = this,
          currentElement = self.getCurrentElement();

        if (!self.pasteEvent) {
          self.pasteEvent = self.getPasteEvent();
        }

        this.pasteWrapper = function (e) {

          var paste = e.originalEvent.clipboardData && e.originalEvent.clipboardData.getData ?
            e.originalEvent.clipboardData.getData('text/plain') : // Standard
            window.clipboardData && window.clipboardData.getData ?
            window.clipboardData.getData('Text') : // MS
            false,
            paragraphs,
            html = '',
            p;

          if (self.sourceViewActive() ) {
            return this;
          }

          if (paste && !e.defaultPrevented) {
            e.preventDefault();
            paragraphs = paste.split(/[\r\n]/g);

            for (p = 0; p < paragraphs.length; p += 1) {
              if (paragraphs[p] !== '') {
                if (navigator.userAgent.match(/firefox/i) && p === 0) {
                  html += '<p>' + self.htmlEntities(paragraphs[p]) + '</p>';
                } else {
                  if((/\.(gif|jpg|jpeg|tiff|png)$/i).test(paragraphs[p])) {
                    html += '<img src="' + self.htmlEntities(paragraphs[p]) + '" />';
                  } else {
                    html += '<p>' + self.htmlEntities(paragraphs[p]) + '</p>';
                  }
                }
              }
            }

            if (document.queryCommandSupported('insertText')) {
                document.execCommand('insertHTML', false, html);
                return false;
            } else { // IE > 7
              self.pasteHtmlAtCaret(html);
            }
          }
        };

        this.pasteWrapperHtml = function (e) {
          if (self.sourceViewActive()) {
            return this;
          }
          var types, clipboardData, pastedData,
            paste, p, paragraphs,
            getCleanedHtml = function(pastedData) {
              var i, l, attributeStripper,
                s = pastedData || '',
                badAttributes = [
                  'start','xmlns','xmlns:o','xmlns:w','xmlns:x','xmlns:m',
                  'onmouseover','onmouseout','onmouseenter','onmouseleave',
                  'onmousemove','onload','onfocus','onblur','onclick',
                  'style'
                ];

              // Remove extra word formating
              if (self.isWordFormat(s)) {
                s = self.cleanWordHtml(s);
              }

              // Remove bad attributes
              for (i = 0, l = badAttributes.length; i < l; i++) {
                attributeStripper = new RegExp(' ' + badAttributes[i] + '="(.*?)"','gi');
                s = self.stripAttribute(s, badAttributes[i], attributeStripper);

                attributeStripper = new RegExp(' ' + badAttributes[i] + '=\'(.*?)\'','gi');
                s = self.stripAttribute(s, badAttributes[i], attributeStripper);
              }

              // Remove "ng-" directives and "ng-" classes
              s = s.replace(/(ng-\w+-\w+="(.|\n)*?"|ng-\w+="(.|\n)*?"|ng-(\w+-\w+)|ng-(\w+))/g, '');

              // Remove comments
              s = s.replace(/<!--(.*?)-->/gm, '');

              // Remove extra spaces
              s = s.replace(/\s\s+/g, ' ').replace(/\s>+/g, '>');

              // Remove extra attributes from list elements
              s = s.replace(/<(ul|ol)(.*?)>/gi, '<$1>');

              // Remove html and body tags
              s = s.replace(/<\/?(html|body)(.*?)>/gi, '');

              // Remove header tag and content
              s = s.replace(/<head\b[^>]*>(.*?)<\/head>/gi, '');

              return s;
            };

          if (e.clipboardData || e.originalEvent) {
            if (e.clipboardData && e.clipboardData.types) {
              clipboardData = e.clipboardData;
            }
            else if (e.originalEvent && e.originalEvent.clipboardData && e.originalEvent.clipboardData.getData) {
              clipboardData = e.originalEvent.clipboardData;
            }
          }

          if (clipboardData && clipboardData.types) {
            types = clipboardData.types;
            // jshint undef:false
            if ((types instanceof DOMStringList && types.contains('text/html')) ||
                (types.indexOf && types.indexOf('text/html') !== -1)) {
            // jshint undef:true
              pastedData =  e.originalEvent.clipboardData.getData('text/html');
            }
          } else {
            paste = window.clipboardData.getData('Text');
            paragraphs = paste.split(/[\r\n]/g);
            pastedData = '';
            for (p = 0; p < paragraphs.length; p += 1) {
              if (paragraphs[p] !== '') {
                if (navigator.userAgent.match(/firefox/i) && p === 0) {
                  pastedData += '<p>' + self.htmlEntities(paragraphs[p]) + '</p>';
                } else {
                  if((/\.(gif|jpg|jpeg|tiff|png)$/i).test(paragraphs[p])) {
                    pastedData += '<img src="' + self.htmlEntities(paragraphs[p]) + '" />';
                  } else {
                    pastedData += '<p>' + self.htmlEntities(paragraphs[p]) + '</p>';
                  }
                }
              }
            }
          }

          self.pastedData = getCleanedHtml(pastedData);

          $.when(self.element.triggerHandler('beforepaste', [{pastedData: self.pastedData}])).done(function() {
            if (self.pastedData && !e.defaultPrevented) {
              e.preventDefault();

              if (document.queryCommandSupported('insertText')) {
                  document.execCommand('insertHTML', false, self.pastedData);
                  return false;
              } else { // IE > 7
                self.pasteHtmlAtCaret(self.pastedData);
              }
            }
            self.element.triggerHandler('afterpaste', [{pastedData: self.pastedData}]);
            self.pastedData = null;
          });
          return false;
        };

        currentElement.on(self.pasteEvent, (self.settings.pasteAsPlainText ? self.pasteWrapper : self.pasteWrapperHtml));

        return this;
      },

      pasteHtmlAtCaret: function(html) {
        var sel, range;
        if (window.getSelection) {
          // IE9 and non-IE
          sel = window.getSelection();
          if (sel.getRangeAt && sel.rangeCount) {
            range = sel.getRangeAt(0);
            range.deleteContents();

            // Range.createContextualFragment() would be useful here but is
            // only relatively recently standardized and is not supported in
            // some browsers (IE9, for one)
            var el = document.createElement('div');

            el.innerHTML = html;
            var frag = document.createDocumentFragment(), node, lastNode;
            while ( (node = el.firstChild) ) {
              lastNode = frag.appendChild(node);
            }
            range.insertNode(frag);

            // Preserve the selection
            if (lastNode) {
              range = range.cloneRange();
              range.setStartAfter(lastNode);
              range.collapse(true);
              sel.removeAllRanges();
              sel.addRange(range);
            }
          }
        } else if (document.selection && document.selection.type !== 'Control') {
          // IE < 9
          document.selection.createRange().pasteHTML(html);
        }
      },

      htmlEntities: function (str) {
        // converts special characters (like <) into their escaped/encoded values (like &lt;).
        // This allows you to show to display the string without the browser reading it as HTML.
        return String(str).replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
      },

      bindWindowActions: function () {
        var self = this,
          editorContainer = this.element.closest('.editor-container'),
          currentElement = self.getCurrentElement();

        self.element
        // Work around for Firefox with using keys was not focusing on first child in editor
        // Firefox behaves differently than other browsers
        .on('mousedown.editor', function () {
          self.mousedown = true;
        })
        .on('focus.editor', function () {
          if (self.isFirefox && !self.mousedown && self.element === currentElement) {
            self.setFocus();
          }
        })

        // Work around for Chrome's bug wrapping contents in <span>
        // http://www.neotericdesign.com/blog/2013/3/working-around-chrome-s-contenteditable-span-bug
        .on('DOMNodeInserted', function(e) {
          var target = $(e.target),
            helper = $('<b>helper</b>');

          if (e.target.tagName === 'IMG') {
            target.removeAttr('id style srcset');
          }
          else if (e.target.tagName === 'SPAN') {

            target.before(helper);
            helper.after(target.contents());
            helper.add(target).remove();
          }
        });

        editorContainer
          .on('focus.editor', '.editor, .editor-source', function () {
            var elem = $(this);

            editorContainer.addClass('is-active');
            setTimeout(function () {
              if (elem.hasClass('error')) {
                editorContainer.parent().find('.editor-toolbar').addClass('error');
                editorContainer.parent().find('.editor-source').addClass('error');
              }
            }, 100);
          })
          .on('blur.editor', '.editor, .editor-source', function() {
            editorContainer.removeClass('is-active');
            editorContainer.parent().find('.editor-toolbar').removeClass('error');
            editorContainer.parent().find('.editor-source').removeClass('error');
          });

        //Attach Label
        var label = this.element.prevAll('.label');
        for (var i = 0, l = label.length; i < l; i++) {
          label[i].style.cursor = 'default';
        }
        label.on('click.editor', function () {
          currentElement.focus();
        });
        currentElement.attr('aria-label', label.text());
        return this;
      },

      //Restore Text Selection
      restoreSelection: function(savedSel) {
        var i,
          len,
          sel = window.getSelection();

        if (!savedSel) {
          savedSel = this.savedSelection;
        }

        if (savedSel) {
          sel.removeAllRanges();
          for (i = 0, len = savedSel.length; i < len; i += 1) {
              sel.addRange(savedSel[i]);
          }
        }
      },

      //Save Text Selection
      saveSelection: function() {
        var i,
          len,
          ranges,
          sel = window.getSelection();

        if (sel.getRangeAt && sel.rangeCount) {
          ranges = [];
          for (i = 0, len = sel.rangeCount; i < len; i += 1) {
              ranges.push(sel.getRangeAt(i));
          }
          return ranges;
        }
        return null;
      },

      // Get the Element the Caret idea from http://bit.ly/1kRmZIL
      getSelectionStart: function() {
        var node = document.getSelection().anchorNode,
          startNode = (node && node.nodeType === 3 ? node.parentNode : node);
        return startNode;
      },

      getrange: function() {
        return window.getSelection().getRangeAt(0);
      },

      // Find element within the selection
      // http://stackoverflow.com/questions/6052870/how-to-know-if-there-is-a-link-element-within-the-selection
      findElementInSelection: function(tagname, container) {
        var i, len, el, comprng, selparent,
          rng = this.getrange();

        if (rng) {
          selparent = rng.commonAncestorContainer || rng.parentElement();
          // Look for an element *around* the selected range
          for (el = selparent; el !== container; el = el.parentNode) {
            if (el.tagName && el.tagName.toLowerCase() === tagname) {
              return el;
            }
          }

          // Look for an element *within* the selected range
          if (!rng.collapsed && (rng.text === undefined || rng.text) && selparent.getElementsByTagName) {
            el = selparent.getElementsByTagName(tagname);
            comprng = document.createRange ? document.createRange() : document.body.createTextRange();

            for (i = 0, len = el.length; i < len; i++) {
              // determine if element el[i] is within the range
              if (document.createRange) { // w3c
                comprng.selectNodeContents(el[i]);
                if (rng.compareBoundaryPoints(Range.END_TO_START, comprng) < 0 && rng.compareBoundaryPoints(Range.START_TO_END, comprng) > 0) {
                  return el[i];
                }
              }
              else { // microsoft
                comprng.moveToElementText(el[i]);
                if (rng.compareEndPoints('StartToEnd', comprng) < 0 && rng.compareEndPoints('EndToStart', comprng) > 0) {
                  return el[i];
                }
              }
            }
          }
        }
      },

      // Restore if Selection is a Link
      restoreLinkSelection: function () {
        var currentLink = $(this.findElementInSelection('a', this.element[0]));

        settings.anchor.url = settings.anchor.defaultUrl;
        settings.anchor.class = settings.anchor.defaultClass;
        settings.anchor.target = settings.anchor.defaultTarget;

        if (currentLink.length) {
          settings.anchor.url = currentLink.attr('href');
          settings.anchor.class = currentLink.attr('class');
          settings.anchor.target = currentLink.attr('target');

          // currentLink.removeAttr('class target');
          // document.execCommand('unlink', false, null);
        }

      },

      //Run the CE action.
      execAction: function (action) {
        var currentElement = this.getCurrentElement();

        // Visual Mode
        if (currentElement === this.element) {
          if (action.indexOf('append-') > -1) {
            this.execFormatBlock(action.replace('append-', ''));
            this.setToolbarButtonStates();
          } else if (action === 'anchor') {
            this.restoreLinkSelection();
            this.modals.url.data('modal').open();
          } else if (action === 'image') {
            this.modals.image.data('modal').open();
          } else if (action === 'foreColor' || action === 'backColor') {
            this.colorpickerActions(action);
          } else if (action === 'source' || action === 'visual') {
            this.toggleSource();
          } else {
            document.execCommand(action, false, null);
          }
        } else {
          // Source Mode
          switch(action) {
            case 'visual':
              this.toggleSource();
              break;
            case 'anchor':
              this.modals.url.data('modal').open();
              break;
            default:
              this.insertTextAreaContent(null, action);
              break;
          }
        }

      },

      insertImage: function (url) {
        document.execCommand('insertImage', false, url);
      },

      toggleSource: function() {
        if (this.sourceViewActive()) {
          this.element.empty().html($.sanitizeHTML(this.textarea.val()));
          this.element.removeClass('source-view-active hidden');
          this.sourceView.addClass('hidden').removeClass('is-focused');
          this.element.trigger('focus.editor');
        } else {
          // Format The Text being pulled from the WYSIWYG editor
          var val = this.element.html().toString().trim()
            .replace(/\s+/g, ' ')
            .replace(/<br( \/)?>/g, '<br>\n')
            .replace(/<\/p> /g, '</p>\n\n')
            .replace(/<\/blockquote>( )?/g, '</blockquote>\n\n');

          this.textarea.val(val).focus();

          // var val = this.element.html().toString();
          // this.textarea.val(this.formatHtml(val)).focus();

          this.element.addClass('source-view-active hidden');
          this.sourceView.removeClass('hidden');
          this.adjustSourceLineNumbers();
          this.textarea.focus();
        }
        this.switchToolbars();
      },

      // Colorpicker actions ['foreColor'|'backColor']
      colorpickerActions: function(action) {
        var self = this,
          cpBtn = $('[data-action="'+ action +'"]', this.toolbar),
          cpApi = cpBtn.data('colorpicker'),
          color = document.queryCommandValue(action);

        // Set selection color checkmark in picker popup
        // by adding/updating ['data-value'] attribute
        if (cpApi) {
          if (self.isFirefox && action === 'backColor') {
            color = $(window.getSelection().focusNode.parentNode).css('background-color');
          }
          // IE-11 queryCommandValue returns the as decimal
          if (typeof color === 'number') {
            color = cpApi.decimal2rgb(color);
          }
          color = cpApi.rgb2hex(color);
          cpBtn.attr('data-value', color).find('.icon').css('fill', color);
        }

        cpBtn.on('selected.editor', function (e, item) {
          var value = ('#' + item.data('value')).toLowerCase();
          cpBtn.attr('data-value', value).find('.icon').css('fill', value);

          if (self.isIE || action === 'foreColor') {
            document.execCommand(action, false, value);
          }

          // [action: backColor] - for Chrome/Firefox/Safari
          else {
            // Get selection parent element
            var getSelectionParentElement = function() {
              var parentEl = null, sel;
              if (window.getSelection) {
                sel = window.getSelection();
                if (sel.rangeCount) {
                  parentEl = sel.getRangeAt(0).commonAncestorContainer;
                  if (parentEl.nodeType !== 1) {
                    parentEl = parentEl.parentNode;
                  }
                }
              } else if ( (sel = document.selection) && sel.type !== 'Control') {
                  parentEl = sel.createRange().parentElement();
              }
              return parentEl;
            };

            // FIX: "backColor" - Chrome/Firefox/Safari
            // some reason font/span node not get inserted with "backColor"
            // so use "fontSize" command to add node, then remove size attribute
            // this fix will conflict with combination of font size & background color
            document.execCommand('fontSize', false, '2');
            var parent = getSelectionParentElement().parentNode,
              els = parent.getElementsByTagName('font');

            // Using timeout, firefox not executes with current call stack
            setTimeout(function() {
              for (var i = 0, l = els.length; i < l; i++) {
                if (els[i].hasAttribute('size')) {
                  els[i].setAttribute('style', 'background-color: '+ value +';');
                  els[i].removeAttribute('size');
                }
              }
            }, 0);

          }
        });

        // Toggle colorpicker
        cpApi.toggleList();
      },

      execFormatBlock: function (el) {
        var selectionData = this.getSelectionData(this.selection.anchorNode);
        // FF handles blockquote differently on formatBlock
        // allowing nesting, we need to use outdent
        // https://developer.mozilla.org/en-US/docs/Rich-Text_Editing_in_Mozilla
        if (el === 'blockquote' && selectionData.el &&
            selectionData.el.parentNode.tagName.toLowerCase() === 'blockquote') {
            return document.execCommand('outdent', false, null);
        }
        if (selectionData.tagName === el) {
            el = 'p';
        }
        // When IE we need to add <> to heading elements and
        // blockquote needs to be called as indent
        // http://stackoverflow.com/questions/10741831/execcommand-formatblock-headings-in-ie
        // http://stackoverflow.com/questions/1816223/rich-text-editor-with-blockquote-function/1821777#1821777
        if (this.isIE) {
          if (el === 'blockquote') {
              return document.execCommand('indent', false, el);
          }
          el = '<' + el + '>';
        }

        return document.execCommand('formatBlock', false, el);
      },

      //Get What is Selected
      getSelectionData: function (el) {
        var tagName;

        if (el && el.tagName) {
        tagName = el.tagName.toLowerCase();
        }

        while (el && this.parentElements.indexOf(tagName) === -1) {
          el = el.parentNode;
          if (el && el.tagName) {
              tagName = el.tagName.toLowerCase();
          }
        }

        return {
          el: el,
          tagName: tagName
        };
      },

      isListItemChild: function (node) {
        var parentNode = node.parentNode,
            tagName = parentNode.tagName.toLowerCase();
        while (this.parentElements.indexOf(tagName) === -1 && tagName !== 'div') {
          if (tagName === 'li') {
              return true;
          }
          parentNode = parentNode.parentNode;
          if (parentNode && parentNode.tagName) {
              tagName = parentNode.tagName.toLowerCase();
          } else {
              return false;
          }
        }
        return false;
      },

      destroyToolbar: function() {
        var element = this.getCurrentElement();
        // Unbind all events attached to the old element that involve triggering the toolbar hide/show

        var toolbarApi = this.toolbar.data('toolbar');
        if (toolbarApi) {
          toolbarApi.destroy();
        }

        var tooltips = this.toolbar.find('button');
        tooltips.each(function() {
          var tooltip = $(this).data('tooltip');
          if (tooltip && typeof tooltip.destroy === 'function') {
            tooltip.destroy();
          }
        });

        this.toolbar.off('click.editor mousedown.editor');
        this.toolbar.remove();
        this.toolbar = undefined;
        this.element.off('mouseup.editor keyup.editor focus.editor blur.editor ' + this.pasteEvent);
        this.textarea.off('mouseup.editor keyup.editor focus.editor blur.editor ' + this.pasteEvent);
        element.off('keydown.editor');
        this.element.prev('.label').off('click.editor');
        $(window).off('resize.editor');
        $.each(this.modals, function(i, modal) {
          modal.off('beforeclose close open');
        });
        this.modals = {};

        this.element.trigger('destroy.toolbar.editor');
      },

      updated: function() {
        // TODO: Updated Method
        return this;
      },

      disable: function () {
        this.element.addClass('is-disabled').attr('contenteditable', 'false');
        this.container.addClass('is-disabled');
      },

      enable: function () {
        this.element.removeClass('is-disabled is-readonly').attr('contenteditable', 'true');
        this.container.removeClass('is-disabled is-readonly');
      },

      readonly: function () {
        this.element.removeClass('is-readonly').attr('contenteditable', 'false');
        this.container.addClass('is-readonly');
      },

      // Fix to Firefox get focused by keyboard
      setFocus: function() {
        var self = this,
          el = ($.trim(self.element.html()).slice(0, 1) === '<') ?
            $(':first-child', self.element)[0] : self.element[0];

        window.setTimeout(function() {
          var sel, range;
          if (window.getSelection && document.createRange) {
            range = document.createRange();
            range.selectNodeContents(el);
            range.collapse(true);
            sel = window.getSelection();
            sel.removeAllRanges();
            sel.addRange(range);
          } else if (document.body.createTextRange) {
            range = document.body.createTextRange();
            range.moveToElementText(el);
            range.collapse(true);
            range.select();
          }
        }, 1);

      },

      // Called whenever a paste event has occured
      onPasteTriggered: function () {
        if(!this.isFirefox && document.addEventListener) {
          document.addEventListener('paste', function (e) {
            if(typeof e.clipboardData !== 'undefined') {
              var copiedData = e.clipboardData.items[0]; // Get the clipboard data
              // If the clipboard data is of type image, read the data
              if(copiedData.type.indexOf('image') === 0) {
                var imageFile = copiedData.getAsFile();
                // We will use HTML5 FileReader API to read the image file
                var reader = new FileReader();

                reader.onload = function (evt) {
                  var result = evt.target.result; // base64 encoded image
                  document.execCommand('insertImage', false, result);
                  // Create an image element and append it to the content editable div
                  // var img = document.createElement('img');
                  // img.src = result;
                  // document.getElementById('editablediv').appendChild(img);
                };
                // Read the image file
                reader.readAsDataURL(imageFile);
              }
            }
          }, false);
        }
      },

      isWordFormat: function(content) {
        return (
          (/<font face="Times New Roman"|class="?Mso|style="[^"]*\bmso-|style='[^'']*\bmso-|w:WordDocument/i).test(content) ||
          (/class="OutlineElement/).test(content) ||
          (/id="?docs\-internal\-guid\-/.test(content))
        );
      },

      cleanWordHtml: function(content) {
        var s = content;

        // Word comments like conditional comments etc
        s = s.replace(/<!--[\s\S]+?-->/gi, '');

        // Remove comments, scripts (e.g., msoShowComment), XML tag, VML content,
        // MS Office namespaced tags, and a few other tags
        s = s.replace(/<(!|script[^>]*>.*?<\/script(?=[>\s])|\/?(\?xml(:\w+)?|img|meta|link|style|\w:\w+)(?=[\s\/>]))[^>]*>/gi, '');

        // Convert <s> into <strike> for line-though
        s = s.replace(/<(\/?)s>/gi, '<$1strike>');

        // Replace nsbp entites to char since it's easier to handle
        s = s.replace(/&nbsp;/gi, '\u00a0');

        // Convert <span style="mso-spacerun:yes"></span> to string of alternating
        // breaking/non-breaking spaces of same length
        s = s.replace(/<span\s+style\s*=\s*"\s*mso-spacerun\s*:\s*yes\s*;?\s*"\s*>([\s\u00a0]*)<\/span>/gi, function(str, spaces) {
          return (spaces.length > 0) ?
          spaces.replace(/./, ' ').slice(Math.floor(spaces.length / 2)).split('').join('\u00a0') : '';
        });

        // Remove line breaks / Mso classes
        s = s.replace(/(\n|\r| class=(\'|")?Mso[a-zA-Z]+(\'|")?)/g, ' ');

        var i, l, re,
          badTags = ['style', 'script','applet','embed','noframes','noscript'];

        // Remove everything in between and including "badTags"
        for (i = 0, l = badTags.length; i < l; i++) {
          re = new RegExp('<'+badTags[i]+'.*?'+badTags[i]+'(.*?)>', 'gi');
          s = s.replace(re, '');
        }

        return s;
      },

      // Strip attributes
      stripAttribute: function (s, attribute, attributeStripper) {
        return (attribute === 'style') ?
          this.stripStyles(s, attributeStripper) :
          s.replace(attributeStripper, '');
      },

      // Strip styles
      stripStyles: function (s, styleStripper) {
        var stylesToKeep = ['color','background','font-weight','font-style','text-decoration','text-align'];
        return s.replace(styleStripper, function(m) {
          m = m.replace(/( style=|("|\'))/gi, '');
          var attributes = m.split(';'),
          strStyle = '';
          for (var i = 0; i < attributes.length; i++) {
            var entry = attributes[i].split(':');
            strStyle += (stylesToKeep.indexOf(entry[0]) > -1) ? entry[0] +':'+ entry[1] +';' : '';
          }
          return (strStyle !=='') ? (' style="'+ strStyle +'"') : '';
        });
      },

      getIndent: function(level) {
        var result = '',
          i = level * 2;
        if (level > -1) {
          while (i--) {
            result += ' ';
          }
        }
        return result;
      },

      formatHtml: function(html) {
        html = html.trim();
        var result = '',
          indentLevel = 0,
          tokens = html.split(/</);

        for (var i = 0, l = tokens.length; i < l; i++) {
          var parts = tokens[i].split(/>/);
          if (parts.length === 2) {
            if (tokens[i][0] === '/') {
              indentLevel--;
            }
            result += this.getIndent(indentLevel);
            if (tokens[i][0] !== '/') {
              indentLevel++;
            }
            if (i > 0) {
              result += '<';
            }
            result += parts[0].trim() + '>\n';
            if (parts[1].trim() !== '') {
              result += this.getIndent(indentLevel) + parts[1].trim().replace(/\s+/g, ' ') + '\n';
            }
            if (parts[0].match(/^(area|base|br|col|command|embed|hr|img|input|link|meta|param|source)/)) {
              indentLevel--;
            }
          } else {
            result += this.getIndent(indentLevel) + parts[0] + '\n';
          }
        }
        return result.trim();
      },

      destroy: function () {
        $('html').off('mouseup.editor');
        this.destroyToolbar();
        this.sourceView.remove();
        if ($('[data-editor="true"]').length === 1) {
          $('#editor-modal-url, #editor-modal-image').remove();
        }
        $.removeData(this.element[0], pluginName);
      }
    };

    // Make it plugin protecting from double initialization
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (instance) {
        instance.settings = $.extend({}, instance.settings, options);
        instance.updated();
      } else {
        instance = $.data(this, pluginName, new Editor(this, settings));
      }
    });

  };


  $.fn.expandablearea = function(options) {

    'use strict';

    // Settings and Options
    var pluginName = 'expandablearea',
        defaults = {
          trigger: null, //Id of some other button to use as a trigger
          bottomBorder: false //Change the border to bottom vs top
        },
        settings = $.extend({}, defaults, options);

    /**
     * @constructor
     * @param {Object} element
     */
    function ExpandableArea(element) {
      this.settings = $.extend({}, settings);
      this.element = $(element);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    // Plugin Methods
    ExpandableArea.prototype = {
      init: function() {
        this
          .setup()
          .build()
          .handleEvents();
      },

      setup: function() {
        var id;
        this.id = id = this.element.attr('id');
        if (!id || id === undefined) {
          this.id = id = 'expandable-area-' + $('body').find('.expandable-area').index(this.element);
        }

        this.header = this.settings.trigger ? this.element : this.element.children('.expandable-header');
        this.footer = this.element.children('.expandable-footer');
        this.content = this.element.children('.expandable-pane');

        this.isCard = this.element.is('.card, .widget');
        return this;
      },

      build: function() {
        var self = this,
          expanded = this.element.hasClass('is-expanded');

        this.header.attr({
          'aria-expanded': '' + expanded,
          'aria-controls': this.id + '-content',
          'id': this.id + '-header'
        });
        this.content.attr({
          'id': this.id + '-content'
        });

        // Add the link and footer if not there.
        // If we're using an expandable card,
        if (!this.isCard && !this.footer.length && !this.settings.trigger) {
          this.footer =  $('<div class="expandable-footer"></div>').appendTo(this.element);
        }

        function getExpander(instance, useHeaderExpander) {
          var expander;

          if (useHeaderExpander === true) {
            // Use icon-based expander in the header
            expander = instance.header.find('expandable-expander');
            if (!expander.length) {
              expander = $('<a href="#" target="_self" class="btn-expander">' +
                '<svg class="chevron icon" focusable="false" aria-hidden="true" role="presenation">' +
                  '<use xlink:href="' + '#icon-caret-down' + '"></use>' +
                '</svg>' +
                '<span class="audible">'+ Locale.translate('ShowMore') +'</span>' +
              '</a>').appendTo(instance.header);
            }

            return expander;
          }

          // Use the text-based expander button in the footer
          expander = instance.footer.find('.expandable-expander');
          if (!expander.length) {
            expander = $('<a href="#" target="_self" class="expandable-expander hyperlink">' +
              '<span data-translated="true">'+ Locale.translate('ShowMore') +'</span>' +
            '</a>').prependTo(instance.footer);
          }
          return expander;
        }

        this.expander = getExpander(self, this.isCard);
        this.expander.attr('href', '#').hideFocus();

        if (this.expander.length === 0) {
          this.expander = $('#' + this.settings.trigger);
        }

        // Change the borer to the bottom vs top
        if (this.settings.bottomBorder) {
          this.element.addClass('has-bottom-border');
        }

        //Initialized in expanded mode.
        if (expanded) {
          this.content.addClass('no-transition');
          this.element.one('afterexpand.expandable-area', function() {
            self.content.removeClass('no-transition');
          });
          this.open();
        }

        if (!expanded) {
          this.content.addClass('no-transition');
          this.element.one('aftercollapse.expandable-area', function() {
            self.content.removeClass('no-transition');
          });
          this.close();
        }

        return this;
      },

      isDisabled: function() {
        return this.element.hasClass('is-disabled');
      },

      handleEvents: function() {
        var self = this;
        this.expander.onTouchClick('expandablearea').on('click.expandablearea', function(e) {
          if (!self.isDisabled()) {
            e.preventDefault();
            self.toggleExpanded();
          }
        });

        this.header.on('keydown.expandablearea', function(e) {
          self.handleKeys(e);
        }).on('focus.expandablearea', function(e) {
          self.handleFocus(e);
        }).on('blur.expandablearea', function(e) {
          self.handleBlur(e);
        });

        return this;
      },

      handleKeys: function(e) {
        if (this.isDisabled()) {
          return;
        }

        var key = e.which;

        if (key === 13 || key === 32) { // Enter/Spacebar
          e.preventDefault();
          this.toggleExpanded();
          return false;
        }
      },

      handleFocus: function() {
        if (this.isDisabled()) {
          return;
        }

        this.header.addClass('is-focused');
      },

      handleBlur: function() {
        if (this.isDisabled()) {
          return;
        }

        this.header.removeClass('is-focused');
      },

      /**
       * Indicates whether or not this area is expanded.
       * @returns {boolean}
       */
      isExpanded: function() {
        return this.element.is('.is-expanded');
      },

      toggleExpanded: function() {
        // if (this.header.attr('aria-expanded') === 'true') {
        if (this.isExpanded()) {
          this.close();
        } else {
          this.open();
        }
      },

      open: function() {
        var self = this,
        canExpand = this.element.triggerHandler('beforeexpand', [this.element]);

        if (canExpand === false) {
          return;
        }

        this.element.addClass('is-expanded');
        this.header.attr('aria-expanded', 'true');
        this.expander.addClass('active');
        this.element.triggerHandler('expand', [this.element]);

        this.expander.find('span[data-translated="true"]').text(Locale.translate('ShowLess') ? Locale.translate('ShowLess') : 'Show Less');

        if (this.isCard) {
          this.expander.find('.icon').addClass('active');
        }

        if (this.content[0]) {
          this.content[0].style.display = 'block';
        }
        this.content.one('animateopencomplete', function() {
          self.element.triggerHandler('afterexpand', [self.element]);
        }).animateOpen();
      },

      close: function() {
        var self = this,
        canCollapse = this.element.triggerHandler('beforecollapse', [this.element]);

        if (canCollapse === false) {
          return;
        }

        this.expander.removeClass('active');
        this.element.triggerHandler('collapse', [this.element]);
        this.expander.find('span[data-translated="true"]').text(Locale.translate('ShowMore') ? Locale.translate('ShowMore') : 'Show More');

        if (this.isCard) {
          this.expander.find('.icon').removeClass('active');
        }

        this.content.one('animateclosedcomplete', function() {
          self.element.removeClass('is-expanded');
          self.header.attr('aria-expanded', 'false');
          self.element.triggerHandler('aftercollapse', [self.element]);
          self.content[0].style.display = 'none';
        }).animateClosed();
      },

      disable: function() {
        this.element.addClass('is-disabled');
      },

      enable: function() {
        this.element.removeClass('is-disabled');
      },

      // Teardown - Remove added markup and events
      destroy: function() {
        this.header.children('a').offTouchClick('expandablearea').off();
        this.header.off();
        this.header
          .removeAttr('aria-controls')
          .removeAttr('aria-expanded')
          .removeAttr('id');
        this.content.removeAttr('id').removeClass('no-transition');
        $.removeData(this.element[0], pluginName);
      }
    };

    // Initialize the plugin (Once)
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (instance) {
        instance.settings = $.extend({}, defaults, options);
      } else {
        instance = $.data(this, pluginName, new ExpandableArea(this, settings));
      }
    });
  };


/**
 * The jQuery plugin namespace.
 * @external "jQuery.fn"
 * @see {@link http://learn.jquery.com/plugins/|jQuery Plugins}
 * @private
 */

 /**
  * Make something disabled
  * @private
  * @function external:"jQuery.fn".disable
  */
  $.fn.disable = function() {
    $.each(this.data(), function(index, value) {
      if (value instanceof jQuery) {
        return;
      }

      if (value.disable) {
        value.disable();
      }
    });
    this.prop('disabled', true);
    return this;
  };

 /**
  * Make something enabled
  * @private
  * @function external:"jQuery.fn".enabled
  */
  $.fn.enable = function() {
    $.each(this.data(), function(index, value) {
      if (value instanceof jQuery) {
        return;
      }

      if (value.enable) {
        value.enable();
      }
    });
    this.prop('disabled', false);
    return this;
  };

 /**
  * Make something readonly
  * @private
  * @function external:"jQuery.fn".readonly
  */
  $.fn.readonly = function() {
    $.each(this.data(), function(index, value) {
      if (value instanceof jQuery) {
        return;
      }

      if (value.readonly) {
        value.readonly();
      }
    });
    this.prop('readonly', true);
    return this;
  };

 /**
  * Track Input is changed from last submit
  * @private
  * @function external:"jQuery.fn".trackdirty
  */
  $.fn.trackdirty = function() {
      this.each(function () {
        var input = $(this);

        function valMethod(elem) {
          switch(elem.attr('type')) {
            case 'checkbox':
            case 'radio':
              return elem.prop('checked');
            default:
              return elem.val();
          }
        }

        // Get absolute position for an element
        function getAbsolutePosition(element) {
          var pos = element.position();
          element.parents().each(function() {
            var el = this;
            if (window.getComputedStyle(el, null).position === 'relative') {
              return false;
            }
            pos.left += el.scrollLeft;
            pos.top += el.scrollTop;
          });
          return {left:pos.left, top:pos.top};
        }

        input.data('original', valMethod(input))
        .on('resetdirty.dirty', function () {
          input.data('original', valMethod(input))
            .triggerHandler('doresetdirty.dirty');
        })
        .on('change.dirty doresetdirty.dirty', function (e) {
          var el = input,
            field = input.closest('.field'),
            label = $('label:visible', field),
            d = {class: '', style: ''};

          // Used element without .field wrapper
          if (!label[0]) {
            label = input.next('label');
          }
          if (input.attr('data-trackdirty') !== 'true') {
            return;
          }

          // Add class to element
          input.addClass('dirty');

          //Set css class
          if (input.is('[type="checkbox"], [type="radio"]')) {
            d.class += ' dirty-'+ input.attr('type');
            d.class += input.is(':checked') ? ' is-checked' : '';
          }
          if (input.is('select')) {
            d.class += ' is-select';
            el = input.next('.dropdown-wrapper').find('.dropdown');
          }

          //Add class and icon
          d.icon = el.prev();
          if (!d.icon.is('.icon-dirty')) {
            if (input.is('[type="checkbox"]')) {
              d.rect = getAbsolutePosition(label);
              d.style = ' style="left:'+ d.rect.left +'px; top:'+ d.rect.top +'px;"';
            }
            d.icon = '<span class="icon-dirty'+ d.class +'"'+ d.style +'></span>';
            d.msg = Locale.translate('MsgDirty') || '';
            d.msg = '<span class="audible msg-dirty">'+ d.msg +'</span>';

            // Add icon and msg
            el.before(d.icon);
            label.append(d.msg);

            // Cache icon and msg
            d.icon = el.prev();
            d.msg = label.find('.msg-dirty');
          }

          //Handle reseting value back
          if (valMethod(input) === input.data('original')) {
            input.removeClass('dirty');
            $('.icon-dirty, .msg-dirty', field).add(d.icon).add(d.msg).remove();
            input.trigger(e.type === 'doresetdirty' ? 'afterresetdirty' : 'pristine');
            return;
          }

          //Trigger event
          input.trigger('dirty');

        });
      });
    return this;
  };

  // Fix: Labels without the "for" attribute
  $(function () {
    var str, control,
      labelText = $('.label-text'),
      labels = labelText.closest('label, .label');

    labels.each(function () {
      control = $('input, textarea, select', this);
      str = control.attr('class');

      $(this).addClass(function () {
        // Add "inline" and "inline-{control}" class to label
        // assuming control class is first thing in class string
        return 'inline' + (str ? ' inline-'+ (str.indexOf(' ') === -1 ? str : str.substr(0, str.indexOf(' '))) : '');
      });
    });
  });

  // Fix: Radio buttons was not selecting when click and than use arrow keys on Firefox
  $(function () {
    $('input:radio').on('click.radios', function() {
      this.focus();
    });
  });

  // Add css classes to parent for apply special rules
  $(function () {
    var addCssClassToParent = function(elemArray, cssClass) {
      for (var i = 0, l = elemArray.length; i < l; i++) {
        $(elemArray[i]).parent().addClass(cssClass);
      }
    };
    addCssClassToParent($('.field > input:checkbox, .field > .inline-checkbox'), 'field-checkbox');
    addCssClassToParent($('.field > input:radio, .field > .inline-radio'), 'field-radio');
  });


  $.fn.fileupload = function() {

    'use strict';

    // Settings and Options
    var pluginName = 'fileupload';

    /**
     * @constructor
     * @param {Object} element
     */
    function FileUpload(element) {
      this.element = $(element);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    // FileUpload Methods
    FileUpload.prototype = {

      init: function() {
        this.build();
      },

      // Example Method
      build: function() {
        var elem = this.element;
        this.fileInput = elem.find('input');

        elem.parent('.field').addClass('field-fileupload');

        //append markup
        var id = elem.find('input').attr('name'),
          elemClass = elem.find('input').attr('class'),
          instructions = Locale.translate('FileUpload'),
          label = $('<label for="'+ id +'-filename">'+ elem.text() +' <span class="audible">'+ instructions +'</span></label>'),
          shadowField = $('<input readonly id="'+ id +'-filename" class="fileupload-background-transparent '+ elemClass +'" type="text">'),
          svg = '<span class="trigger" tabindex="-1">' + $.createIcon('folder') + '</span>';

        elem.before(label, shadowField);
        this.fileInput.after(svg);

        this.textInput = elem.parent().find('[type="text"]');
        this.textInput.on('keypress.fileupload', function (e) {
          if (e.which === 13 || e.which === 32) {
            e.stopPropagation();
            elem.find('input').trigger('click');
          }
        });

        if (this.fileInput.is(':disabled')) {
          this.textInput.prop('disabled', true);
        }

        if (this.fileInput.attr('readonly')) {
          this.textInput.prop('disabled', false);
          this.textInput[0].classList.remove('fileupload-background-transparent');
          this.fileInput.attr('disabled', 'disabled');
        }

        this.fileInput.attr('tabindex', '-1').on('change.fileupload', function () {
          elem.prev('input').val(this.files[0].name);
        });
      },

      // Teardown - Remove added markup and events
      destroy: function() {
        this.fileInput.removeAttr('tabindex').off('change.fileupload');
        this.textInput.off('keypress.fileupload');
        this.element.closest('.field-fileupload')
          .removeClass('field-fileupload')
          .find('>label:first, >[type="text"]:first, .trigger').remove();

        $.removeData(this.element[0], pluginName);
      },

      disable: function() {
        this.textInput.prop('disabled', true);
        this.fileInput.prop('disabled', true);
      },

      enable: function() {
        this.textInput.prop('disabled', false).prop('readonly', false);
        this.fileInput.removeAttr('disabled');
      },

      readonly: function() {
        this.textInput.prop('readonly', true);
        this.fileInput.prop('disabled', true);
      }

    };

    // Initialize the plugin (Once)
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (!instance) {
        instance = $.data(this, pluginName, new FileUpload(this));
      }
    });
  };


  $.fn.fileuploadadvanced = function(options) {
    'use strict';

    // Settings and Options
    var pluginName = 'fileuploadadvanced',
        defaults = {
          isStandalone: true, // on page -or- on modal [for some visual style only]
          standaloneClass: 'standalone', // css class if on page
          allowedTypes: '*', // restrict file types(ie. 'jpg|png|gif') ['*' all types]
          maxFilesInProcess: 99999, // max files can be upload
          maxFileSize: -1, // max file size in bytes, -1 for unlimited
          fileName: 'myfile', // variable name to read from server

          // Text strings
          textDropArea: 'Drag and Drop File to Upload',
          textBtnCancel: 'Cancel uploading this file',
          textBtnCloseError: 'Close this error',
          textBtnRemove: 'Remove from server this file',

          // Error strings
          errorAllowedTypes: '<em>'+ Locale.translate('Error') +'</em>: '+ Locale.translate('ErrorAllowedTypes'),
          errorMaxFileSize: '<em>'+ Locale.translate('Error') +'</em>: '+ Locale.translate('ErrorMaxFileSize'),
          errorMaxFilesInProcess: '<em>'+ Locale.translate('Error') +'</em>: '+ Locale.translate('ErrorMaxFilesInProcess')
        },
        settings = $.extend({}, defaults, options);

    /**
     * @constructor
     * @param {Object} element
     */
    function FileUploadAdvanced(element) {
      this.element = $(element);
      this.settings = settings;
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    // FileUploadAdvanced Methods
    FileUploadAdvanced.prototype = {

      init: function() {
        this.build();
        this.handleEvents();
      },

      //Add any markup
      build: function() {
        var settings = this.settings,
          standaloneClass = settings.isStandalone ? settings.standaloneClass : '';

        this.element.append(
          '<div class="fileupload-wrapper '+ standaloneClass +'">' +
            '<div class="container drop-area">' +
              $.createIcon('upload-adv') +
              '<p>'+ settings.textDropArea +'</p>' +
            '</div>' +
          '</div>');

        this.dropArea = $('.drop-area', this.element);
      },

      //Attach Events used by the Control
      handleEvents: function () {
        var self = this,
          settings = this.settings;

        self.dropArea

        // Drag enter
        .on('dragenter.fileuploadadvanced', function (e) {
          self.element.triggerHandler('filesdragenter');
          e.stopPropagation();
          e.preventDefault();
          $(this).addClass('hover');
        })

        // Drag over
        .on('dragover.fileuploadadvanced', function (e) {
          e.stopPropagation();
          e.preventDefault();
        })

        // Drop
        .on('drop.fileuploadadvanced', function (e) {
          var files = e.originalEvent.dataTransfer.files;
          e.preventDefault();

          self.element.triggerHandler('filesdroped', [files]);

          $(this).removeClass('hover');

          // Clear previous errors in general area
          $('span.msg', this.element).closest('.error').remove();

          // Max files can be upload
          if ((files.length + $('.progress', this.element).length) > settings.maxFilesInProcess) {
            self.showError(settings.errorMaxFilesInProcess);
            return;
          }

          self.handleFileUpload(files);
        });

        // If the files are dropped outside the div, files will open in the browser window.
        // To avoid this prevent 'drop' event on document.
        $(document).on('dragenter.fileuploadadvanced dragover.fileuploadadvanced drop.fileuploadadvanced', function (e) {
          e.stopPropagation();
          e.preventDefault();

          if (e.type === 'dragover') {
            self.dropArea.removeClass('hover');
          }
        });

      },

      // Read the file contents using HTML5 FormData()
      handleFileUpload: function (files) {
        var fileName = this.settings.fileName.replace('[]', '');

        for (var i = 0, l = files.length; i < l; i++) {

          // Check if file type allowed
          if (!this.isFileTypeAllowed(files[i].name)) {
            this.showError(settings.errorAllowedTypes, files[i]);
            continue;
          }

          // Check for max file size
          if (settings.maxFileSize !== -1 && files[i].size > settings.maxFileSize) {
            this.showError(settings.errorMaxFileSize, files[i]);
            continue;
          }

          this.element.triggerHandler('beforecreatestatus', [files[i]]);
          var fd = new FormData();
          fd.append(fileName + '[]', files[i]);

          var status = this.createStatus(files[i]);
          this.element.triggerHandler('aftercreatestatus', [files[i]]);

          this.sendFileToServer(fd, status);
        }
      },

      // Create status
      createStatus: function (file) {
        var self = this,
          settings = this.settings,
          container = $(
            '<div class="container">' +
              '<div class="file-row">' +
                '<span class="status-icon">' +
                  '<button type="button" class="btn-icon action">' +
                    $.createIcon({ icon: 'close', classes: ['icon-close'] }) +
                    '<span>'+ settings.textBtnCancel +'</span>' +
                  '</button>' +
                '</span>' +
                '<span class="description">'+ file.name +'</span>' +
                '<div class="l-pull-right">' +
                  '<span class="size">'+ self.formatFileSize(file.size) +'</span>' +
                '</div>' +
              '</div>' +
              '<div class="progress-row">' +
                '<span class="progress">' +
                  '<span class="progress-bar" data-value="0"></span>' +
                '</span>' +
              '</div>' +
            '</div>'),

          btnCancel = $('.action', container).button(),
          rightSide = $('.l-pull-right', container),
          progressBar = $('.progress-bar', container).progress({ animationLength: 10 });

        // Add this container
        self.dropArea.after(container);

        // Update progress-bar
        var setProgress = function(progress) {
            self.element.triggerHandler('fileprogress', [{file: file, 'progress': progress}]);
            progressBar.attr('data-value', progress).triggerHandler('updated');
          },

          // Set abort action
          setAbort = function(jqxhr) {
            btnCancel.on('click.fileuploadadvanced', function() {
              self.element.triggerHandler('fileaborted', [file]);
              jqxhr.abort();
              container.remove();
            });
          },

          // Set completed state
          setCompleted = function(data) {
            container.addClass('completed');

            // Add "Completed" icon
            btnCancel.after($.createIcon('check'));

            // Add "Remove from server" button
            rightSide.append(
              '<button type="button" class="btn-icon action">' +
                $.createIcon({ classes: ['icon-close'], icon: 'close' }) +
                '<span>'+ settings.textBtnRemove +'</span>' +
              '</button>');

            // Set "Remove from server" button action
            $('.action', rightSide).button().on('click.fileuploadadvanced', function() {
              container.remove();

              // TODO: server call for removing data
              data.remove();
            });

            // Remove Cancel button and progress-bar area
            btnCancel.add(progressBar.closest('.progress-row')).remove();
            self.element.triggerHandler('filecompleteuploading', [file]);
          };

        return {
          file: file,
          container: container,
          setProgress: setProgress,
          setAbort: setAbort,
          setCompleted: setCompleted
        };
      },

      // For ui testing only
      sendFileToServer: function (formData, status) {
        var jqXHR = { abort: function() {} },
          tempData = { remove: function() {} },
          percent = 0,
          total = parseFloat(status.file.size),
          timer = new $.fn.timer(function() {
            status.setCompleted(tempData);
          }, total);

        $(timer.event)
        .on('update', function(e, data) {
          percent = Math.ceil(data.counter / total * 100);
          status.setProgress(percent);
        });

        status.setAbort(jqXHR);
      },

      sendFileToServer2: function (formData, status) {
        this.element.triggerHandler('beforeuploading', [formData]);
        var uploadURL = 'http://myserver.com/upload/upload.php', // Upload URL
          jqXHR = $.ajax({
            xhr: function() {
              var xhrobj = $.ajaxSettings.xhr();

              if (xhrobj.upload) {
                xhrobj.upload.addEventListener('progress', function(e) {
                  var percent = 0,
                    position = e.loaded || e.position,
                    total = e.total;

                  if (e.lengthComputable) {
                    percent = Math.ceil(position / total * 100);
                  }

                  // Set progress
                  status.setProgress(percent);
                }, false);
              }
              return xhrobj;
            },
            url: uploadURL,
            type: 'POST',
            contentType: false,
            processData: false,
            cache: false,
            data: formData,
            success: function(data) {
              // File upload Done
              status.setCompleted(data);
            }
        });

        status.setAbort(jqXHR);
      },

      // Show Errors
      showError: function (error, file) {
        var container;

        if (error === this.settings.errorMaxFilesInProcess) {
          // This error show without file name or size in general area
          container = $(
            '<div class="container error">' +
              '<div class="file-row">' +
                '<span class="status-icon">' +
                  '<button type="button" class="btn-icon action">' +
                    $.createIcon({ classes: ['icon-close'], icon: 'close' }) +
                    '<span>'+ settings.textBtnCloseError +'</span>' +
                  '</button>' +
                '</span>' +
                '<span class="msg">'+ error +'</span>' +
              '</div>' +
            '</div>');
        }
        else {
          container = $(
            '<div class="container error">' +
              '<div class="file-row">' +
                '<span class="status-icon">' +
                  '<button type="button" class="btn-icon action">' +
                    $.createIcon({ classes: ['icon-close'], icon: 'close' }) +
                    '<span>'+ settings.textBtnCloseError +'</span>' +
                  '</button>' +
                '</span>' +
                '<span class="description">'+ file.name +'</span>' +
                '<div class="l-pull-right">' +
                  '<span class="size">'+ this.formatFileSize(file.size) +'</span>' +
                '</div>' +
              '</div>' +
              '<div class="msg">' +
                '<p>' + error +'</p>' +
              '</div>' +
            '</div>');
        }

        $('.action', container).button().on('click.fileuploadadvanced', function() {
          container.remove();
        });

        // Add this container
        this.dropArea.after(container);
      },

      // Check if file type allowed
      isFileTypeAllowed: function (fileName) {
        var fileExtensions = this.settings.allowedTypes.toLowerCase().split(/[\s|]+/g),
          ext = fileName.split('.').pop().toLowerCase();
          if(this.settings.allowedTypes !== '*' && $.inArray(ext, fileExtensions) < 0) {
            return false;
          }
          return true;
        },


      // Helper function that formats the file sizes
      formatFileSize: function (bytes) {
        var scale = {
          GB: 1000000000,
          MB: 1000000,
          KB: 1000
        };
        if (typeof bytes !== 'number') {
          return '';
        }
        if (bytes >= scale.GB) {
          return (bytes / scale.GB).toFixed(2) +' GB';
        }
        if (bytes >= scale.MB) {
          return (bytes / scale.MB).toFixed(2) +' MB';
        }
        return (bytes / scale.KB).toFixed(2) +' KB';
      },

      // Teardown
      destroy: function() {
        this.dropArea.off('dragenter.fileuploadadvanced dragover.fileuploadadvanced drop.fileuploadadvanced');
        $(document).off('dragenter.fileuploadadvanced dragover.fileuploadadvanced drop.fileuploadadvanced');
        $('.action', this.element).off('click.fileuploadadvanced');
        $('.fileupload-wrapper', this.element).remove();

        $.removeData(this.element[0], pluginName);
      }
    };

    // Initialize the plugin (Once)
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (instance) {
        instance.settings = $.extend({}, defaults, options);
      } else {
        instance = $.data(this, pluginName, new FileUploadAdvanced(this, settings));
      }
    });
  };


/*
ERROR
--------
https://social.technet.microsoft.com/Forums/ie/en-US/ec3c0be0-0834-4873-8e94-700e9df9c822/edge-browser-drag-and-drop-files-not-working?forum=ieitprocurrentver

*/

  $.fn.header = function(options) {

    'use strict';

    // Tab Settings and Options
    var pluginName = 'header',
        defaults = {
          demoOptions: true, // Used to enable/disable default SoHo Xi options for demo purposes
          useBackButton: true, // If true, displays a back button next to the title in the header toolbar
          useBreadcrumb: false, // If true, displays a breadcrumb on drilldown
          usePopupmenu: false, // If true, changes the Header Title into a popupmenu that can change the current page
          tabs: null, // If defined as an array of Tab objects, displays a series of tabs that represent application sections
          wizardTicks: null, // If defined as an array of Wizard Ticks, displays a Wizard Control that represents steps in a process
          useAlternate: false, // If true, use alternate background/text color for sub-navigation areas
          addScrollClass: false //If true a class will be added as the page scrolls up and down to the header for manipulation. Eg: Docs Page.
        },
        settings = $.extend({}, defaults, options);

    /**
     * Special Toolbar at the top of the page used to faciliate SoHo Xi Nav Patterns
     * @constructor
     * @param {Object} element
     */
    function Header(element) {
      this.settings = $.extend({}, settings);
      this.element = $(element);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    Header.prototype = {

      init: function() {
        this
          .setup()
          .build()
          .handleEvents();

        // Theme, Personalization, Language Changer, Scrolling
        if (this.settings.demoOptions) {
          this.initPageChanger();
        }
      },

      setup: function() {
        // TODO: Settings all work independently, but give better descriptions
        this.settings.demoOptions = this.element.attr('data-demo-options') ? this.element.attr('data-demo-options') === 'true' : this.settings.demoOptions;
        this.settings.useBackButton = this.element.attr('data-use-backbutton') ? this.element.attr('data-use-backbutton') === 'true' : this.settings.useBackButton;
        this.settings.useBreadcrumb = this.element.attr('data-use-breadcrumb') ? this.element.attr('data-use-breadcrumb') === 'true' : this.settings.useBreadcrumb;
        this.settings.useAlternate = this.element.attr('data-use-alternate') ? this.element.attr('data-use-alternate') === 'true' : this.settings.useAlternate;

        this.settings.tabs = !$.isArray(this.settings.tabs) ? null : this.settings.tabs;
        this.settings.wizardTicks = !$.isArray(this.settings.wizardTicks) ? null : this.settings.wizardTicks;

        this.titleText = this.element.find('.title > h1');

        // Used to track levels deep
        this.levelsDeep = [];
        this.levelsDeep.push('' + this.titleText.text());

        return this;
      },

      build: function() {
        this.toolbarElem = this.element.find('.toolbar');

        // Build toolbar if it doesn't exist
        if (!this.toolbarElem.data('toolbar')) {
          var opts = $.fn.parseOptions(this.toolbarElem);
          this.toolbarElem.toolbar(opts);
        }
        this.toolbar = this.toolbarElem.data('toolbar');

        // Hamburger Icon is optional, but tracking it is necessary.
        this.titleButton = this.element.find('.title > .application-menu-trigger');
        this.hasTitleButton = this.titleButton.length > 0;

        if (this.hasTitleButton) {
          this.toolbarElem.addClass('has-title-button');
          var appMenu = $('#application-menu').data('applicationmenu');
          if (appMenu) {
            appMenu.modifyTriggers([this.titleButton], null, true);
          } else {
            $('#application-menu').applicationmenu({
              triggers: [this.titleButton]
            });
          }
        }

        // Application Tabs would be available from the Application Start, so activate them during build if they exist
        if (this.settings.tabs && this.settings.tabs.length) {
          this.buildTabs();
        }

        if (this.settings.wizardTicks && this.settings.wizardTicks.length) {
          this.buildWizard();
        }

        if (this.settings.usePopupmenu) {
          this.buildPopupmenu();
        }

        //Add a Scrolling Class to manipulate the header
        if (this.settings.addScrollClass) {
          var self =$(this.element),
            scrollDiv = $(this.element).next('.scrollable'),
            container = (scrollDiv.length === 1 ? scrollDiv : $(window)),
            scrollThreshold = this.settings.scrollThreshold ? this.settings.scrollThreshold : 15;

          container.on('scroll.header', function () {
            if (this.scrollTop > scrollThreshold) {
              self.addClass('is-scrolled-down');
            } else {
              self.removeClass('is-scrolled-down');
            }

          });

          if (container.scrollTop() > scrollThreshold ) {
            self.addClass('is-scrolled-down');
          }
        }

        return this;
      },

      buildTitleButton: function() {
        if (this.levelsDeep.length > 1 && !this.hasTitleButton && !this.titleButton.length) {
          this.titleButton = $('<button class="btn-icon back-button" type="button"></button>');
          this.titleButton.html('<span class="audible">'+ Locale.translate('Drillup') +'</span>' +
            '<span class="icon app-header go-back">' +
              '<span class="one"></span>' +
              '<span class="two"></span>' +
              '<span class="three"></span>' +
            '</span>');
          this.titleButton.prependTo(this.element.find('.title'));

          // Need to trigger an update on the toolbar control to make sure tabindexes and events are all firing on the button
          this.toolbar.element.triggerHandler('updated');
        }

        this.titleButton.find('.icon.app-header').addClass('go-back');
      },

      // Used for adding a Breadcrumb Element to the Header
      buildBreadcrumb: function() {
        var self = this,
          breadcrumbClass = 'has-breadcrumb';

        if (this.settings.useAlternate) {
          breadcrumbClass = 'has-alternate-breadcrumb';
        }
        this.element.addClass(breadcrumbClass);

        this.breadcrumb = this.element.find('.breadcrumb');
        if (!this.breadcrumb.length) {
          this.breadcrumb = $('<nav class="breadcrumb" role="navigation" style="display: none;"></nav>').appendTo(this.element);
          this.breadcrumb.on('click', 'a', function(e) {
            self.handleBreadcrumbClick(e);
          });
        }

        this.breadcrumb[this.settings.useAlternate ? 'addClass' : 'removeClass']('alternate');
        this.adjustBreadcrumb();
      },

      // Builds Breadcrumb markup that reflects the current state of the application
      adjustBreadcrumb: function() {
        var last = this.levelsDeep[this.levelsDeep.length - 1];
        this.breadcrumb.empty();

        var bcMarkup = $('<ol aria-label="breadcrumb"></ol>').appendTo(this.breadcrumb);
        $.each(this.levelsDeep, function(i, txt) {
          var current = '';
          if (last === txt) {
            current = ' current';
          }

          bcMarkup.append($('<li><a href="#" class="hyperlink'+ current +'">'+ txt +'</a></li>'));
        });
      },

      buildTabs: function() {
        this.tabsContainer = this.element.find('.tab-container');
        if (!this.tabsContainer.length) {
          this.tabsContainer = $('<div class="tab-container"></div>').appendTo(this.element);

          // TODO: Flesh this out so that the header control can build tabs based on options
          var tablist = $('<ul class="tab-list" role="tablist"></ul>').appendTo(this.tabsContainer);
          $('<li class="tab"><a href="#header-tabs-home" role="tab">SoHo Xi Controls | Patterns</a></li>').appendTo(tablist);
          $('<li class="tab"><a href="#header-tabs-level-1" role="tab">Level 1 Detail</a></li>').appendTo(tablist);
          $('<li class="tab"><a href="#header-tabs-level-2" role="tab">Level 2 Detail</a></li>').appendTo(tablist);
        }

        this.element.addClass(this.settings.useAlternate ? 'has-alternate-tabs' : 'has-tabs');
        this.tabsContainer[this.settings.useAlternate ? 'addClass' : 'removeClass']('alternate');

        // NOTE: For demo purposes the markup for tab panels is already inside the Nav Patterns Test page.
        $('#header-tabs-level-1').removeAttr('style');
        $('#header-tabs-level-2').removeAttr('style');

        // Invoke Tabs Control
        this.tabsContainer.tabs({
          containerElement: '#maincontent'
        });
      },

      buildWizard: function() {
        this.element.addClass('has-wizard');

        this.wizard = this.element.find('.wizard');
        if (!this.wizard.length) {
          this.wizard = $('<div class="wizard"></div>').appendTo(this.element);
          var header = $('<div class="wizard-header"></div>').appendTo(this.wizard),
            bar = $('<div class="bar"></div>').appendTo(header);
          $('<div class="completed-range"></div>').appendTo(bar);

          // TODO: Flesh this out so the header control can build the Wizard Ticks based on options
          $('<a href="#" class="tick current"><span class="label">Context Apps</span></a>').appendTo(bar);
          $('<a href="#" class="tick"><span class="label">Utility Apps</span></a>').appendTo(bar);
          $('<a href="#" class="tick"><span class="label">Inbound Configuration</span></a>').appendTo(bar);
          $('<a href="#" class="tick"><span class="label">OID Mapping</span></a>').appendTo(bar);
        }

        this.wizard[this.settings.useAlternate ? 'addClass' : 'removeClass']('alternate');

        // NOTE: For Demo Purposes, the shifting forms associated with the Wizard are coded
        // inside the Nav Patterns Test page.
        // TODO: Build shifting forms

        // Invoke the Wizard Control
        this.wizard.wizard();
      },

      buildPopupmenu: function() {
        var title = this.toolbarElem.children('.title');
        this.titlePopup = title.find('.btn-menu');
        if (!this.titlePopup.length) {
          var heading = title.find('h1'); // If H1 doesn't exist here, you're doing it wrong.
          heading.wrap('<button id="header-menu" type="button" class="btn-menu"></button>');
          this.titlePopup = heading.parent('.btn-menu');
        }
        this.titlePopupMenu = this.titlePopup.next('.popupmenu');
        if (!this.titlePopupMenu.length) {
          this.titlePopupMenu = $('<ul class="popupmenu is-selectable"></ul>').insertAfter(this.titlePopup);
          $('<li class="is-checked"><a href="#">Page One Title</a></li>' +
            '<li><a href="#">Page Two Title</a></li>' +
            '<li><a href="#">Page Three Title</a></li>' +
            '<li class="is-disabled"><a href="#">Page Four Title</a></li>' +
            '<li><a href="#">Page Five Title</a></li>').appendTo(this.titlePopupMenu);
        }
        this.titlePopupMenu.addClass('is-selectable');

        // Set the text on the Title
        this.titlePopup.children('h1').text(this.titlePopupMenu.children().first().text());

        // Invoke the Popupmenu on the Title
        this.titlePopup.button().popupmenu();

        // Update the Header toolbar to account for the new button
        this.toolbarElem.triggerHandler('updated');
      },

      handleEvents: function() {
        var self = this;

        this.element
          .on('updated.header', function() {
            self.updated();
          })
          .on('reset.header', function() {
            self.reset();
          })
          .on('drilldown.header', function(e, viewTitle) {
            self.drilldown(viewTitle);
          })
          .on('drillup.header', function(e, viewTitle) {
            self.drillup(viewTitle);
          });

        // Events for the title button.  e.preventDefault(); stops Application Menu functionality while drilled
        this.titleButton.bindFirst('click.header', function(e) {
          if (self.levelsDeep.length > 1) {
            e.stopImmediatePropagation();
            self.drillup();
            e.returnValue = false;
          }
        });

        // Popupmenu Events
        if (this.settings.usePopupmenu) {
          this.titlePopup.on('selected.header', function(e, anchor) {
            $(this).children('h1').text(anchor.text());
          });
        }

        return this;
      },

      handleBreadcrumbClick: function(e) {
        var selected = $(e.target).parent(),
          breadcrumbs = this.breadcrumb.find('li'),
          selectedIndex = breadcrumbs.index(selected),
          delta;

        if (selected.hasClass('current')) {
          return;
        }

        if (selectedIndex === 0) {
          return this.reset();
        }

        if (selectedIndex < breadcrumbs.length - 1) {
          delta = (breadcrumbs.length - 1) - selectedIndex;
          while (delta > 0) {
            this.drillup();
            delta = delta - 1;
          }
        }
      },

      initPageChanger: function () {
        this.element.find('.page-changer').on('selected.header', function (e, link) {
          // Change Theme
          if (link.attr('data-theme')) {
            var theme = link.attr('data-theme');
            $('body').trigger('changetheme', theme.replace('-theme',''));
            return;
          }

          // TODO: Change Lang
          if (link.attr('data-lang')) {
            Locale.set(link.attr('data-lang'));
            return;
          }

          // Change Color
          var color = link.attr('data-rgbcolor');
          $('body').trigger('changecolors', [color]);
        });
      },

      // Activates the Drilldown Header View
      drilldown: function(viewTitle) {
        this.element.addClass('is-drilldown');
        this.levelsDeep.push(viewTitle.toString());
        this.titleText.text(this.levelsDeep[this.levelsDeep.length - 1]);

        if (this.settings.useBackButton) {
          this.buildTitleButton();
        }

        if (this.settings.useBreadcrumb) {
          if (!this.breadcrumb || !this.breadcrumb.length) {
            this.buildBreadcrumb();
            this.breadcrumb.css({'display': 'block', 'height': 'auto'});
          } else {
            this.adjustBreadcrumb();
          }
        }
      },

      drillup: function(viewTitle) {
        var title;
        this.element.removeClass('is-drilldown');

        if (this.levelsDeep.length > 1) {
          this.levelsDeep.pop();
          title = this.levelsDeep[this.levelsDeep.length - 1];
        }

        if (viewTitle !== undefined) {
          title = viewTitle;
        }

        if (this.levelsDeep.length > 1) {
          if (this.settings.useBreadcrumb) {
            this.adjustBreadcrumb();
          }
          this.titleText.text(title);
          return;
        }

        // Completely reset all the way back to normal
        title = this.levelsDeep[0];

        if (this.settings.useBackButton) {
          this.removeButton();
        }
        if (this.settings.useBreadcrumb) {
          this.removeBreadcrumb();
        }
        if (this.settings.usePopupmenu) {
          this.removePopupmenu();
        }

        this.titleText.text(title);
        this.element.trigger('drillTop');
      },

      reset: function() {
        while (this.levelsDeep.length > 1) {
          this.levelsDeep.pop();
        }
        this.titleText.text(this.levelsDeep[0]);

        this.removeBreadcrumb();
        this.removeTabs();
        this.removeWizard();
        this.removePopupmenu();
        this.removeButton();

        this.element.trigger('afterreset');
        return this;
      },

      removeButton: function() {
        if (this.hasTitleButton) {
          this.titleButton.find('.icon.app-header').removeClass('go-back');
          return;
        }

        if (this.titleButton && this.titleButton.length) {
          this.titleButton.remove();
          this.titleButton = $();

          // Need to trigger an update on the toolbar control to make sure tabindexes and events are all firing on the button
          this.toolbar.element.triggerHandler('updated');
        }
      },

      removeBreadcrumb: function() {
        if (!this.breadcrumb || !this.breadcrumb.length) {
          return;
        }

        var self = this,
          transitionEnd = $.fn.transitionEndName(),
          timeout;

        function destroyBreadcrumb() {
          if (timeout) {
            clearTimeout(timeout);
            timeout = null;
          }

          self.element.off(transitionEnd + '.breadcrumb-header');
          self.breadcrumb.off().remove();
          self.breadcrumb = $();
        }

        self.element.removeClass('has-breadcrumb').removeClass('has-alternate-breadcrumb');
        if (this.breadcrumb.is(':not(:hidden)')) {
          this.element.one(transitionEnd + '.breadcrumb-header', destroyBreadcrumb);
          timeout = setTimeout(destroyBreadcrumb, 300);
        } else {
          destroyBreadcrumb();
        }
      },

      removeTabs: function() {
        if (!this.tabsContainer || !this.tabsContainer.length) {
          return;
        }

        var self = this,
          transitionEnd = $.fn.transitionEndName(),
          timeout;

        function destroyTabs() {
          if (timeout) {
            clearTimeout(timeout);
            timeout = null;
          }

          self.element.off(transitionEnd + '.tabs-header');
          self.tabsContainer.data('tabs').destroy();
          self.tabsContainer.remove();
          self.tabsContainer = null;

          // NOTE: For demo purposes the markup for tab panels is already inside the Nav Patterns Test page.
          $('#header-tabs-level-1').css('display', 'none');
          $('#header-tabs-level-2').css('display', 'none');
        }

        this.element.removeClass('has-tabs').removeClass('has-alternate-tabs');
        if (this.tabsContainer.is(':not(:hidden)')) {
          this.element.one(transitionEnd + '.tabs-header', destroyTabs);
          timeout = setTimeout(destroyTabs, 300);
        } else {
          destroyTabs();
        }
      },

      removeWizard: function() {
        if (!this.wizard || !this.wizard.length) {
          return;
        }

        var self = this,
          transitionEnd = $.fn.transitionEndName(),
          timeout;

        function destroyWizard() {
          if (timeout) {
            clearTimeout(timeout);
            timeout = null;
          }

          self.element.off(transitionEnd + '.wizard-header');
          self.wizard.data('wizard').destroy();
          self.wizard.remove();
          self.wizard = null;

        }

        this.element.removeClass('has-wizard');
        if (this.wizard.is(':not(:hidden)')) {
          this.element.one(transitionEnd + '.wizard-header', destroyWizard);
          timeout = setTimeout(destroyWizard, 300);
        } else {
          destroyWizard();
        }
      },

      removePopupmenu: function() {
        var self = this;

        if (!this.titlePopup || !this.titlePopup.length) {
          return;
        }

        this.titlePopup.data('popupmenu').destroy();
        this.titlePopup.data('button').destroy();
        this.titlePopupMenu.remove();
        this.titlePopup.children('h1').detach().insertBefore(self.titlePopup);
        this.titlePopup.remove();

        this.titlePopup = undefined;
        this.titlePopupMenu = undefined;

        this.toolbarElem.triggerHandler('updated');
      },

      // teardown events
      unbind: function() {
        this.titleButton.off('click.header');
        this.element.off('drilldown.header drillup.header');
        return this;
      },

      updated: function() {
        this
          .reset()
          .unbind()
          .init();
      },

      destroy: function() {
        this.unbind();
        if (this.hasTitleButton) {
          this.toolbarElem.removeClass('has-title-button');
        }

        $.removeData(this.element[0], pluginName);
      }
    };

    // Keep the Chaining while Initializing the Control (Only Once)
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (instance) {
        instance.settings = $.extend({}, instance.settings, options);
        instance.updated();
      } else {
        instance = $.data(this, pluginName, new Header(this, settings));
      }
    });
  };


 $.fn.hierarchy = function(options) {
    'use strict';

    // Settings and Options
    var pluginName = 'hierarchy',
        defaults = {
          legend: [],
          legendKey: '',
          dataset: [],
          newData: [],
          templateId: '',  //Id to the Html Template
          mobileView: false,
          mouseEnterTarget: '',
          rightClickTarget: '',
          leafHeight: null,
          leafWidth: null,
          beforeExpand: null  // A callback that fires before node expansion of a node.
        },
        settings = $.extend({}, defaults, options);

    var colorClass = [
      'azure08', 'turquoise02', 'amethyst06', 'slate06', 'amber06', 'emerald07', 'ruby06'
    ];

    var constants = {
      container       : 'container',
      chart           : 'content',
      toplevel        : 'top-level',
      sublevel        : 'sub-level',
      noSublevel      : 'no-sublevel',
      sublist         : 'sublist',
      button          : 'btn-expand',
      leaf            : 'leaf',
      inner           : 'inner',
      multiRoot       : 'multi-root',
      root            : 'root',
      back            : 'back',
      activeBranch    : 'active-branch',
      branchExpanded  : 'branch-expanded',
      branchCollapsed : 'branch-collapsed',
      collapsedLeaf   : 'collapsed-leaf',
      expanded        : 'expanded',
      collapsed       : 'collapsed',
      close           : 'close',
      open            : 'open',
      shadow          : 'shadow',
      line            : 'line',
      selected        : 'selected',
      show            : 'show',
      hide            : 'hidden'
    };

    /**
     * For Org Charts and Trees ect...
     * @constructor
     * @param {Object} element
     */
    function Hierarchy(element) {
      this.element = $(element);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    // Hierarchy Methods
    Hierarchy.prototype = {
      init: function() {

        var isMobile = $(this.element).parent().width() < 610; //Phablet down

        if (isMobile) {
          this.mobileView = true;
        } else {
          this.mobileView = false;
        }

        this.handleEvents();

        if (settings.dataset) {
          if (settings.dataset[0].children.length > 0) {
            var data = settings.dataset[0] === undefined ? settings.dataset : settings.dataset[0];

            data.isRootNode = true;
            data.isExpanded = true;
            this.render(data);
          } else {
            $(this.element).append('<p style=\'padding:10px;\'>No data available</p>');
          }
        }

        if (settings.leafHeight !== null && settings.leafWidth !== null) {

          var style = 'body .hierarchy .leaf,' +
                'body .hierarchy .sublevel .leaf,' +
                'body .hierarchy .container .root.leaf { width: ' + settings.leafWidth + 'px; ' + ' height: ' + settings.leafHeight + 'px; ' + ' }';

          $('<style type=\'text/css\' id=\'hierarchyLeafStyles\'>' + style + '</style>').appendTo('body');
        }
      },

      // Attach all event handlers
      handleEvents: function() {
        var self = this;

        // Expand or Collapse
        self.element.onTouchClick('hierarchy', '.' + constants.button).on('click.hierarchy', '.' + constants.button, function(event) {

          if (settings.newData.length > 0) {
            settings.newData = [];
          }

          var nodeId = $(this).closest('.' + constants.leaf).attr('id');
          var dataObject = self.data(nodeId, settings.dataset, settings.newData);
          var domObject = {
            branch: $(this).closest('li'),
            leaf: $(this).closest('.' + constants.leaf),
            button: $(this)
          };

          if (dataObject.isExpanded) {
            self.collapse(event, dataObject, domObject);
          } else {
            self.expand(event, dataObject, domObject);
          }

        });

        //TODO: Are we using this?
        self.element.onTouchClick('click', '.' + constants.back).on('click', '.' + constants.back, function() {
          var nodeId     = $(this).parent().find('.' + constants.leaf).attr('id');
          var nodeData   = self.data(nodeId, settings.dataset, settings.newData);
          var domObject  = {
            branch: $(this).closest('li'),
            leaf: $(this).closest('.' + constants.leaf),
            button: $(this)
          };

          self.collapse(event, nodeData, domObject);
        });

        self.element.on('keypress', '.' + constants.leaf, function(event) {
          var nodeId     = $(this).attr('id');
          var nodeData   = self.data(nodeId, settings.dataset, settings.newData);

          if (event.which === 13) {
            if (nodeData.isExpanded) {
              self.collapse(event, nodeData);
            } else {
              self.expand(event, nodeData);
            }
          }
        });

        // Select
        self.element.on('mousedown', '.' + constants.leaf, function(event) {
          var nodeData = $(this).data();
          var element = {target: event.target, pageX: event.pageX, pageY: event.pageY};

          $('.is-' + constants.selected).removeClass('is-'+constants.selected);
          $('#' + nodeData.id).addClass('is-'+constants.selected);

          $(this).trigger('selected', nodeData, element);
        });

        // Right Click
        var rightClickTarget = settings.rightClickTarget === '' ? '.' + constants.leaf : settings.rightClickTarget;
        self.element.on('mousedown', rightClickTarget, function(event) {
          var nodeData = $(this).data();
          var element = {target: event.target, pageX: event.pageX, pageY: event.pageY};
          if (event.which === 1) {
            $(this).trigger('click');
          }
          if (event.which === 3) {
            $(this).trigger('rightClick', [nodeData, element]);
          }
        });

        // Mouseenter
        var mouseEnterTarget = settings.mouseEnterTarget === '' ? '.' + constants.leaf : settings.mouseEnterTarget;
        self.element.on('mouseenter', mouseEnterTarget, function(event) {
          var nodeData = $(this).data();
          var element = {target: event.target, pageX: event.pageX, pageY: event.pageY};

          if (event.which !== 3) {
            $(this).trigger('mouseEnter', [nodeData, element]);
          }
        });

        // Double Click
        self.element.on('dblclick', '.' + constants.leaf, function(event) {
          var nodeData  = $(this).data();
          var element = {target: event.target, clientX: event.clientX, clientY: event.clientY};

          $(this).trigger('doubleClick', nodeData, element);
        });

      },

      // Process data attached through jquery data
      data: function(nodeId, currentDataObject, newDataObject, params) {

        if (params === undefined) {
          params = {};
        }

        var obj = currentDataObject.isRootNode ? currentDataObject : currentDataObject[0];
        var nodeData = [];

        if (settings.newData.length > 0) {
          settings.newData = [];
        }

        function processData(self, obj, newDataObject) {
          if (obj.length === undefined) {
            checkForChildren(self, obj, newDataObject);
          } else {
            for (var i = 0, l = obj.length; i < l; i++) {
              var o = obj[i];
              checkForChildren(self, o, newDataObject);
            }
          }
        }

        if (newDataObject !== undefined) {
          processData(this, obj, newDataObject);
        }

        function checkForChildren(self, obj, newDataObject) { //jshint ignore:line
          for (var prop in obj) {
            if (prop === 'id' && nodeId === obj.id) {
              if (!obj.isLoaded && !obj.isRootNode) {
                if (params.updateDisplay) {
                  obj.displayClass = constants.hide + ' ' + constants.collapsed;
                }
                else {
                  addChildrenToObject(obj, params);
                }
              }
              nodeData.push(obj);
            }
          }
          if (obj.children) {
            processData(self, obj.children, newDataObject);
          }
        }

        function addChildrenToObject(obj, params) { //jshint ignore:line
          if (params.insert) {
            delete obj.isLeaf;
            delete obj.displayClass;
            obj.displayClass = constants.expanded;
            obj.isExpanded = true;
          }
          if (newDataObject.length !== 0 && params.insert) {
            obj.children = [newDataObject];
          } else {
            obj.children = newDataObject;
          }
        }

        if (nodeData.length !== 0) {
          $('#' + nodeData[0].id).data(nodeData[0]);
        }

        return nodeData[0];
      },

      // Add data as children for the given nodeId.
      add: function (nodeId, currentDataObject, newDataObject) {
        var self            = this;
        var id              = currentDataObject.id !== undefined ? currentDataObject.id : nodeId;
        var node            = $('#' + id);
        var parentContainer = node.parent().hasClass('leaf-container') ? node.parent().parent() : node.parent();
        var selectorObject  = {};
        var isSubLevelChild = parentContainer.parent().attr('class') !== constants.sublevel;
        var subListExists   = parentContainer.children('.' + constants.sublist).length === 1;

        if (isSubLevelChild) {
          if (subListExists) {
            selectorObject.element = parentContainer.children('.' + constants.sublist);
          } else {
            selectorObject.el = parentContainer.append('<ul class=\'' + constants.sublist + '\'></ul>');
            selectorObject.element = $(selectorObject.el).find('.' + constants.sublist);
          }
        } else {
          selectorObject.el = parentContainer.children('ul');
          selectorObject.element = $(selectorObject.el);
        }

        if (!currentDataObject.isRootNode) {
          for(var i = 0, l = newDataObject.length; i < l; i++) {
            settings.newData.push(newDataObject[i]);
          }
          self.createLeaf(newDataObject, selectorObject.element);
        }
      },

      // Expand the nodes until nodeId is displayed on the page.
      expand: function(event, nodeData, domObject) {
        var self = this,
          node = domObject.leaf,
          nodeTopLevel  = node.next().not('.' + constants.line);

        nodeTopLevel.animateOpen();
        self.element.trigger(constants.expanded, [nodeData, settings.dataset]);

        if (node.hasClass('root')) {
          nodeTopLevel  = nodeTopLevel.next('ul');
          nodeTopLevel.animateOpen();
        }

        nodeData.isExpanded = true;
        self.setNodeData(nodeData);

        node.parent().removeClass(constants.branchCollapsed).addClass(constants.branchExpanded);
        self.setButtonState(node, nodeData);
      },

      // Collapse the passed in nodeId.
      collapse: function(event, nodeData, domObject) {
        var self = this,
          node = domObject.leaf,
          nodeTopLevel  = node.next().not('.' + constants.line);

        nodeTopLevel.animateClosed().on('animateclosedcomplete', function () {
          self.element.trigger(constants.collapsed, [nodeData, settings.dataset]);
        });

        if (node.hasClass('root')) {
          nodeTopLevel  = nodeTopLevel.next('ul');
          nodeTopLevel.animateClosed();
        }

        nodeData.isExpanded = false;
        self.setNodeData(nodeData);
        node.parent().removeClass(constants.branchExpanded).addClass(constants.branchCollapsed);
        self.setButtonState(node, nodeData);
      },

      //Main render method
      render: function (data) {
        var legend       = settings.legend;
        var children     = data.children;
        var hasTopLevel  = this.checkChildren(children, 'top-level');
        var hasSubLevel  = this.checkChildren(children, 'sub-level');
        var rootNodeHTML = [];
        var structure    = {
          legend    : '<legend><ul></ul></legend>',
          chart     : '<ul class=\'' + constants.container + '\'>'+ '<li class=\'' + constants.chart + '\'></li></ul>',
          toplevel  : '<ul class=\'' + constants.toplevel + '\'></ul>',
          sublevel  : '<ul class=\'' + constants.sublevel + '\'></ul>'
        };

        var chartContainer  = this.element.append(structure.chart);
        var chart = $('.' + constants.chart, chartContainer);

        if (legend.length !== 0) {
          this.element.prepend(structure.legend);
          var element = $('legend', chartContainer);
          this.createLegend(element);
        }

        // Create root node
        this.setColor(data);
        this.displayButton(data);

        if (data.isMultiRoot) {
          var multiRootHTML = '<div class=\'' + constants.leaf + ' ' + constants.multiRoot + '\'><div class=\'' +
            constants.inner + '\'><h2>' +
            data.multiRootText +'</h2></div></div>';

          rootNodeHTML.push(multiRootHTML);
          $(rootNodeHTML[0]).addClass(constants.root).appendTo(chart);

        } else {

          var leafTemplate = Tmpl.compile('{{#dataset}}' + $('#' + settings.templateId).html() + '{{/dataset}}');
          var leaf = leafTemplate.render({dataset: data});
          rootNodeHTML.push(leaf);

          $(rootNodeHTML[0]).addClass(constants.root).appendTo(chart);
          this.setNodeData(data);
        }

        if (!hasTopLevel) {
          $('<div class=\'' + constants.line + '\'></div>').insertAfter('.' + constants.root);
        }

        function renderSubChildren(self, subArray, data) {
          if (subArray !== null && subArray !== undefined) {
            for (var i = 0, l = subArray.length; i < l; i++) {
              var obj = subArray[i];
              subArrayChildren(self, obj, data);
            }
          }
        }

        // Create children nodes
        if (children.length > 0) {
          for (var i = 0, l = children.length; i < l; i++) {

            var childObject = data.children[i].children;

            if (this.isLeaf(children[i])) {
              this.createLeaf(data.children[i], $(structure.toplevel));
            }
            else {
              this.createLeaf(data.children[i], $(structure.sublevel));
            }

            if (childObject !== undefined && childObject !== null) {
              var subArray = data.children[i].children;
              var self = this;
              renderSubChildren(self, subArray, data);
            }
          }
        }

        function subArrayChildren(self, obj, data) { //jshint ignore:line
          for(var prop in obj) {
            if (prop === 'children') {
              var nodeId = obj.id;
              var currentDataObject = obj;
              var newDataObject = obj.children;

              if (newDataObject !== null && newDataObject !== undefined) {
                if (newDataObject.length > 0) {
                  self.add(nodeId, currentDataObject, newDataObject);
                }
              }

              return renderSubChildren(self, newDataObject, data);
            }
          }
        }

        if (!hasSubLevel) {
          $('.' + constants.topLevel).addClass(constants.noSublevel);
        }

        var containerWidth = this.element.find('.' + constants.container).outerWidth();
        var windowWidth = $(window).width();
        var center = (containerWidth - windowWidth) / 2;
        this.element.scrollLeft(center);

      },

      checkChildren : function(children, param) {
        var n = 0;
        var i = children.length;
        while(i--) {
          if (param === 'top-level') {
            if (children[i].isLeaf) {
              n += 1;
            }
          }
          if (param === 'subLevel') {
            if (children[i].children) {
              n += 1;
            }
          }
        }
        return n > 0;
      },

      // Add the legend from the Settings
      createLegend : function(element) {
        var mod      = 4;
        var index    = 0;

        for (var i = 0, l = settings.legend.length; i < l; i++) {
          var label  = settings.legend[i].label;
          var color  = colorClass[i];

          if (i - 1 % mod + 1 === mod) {
            element.append('<ul></ul>');
            index++;
          }

          element.children('ul').eq(index).append(
            '<li>' +
            '<span>' + label + '</span>' +
            '<span class=\'key ' + color + '\'></span>' +
            '</li>'
          );
        }
      },

      // Creates a leaf node under element for nodeData
      createLeaf: function(nodeData, container) {
        var self           = this;
        //console.log(nodeData.id);
        var chartClassName = self.element.attr('class');
        var chart          = $('.' + chartClassName + ' .' + constants.chart, self.container);
        var elClassName    = container.attr('class');
        var el             = elClassName !== undefined ? $('.' + elClassName) : container;

        if (el.length < 1) {
          if (elClassName === constants.toplevel) {
            container.insertAfter('.' + constants.root);
          } else {
            container.appendTo(chart);
          }
        }

        function processDataForleaf(nodeData, isLast) {
          self.setColor(nodeData);
          self.displayButton(nodeData);

          var leafTemplate = Tmpl.compile('{{#dataset}}' + $('#' + settings.templateId).html() + '{{/dataset}}');
          var leaf = leafTemplate.render({dataset: nodeData});
          var animateParam = nodeData.isExpanded || nodeData.isExpanded === undefined ? 'expand' : 'collapse';
          var parent       = el.length === 1 ? el : container;
          var lineHtml     = '';

          parent.children('li').children('.ln').removeClass('last-line');

          if (isLast) {
            lineHtml += '<span class=\'ln last-line\'></span>';
          } else {
            lineHtml += '<span class=\'ln\'></span>';
          }

          var lf = $(leaf);
          self.setButtonState(lf, nodeData);

          if (elClassName !== constants.sublevel && elClassName !== constants.toplevel) {
            $(lf).append('<span class=\'horizontal-line\'></span>');
          }

          var branchState = nodeData.isExpanded || nodeData.isExpanded === undefined ? constants.branchExpanded : constants.branchCollapsed;
          if (nodeData.isLeaf) {
            branchState = '';
          }

          parent.append('<li class=' + branchState + '>' + lineHtml + $(lf)[0].outerHTML + '</li>');

          self.setNodeData(nodeData);

          if (nodeData.children) {
            var childrenNodes = '';
            nodeData.isLoaded = true;

            if (nodeData.displayClass === constants.expanded || nodeData.isExpanded) {
              nodeData.isExpanded = true;
              $('#' + nodeData.id).data(nodeData);
            }
            else {
              nodeData.isExpanded = false;
            }

            for (var j = 0, l = nodeData.children.length; j < l; j++) {
              self.setColor(nodeData.children[j]);
              self.displayButton(nodeData.children[j]);

              var childleaf = leafTemplate.render({dataset: nodeData.children[j]});
              var c = $(childleaf);

              $(c).append('<span class=\'horizontal-line\'></span>');

              if (j === nodeData.children.length - 1) {
                childrenNodes += '<li><span class=\'ln last-line\'></span>' + $(c)[0].outerHTML + '</li>';
              }
              else {
                childrenNodes += '<li><span class=\'ln\'></span>' + $(c)[0].outerHTML + '</li>';
              }
            }

            parent = $('#' + nodeData.id).parent();
            parent.append('<ul>' + childrenNodes + '</ul>');

            var childLength = nodeData.children.length;
            while (childLength--) {
              self.setNodeData(nodeData.children[childLength]);
            }

            //TODO: Test case with data loading collapsed nodes
            if (!nodeData.isExpanded && !nodeData.isLeaf) {
              self.animateExpandCollapse($('#' + nodeData.id).parent(), animateParam);
            }
          }
        }

        if (nodeData.length) {
          for (var i = 0, l = nodeData.length; i < l; i++) {
            var isLast = i === nodeData.length -1;
            processDataForleaf(nodeData[i], isLast);
          }
        } else {
          processDataForleaf(nodeData, true);
        }

      },

      // Determine the color from settings
      setColor: function(data) {
        for (var i = 0, l = settings.legend.length; i < l; i++) {
          if (data[settings.legendKey] === settings.legend[i].value) {
            data.colorClass = colorClass[i];
            break;
          }
          else if (data[settings.legendKey] === '') {
            data.colorClass =  'default-color';
          }
        }

        if (data.children && !data.isRootNode) {
          for (var k = 0, ln = data.children.length; k < ln; k++) {
            for (var j = 0, x = settings.legend.length; j < x; j++) {
              if (data.children[k][settings.legendKey] === settings.legend[j].value) {
                data.children[k].colorClass = colorClass[j];
              }
            }
          }
        }
      },

      setNodeData: function(nodeData) {
        var leafObject   = $('#' + nodeData.id).data(nodeData);
        leafObject.data  = nodeData;
      },

      // Return whether or not a particular node is a leaf
      isLeaf: function(dataNode) {

        if (dataNode.children === undefined) {
          dataNode.isLeaf = true;
          return dataNode.isLeaf;
        }

        if (settings.beforeExpand) {
          return dataNode.isLeaf;
        }

        if (dataNode.children && dataNode.children.length > 0) {
          return false;
        }

        return true;
      },

      //set the classes and svg on the button
      setButtonState: function (leaf, data) {
        var btn = leaf.find('.'+ constants.button);

        if (data.isExpanded || data.isExpanded === undefined) {
          btn.find('svg.icon').changeIcon('caret-up');
        } else {
          btn.find('svg.icon').changeIcon('caret-up');
        }

        if (data.isExpanded === undefined) {
          btn.button();
        }
      },

      // Determine the state of the expand collapse button and show it
      displayButton: function(data) {

        if (data.isLeaf) {
          data.displayClass = constants.hide;
        } else {
          data.displayClass = constants.show;
        }

        if (data.isRootNode) {
          data.displayClass = constants.hide;
        }

        if (data.isExpanded) {
          data.displayClass += ' ' + constants.expanded;
        } else {
          data.displayClass += ' ' + constants.collapsed;
        }

        if (data.isExpanded === undefined) {
          if (!data.isLeaf && data.children && !data.isRootNode) {
            data.displayClass = constants.expanded;
          }
        }

      }
    };

    // Initialize the plugin (Once)
    return this.each(function() {
      var instance = $.data(this, pluginName);

      if (instance) {
        instance.settings = $.extend({}, defaults, options);
      } else {
        instance = $.data(this, pluginName, new Hierarchy(this, settings));
      }

    });
  };

/*
 * Text Highlight/Unhighlight Control
 * Originally called "highlight v5" by Johann Burkard
 * http://johannburkard.de/blog/programming/javascript/highlight-javascript-text-higlighting-jquery-plugin.html
 *
 * Modified for SoHo Xi (TODO: bit.ly link to docs)
**/


  $.fn.highlight = function(pat) {

    function innerHighlight(node, pat) {
      var skip = 0,
        pos, spannode, middlebit, middleclone, endbit;

      if (node.nodeType === 3) {
        pos = node.data.toUpperCase().indexOf(pat);
        pos -= (node.data.substr(0, pos).toUpperCase().length - node.data.substr(0, pos).length);

        if (pos >= 0) {
          spannode = document.createElement('mark');
          spannode.className = 'highlight';
          middlebit = node.splitText(pos);
          endbit = middlebit.splitText(pat.length);
          middleclone = middlebit.cloneNode(true);
          spannode.appendChild(middleclone);
          middlebit.parentNode.replaceChild(spannode, middlebit);
          skip = 1;
        }

      } else if (node.nodeType === 1 && node.childNodes && !/(script|style)/i.test(node.tagName)) {
        for (var i = 0; i < node.childNodes.length; ++i) {
          i += innerHighlight(node.childNodes[i], pat);
        }
      }

      return skip;
    }

    return this.length && pat && pat.length ? this.each(function() {
      innerHighlight(this, pat.toUpperCase());
    }) : this;
  };

  $.fn.unhighlight = function() {
    return this.find('mark.highlight').each(function() {
      var node = this.parentNode;
      node.replaceChild(this.firstChild, this);
      node.normalize();
    }).end();
  };


  $.fn.homepage = function(options) {

    // Settings and Options
    var pluginName = 'homepage',

        defaults = {
          gutterSize: 20,
          widgetWidth: 360,
          widgetHeight: 370,
          animate: true,
          timeout: 100,
          columns: 3,
          easing: 'blockslide'
        },
        settings = $.extend({}, defaults, options);


    /**
     * @constructor
     * @param {Object} element
     */
    function Homepage(element) {
      this.element = $(element);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    // Plugin Methods
    Homepage.prototype = {

      init: function() {
        this.settings = settings;
        this.isTransitionsSupports = this.supportsTransitions();
        this.initHeroWidget();
        this.attachEvents();

        //Initial Sizing
        this.resize(this, false);
      },

      initColumns: function(row) {
        row = row || 0;
        this.rowsAndCols[row] = [];

        for (var i = 0, l = this.settings.columns; i < l; i++) {
          this.rowsAndCols[row][i] = true;// Make all columns available in first row[true]
        }
      },

      initHeroWidget: function() {
        var heroWidget = $('.hero-widget');
        if (heroWidget.length > 1) {
          heroWidget = heroWidget.not(':first').remove();
        }
        this.heroWidget = heroWidget;
      },

      initRowsAndCols: function() {
        this.rowsAndCols = [];// Keeping all blocks as rows and columns
        this.initColumns();
      },

      // Return [x and y] where we can fit this block
      getAvailability: function(block) {
        var i, j, n, l, cols, innerCheck,
          self = this,
          rows = self.rowsAndCols.length,
          smallest = {},
          abort = false;

        // Loop thru each row and column soon it found first available spot
        // Then check for if block's width can fit in(yes), asign to [smallest] and break both loops
        for (i = 0, l = rows; i < l && !abort; i++) {
          for (j = 0, innerCheck = true, cols = self.rowsAndCols[i].length; j < cols && !abort; j++) {
            if ((self.rowsAndCols[i][j]) && ((block.w + j) <= cols)) {
              if ((block.w > 1) && (cols > (j+1))) {
                for (n = 0; n < block.w; n++) {
                  if (!self.rowsAndCols[i][j + n]) {
                    innerCheck = false;
                    break;
                  }
                }
              }
              if ((block.h > 1) && (rows > (i+1))) {
                for (n = 0; n < block.h; n++) {
                  if (!self.rowsAndCols[i + n][j]) {
                    innerCheck = false;
                    break;
                  }
                }
              }
              if (innerCheck) {
                smallest.row = i;
                smallest.col = j;
                abort = true;
              }
            }
          }
        }

        // If did not found any available spot from previous loops
        // Add new row and asign to [smallest] first column in this new row
        if (!Object.getOwnPropertyNames(smallest).length) {
          self.initColumns(rows);
          smallest.row = rows;
          smallest.col = 0;
        }

        return smallest; //{x:0, y:0}
      },

      // Make all spots as unavailable, depends on block's width and height
      // Soon we used this block
      fitBlock: function(r, c, block) {
        var i, j, l, l2,
          self = this,
          addRow = true;

        block.x = c;
        block.y = r;

        if ((block.w === 1) && (block.h === 1)) { // Single block can fit anywhere
          self.rowsAndCols[r][c] = false;
        } else {
          // If more then one row or column then loop thru to block's width and height
          // If height is more then current rows then add new row
          // Mark those spots as unavailable[false]
          if(block.w !== 1) {
            // Left to right
            for (i = r, l = block.h + r; i < l; i++) {
              for (j = c, l2 = block.w + c; j < l2; j++) {
                if (!self.rowsAndCols[i]) {
                  self.initColumns(i);
                }
                self.rowsAndCols[i][j] = false;
              }
            }
          } else {
            // Top to bottom
            for (i = r, l = block.h + r; i < l; i++) {
              for (j = c, l2 = block.h + c; j < l2; j++) {
                if (!self.rowsAndCols[i]) {
                  self.initColumns(i);
                }
                self.rowsAndCols[i][c] = false;
              }
            }
          }
        }

        // Check if reach to end of columns then assign flag[addRow]
        for (i = 0, l = self.rowsAndCols[r].length; i < l; i++) {
          if(self.rowsAndCols[r][i]) {
            addRow = false;
          }
        }

        // If reach to end of columns and next row is not avaiable then add new row
        // Make all columns available, if not assigned earlier as unavailable
        if (addRow) {
          if (!self.rowsAndCols[r +1]) {
            self.initColumns(r +1);
          }
        }
      },

      // Setup each block sizes, based on classes provided from markup
      setBlocks: function() {
        var self = this;
        self.blocks = [];

        self.element.find('.card, .widget').each(function () {
          var card = $(this),
            h = card.hasClass('double-height') ? 2 : 1,
            w = card.hasClass('quad-width') ? 4 : card.hasClass('triple-width') ? 3 : card.hasClass('double-width') ? 2 : 1;

          self.blocks.push({w: w, h: h, elem: card, text: card.text()});
        });

        // Max sized columns brings to top
        for (var i=0, j=0, w=0, l=self.blocks.length; i<l; i++) {
          if (self.settings.columns > 1) {
            if (self.blocks[i].w >= self.settings.columns && i) {
              self.arrayIndexMove(self.blocks, i, j);
            }
            w += self.blocks[i].w;
            if(w >= self.settings.columns) {
              w = 0; //reset
              j = (self.blocks[j].w >= self.settings.columns) ? j+1 : i; //record to move
            }
          }
        }
      },

      //Move an array element position
      arrayIndexMove: function(arr, from, to) {
        arr.splice(to, 0, arr.splice(from, 1)[0]);
      },

      attachEvents: function () {
        var self = this;

        $('body').on('resize.homepage', function() {
          self.resize(self, self.settings.animate);
        });

        $('.application-menu').on('applicationmenuopen.homepage applicationmenuclose.homepage', function () {
          self.resize(self, self.settings.animate);
        });
      },

      // Resize Method
      resize: function(self, animate) {
        //Sizes of "breakpoints" is  320, 660, 1000 , 1340 (for 320)
        //or 360, 740, 1120, 1500 or (for 360)
        var bpXL    = (self.settings.widgetWidth * 4) + (self.settings.gutterSize * 3),
          bpDesktop = (self.settings.widgetWidth * 3) + (self.settings.gutterSize * 2),
          bpTablet  = (self.settings.widgetWidth * 2) + self.settings.gutterSize,
          bpPhone   = self.settings.widgetWidth;

        var bp = bpXL, //1340,
          elemWidth = self.element.outerWidth(); //Math min against window.screen.width for single line mobile support

        // elemWidth -= 30; //extra break space

        // Find the Breakpoints
        var xl    = (elemWidth >= bpXL),
          desktop = (elemWidth >= bpDesktop && elemWidth <= bpXL),
          tablet  = (elemWidth >= bpTablet && elemWidth <= bpDesktop),
          phone   = (elemWidth <= bpTablet);

        var maxAttr = this.element.attr('data-columns'),
          content = self.element.find('> .content');
        this.settings.columns = parseInt((maxAttr || this.settings.columns));

        // Assign columns as breakpoint sizes
        if (xl && self.settings.columns === 4) {
          self.settings.columns = 4;
          bp = bpXL;
        }
        if ((desktop) || (xl && self.settings.columns === 3)) {
          self.settings.columns = 3;
          bp = bpDesktop;
        }
        if (tablet) {
          self.settings.columns = 2;
          bp = bpTablet;
        }
        if (phone) {
          self.settings.columns = 1;
          bp = bpPhone;
        }

        if (content.length) {
          content[0].style.marginLeft = '-' + (bp/2) + 'px';
        }

        this.setBlocks(); //setup blocks
        this.initRowsAndCols(); //setup colums

        // Loop thru each block, make fit where available and
        // If block more wider than available size, make as  available size
        // Assign new left and top css positions
        for (var i = 0, l = self.blocks.length; i < l; i++) {
          var left, top, pos, available,
            block = self.blocks[i];

          // Remove extra classes if assigned earlier
          block.elem.removeClass('to-single to-double to-triple');

          // If block more wider than available size, make as available size
          if (block.w > self.settings.columns) {
            block.w = self.settings.columns;

            if (self.settings.columns === 1) {
              block.elem.addClass('to-single');
            }
            else if (self.settings.columns === 2) {
              block.elem.addClass('to-double');
            }
            else if (self.settings.columns === 3) {
              block.elem.addClass('to-triple');
            }
          }

          // Get Availability
          available = self.getAvailability(block);

          // Set positions
          var box = self.settings.widgetWidth + self.settings.gutterSize,
            totalWidth = box * self.settings.columns;

          left = Locale.isRTL() ? totalWidth - ((box * block.w) + (box * available.col)) : box * available.col;
          top = (self.settings.widgetHeight + self.settings.gutterSize) * available.row;
          pos = {left: left, top: top};

          if (animate) {
            var easing = self.settings.easing,
              blockslide = [0.09, 0.11, 0.24, 0.91];

            if (easing === 'blockslide') {
              if (self.isTransitionsSupports) {
                self.applyCubicBezier(block.elem, blockslide);
                block.elem[0].style.left = pos.left + 'px';
                block.elem[0].style.top = pos.top + 'px';
              }
              // IE-9
              else {
                block.elem.animate(pos, self.settings.timeout);
              }
            }

            // Other easing effects ie (linear, swing)
            else {
              block.elem.animate(pos, self.settings.timeout, easing);
            }
          }
          else {
            block.elem[0].style.left = pos.left + 'px';
            block.elem[0].style.top = pos.top + 'px';
          }

          // Mark all spots as unavailable for this block, as we just used this one
          self.fitBlock(available.row, available.col, block);
        }
        self.element.triggerHandler('resize', self.settings.columns);
      },

      applyCubicBezier: function (el, cubicBezier) {
        el[0].style['-webkit-transition'] = 'all .3s cubic-bezier('+ cubicBezier +')';
        el[0].style['-moz-transition'] = 'all .3s cubic-bezier('+ cubicBezier +')';
        el[0].style['-ms-transition'] = 'all .3s cubic-bezier('+ cubicBezier +')';
        el[0].style['-o-transition'] = 'all .3s cubic-bezier('+ cubicBezier +')';
        el[0].style.transition = 'all .3s cubic-bezier('+ cubicBezier +')';
      },

      supportsTransitions: function () {
        var s = document.createElement('p').style,
          p = 'transition';

        if (typeof s[p] === 'string') {
          return true;
        }

        // Tests for vendor specific prop
        var v = ['Moz', 'webkit', 'Webkit', 'Khtml', 'O', 'ms'];
        p = p.charAt(0).toUpperCase() + p.substr(1);

        for (var i = 0, l = v.length; i < l; i++) {
          if (typeof s[v[i] + p] === 'string') {
            return true;
          }
        }
        return false;
      },

      detachEvents: function () {
        $('body').off('resize.homepage');
        $('.application-menu').off('applicationmenuopen.homepage applicationmenuclose.homepage');
      },

      // Teardown - Remove added markup and events
      destroy: function() {
        this.detachEvents();
        $.removeData(this.element[0], pluginName);
      }
    };

    // Initialize the plugin (Once)
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (instance) {
        instance.settings = $.extend({}, defaults, options);
      } else {
        instance = $.data(this, pluginName, new Homepage(this, settings));
      }
    });
  };


  //NOTE: Just this part will show up in SoHo Xi Builds.

  $.fn.icon = function(options) {
    'use strict';

    // Settings and Options
    var pluginName = 'icon',
        defaults = {
          use: 'user-profile', // Match this to one of the SoHo Xi icons, prefixed with an ID of '#icon-'
          focusable: false
        },
        settings = $.extend({}, defaults, options);

    /**
     * Icon Control
     * Wraps SVG Icons with a Javascript control that can change the icon type, reference
     * relative or absolute URLs, and clean up after itself.  Works with the Base tag.
     * @constructor
     * @param {Object} element
     */
    function Icon(element, settings) {
      this.settings = $.extend({}, settings);
      this.element = $(element);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    // Plugin Methods
    Icon.prototype = {
      init: function() {
        this.getExistingUseTag();

        //Do other init (change/normalize settings, load externals, etc)
        return this
          .render()
          .handleEvents();
      },

      // Add markup to the control
      render: function() {
        var self = this;
        this.element.addClass('icon');

        if (!this.element.is('svg')) {
          // TODO: Possibly work with span-based icons here?
          return this;
        }

        // Get a "base-tag-proof" version of the Use tag's definition.
        // jQuery can't work with SVG elements, so we just modify it with regular DOM APIs
        var use = this.element[0].getElementsByTagName('use')[0];
        if (!use) {
          return this;
        }

        if (use.getAttribute('xlink:href') !== self.getBasedUseTag()) {
          setTimeout(function () {
            use.setAttribute('xlink:href', self.getBasedUseTag());
          }, 0);
        }

        return this;
      },

      getBasedUseTag: function() {
        return $.getBaseURL('#icon-' + this.settings.use);
      },

      // In the event that a <use> tag exists on an icon, we want to retain it
      // and replace the settings.
      getExistingUseTag: function() {
        if (!this.element.is('svg')) {
          return;
        }

        var useTag = this.element.children('use');
        if (!useTag.length) {
          return this;
        }

        var xlinkHref = useTag.attr('xlink:href');
        this.settings.use = xlinkHref.replace('#icon-', '');

        return this;
      },

      // Sets up event handlers for this control and its sub-elements
      handleEvents: function() {
        var self = this;

        this.element.on('updated.' + pluginName, function() {
          self.updated();
        });

        return this;
      },

      //Handle Updating Settings
      updated: function() {
        return this
          .teardown()
          .init();
      },

      // Simple Teardown - remove events & rebuildable markup.
      teardown: function() {
        this.element.off('updated.' + pluginName);
        return this;
      },

      // Teardown - Remove added markup and events
      destroy: function() {
        this.teardown();
        $.removeData(this.element[0], pluginName);
      }
    };

    // Initialize the plugin (Once)
    return this.each(function() {
        var instance = $.data(this, pluginName);
      if (!instance) {
        instance = $.data(this, pluginName, new Icon(this, settings));
      }
    });
  };

  // Factory Function for instantly building icons.
  // Use this for building icons that don't exist yet.
  // Scoped Privately on purpose...
  (function (){
    'use strict';

    function normalizeIconOptions(options) {
      var defaults = {
        icon: 'user-profile', // omit the "icon-" if you want; this code strips it out.
        classes: ['icon']
      };
      options = options || $.extend({}, defaults);

      if (typeof options === 'string') {
        options = $.extend({}, defaults, {
          icon: options.replace('icon-', '')
        });
      }

      // reroute "options.class" if that exists
      if (!options.classes && options.class) {
        options.classes = options.class;
        delete options.class;
      }

      if (!options.classes) {
        options.classes = [].concat(defaults.classes);
      }

      if (typeof options.classes === 'string') {
        options.classes = options.classes.split(' ');
      }

      if (options.classes.indexOf('icon') === -1) {
        options.classes.push('icon');
      }

      return options;
    }

    // Returns the RAW HTML for creating a new icon in string form
    $.createIcon = function createIcon(options) {
      options = normalizeIconOptions(options);

      return [
        '<svg class="' + options.classes.join(' ') + '" focusable="false" aria-hidden="true" role="presentation">' +
          '<use xlink:href="#icon-' + options.icon + '"></use>' +
        '</svg>'
      ].join('');
    };

    // Returns a jQuery-wrapped element containing a new icon
    $.createIconElement = function createIconElement(options) {
      return $($.createIcon(options));
    };

    // Returns just the path part
    $.createIconPath = function createIconElement(options) {
      options = normalizeIconOptions(options);
      return $.getBaseURL('#icon-' + options.icon.replace('icon-',''));
    };

    //Toggle the use or entire svg icon in the case of the polyfill
    $.fn.changeIcon = function(icon) {
      $(this).find('use').attr('xlink:href', $.createIconPath({icon: icon}));
    };

    $.fn.getIconName = function() {
      var svg = $(this),
          use = svg.find('use');

      if (use.length === 1) {
        return use.attr('xlink:href').substr(use.attr('xlink:href').indexOf('#icon-')+6);
      } else {
        return svg.attr('data-icon');
      }

    };

  })();


  $.fn.lookup = function(options) {
    'use strict';

    // Settings and Options
    var pluginName = 'lookup',
        defaults = {
          click: null,
          field: 'id',  //Field to return from the array or can be a function
          title: null, //Dialog title or takes the label + Lookup
          buttons: [], //Pass dialog buttons or Cancel / Apply
          options: null,  //Options to pass to the data grid
          beforeShow: null, //Call back before the lookup is opened.
          modalContent: null, //Custom modal markup
          editable: true, //Can the user type random text in the field
          typeahead: false, // Future TODO
          autoApply: true,
          validator: null //A function that fires to let you validate form items on open and select
        },
        settings = $.extend({}, defaults, options);

    /**
     * @constructor
     * @param {Object} element
     */
    function Lookup(element) {
      this.element = $(element);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    var lookupGridId = 'lookup-datagrid';

    // Plugin Methods
    Lookup.prototype = {

      init: function() {
        this.settings = settings;
        this.inlineLabel = this.element.closest('label');
        this.inlineLabelText = this.inlineLabel.find('.label-text');
        this.isInlineLabel = !!this.inlineLabelText.length;
        this.build();
        this.handleEvents();
        this.grid = null;
        this.selectedRows = null;
      },

      // Build the Ui lookup
      build: function() {
         var lookup = this.element;

        var cssClass = this.element.is('.input-xs') ? 'lookup-wrapper xs' :
            this.element.is('.input-sm') ? 'lookup-wrapper sm' :
            this.element.is('.input-lg') ? 'lookup-wrapper lg' : 'lookup-wrapper';

        if (this.element.is('.has-actions')) {
         cssClass += ' has-actions-wrapper';
        }

        //Add Button
        this.icon = $('<span class="trigger" tabindex="-1"></span>').append($.createIcon('search-list'));
        if (this.isInlineLabel) {
          this.inlineLabel.addClass(cssClass);
        }
        else {
          this.container = $('<span class="'+ cssClass +'"></span>');
          lookup.wrap(this.container);
        }

        // this.container = $('<span class="lookup-wrapper"></span>');
        // lookup.wrap(this.container);
        lookup.after(this.icon);

        //Add Masking to show the #
        if (lookup.attr('data-mask')) {
          lookup.mask();
        }

        if (this.element.is(':disabled')) {
          this.disable();
        }

        if (!this.settings.editable) {
          this.element.attr('readonly', 'true').addClass('is-not-editable');
        }
        this.addAria();
      },

      // Add/Update Aria
      addAria: function () {
        var self = this;

        setTimeout(function () {
          self.label = self.isInlineLabel ? self.inlineLabelText : $('label[for="'+ self.element.attr('id') + '"]');

          if (self.label) {
            self.label.append('<span class="audible">' + Locale.translate('UseEnter') + '</span>');
          }
        }, 500);
      },

      //Handle events on the field
      handleEvents: function () {
        var self = this;

        this.icon.on('click.lookup', function (e) {
          self.openDialog(e);
        });

        //Down Arrow opens the dialog in this field
        this.element.on('keyup.lookup', function (e) {
          //If autocomplete open dont open list
          if ($('#autocomplete-list').length > 0) {
            return;
          }

          if (e.which === 40) {
            self.openDialog(e);
          }
        });

      },

      //Create and Open the Dialog
      openDialog: function (e) {
        var self = this,
          canOpen = self.element.triggerHandler('beforeopen');

        if (canOpen === false) {
          return;
        }

        if (self.isDisabled() || (self.isReadonly() && !self.element.hasClass('is-not-editable'))) {
          return;
        }

        if (self.settings.click) {
          self.settings.click(e, this);
          return;
        }

        if (this.settings.beforeShow) {
         var response = function (grid) {
            if (grid) {
              self.createGrid(grid);
            }
            self.createModal();
            self.element.triggerHandler('complete'); // for Busy Indicator
            self.element.trigger('open', [self.modal, self.grid]);

            if (self.settings.validator) {
              self.settings.validator(self.element, self.modal, self.grid);
            }
            return;
          };

          this.element.triggerHandler('start'); // for Busy Indicator
          this.settings.beforeShow(this, response);
          return;
        }

        if (!this.settings.options) {
          return;
        }

        self.createModal();
        self.element.trigger('open', [self.modal, self.grid]);

        self.modal.element.find('.btn-actions').removeClass('is-selected');

        // Fix: IE-11 more button was not showing
        var thisMoreBtn = self.modal.element.find('.toolbar .more > .btn-actions');
        if (thisMoreBtn.length) {
          setTimeout(function() {
            window.Soho.utils.fixSVGIcons(thisMoreBtn);
          }, 600);
        }

        self.element.trigger('afteropen', [self.modal, self.grid]);

        if (self.settings.validator) {
          self.settings.validator(self.element, self.modal, self.grid);
        }

      },

      //Overidable function to create the modal dialog
      createModal: function () {
        var self = this,
          content = '<div id="'+lookupGridId+'"></div>',
          thisLabel = $('label[for="'+self.element.attr('id')+'"]'),
          labelText = self.isInlineLabel ? self.inlineLabelText : (thisLabel.length ? thisLabel.clone().find('span').remove().end().text() : '');

        if (this.settings.title) {
          labelText = this.settings.title;
        }

        var settingContent = this.settings.modalContent;
        if (settingContent && settingContent instanceof jQuery) {
          content = settingContent;
          settingContent.show();
        }

        if (settingContent && !(settingContent instanceof jQuery)) {
          content = settingContent;
        }

        var buttons = this.settings.buttons;
        if (this.settings.options && this.settings.options.selectable === 'multiple' && buttons.length === 0 || (!self.settings.autoApply && buttons.length === 0)) {
          buttons = [{
            text: Locale.translate('Cancel'),
            click: function(e, modal) {
              self.element.focus();
              modal.close();
            }
          }, {
            text: Locale.translate('Apply'),
            click: function(e, modal) {
              var selectedRows = self.grid.selectedRows();
              modal.close();
              self.insertRows(selectedRows);
            },
            isDefault: true
          }];
        }

        if (this.settings.options && this.settings.options.selectable === 'single' && buttons.length === 0 && self.settings.autoApply) {
          buttons = [{
            text: Locale.translate('Cancel'),
            click: function(e, modal) {
              self.element.focus();
              modal.close();
            }
          }];
        }

        var hasKeywordSearch = this.settings.options && this.settings.options.toolbar && this.settings.options.toolbar.keywordFilter;

        $('body').modal({
          title: labelText,
          content: content,
          buttons: buttons,
          cssClass: 'lookup-modal' + (!hasKeywordSearch ? ' lookup-no-search' : '')
        }).off('open').on('open', function () {
          self.createGrid();
        }).off('close').on('close', function () {
          self.element.focus();
        });

        self.modal = $('body').data('modal');
        if (!this.settings.title) {
          self.modal.element.find('.modal-title').append(' <span class="datagrid-result-count"></span>');
        }

        // Wait until search field available
        setTimeout(function () {
          $('.modal.is-visible .searchfield').on('keypress.lookup', function (e) {
            if (e.keyCode === 13) {
              return false; // Prevent for closing modal
            }
          });
        }, 300);
      },

      //Overridable Function in which we create the grid on the current ui dialog.
      createGrid: function (grid) {
        var self = this, lookupGrid;

        if (grid) {
          lookupGrid = grid;
          lookupGridId = grid.attr('id');
          self.settings.options = grid.data('datagrid').settings;
        } else {
          lookupGrid = self.modal.element.find('#' + lookupGridId);
        }

        if (self.settings.options) {

          if (self.settings.options.selectable === 'single' && self.settings.autoApply) {
            self.settings.options.cellNavigation = false;
            lookupGrid.find('tr').addClass('is-clickable');
          }

          self.settings.options.isList = true;

          // Create grid (unless already exists from passed in grid)
          if (!lookupGrid.data('datagrid')) {
            lookupGrid.datagrid(self.settings.options);
          }
        }

        self.grid = lookupGrid.data('datagrid');
        if (!this.settings.title && self.modal) {
          self.modal.element.find('.title').remove();
        }

        var hasKeywordSearch = this.settings.options && this.settings.options.toolbar && this.settings.options.toolbar.keywordFilter;
        if (!hasKeywordSearch && self.modal) {
          self.modal.element.find('.toolbar').appendTo(self.modal.element.find('.modal-header'));
        }

        //Mark selected rows
        lookupGrid.off('selected.lookup');
        var val = self.element.val();
        if (val) {
          self.selectGridRows(val);
        }

        if (this.settings.options) {
          lookupGrid.on('selected.lookup', function (e, selectedRows) {

            // Only proceed if a row is selected
            if (!selectedRows || selectedRows.length === 0) {
              return;
            }

            if (self.settings.validator) {
              self.settings.validator(self.element, self.modal, self.grid);
            }

            if (self.settings.options.selectable === 'single' && self.settings.autoApply) {
              setTimeout(function () {
                self.modal.close();
                self.insertRows();
              }, 100);
            }
          });
        }

      },

      //Given a field value, select the row
      selectGridRows: function (val) {
        var self = this,
          selectedId = val;

        if (!val) {
          return;
        }

        //Multi Select
        if (selectedId.indexOf(',') > 1) {
          var selectedIds = selectedId.split(',');

          for (var i = 0; i < selectedIds.length; i++) {
            self.selectRowByValue(self.settings.field, selectedIds[i]);
          }
          return;
        }

        self.selectRowByValue(self.settings.field, selectedId);
      },

      //Find the row and select it based on select value / function / field value
      selectRowByValue: function(field, value) {
        if (!this.settings.options) {
          return;
        }

        var self = this,
          data = this.settings.options.dataset,
          selectedRows = [];

        for (var i = 0; i < data.length; i++) {
          if (typeof self.settings.match === 'function') {
            if (self.settings.match(value, data[i], self.element, self.grid)) {
              selectedRows.push(i);
            }

            continue;
          }

          if (data[i][field] == value) {  // jshint ignore:line
            selectedRows.push(i);
          }
        }

        if (this.grid) {
          this.grid.selectedRows(selectedRows);
        }
      },

      //Get the selected rows and return them to the UI
      insertRows: function () {
        var self = this,
          value = '';

        self.selectedRows = self.grid.selectedRows();

        for (var i = 0; i < self.selectedRows.length; i++) {
          var currValue = '';

          if (typeof self.settings.field === 'function') {
            currValue = self.settings.field(self.selectedRows[i].data, self.element, self.grid);
          } else {
            currValue = self.selectedRows[i].data[self.settings.field];
          }

          value += (i !== 0 ? ',' : '') + currValue;
        }

        self.element.val(value).trigger('change', [self.selectedRows]);
        self.element.focus();
      },

      //Enable the field
      enable: function() {
        this.element.prop('disabled', false).prop('readonly', false);
        this.element.parent().removeClass('is-disabled');
      },

      //Disable the field
      disable: function() {
        this.element.prop('disabled', true);
        this.element.parent().addClass('is-disabled');
      },

      //Make the field readonly
      readonly: function() {
        this.element.prop('readonly', true);
      },

      //Check if the field is disabled
      isDisabled: function() {
        return this.element.prop('disabled');
      },

      //Check if the field is readonly
      isReadonly: function() {
        return this.element.prop('readonly');
      },

      // Remove added markup and events
      destroy: function() {
        $.removeData(this.element[0], pluginName);
        this.element.off('click.dropdown keypress.dropdown');

        this.icon.remove();
        this.element.unwrap();

        if (this.label && this.label != null) {
          this.label.find('.audible').remove();
        }
      }
    };

    // Initialize the plugin once
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (instance) {
        instance.settings = $.extend({}, defaults, options);
      } else {
        instance = $.data(this, pluginName, new Lookup(this, settings));
      }
    });
  };

 // Lifecycle Methods for jQuery Controls
 // Recursive methods that "globally" call certain methods on large groups of controls


  var EXCLUDED_FROM_CLOSE_CHILDREN = ['.expandable-area', '.accordion'],
      EXCLUDED_FROM_HANDLE_RESIZE = [];

  // Used by several of these plugins to detect whether or not the "data" property in question
  // is a valid SoHo Xi Control.
  function canAccessAPI(prop) {
    return prop && !(prop instanceof jQuery);
  }

  // Used by several of these plugins to detect whether or not there is a method on a "data" api
  // that can be called.
  function canCall(prop, method) {
    var api = canAccessAPI(prop);
    if (!api) {
      return false;
    }

    return (prop[method] && typeof prop[method] === 'function');
  }

  // Actually triggers the method on the control if it's possible
  function triggerAPIMethod(prop, method) {
    if (canCall(prop, method)) {
      prop[method]();
      return true;
    }
    return false;
  }

  // Tracks each element that attempts to trigger an API method.
  // If a trigger is successful, it stores it in an array that's used later.
  function findControlsOnElements(elems, method) {
    var foundControls = [];

    $.each(elems, function elementIterator(index, elem) {
      $.each($(elem).data(), function dataEntryIterator(index, dataEntry) {
        if (triggerAPIMethod(dataEntry, method)) {
          foundControls.push({ elem: $(elem), control: dataEntry });
        }
      });
    });

    return foundControls;
  }

  // Kicks it all off
  function siftFor(rootElem, method, filteredOutElements) {
    if (!rootElem || !method) {
      return;
    }

    rootElem = $(rootElem);
    var DOMelements = rootElem.find('*').add(rootElem);

    if (filteredOutElements) {
      DOMelements = DOMelements.not(filteredOutElements.join(', '));
    }
    var siftedControls = findControlsOnElements(DOMelements, method);

    rootElem.trigger('sift-' + method + '-complete', [siftedControls]);
    return rootElem;
  }

  //==========================================================
  // Actual Control Plugins
  //==========================================================

  $.fn.destroy = function() {
    return siftFor($(this), 'destroy');
  };

  $.fn.closeChildren = function() {
    return siftFor($(this), 'close', EXCLUDED_FROM_CLOSE_CHILDREN);
  };

  $.fn.handleResize = function() {
    return siftFor($(this), 'handleResize', EXCLUDED_FROM_HANDLE_RESIZE);
  };


  $.fn.listview = function(options) {
    // TODOs: edit and/or alt template
    // navigatable
    // template (as id or string)
    // Methods: add, remove (X), clear (X), destroy, refresh (rebind) (X), select (get or set) (X)
    // Events: rendered, add, select
    // Settings and Options
    var pluginName = 'listview',
      defaults = {
        dataset: [], // Array of data
        template: null,  //Html Template String
        description: null,  //Audible Label (or use parent title)
        paging: false, // If true, activates paging
        pagesize: 10, // If paging is activated, sets the number of listview items available per page
        searchable: false, // If true, associates itself with a Searchfield/Autocomplete and allows itself to be filtered
        selectable: 'single', //false, 'single' or 'multiple'
        selectOnFocus: true, //true or false
        hoverable: true, //true or false - can disable hover state
        source: null, // External function that can be used to provide a datasource
      },
      settings = $.extend({}, defaults, options);

    /**
     * @constructor
     * @param {Object} element
     */
    function ListView(element) {
      this.settings = $.extend({}, settings);
      this.element = $(element);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    // Plugin Object
    ListView.prototype = {
      init: function() {
        this.setup();
        this.refresh();
        this.selectedItems = [];
        this.lastSelectedRow = 0; // Rember index to use shift key
        this.isSelectedAll = false; // Rember if all selected or not
        this.sortInit('listview', 'click.listview', 'data-sortlist');
        this.handleEvents();
        this.handleResize();
      },

      setup: function() {
        var self = this,
          card = this.element.closest('.card, .widget'),
          selectable = this.element.attr('data-selectable'),
          selectOnFocus = this.element.attr('data-select-onfocus');

        if (selectable && selectable.length) {
          this.settings.selectable = selectable;
        }

        if (selectOnFocus && selectOnFocus.length) {
          this.settings.selectOnFocus = JSON.parse(selectOnFocus);
        }

        self.actionButton = card.find('.btn-actions');

        if (self.actionButton.length > 0) {
          // Action Buttons may already be invoked via initialize.js.
          if (!(self.actionButton.data('popupmenu'))) {
            self.actionButton.popupmenu();
          }
        }

        this.element.attr({'tabindex': '-1'});

        // Configure Paging
        if (this.element.is('.paginated') || this.settings.paging === true) {
          this.element.pager({
            componentAPI: this,
            pagesize: this.settings.pagesize,
            source: this.settings.source
          });
        }

        var cardWidgetContent =  this.element.parent('.card-content, .widget-content');
        if (cardWidgetContent[0]) {
          cardWidgetContent[0].style.overflow = 'hidden';
        }

         // Add Aria Roles
        this.element.attr({ 'role' : 'listbox',
          'aria-label' : this.settings.description || card.find('.card-title, .widget-title').text()
        });

        // Associate with an existing searchfield, if applicable
        if (this.settings.searchable) {
          this.searchfield = this.element.parent().find('.searchfield, .autocomplete');

          if (!this.searchfield.length) {
            // TODO: Create Searchfield somehow
          }

          this.listfilter = new ListFilter({
            filterMode: 'contains'
          });
        }

        if (this.settings.dataset) {
          // Search the global variable space for a dataset variable name, if provided.
          if (typeof this.settings.dataset === 'string') {
            var dataset = window[this.settings.dataset];
            if (dataset && dataset.length) {
              this.settings.dataset = dataset;
            }
          }
        }
      },

      getTotals: function(dataset) {
        var totals = { count: dataset.length },
          property;

        if (!dataset[0]) {
          return;
        }

        for (property in dataset[0]) {
          totals[property] = 0;
        }

        for (var i = 0; i < dataset.length; i++) {
          for (property in dataset[i]) {
            totals[property] += parseFloat(dataset[i][property]);
          }
        }
        return totals;
      },

      render: function(dataset, pagerInfo) {
        var self = this,
          totals = {};

        // Render "mustache" Template
        if (typeof Tmpl === 'object' && dataset && this.settings.template) {

          // create a copy of an inlined template
          if (this.settings.template instanceof $) {
            this.settings.template = '' + this.settings.template.html();
          }

          if (this.settings.template.indexOf('{{#totals}}') > -1) {
            totals = this.getTotals(dataset);
          }

          var compiledTmpl = Tmpl.compile(this.settings.template),
            renderedTmpl = compiledTmpl.render({dataset: dataset, totals: totals});

          this.element.html(renderedTmpl);
        }

        // Render Pager
        if (this.settings.paging) {
          this.renderPager(pagerInfo);
        }

        // Add Aria
        $('ul', this.element).attr({'role': 'presentation'});

        // Add Checkboxes
        var first = this.element.find('li, tbody > tr').first(),
          items = this.element.find('li, tr'),
          isMultiselect = (this.settings.selectable === 'multiple');

        //Set Initial Tab Index
        first.attr('tabindex', 0);

        items.each(function (i) {
          var row = $(this);

          row.attr('role', 'option');

          if (isMultiselect) {
            // Add Selection Checkboxes
            self.element.addClass('is-muliselect');

            // Create a Toolbar for the "Selected Items" area
            var selectedToolbar = self.element.prevAll('.toolbar');
            if (selectedToolbar.length && selectedToolbar.data('toolbar')) {
              selectedToolbar.data('toolbar').toggleMoreMenu();
            }
          }

          // Add Aria
          row.attr({'aria-posinset': i+1, 'aria-setsize': items.length});

          // Add Aria disabled
          if (row.hasClass('is-disabled')) {
            row.attr('aria-disabled','true');
          }
        });

        // TODO: Invoke the "element" here after we write an updated method.
        this.element.children().initialize();
        this.element.trigger('rendered', [dataset]);

        //Handle refresh
        this.element.off('updated').on('updated', function () {
          self.refresh();
        });
      },

      renderPager: function(updatedPagerInfo) {
        var api = this.element.data('pager');
        if (!api || !this.settings.pager) {
          return;
        }

        api.updatePagingInfo(updatedPagerInfo);
      },

      // Get the Data Source. Can be an array, Object or Url
      refresh: function () {
        this.loadData();

        if (this.list) {
          this.render(this.list.data);
        }
      },

      // Load Data from an external API
      loadData: function (ds, pagerInfo) {
        var ajaxDs = false;

        ds = ds || this.settings.dataset;
        pagerInfo = pagerInfo || {};

        if (!ds) {
          return;
        }

        function done(response, pagingInfo) {
          ds = response;
          this.render(ds, pagingInfo);
        }

        var self = this,
          s = this.settings.source;

        if (typeof ds === 'string' && (ds.indexOf('http') === 0 || ds.indexOf('/') === 0)) {
          s = ds;
          ajaxDs = true;
        }

        // If paging is not active, and a source is present, attempt to retrieve information from the datasource
        // TODO: Potentially abstract this datasource concept out for use elsewhere
        if ((!this.settings.paging && s) || ajaxDs) {
          switch (typeof s) {
            case 'function':
              return s(pagerInfo, done);
            case 'string':
              if (s.indexOf('http') === 0 || s.indexOf('/') === 0) {
                $.ajax({
                  url: s,
                  async: false,
                  dataType: 'json',
                  success: function(response) {
                    ds = self.settings.dataset = response;
                    return self.render(ds, pagerInfo);
                  }
                });
              }
              return;
            default:
              ds = this.settings.dataset = s;
              return this.render(s, pagerInfo);
          }
        }

        // Otherwise, simply render with the existing dataset
        this.render(ds, pagerInfo);
      },

      // Toggle all
      toggleAll: function() {
        this[this.isSelectedAll ?
          'unselectRowsBetweenIndexes' :
          'selectRowsBetweenIndexes']([0, $('li, tbody tr', this.element).length-1]);
        this.isSelectedAll = !this.isSelectedAll;
      },

      // Select rows between indexes
      selectRowsBetweenIndexes: function(indexes) {
        this.clearSelection();
        indexes.sort(function(a, b) { return a-b; });
        for (var i = indexes[0]; i <= indexes[1]; i++) {
          var item = $('li, tbody tr', this.element).eq(i);

          if (!item.is('.is-disabled, .is-selected')) {
            this.select(item);
          }
        }
      },

      // Unselect rows between indexes
      unselectRowsBetweenIndexes: function(indexes) {
        indexes.sort(function(a, b) { return a-b; });
        for (var i = indexes[0]; i <= indexes[1]; i++) {
          var item = $('li, tbody tr', this.element).eq(i);
          if(!item.is('.is-disabled') && item.is('.is-selected')) {
            this.select(item);
          }
        }
      },

      // Clear Selection
      clearSelection: function() {
        if (window.getSelection) {
          window.getSelection().removeAllRanges();
        } else if (document.selection) {
          document.selection.empty();
        }
      },

      // Handle Keyboard / Navigation Ect
      handleEvents: function () {
        var self = this,
          isSelect = false,
          isFocused = false,
          isMultiple = self.settings.selectable === 'multiple';

        this.element.on('focus.listview', 'li, tbody tr', function () {
          var item = $(this);

          // First element if disabled
          if (item.is(':first-child') && item.hasClass('is-disabled')) {
            var e = $.Event('keydown.listview');
              e.keyCode= 40; // move down
            isSelect = true;
            item.trigger(e);
          }

          if ((!isSelect) &&
              (!item.hasClass('is-disabled')) &&
              (self.settings.selectOnFocus) &&
              (self.settings.selectable !== 'multiple')) {

            self.select(item);
            isSelect = true;
            isFocused = true;
          }
        });

        // Key Board
        this.element.on('keydown.listview', 'li, tr', function (e) {
          var item = $(this),
            list = item.parent(),
            key = e.keyCode || e.charCode || 0,
            metaKey = e.metaKey;

          if (item.index() === 0 && e.keyCode === 38) {
            return;
          }

          if ((key === 40 || key === 38) && !metaKey) {// move down or up
            var newItem = e.keyCode === 40 ? item.nextAll(':not(.is-disabled):visible:first') : item.prevAll(':not(.is-disabled):visible:first');

            if ($(e.target).is(item) || e.shiftKey) {
              self.focus(newItem);
            }
            e.preventDefault();
            e.stopPropagation();  //prevent container from scrolling
          }

          if (key === 35 || (key === 40 && metaKey)) { //end
            var last = list.children().last();
            self.focus(last);
            e.stopPropagation();
            return false;
          }

          if (key === 36 || (key === 38 && metaKey)) {  //home
            var first = list.children().first();
            self.focus(first);
            e.stopPropagation();
            return false;
          }

          if (key === 32) { // Space to toggle selection
            if ($(e.target).is(item)) {
              if(isMultiple && e.shiftKey) {
                self.selectRowsBetweenIndexes([self.lastSelectedRow, item.index()]);
              } else {
                self.select(item);
              }
              e.preventDefault();
            }
          }

          // If multiSelect is enabled, press Control+A to toggle select all rows
          if (isMultiple && ((e.ctrlKey || e.metaKey) && key === 65)) {
            self.toggleAll();
            self.focus(item);
            e.preventDefault();
          }

        });

        // Selection View Click/Touch
        if (this.settings.selectable) {

          this.element.addClass('is-selectable');
          var trigger = $('.list-detail-back-button').find('.app-header'),
            pattern = $(this.element).closest('.list-detail, .builder');

          trigger.parent().onTouchClick('listview').on('click.listview', function (e) {
            if (trigger.hasClass('go-back')) {
              trigger.removeClass('go-back');
              pattern.removeClass('show-detail');
            }
            e.stopPropagation();
            e.stopImmediatePropagation();
            e.preventDefault();
            return false;
          });

          this.element
          .off('listview', 'li, tr')
          .on('click.listview', 'a', function (e) {
            $(this).closest('li').click();
            e.preventDefault();
            return false;
          });

          this.element
          .off('listview', 'li, tr')
          .on('click.listview', 'li, tr', function (e) {
            var item = $(this);

            if (!isFocused && !item.hasClass('is-disabled')) {
              isSelect = true;

              if(isMultiple && e.shiftKey) {
                self.selectRowsBetweenIndexes([self.lastSelectedRow, item.index()]);
                e.preventDefault();
              } else {
                self.select(item);
              }
              item.focus();
            }

            if (pattern.length > 0 && $(window).outerWidth() < 767 && !item.hasClass('is-disabled')) {
              pattern.toggleClass('show-detail');
              trigger.toggleClass('go-back');
            }

            isFocused = false;
          });
        }

        if (!this.settings.hoverable || this.settings.hoverable === 'false') {
          this.element.removeClass('is-selectable');
          this.element.addClass('disable-hover');
        }

        if (!this.settings.selectable || this.settings.selectable === 'false') {
          this.element.removeClass('is-selectable');
          this.element.addClass('disable-hover');
        }

        if (this.settings.selectable === 'multiple') {
          this.element.on('change.selectable-listview', '.listview-checkbox input', function (e) {
           $(this).parent().trigger('click');
           e.stopPropagation();
          });
        }

        // For use with Searchfield
        if (this.settings.searchable) {
          this.searchfield.on('contents-checked.searchable-listview', function(e) {
            self.handleSearch(e, $(this));
          });
        }

        //If used with a Pager Control, listen for the end of the page and scroll the Listview to the top
        if (this.element.data('pager')) {
          this.element.on('afterpaging.listview', function() {
            self.element.scrollTop(0);
          });
        }

        $('body').on('resize.listview', function() {
          self.handleResize();
        });

        //Animate open and Closed from the header
        self.element.prev('.listview-header').onTouchClick().on('click', function () {
          var icon = $(this).find('.plus-minus');
          if (icon.hasClass('active')) {
            icon.removeClass('active');
            self.element.animateClosed();
          } else {
            icon.addClass('active');
            self.element.animateOpen();
          }
        });

      },

      // Handle Resize
      handleResize: function () {
        var items = $('li .listview-heading, tr .listview-heading', this.element),
          item1 = items.eq(1),
          item1W = item1.width();

        if (item1.length && item1W) {
          items[0].style.width = item1W + 'px';
        }

        this.setChildIconsValign();

        if (this.element.data('pager')) {
          this.element.data('pager').renderBar();
        }
      },

      // For instances of Listview that are paired with a Searchfield
      // NOTE: Search functionality is called from "js/listfilter.js"
      handleSearch: function(e, searchfield) {
        var list = this.element.find('li, tbody > tr'),
            term = searchfield.val(),
            results;

        this.resetSearch(list);

        if (term && term.length) {
          results = this.listfilter.filter(list, term);
        }

        if (!results || !results.length && !term) {
          return;
        }

        list.not(results).addClass('hidden');
        list.filter(results).each(function(i) {
          var li = $(this);
          li.attr('tabindex', i === 0 ? '0' : '-1');
          li.highlight(term);
        });

        this.renderPager();
      },

      resetSearch: function(list) {
        list.removeClass('hidden').each(function() {
          $(this).unhighlight();
        });
      },

      // Fix: for vertical-align to icons and buttons
      setChildIconsValign: function() {
        $('li > .icon, li > button', this.element).each(function() {
          var item = $(this),
          itemHeihgt = item.is('button') ? 42 : 22,
          row = item.closest('li'),
          padding = parseInt(row[0].style.paddingTop, 10) + parseInt(row[0].style.paddingBottom, 10),
          rowHeight = row.outerHeight() - padding;

          this.style.top = ((rowHeight - itemHeihgt)/2) +'px';
        });
      },

      focus: function (item) {
        if (item.is(':hidden') || item.is('.is-disabled')) {
          return;
        }

        item.siblings().removeAttr('tabindex');
        item.attr('tabindex', 0).focus();

        if (this.settings.selectOnFocus && (this.settings.selectable !== 'multiple')) {
          this.select(item);
        }
      },

      // Remove Either the list element or index
      remove: function (li) {
        if (typeof li === 'number') {
          li = $(this.element.children()[0]).children().eq(li);
        }
        // Un-select selected item
        // and donot trigger selected event, sinnce we removeing
        if (li.is('.is-selected')) {
          this.select(li, true);
        }
        li.remove();
      },

      // Remove All
      clear: function () {
        var root = $(this.element.children()[0]);
        root.empty();
      },

      // Remove all selected
      removeAllSelected: function () {
        var self = this;
        $.each(this.selectedItems, function(index, selected) {
          self.remove(selected);
        });
      },

      // Clear all selected
      clearAllSelected: function () {
        var self = this;
        $.each(this.selectedItems, function(index, selected) {
          // Un-select selected item
          self.select(selected);
        });
      },

      // Initialize sortlist
      sortInit: function(control, onEvent, attr){
        if(!attr || $.trim(attr) === '') {
          return;
        }
        $('['+ attr +']').each(function() {
          var elment = $(this),
            options = $.fn.parseOptions(elment, attr);

          elment.on(onEvent, function(e) {
            $(options.list).data(control).setSortColumn(options);
            e.preventDefault();
          });
        });
      },

      // Sort data set
      setSortColumn: function(options) {
        var sort,
        field = options.orderBy || this.list.sort.field,
        reverse = options.order;

        if (!this.list.data && !field) {
          return;
        }

        reverse = reverse ?
          (reverse === 'desc') :
          (this.list.sort && this.list.sort[field] && this.list.sort[field].reverse) ? false : true;

        //reload data
        if (options.reloadApi || options.reloadApiNoSort) {
          this.loadData();
        }

        //reload data but no sort change
        if (options.reloadApiNoSort) {
          field = this.list.sort.field;
          reverse = this.list.sort[field].reverse;
        }

        sort = this.sortFunction(field, reverse);
        this.list.data.sort(sort);
        this.render(this.list.data);

        this.list.sort = {field: field};
        this.list.sort[field] = {reverse: reverse};

        this.element.trigger('sorted', [this.element, this.list.sort]);
      },

      //Overridable function to conduct sorting
      sortFunction: function(field, reverse, primer) {
        var key;
        if (!primer) {
          primer = function(a) {
            a = (a === undefined || a === null ? '' : a);
            if (typeof a === 'string') {
              a = a.toUpperCase();

              if (!isNaN(parseFloat(a))) {
                a = parseFloat(a);
              }
            }
            return a;
          };
        }
        key = primer ? function(x) { return primer(x[field]); } : function(x) { return x[field]; };
        reverse = !reverse ? 1 : -1;
        return function (a, b) {
           return a = key(a), b = key(b), reverse * ((a > b) - (b > a));
        };
      },

      // Un-select selected item
      unselect: function (li) {
        if (typeof li === 'number') {
          li = $(this.element.children()[0]).children().eq(li);
        }
        if (li.is('.is-selected')) {
          this.select(li);
        }
      },

      // Handle Selecting the List Element
      select: function (li, noTrigger) {
        var self = this,
          isChecked = false;

        self.selectedItems = [];
        if (typeof li === 'number') {
          li = $(this.element.children()[0]).children().eq(li);
        }

        isChecked = li.hasClass('is-selected');

        //focus
        if (!li.is('[tabindex="0"]')) {
          li.siblings().removeAttr('tabindex');
          li.attr('tabindex', 0);
        }

        if (this.settings.selectable === false || this.settings.selectable === 'false') {
          return;
        }

        //Select
        if (this.settings.selectable !== 'multiple') {
          li.parent().children().removeAttr('aria-selected');
          li.parent().find('.is-selected').removeClass('is-selected');
          self.selectedItems[0] = $(this);
        }

        if (isChecked) {
          self.selectedItems = [];
          li.removeClass('is-selected');
        } else {
          if (this.settings.selectable) {
            li.addClass('is-selected');
            self.lastSelectedRow = li.index();// Rember index to use shift key
          }
        }

        li.parent().find('.is-selected').each(function (i) {
          self.selectedItems[i] = $(this);
        });

        li.attr('aria-selected', !isChecked);
        if (!noTrigger) {
          this.element.triggerHandler('selected', {selectedItems: this.selectedItems, elem: li});
        }

        var toolbar, toolbarControl,
          parent = this.element.closest('.card, .widget');

        if (!parent.length) {
          parent = this.element.parent();
        }
        toolbar = parent.find('.listview-toolbar, .contextual-toolbar');

        toolbarControl = toolbar.data('toolbar');

        if (self.selectedItems.length > 0) {
          if (toolbarControl) {
            toolbarControl.toggleMoreMenu();
          }
          // Order of operations: set up event, change display prop, animate, toggle menu.
          // Menu toggle takes place after the animation starts
          toolbar.one('animateopencomplete', function() {
            self.element.addClass('is-toolbar-open');
            toolbar.trigger('recalculate-buttons').removeClass('is-hidden');
          });
          if (toolbar[0]) {
            toolbar[0].style.display = 'block';
          }
          // toolbar.animateOpen({distance: 52});
          toolbar.animateOpen({distance: 40});

          var title = toolbar.find('.title, .selection-count');
          if (!title || !title.length) {
            title = $('<div class="title selection-count"></div>');
            toolbar.prepend(title);
          }
          title.text(self.selectedItems.length + ' ' + Locale.translate('Selected'));

        } else {
          toolbar.addClass('is-hidden').one('animateclosedcomplete', function(e) {
            e.stopPropagation();
            this.style.display = 'none';
          }).animateClosed();

        }
      },

      updated: function() {
        this.refresh();
        return this;
      },

      teardown: function() {
        $('body').off('resize.listview');
        this.element.off('focus.listview click.listview touchend.listview keydown.listview change.selectable-listview afterpaging.listview').empty();
        return this;
      },

      destroy: function() {
        this.teardown();
        this.element.removeData(pluginName);
      }
    };

    // Initializing the Control Once or Call Methods.
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (instance) {
        instance.settings = $.extend({}, instance.settings, options);
        instance.updated();
      } else {
        instance = $.data(this, pluginName, new ListView(this, settings));
      }
    });
  };


  $.fn.listbuilder = function(options) {
    'use strict';

    // Settings and Options
    var pluginName = 'listbuilder',
        defaults = {
          'dataset': [], // Array of data

          // Action buttons
          // use "data-action" attributes, ie. data-action="add"
          // or jQuery elements
          'btnAdd': 'add',
          'btnEdit': 'edit',
          'btnDelete': 'delete',
          'btnGoUp': 'goup',
          'btnGoDown': 'godown',

          // Template HTML
          'template': ''+
            '<ul data-handle=".handle">'+
              '{{#dataset}}'+
                '{{#text}}'+
                  '<li'+
                    '{{#value}} data-value="{{value}}"{{/value}}'+
                    '{{#selected}} selected="selected"{{/selected}}'+
                    '{{#disabled}} class="is-disabled"{{/disabled}}'+
                  '>'+
                    '<span class="handle" focusable="false" aria-hidden="true" role="presentation">&#8286;</span>'+
                    '<div class="item-content"><p>{{text}}</p></div>'+
                  '</li>'+
                '{{/text}}'+
              '{{/dataset}}'+
            '</ul>',

          'templateNewItem': ''+
            '<li data-value="{{text}}" role="option">'+
              '<span class="handle" focusable="false" aria-hidden="true" role="presentation">&#8286;</span>'+
              '<div class="item-content"><p>{{text}}</p></div>'+
            '</li>',

          'templateItemContent': '<p>{{text}}</p>'
        },
        settings = $.extend({}, defaults, options);

    /**
     * @constructor
     * @param {Object} element
     */
    function ListBuilder(element) {
      this.settings = $.extend({}, settings);
      this.element = $(element);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    // ListBuilder Methods
    ListBuilder.prototype = {

      init: function() {
        var self = this;
        this
          .loadListview()
          .initDataset()
          .setElements()
          .handleEvents();

        setTimeout(function() {
          self.setSelected();
        }, 0);
      },

      // Load listview
      loadListview: function() {
        var s = this.settings,
          lv = $('.listview', this.element);

        if (!s.dataset.length && lv.length && $('li', lv).length) {
          this.listApi = lv.listview({selectable: 'single'}).data('listview');
        } else if (lv.length) {
          this.listApi = lv.listview({dataset: s.dataset, template: s.template, selectable: 'single'}).data('listview');
        }
        return this;
      },

      // Init dataset
      initDataset: function() {
        var s = this.settings,
          nodes = $('.listview li', this.element);

        this.dataset = [];
        for (var i = 0, l = nodes.length; i < l; i++) {
          var data,
            li = $(nodes[i]);
          if (s.dataset) {
            // Make sure it's not reference pointer to data object, make copy of data
            data = JSON.parse(JSON.stringify(s.dataset[i]));
            data.node = li;
          }
          else {
            data = this.extractNodeData(li);
          }
          this.dataset.push(data);
        }
        return this;
      },

      // Extract node data
      extractNodeData: function(node) {
        var data = {node: node, text: $.trim($('.item-content', node).text())},
          value = node.attr('data-value');
        if (typeof value !== 'undefined') {
          data.value = value;
        }
        return data;
      },

      // Set elements
      setElements: function() {
        var self = this,
          s = this.settings;

        // Action buttons
        var setAction = function(selector) {
          return self.isjQuery(selector) ?
            selector : (typeof selector === 'string' ?
              $('[data-action="'+ selector +'"]', self.element) : null);
        };
        s.btnAdd = setAction(s.btnAdd);
        s.btnGoUp = setAction(s.btnGoUp);
        s.btnGoDown = setAction(s.btnGoDown);
        s.btnEdit = setAction(s.btnEdit);
        s.btnDelete = setAction(s.btnDelete);

        // Init tooltips
        this.topButtons = s.btnAdd.add(s.btnGoUp).add(s.btnGoDown).add(s.btnEdit).add(s.btnDelete);
        this.topButtons.tooltip();

        // Make Draggable
        this.ul = $('.listview ul', this.element);
        this.arrangeApi = this.ul.arrange({
          placeholder: s.templateNewItem
        }).data('arrange');

        return this;
      },

      // Handle Events
      handleEvents: function() {
        var data,
          self = this,
          s = self.settings;

        // TOP BUTTONS =============================================================================
        var topButtonsClick = function(btn, method) {
          btn.offTouchClick('listbuilder').off('click.listbuilder')
            .onTouchClick('listbuilder').on('click.listbuilder', function() {
            self[method]();
          });
        };
        topButtonsClick(s.btnAdd, 'addItem');
        topButtonsClick(s.btnGoUp, 'moveItemUp');
        topButtonsClick(s.btnGoDown, 'moveItemDown');
        topButtonsClick(s.btnEdit, 'editItem');
        topButtonsClick(s.btnDelete, 'deleteItem');

        // DRAGGABLE ===============================================================================
        self.arrangeApi.element
        .on('beforearrange.listbuilder', function(e, status) {
          var d = self.getDataByNode(status.start),
            str = s.templateItemContent.replace(/{{text}}/g, d.data.text);

          self.arrangeApi.placeholders.attr('data-value', d.data.text)
            .find('.item-content').html(str);
        })
        .on('arrangeupdate.listbuilder', function(e, status) {
          self.updateAttributes();
          self.arrayIndexMove(self.dataset, status.startIndex, status.endIndex);
          data = self.getDataByNode(status.end);
          data.indexBeforeMove = status.startIndex;
          self.element.triggerHandler('arrangeupdate', [data]);
        });

        $('li:not(.is-disabled) '+ self.arrangeApi.handle, self.ul)
          .on('mousedown.listbuilder touchstart.listbuilder', function() {
            var li = $(this);
            if (!li.is('.is-selected')) {
              li.trigger('click');
            }
          });

        $('.listview', self.element)
          .off('selected.listbuilder')
          .on('selected.listbuilder', function(e, args) {
            var data = self.getDataByNode(args.elem[0]);
            self.element.triggerHandler('selected', [data]);
          });

        return this;
      }, // END: Handle Events ---------------------------------------------------------------------

      // Add new item
      addItem: function() {
        var self = this,
          s = self.settings;

        $.when(self.element.triggerHandler('beforeadd')).done(function() {
          var li, data,
            index = 0,
            node = self.listApi.selectedItems[0],
            str = s.templateNewItem.replace(/{{text}}/g, Locale.translate('NewItem'));

          if (node && node.length > 0) {
            data = self.getDataByNode(node);
            index = data.index + 1;
            $(str).insertAfter(node);
            li = $('li', self.ul).eq(index);
          }
          else {
            self.ul.prepend(str);
            li = $('li:first-child', self.ul);
          }

          self.dataset.push(self.extractNodeData(li));
          self.arrayIndexMove(self.dataset, self.dataset.length - 1, index);
          self.updateAttributes();
          li.trigger('click');
          self.arrangeApi.updated();
          self.editItem(true);

          data = self.dataset[index];
          self.element.triggerHandler('afteradd', [data]);
        });
      },

      // Move item up
      moveItemUp: function() {
        var self = this,
          node = self.listApi.selectedItems[0];
        if (node && node.length > 0) {
          var data = self.getDataByNode(node);
          if (typeof data.index !== 'undefined' && data.index > 0) {
            $.when(self.element.triggerHandler('beforegoup', [data])).done(function() {
              var prev = node.prev();
              node.insertBefore(prev);
              self.updateAttributes();
              self.arrayIndexMove(self.dataset, data.index, data.index - 1);
              data.indexBeforeMove = data.index;
              data.index = data.index - 1;
              self.element.triggerHandler('aftergoup', [data]);
            });
          }
        }
      },

      // Move item down
      moveItemDown: function() {
        var self = this,
          node = self.listApi.selectedItems[0];
        if (node && node.length > 0) {
          var data = self.getDataByNode(node);
          if (typeof data.index !== 'undefined' && data.index < self.dataset.length - 1) {
            $.when(self.element.triggerHandler('beforegodown', [data])).done(function() {
              var next = node.next();
              node.insertAfter(next);
              self.updateAttributes();
              self.arrayIndexMove(self.dataset, data.index, data.index + 1);
              data.indexBeforeMove = data.index;
              data.index = data.index + 1;
              self.element.triggerHandler('aftergodown', [data]);
            });
          }
        }
      },

      // Edit item
      editItem: function(isNewItem) {
        var node = this.listApi.selectedItems[0];
        if (node && node.length > 0) {
          if (node.is('.is-editing')) {
            this.commitEdit(node, isNewItem);
          } else {
            this.makeEditable(node, isNewItem);
          }
        }
      },

      // Make item editable
      makeEditable: function(node, isNewItem) {
        var self = this,
          data = self.getDataByNode(node),
          container = $('.item-content', node);

        if (typeof data.index !== 'undefined' && data.index < self.dataset.length) {
          $.when(self.element.triggerHandler('beforeedit', [data])).done(function() {
            var origValue = container.text().trim(),
              editInput = $('<input name="edit-input" class="edit-input" type="text" value="'+ origValue +'" />');

            node.addClass('is-editing');
            container.html(editInput);
            editInput.focus().select();

            editInput
            .on('click.listbuilder', function() {
              return false;
            })
            .on('blur.listbuilder', function() {
              self.commitEdit(node, isNewItem);
            })
            .on('keypress.listbuilder', function (e) {
              var key = e.keyCode || e.charCode || 0;
              if (key === 13) {
                self.commitEdit(node, isNewItem);
                node.focus();
              }
            });

            self.element.triggerHandler('entereditmode', [data]);
          });
        }
      },

      // Commit editable item
      commitEdit: function(node, isNewItem) {
        var self = this,
          s = this.settings,
          data = self.getDataByNode(node),
          container = $('.item-content', node),
          editInput = $('.edit-input', container);

        if (isNewItem) {
          data.data.value = editInput.val();
        }
        data.data.text = editInput.val();
        editInput.off('click.listbuilder blur.listbuilder keypress.listbuilder');
        container.html(s.templateItemContent.replace(/{{text}}/g, editInput.val()));
        node.removeClass('is-editing');
        self.element.triggerHandler('exiteditmode', [data]);
      },

      // Delete item
      deleteItem: function() {
        var self = this,
          node = self.listApi.selectedItems[0];
        if (node && node.length > 0) {
          var data = self.getDataByNode(node);
          if (typeof data.index !== 'undefined') {
            $.when(self.element.triggerHandler('beforedelete', [data])).done(function() {
              self.listApi.removeAllSelected();
              self.updateAttributes();
              self.dataset.splice(data.index, 1);
              self.element.triggerHandler('afterdelete', [data]);
            });
          }
        }
      },

      // Get data from dataset by node
      getDataByNode: function(node) {
        var data = {};
        for (var i = 0,l = this.dataset.length; i < l; i++) {
          var d = this.dataset[i];
          if ($(d.node).is(node)) {
            data = {index: i, data: d};
            break;
          }
        }
        return data;
      },

      // Move an array element position
      arrayIndexMove: function(arr, from, to) {
        arr.splice(to, 0, arr.splice(from, 1)[0]);
      },

      // Check if given object is a jQuery object
      isjQuery: function (obj) {
        return (obj && (obj instanceof jQuery || obj.constructor.prototype.jquery));
      },

      // Move cursor to end
      // http://stackoverflow.com/a/26900921
      moveCursorToEnd: function (el) {
        setTimeout(function() {
          if (typeof el.selectionStart === 'number') {
            el.selectionStart = el.selectionEnd = el.value.length;
          } else if (typeof el.createTextRange !== 'undefined') {
            var range = el.createTextRange();
            range.collapse(false);
            range.select();
          }
        }, 100);
      },

      // Update attributes
      updateAttributes: function() {
        var nodes = $('li', this.ul),
          size = nodes.length;

        nodes.each(function(i) {
          $(this).attr({'aria-posinset': i + 1, 'aria-setsize': size});
        });
      },

      // Update dataset
      updateDataset: function(ds) {
        var self = this,
          nodes = $('li', this.ul),
          lv = $('.listview', this.element).data('listview');

        lv.unselectRowsBetweenIndexes([0, nodes.length-1]);
        this.settings.dataset = ds;
        lv.loadData(this.settings.dataset);

        this
          .initDataset()
          .setElements()
          .handleEvents();

        setTimeout(function() {
          self.setSelected();
        }, 0);
      },

      // Set pre selected items
      setSelected: function() {
        $('li[selected]', this.ul).each(function() {
          var li = $(this);
          li.removeAttr('selected');
          if (!li.is('.is-selected')) {
            li.trigger('click');
          }
        });
        return this;
      },

      // Make selected
      select: function(selector) {
        var li = this.getListItem(selector);

        if (li) {
          if (!li.is('.is-selected')) {
            li.trigger('click');
          }
        }
      },

      // Make unselected
      unselect: function(selector) {
        var li = this.getListItem(selector);

        if (li) {
          if (li.is('.is-selected')) {
            li.trigger('click');
          }
        }
      },

      // Get an item from list, selector: can be
      // jQuery, DOM element, zero based index or 'first'|'last' as string
      getListItem: function(selector) {
        var li = $();
        if (this.isElement(selector) && $.contains(this.ul, selector)) {
          li = this.isjQuery(selector) ? selector : $(selector);
        } else {
          var idx = parseInt(selector),
            items = $('li', this.ul);
          if (!isNaN(idx) && (idx > -1 && idx < items.length)) {
            li = items.eq(idx); // zero based index
          } else if ((selector + '').toLowerCase() === 'first') {
            li = items.first(); // first
          } else if ((selector + '').toLowerCase() === 'last') {
            li = items.last(); // last
          }
        }
        // Make sure to return only one item -or- null
        return (li.length < 1) ? null : ((li.length > 1) ? li.eq(0) : li);
      },

      // Check if given object is a DOM object
      isElement: function(obj) {
        return (this.isjQuery(obj) && obj.get(0) instanceof Element) || obj instanceof Element;
      },

      // Make enable
      enable: function () {
        this.element.removeClass('is-disabled')
          .find('.toolbar .buttonset button').removeAttr('disabled').end()
          .find('.toolbar .buttonset button[data-original-disabled]')
            .attr('disabled', 'disabled').removeAttr('data-original-disabled');

        this.ul
          .find('li').removeClass('is-disabled').end()
          .find('li[data-original-disabled]').addClass('is-disabled').removeAttr('data-original-disabled');
      },

      // Make disable
      disable: function () {
        this.element.addClass('is-disabled')
          .find('.toolbar .buttonset button[disabled]').attr('data-original-disabled', 'disabled').end()
          .find('.toolbar .buttonset button').attr('disabled', 'disabled');

        this.ul
          .find('li.is-disabled').attr('data-original-disabled', 'is-disabled').end()
          .find('li').addClass('is-disabled');
      },

      // Unbind all events
      unbind: function() {
        $('.listview', this.element).off('selected.listbuilder');

        $('li '+ this.arrangeApi.handle, this.ul)
          .off('mousedown.listbuilder touchstart.listbuilder');

        this.arrangeApi.element
          .off('beforearrange.listbuilder arrangeupdate.listbuilder').destroy();

        this.topButtons.off('click.listbuilder').each(function() {
          $(this).data('tooltip').destroy();
        });

        this.listApi.destroy();
        return this;
      },

      // Update this plugin
      updated: function() {
        return this
          .unbind()
          .init();
      },

      // Teardown
      destroy: function() {
        this.unbind();
        $.removeData(this.element[0], pluginName);
      }
    };

    // Initialize the plugin (Once)
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (instance) {
        instance.settings = $.extend({}, instance.settings, options);
        instance.updated();
      } else {
        instance = $.data(this, pluginName, new ListBuilder(this, settings));
      }
    });
  };


  $.fn.circlepager = function(options) {
    'use strict';

    // Settings and Options
    var pluginName = 'circlepager',
        defaults = {
          slidesToShow: 1, // Max number of slides to show in one view
          startingSlide: null, // First showing slide/group, an 0-based integer
          loop: false // Setting loop: true will loop back after next/previous reached to end
        },
        settings = $.extend({}, defaults, options);

    /**
     * @constructor
     * @param {Object} element
     */
    function CirclePager(element) {
      this.settings = $.extend({}, settings);
      this.element = $(element);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    // CirclePager Methods
    CirclePager.prototype = {

      init: function() {
        this.setElements();

        if (this.slides.length) {
          this.createControls();
          this.handleEvents();
          this.showCollapsedView();
          this.initActiveSlide();
        }
      },

      // Set elements
      setElements: function() {
        var self = this,
          s = this.settings;

        this.container = $('.slides', this.element);
        this.slidesJQ = $('.slide', this.element);
        this.slidesToShow = s.slidesToShow;
        this.slides = [];
        this.slidesJQ.each(function() {
          self.slides.push({ node: $(this) });
        });

        if (this.slides.length) {
          // Do not go less than slide width
          this.element.css({'min-width': this.slidesJQ.eq(0).width() + 5});
        }

        this.activeIndex = s.startingSlide !== null &&
          s.startingSlide > -1 && s.startingSlide < this.slides.length ?
            s.startingSlide : 0;
      },

      // Create controls
      createControls: function() {
        var len = this.slides.length,
          html = '<div class="controls">',
          htmlContent = '',
          numOfButtons = 0,
          i, l, slide, temp, href, text, buttonText,
          last, lastIndex, isSingle, isDisabled,
          previousButton, nextButton;

        for (i = 0, l = len; i < l; i += this.slidesToShow) {
          temp = '';
          numOfButtons++;
          isSingle = (this.slidesToShow === 1) || (len - i === 1);
          text = Locale.translate(isSingle ? 'SlideOf' : 'SlidesOf') + '';
          // Keep href in english language only
          href = isSingle ? '#slide {0} of {1}' : '#slides {0} and {1} of {2}';

          // Collect as much bullets need to present
          for (var g = 0; g < this.slidesToShow && (i + g) < len; g++) {
            temp += (i + g + 1) + ', ';
          }
          text = text.replace(isSingle ? '{1}' : '{2}', len);
          href = href.replace(isSingle ? '{1}' : '{2}', len);
          temp = temp.slice(0, -2);
          lastIndex = temp.lastIndexOf(',');
          last = temp.substr(lastIndex + 2);

          // Controls for single slide in view
          if (isSingle) {
            isDisabled = '';
            slide = this.slides[i].node;

            // Set disabled
            if (slide.is('.is-disabled, [disabled]') && !slide.is('[disabled="false"]')) {
              isDisabled = ' disabled tabindex="-1"';
              this.slides[i].isDisabled = true;
            }

            // Set default starting slide
            if (slide.is('.active') && this.settings.startingSlide === null && isDisabled === '') {
              this.activeIndex = i;
            }

            // Use custom text if supplied
            buttonText = slide.attr('data-button-text');
            text = (buttonText && buttonText.length) ?
              buttonText : text.replace('{0}', temp);

            // href = (buttonText && buttonText.length) ?
            //   '#'+ $.trim(text) : href.replace('{0}', temp);
            href = href.replace('{0}', temp);

          }

          // Controls for multiple slides in view
          else {
            temp = temp.substr(0, lastIndex);
            text = text.replace('{1}', last).replace('{0}', temp);
            href = href.replace('{1}', last).replace('{0}', temp);
          }

          href = href.toLowerCase().replace(/[\s,--]+/g, '-');

          htmlContent += '<a href="'+ href +'" class="control-button hyperlink hide-focus"'+ isDisabled +'><span class="audible">'+ text +'</span></a>';
        }

        html += htmlContent + '</div>';

        // Previous/Next buttons
        this.isBulletsNav = this.element.width() > numOfButtons * 29;
        previousButton = $('.btn-previous', this.element);
        nextButton = $('.btn-next', this.element);
        if (!this.isBulletsNav) {
          if (!previousButton.length) {
            html += '<button class="btn-previous" type="button">' + $.createIcon('left-arrow') + '<span class="audible">'+
                Locale.translate('Previous') +'</span></button>';
          }
          if (!nextButton.length) {
            html += '<button class="btn-next" type="button">' + $.createIcon('right-arrow') + '<span class="audible">'+
                Locale.translate('Next') +'</span></button>';
          }
        } else {
          previousButton.add(nextButton).remove();
        }

        this.element.append(html);
      },

      // Handle events
      handleEvents: function() {
        var self = this;

        // Previous button
        $('.btn-previous', this.element)
          .onTouchClick('circlepager')
          .on('click.circlepager', function (e) {
            self.prev();
            e.stopImmediatePropagation();
          });

        // Next button
        $('.btn-next', this.element)
          .onTouchClick('circlepager')
          .on('click.circlepager', function (e) {
            self.next();
            e.stopImmediatePropagation();
          });

        this.controlButtons = $('.control-button', this.element);
        this.controlButtons.each(function(index) {
          var btn = $(this);
          btn.hideFocus();

          // Handle clicks for bottom bullet links
          btn.on('click.circlepager', function(e) {
            e.preventDefault();
            if (self.slides[index].isDisabled) {
              return;
            }
            self.show(index);
          });

        });

        // Handle keyboard events

        // Prevent hidden slide's content to be get focused
        // on focusable elements in slides content
        this.element.on('focus.circlepager', '*', function(e) {
          var handled = false;
          if (!self.isVisibleInContainer($(this))) {
            var canfocus = self.element.find(':focusable');
            for (var i = 0, l = canfocus.length; i < l; i++) {
              if (self.isVisibleInContainer(canfocus.eq(i))) {
                canfocus.eq(i).focus();
                handled = true;
                break;
              }
            }
          }
          e.stopPropagation();
          if (handled) {
            return false;
          }
        });
        // Keydown on focusable elements in slides content to
        // prevent hidden slide's content to be get focused
        this.element.on('keydown.circlepager', '*', function(e) {
          var key = e.which || e.keyCode || e.charCode || 0,
            handled = false,
            canfocus = $(':focusable'),
            index = canfocus.index(this);

          if (key === 9) {//tab
            // Using shift key with tab (going backwards)
            if (e.shiftKey) {
              for (var i = index-1; i >= 0; i--) {
                if ((self.element.has(canfocus.eq(i)).length < 1) ||
                    (self.isVisibleInContainer(canfocus.eq(i)))) {
                  canfocus.eq(i).focus();
                  handled = true;
                  break;
                }
              }
            }
            // Using only tab key (going forward)
            else {
              if (!self.isVisibleInContainer(canfocus.eq(index + 1))) {
                self.controlButtons.first().focus();
                handled = true;
              }
            }
          }
          e.stopPropagation();
          if (handled) {
            return false;
          }
        });

        // Control buttons
        this.controlButtons.on('keydown.circlepager', function(e) {
          var key = e.which || e.keyCode || e.charCode || 0,
            handled = false,
            isRTL = Locale.isRTL();

          // Left and Right arrow keys
          if ([37, 39].indexOf(key) !== -1) {
            self.isFocus = true; // Move focus
            if (e.altKey) {
              // [Alt + Left/Right arrow] to move to the first or last
              if ((key === 37 && !isRTL) || (key === 39 && isRTL)) {
                self.first();
              } else {
                self.last();
              }
            }
            // Left and Right arrow keys to navigate
            else {
              if ((!isRTL && key === 37) || (isRTL && key === 39)) {
                self.prev();
              } else {
                self.next();
              }
              handled = true;
            }
          }

          if (handled) {
            e.preventDefault();
            e.stopPropagation();
            return false;
          }
        });

        // Set max number of slides can view on resize
        $('body').on('resize.circlepager', function() {
          self.responsiveSlidesToShow();
        });

      }, // END: Handle Events ---------------------------------------------------------------------
      // Check if given element is visible in container
      isVisibleInContainer: function(element) {
        if (element && element[0]) {
          var eRect = element[0].getBoundingClientRect();
          var cRect = this.element[0].getBoundingClientRect();
          return (eRect.left > cRect.left && eRect.left < (cRect.left + cRect.width) &&
            eRect.top > cRect.top && eRect.top < (cRect.top + cRect.height));
        }
        return -1;
      },

      // Update number of slides to show in view
      updateSlidesToShow: function(numOfSlides) {
        if (!this.isActive) {
          return;
        }
        this.settings.slidesToShow = numOfSlides || 1;
        this.updated();
        return this;
      },

      // Make sure max number of slides to show in view
      responsiveSlidesToShow: function(numOfSlides) {
        if (!this.isActive) {
          return;
        }
        var self = this;
        this.slidesToShow = numOfSlides || this.settings.slidesToShow;
        this.unbind().slidesJQ.css('width', '');
        if (this.slides.length) {
          setTimeout(function() {
            self.createControls();
            self.handleEvents();
            self.showCollapsedView();
            self.initActiveSlide();
          }, 0);
        }
      },

      // Show slide
      show: function(index) {
        if (!this.isActive) {
          return;
        }
        index = typeof index !== 'undefined' ? index : this.activeIndex;
        this.activeIndex = index;

        // var isBulletsNav = this.element.width() > this.controlButtons.length * 30;
        var left = index > 0 ? ((Locale.isRTL() ? '' : '-') + (index * 100) +'%') : 0;
        this.controlButtons.removeClass('is-active').eq(index).addClass('is-active');
        this.container[0].style.left = left;

        // Make sure bullets navigation do not overflow
        if (!this.isBulletsNav) {
          this.element.addClass('is-bullets-nav-hidden');
          this.controlButtons.find('span').addClass('audible').end()
            .eq(index).find('span').removeClass('audible');
        } else {
          this.element.removeClass('is-bullets-nav-hidden');
          this.controlButtons.find('span').addClass('audible');
        }

        // Set focus
        if (this.isFocus && this.isBulletsNav) {
          this.isFocus = false;
          this.controlButtons.eq(index).focus();
        }
      },

      // First slide
      first: function() {
        this.show(0);
      },

      // Last slide
      last: function() {
        this.show(Math.round(this.slides.length/this.slidesToShow)-1);
      },

      // Previous slide
      prev: function() {
        var self = this,
          prev = this.activeIndex > 0 ?
            this.activeIndex - 1 : (this.settings.loop ? Math.round(this.slides.length/this.slidesToShow)-1 : 0);

        if (this.slides[prev].isDisabled) {
          setTimeout(function() {
            self.prev();
          }, 0);
          this.activeIndex = prev;
          return false;
        }
        this.show(prev);
      },

      // Next slide
      next: function() {
        var self = this,
          next = this.activeIndex >= Math.round(this.slides.length/this.slidesToShow)-1 ?
            (this.settings.loop ? 0 : this.activeIndex) : this.activeIndex + 1;

        if (this.slides[next].isDisabled) {
          setTimeout(function() {
            self.next();
          }, 0);
          this.activeIndex = next;
          return false;
        }
        this.show(next);
      },

      // Make active
      showCollapsedView: function() {
        this.isActive = true;
        this.element.addClass('is-active');
        this.container[0].style.width = (100 * this.slides.length) +'%';
        if (this.settings.slidesToShow > 1 &&
           (this.slidesJQ.eq(0).width() * this.slidesToShow > this.element.width())) {
          this.responsiveSlidesToShow(this.slidesToShow - 1);
          return;
        }
        for (var i = 0, l = this.slidesJQ.length; i < l; i++) {
          this.slidesJQ[i].style.width = ((100/this.slidesToShow) / this.slides.length) +'%';
        }
        this.show();
      },

      // Make un-active
      showExpandedView: function() {
        this.isActive = false;
        this.element.removeClass('is-active');
        this.element[0].style.width = '';
        this.container[0].style.width = '';
        this.container[0].style.left = '';
      },

      // Initialize active slide
      initActiveSlide: function() {
        if (this.slides[this.activeIndex].isDisabled) {
          this.next();
          return false;
        }
        this.show();
      },

      unbind: function() {
        $('body').off('resize.circlepager');
        this.element.off('focus.circlepager keydown.circlepager', '*');
        this.controlButtons.off('click.circlepager keydown.circlepager');
        $('.btn-previous, .btn-next', this.element).off('click.circlepager');
        $('.controls', this.element).remove();
        this.showExpandedView();
        return this;
      },

      updated: function() {
        return this
          .unbind()
          .init();
      },

      // Teardown
      destroy: function() {
        this.unbind();
        $.removeData(this.element[0], pluginName);
      }
    };

    // Initialize the plugin (Once)
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (instance) {
        instance.settings = $.extend({}, instance.settings, options);
        instance.updated();
      } else {
        instance = $.data(this, pluginName, new CirclePager(this, settings));
      }
    });
  };


  $.fn.pager = function(options) {

    // Settings and Options
    var pluginName = 'pager',
        defaults = {
          componentAPI: undefined, // If defined, becomes the definitive way to call methods on parent component.
          type: 'list', //Different types of pagers: list, table and more
          position: 'bottom',  //Can be on top as well.
          activePage: 1, //Start on this page
          hideOnOnePage: false, // If true, hides the pager if there is only one page worth of results.
          source: null,  //Call Back Function for Pager Data Source
          pagesize: 15, //Can be calculate or a specific number
          pagesizes: [15, 25, 50, 75],
          indeterminate: false // Will not show anything that lets you go to a specific page
        },
        settings = $.extend({}, defaults, options);

    var PAGER_NON_NUMBER_BUTTON_SELECTOR = 'li:not(.pager-prev):not(.pager-next):not(.pager-first):not(.pager-last)';

    /**
     * @constructor
     * @param {Object} element
     */
    function Pager(element) {
      this.settings = $.extend({}, settings);
      this.element = $(element);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    // Actual Plugin Code
    Pager.prototype = {

      pagerInfo: {},

      init: function() {
        this.setup();
        this.createPagerBar();
        this.setActivePage(this.settings.activePage); //Get First Page
        this.renderBar();
        this.renderPages('initial');
        this.handleEvents();
      },

      setup: function() {

        // Add [pagesize] if not found in [pagesizes]
        if($.inArray(this.settings.pagesize, this.settings.pagesizes) === -1) {
          var sortNumber = function (a, b) {
            return a - b;
          };
          this.settings.pagesizes.push(this.settings.pagesize);
          this.settings.pagesizes = this.settings.pagesizes.sort(sortNumber);
        }

        var widgetContainer = this.element.parents('.card, .widget');

        // Adjust for the possibility of the pager being attached to a Table instead of normal grid markup
        if (this.element.is('tbody')) {
          this.isTable = true;
          this.settings.type = 'table';
          this.mainContainer = this.element.closest('.datagrid-container');

          if (!this.settings.componentAPI) {
            this.settings.componentAPI = this.mainContainer.data('datagrid');
          }

          if (widgetContainer.length) {
            widgetContainer[0].classList.add('has-datagrid');
          }
        }

        // If contained by a widget/card container, build some settings for that
        var listviewContainer = this.element.is('.listview');
        if (listviewContainer.length) {
          this.isTable = false;
          this.settings.type = 'list';
          this.mainContainer = listviewContainer;

          if (!this.settings.componentAPI) {
            this.settings.componentAPI = this.element.data('listview');
          }
        }

        this.isRTL = Locale.isRTL();

        return this;
      },

      createPagerBar: function () {
        this.pagerBar = this.element.prev('.pager-toolbar');

        if (this.pagerBar.length === 0) {
          this.pagerBar = $('<ul class="pager-toolbar"></ul>');
          var buttons = '<li class="pager-prev">' +
              '<a href="#" rel="prev" title="PreviousPage">' + $.createIcon({ icon: 'previous-page' }) +
                '<span class="audible">' + Locale.translate('PreviousPage') + '</span>' +
              '</a>' +
            '</li>' +
            '<li class="pager-next">' +
              '<a href="#" rel="next" title="NextPage">' + $.createIcon({ icon: 'next-page' }) +
                '<span class="audible">' + Locale.translate('NextPage') + '</span>' +
              '</a>' +
            '</li>';

          if (this.settings.type === 'table') {
            buttons = '<li class="pager-first">' +
              '<a href="#" title="FirstPage">' + $.createIcon({ icon: 'first-page' }) +
                '<span class="audible">' + Locale.translate('FirstPage') + '</span>' +
              '</a>' +
            '</li>' +
            buttons +
            '<li class="pager-last">' +
              '<a href="#" title="LastPage">' + $.createIcon({ icon: 'last-page' }) +
                '<span class="audible">' + Locale.translate('LastPage') + '</span>' +
              '</a>' +
            '</li>';
          }

          this.pagerBar.html(buttons);

          this.pagerBar.children('li').children('a').button();
        }

        if (this.isTable) {
          this.mainContainer.after(this.pagerBar);
        } else {
          if (this.settings.position ==='bottom') {
            this.element.after(this.pagerBar);
          } else {
            this.element.before(this.pagerBar);
          }
        }

        // Inside of Listviews, place the pager bar inside of the card/widget footer
        var widgetContainer = this.element.closest('.card, .widget');
        if (widgetContainer.length) {
          var self = this,
            widgetTypes = ['widget', 'card'];

          widgetTypes.forEach(function(type) {
            var widgetContent = self.element.closest('.' + type + '-content');
            if (!widgetContent.length) {
              return;
            }

            var widgetFooter = widgetContent.next('.' + type + '-footer');
            if (!widgetFooter.length) {
              widgetFooter = $('<div class="'+ type +'-footer"></div>').insertAfter(widgetContent);
            }

            self.pagerBar.appendTo(widgetFooter);
          });
        }

        this.pagerBar.find('a').tooltip();
      },

      // Attach All relevant events
      handleEvents: function () {
        var self = this;

        // Set element to be focused after paging
        self.element.on('afterpaging.pager', function () {
          var isVisible = $('li[tabindex]:visible, td[tabindex]:visible', self.element);
          if (!isVisible.length) {
            $('li:visible:first, td:visible:first', self.element).attr('tabindex', '0');
          }

          // Fix: Firefox by default to not allow keyboard focus on links
          $('li a', self.pagerBar).each(function() {
            var a = $(this),
              li = a.closest('li');

            if (!a.is('[disabled]')) {
              li.attr('tabindex', '0').on('focus.pager', function() {
                $('a', this).focus();
              });
            }
          });
        });

        //Attach button click and touch
        this.pagerBar.onTouchClick('pager', 'a').on('click.pager', 'a', function (e) {
          var li = $(this).parent();
          e.preventDefault();

          if ($(this).attr('disabled')) {
            return;
          }

          if (li.is('.pager-prev')) {
            self.setActivePage(self.activePage - 1, false, 'prev');
            return false;
          }

          if (li.is('.pager-next')) {
            self.setActivePage((self.activePage === -1 ? 0 : self.activePage)  + 1, false, 'next');
            return false;
          }

          if (li.is('.pager-first')) {
            self.setActivePage(1, false, 'first');
            return false;
          }

         if (li.is('.pager-last')) {
            self.setActivePage(self.pageCount(), false, 'last');  //TODO Calculate Last Page?
            return false;
          }

          //Go to the page via the index of the button
          self.setActivePage($(this).parent().index() + (self.settings.type === 'table' ? -1 : 0), false, 'page');

          return false;
        })
        .on('focus.pager', 'a', function() {
          var li = $(this).parent('li');
          li.addClass('is-focused');
        })
        .on('blur.pager', 'a', function() {
          var li = $(this).parent('li');
          li.removeClass('is-focused');
        });

        //Toolbar functionality
        this.pagerBar.on('keydown.pager', 'a', function (e) {
          e = e || window.event;
          var key = e.which || e.keyCode || e.charCode || false,
            parent = $(this).parent(),
            btn = ((key === 37 || key === 9 && e.shiftKey) ? parent.prev() : (key === 39 ? parent.next() : $()));

          if (key === 9 && e.shiftKey && parent.prev().is('.pager-prev, .pager-first, .pager-count') ||
              key === 9 && e.shiftKey && parent.is('.pager-prev, .pager-first')) {
            parent.removeAttr('tabindex');
            setTimeout(function () {
              parent.attr('tabindex', '0');
            }, 0);
          }
          btn = $('a', btn).length ? btn : $(':text', btn);
          if (btn.length && !btn.is('[disabled]')) {
            btn.focus();
          }
        });
      },

      //Set or Get Current Page
      setActivePage: function(pagingInfo, force, op) {
        var lis = this.pagerBar.find(PAGER_NON_NUMBER_BUTTON_SELECTOR),
          pageNum;

        // Backwards compatibility with having "pageNum" as the first argument
        // instead of "pagingInfo"
        if (!isNaN(pagingInfo)) {
          pageNum = pagingInfo;
          pagingInfo = {
            activePage: pageNum
          };
        }

        // Check to make sure our internal active page is set
        if (!this.activePage || isNaN(this.activePage)) {
          this.activePage = this.settings.activePage;
        }

        // If any of the following conditions are met, don't rerender the pages.
        // Only rerender the pager bar.
        if (pageNum === undefined ||
            pageNum === 0 ||
            isNaN(pageNum) ||
            pageNum > this.pageCount() ||
            (pageNum === this.activePage && !force)) {

          this.renderBar(pagingInfo);
          return this.activePage;
        }

        this.activePage = pageNum;

        //Remove selected
        if (!this.settings.source) {
          lis.filter('.selected').removeClass('selected').removeAttr('aria-selected')
            .find('a').removeAttr('aria-disabled')
              .find('.audible').html(Locale.translate('Page'));

          //Set selected Page
          lis.eq(pageNum-1).addClass('selected').attr('aria-selected', true)
            .find('a').attr('aria-disabled', true)
              .find('.audible').html(Locale.translate('PageOn'));
        }

        this.renderBar(pagingInfo);
        this.renderPages(op);
        if (this.settings.componentAPI) {
          this.settings.componentAPI.saveUserSettings();
        }
        return pageNum;
      },

      _pageCount: 0,

      //Get/Set Total Number of pages
      pageCount: function(pages) {
        var self = this;

        if (pages === undefined && this.settings.indeterminate) {
          this._pageCount = this.settings.pagesize;
        }

        if (pages === undefined && !this.settings.source) {
          return this._pageCount;
        }

        if (pages !== undefined) {
          this._pageCount = pages;
        }

        //Add in fake pages
        if (!this.isTable) {
          var i, thisClass, thisText, isAriaSelected, isAriaDisabled;
          this.pagerBar.find(PAGER_NON_NUMBER_BUTTON_SELECTOR).remove();

          for (i = pages; i > 0; i--) {
            if (i === (this.activePage || 1)) {
              thisClass = 'class="selected"';
              thisText = Locale.translate('PageOn');
              isAriaSelected = 'aria-selected="true"';
              isAriaDisabled = 'aria-disabled="true"';
            } else {
              thisClass = '';
              thisText = Locale.translate('Page');
              isAriaSelected = '';
              isAriaDisabled = '';
            }

            $('<li '+ thisClass + isAriaSelected +'><a href="#" '+ isAriaDisabled +'><span class="audible">'+ thisText +' </span>'+ i +'</a></li>').insertAfter(this.pagerBar.find('.pager-prev'));
          }
        }

        if (this.isTable && !this.settings.indeterminate && this.pagerBar.find('.pager-count').length === 0) {
          var text = Locale.translate('PageOf');
          text = text.replace('{0}', '<input name="pager-pageno" value="' + this.activePage + '">');
          text = text.replace('{1}', '<span class="pager-total-pages">' + (pages || 1) + '</span>');
          $('<li class="pager-count"><label>'+ text +' </label>').insertAfter(this.pagerBar.find('.pager-prev'));

          //Setup interactivty with the numeric page input
          var lastValue = null;

          this.pagerBar.find('.pager-count input')
          .on('focus', function () {
            lastValue = $(this).val();
          }).on('blur', function () {
            if (lastValue !== $(this).val()) {
              $(this).val(self.setActivePage(parseInt($(this).val()), false, 'page'));
            }
          }).on('keydown', function (e) {
            if (e.which === 13) {
              self.setActivePage(parseInt($(this).val()), false, 'page');
            }
          });
        }

        //Add functionality to change page size.
        if (this.isTable && this.pagerBar.find('.btn-menu').length === 0) {
          var pageSize = $('<li class="pager-pagesize"></li>'),
            pageSizeButton = $('<button type="button" class="btn-menu">' +
              '<span>' + Locale.translate('RecordsPerPage').replace('{0}', this.settings.pagesize) + '</span> ' +
              $.createIcon({ icon: 'dropdown' }) +
              ' </button>').appendTo(pageSize);

          pageSize.insertAfter(this.pagerBar.find('.pager-last'));

          var menu = $('<ul class="popupmenu has-icons"></ul>');

          for (var k = 0; k < self.settings.pagesizes.length; k++) {
            var size = self.settings.pagesizes[k];
            menu.append('<li '+ (size === self.settings.pagesize ? ' class="is-checked"' : '') +'><a href="#">' + size + '</a></li>');
          }

          pageSizeButton.after(menu);

          var popupOpts = {
            placementOpts: {
              parent: pageSizeButton,
              parentXAlignment: (this.isRTL ? 'left' : 'right'),
              strategies: ['flip']
            }
          };

          pageSizeButton.popupmenu(popupOpts).on('selected.pager', function (e, args) {
            var tag = args;
            tag.closest('.popupmenu').find('.is-checked').removeClass('is-checked');
            tag.parent('li').addClass('is-checked');
            self.settings.pagesize = parseInt(tag.text());

            if (self.settings.componentAPI) {
              self.settings.componentAPI.settings.pagesize = self.settings.pagesize;
            }
            self.setActivePage(1, true, 'first');
          });
        }

        var pattern = (''+ this._pageCount).replace(/\d/g, '#');
        this.pagerBar.find('.pager-count input').attr('data-mask', '').mask({pattern: pattern, mode: 'number', processOnInitialize: false});

        this._pageCount = this._pageCount || 1;

        return this._pageCount;
      },

      // Reliably gets all the pre-rendered elements in the container and returns them for use.
      getPageableElements: function() {
        var elements = this.element.children().not('.datagrid-expandable-row');

        // Adjust for cases where the root is a <ul>
        if (elements.is('ul')) {
          elements = elements.children();
        }

        return elements;
      },

      /**
       * Renders the pager bar based on derived or forced settings.
       * @private
       * @param {SohoPagingInfo} pagingInfo - an object containing information on how to render the pager.
       * @returns {undefined}
       */
      renderBar: function(pagingInfo) {
        //How many can fit?
        var pb = this.pagerBar,
          elems, pc,
          width = (this.element.parent().width() / pb.find('li:first').width()),
          VISIBLE_BUTTONS = 3, // Take out the ones that should be visible (buttons and selected)
          howMany = Math.floor(width - VISIBLE_BUTTONS);

        if (!pagingInfo) {
          pagingInfo = {};
        }

        //Check Data Attr
        if (this.element.attr('data-pagesize')) {
          this.settings.pagesize = this.element.attr('data-pagesize');
        }

        //Adjust Page count numbers
        if (!this.settings.source) {
          var pageableLength = this.getPageableElements().not('.is-filtered').length;
          pc = Math.ceil(pageableLength/this.settings.pagesize);

          if (this.isTable) {
            var isFiltered = function(value) {
              return !value.isFiltered;
            },
            dataLength = this.settings.dataset.filter(isFiltered).length;

            pc = Math.ceil(dataLength/this.settings.pagesize);
          }
          this.pageCount(pc);
        }

        // Update the input field's number
        this.pagerBar
          .find('.pager-count input').val(this.activePage);

        // Update the total number of pages
        if (this._pageCount !== '0' && !isNaN(this._pageCount)) {
          this.pagerBar.find('.pager-total-pages').text(this._pageCount);
        }

        // Update the number of records per page
        this.pagerBar.find('.btn-menu span')
          .text(Locale.translate('RecordsPerPage').replace('{0}', this.settings.pagesize));

        // Refresh Disabled
        var prev = pb.find('.pager-prev a'),
          next = pb.find('.pager-next a'),
          first = pb.find('.pager-first a'),
          last = pb.find('.pager-last a'),
          prevGroup = prev.add(first).add('.pager-prev').add('.pager-first'),
          nextGroup = next.add(last).add('.pager-next').add('.pager-last'),
          disabledAttrs = {'disabled': 'disabled', 'tabindex': -1};

        // Reset all pager buttons' disabled/focusable states
        this.pagerBar[0].classList.remove('hidden');
        prevGroup.add(nextGroup).removeAttr('disabled tabindex');

        // Explicit false turns buttons back on.
        if (pagingInfo.firstPage === false) {
          prevGroup.removeAttr('disabled').removeAttr('tabindex');
        }
        if (pagingInfo.lastPage === false) {
          nextGroup.removeAttr('disabled').removeAttr('tabindex');
        }

        // First page
        if (pagingInfo.firstPage === true || (pagingInfo.firstPage === undefined && this.activePage === 1)) {
          prevGroup.attr(disabledAttrs);

          if (pagingInfo.lastPage !== true) {
            nextGroup.attr({'tabIndex': 0});
          }
        }

        // Last page
        if (pagingInfo.lastPage === true || (pagingInfo.lastPage === undefined && this.activePage === this.pageCount())) {
          nextGroup.attr(disabledAttrs);

          if (pagingInfo.firstPage !== true) {
            prevGroup.attr({'tabindex': 0});
          }
        }

        // Hide the entire pager bar if we're only showing one page, if applicable
        if (this.settings.hideOnOnePage && pagingInfo.total <= pagingInfo.pagesize) {
          this.pagerBar[0].classList.add('hidden');
        }

        // Hide the entire pager bar if both sides are disabled, if applicable
        if ((pagingInfo.firstPage === true && pagingInfo.lastPage === true) && pagingInfo.hideDisabledPagers) {
          this.pagerBar[0].classList.add('hidden');
        }

        // Remove from the front until selected is visible and we have at least howMany showing
        // rowTemplate
        if (!this.settings.source) {
          elems = pb.find(PAGER_NON_NUMBER_BUTTON_SELECTOR);
          elems.show();
          if (elems.length < howMany) {
            return;
          }

          elems.each(function () {
            var li = $(this);
            if (pb.find('.pager-next').offset().top - pb.offset().top > 1 && !li.is('.selected')) {
              $(this).hide();
            }
          });

        }
      },

      // Render Paged Items
      renderPages: function(op) {
        var expr,
          self = this,
          request = {
            activePage: self.activePage,
            pagesize: self.settings.pagesize,
            type: op,
            total: self.settings.componentAPI ? self.settings.componentAPI.settings.dataset.length : -1
          };

        //Make an ajax call and wait
        setTimeout(function () {
          var doPaging = self.element.triggerHandler('beforepaging', request);
          if (doPaging === false) {
            return;
          }

          if (self.settings.source) {
            var response;

            response = function(data, pagingInfo) {
              //Render Data
              pagingInfo.preserveSelected = true;

              // Call out to the component's API to pull in dataset information.
              // This method should also tell the Pager how to re-render itself.
              self.settings.componentAPI.loadData(data, pagingInfo, true);

              setTimeout(function () {
                self.element.trigger('afterpaging', pagingInfo);
              },1);
              return;
            };

            if (self.settings.componentAPI.sortColumn && self.settings.componentAPI.sortColumn.sortId) {
              request.sortAsc = self.settings.componentAPI.sortColumn.sortAsc;
              request.sortField = self.settings.componentAPI.sortColumn.sortField;
              request.sortId = self.settings.componentAPI.sortColumn.sortId;
            }

            if (self.settings.componentAPI.filterExpr) {
               request.filterExpr = self.settings.componentAPI.filterExpr;
            }
            self.settings.source(request, response);
          }

          //Make an ajax call and wait
          self.element.trigger('paging', request);
          var elements = self.getPageableElements();

          //Render page objects
          if (!self.settings.source) {
            var rows = self.settings.pagesize;

            self.updatePagingInfo(request);

            if (self.settings.componentAPI && typeof self.settings.componentAPI.renderRows === 'function') {
              self.settings.componentAPI.renderRows();
            }

            elements.hide();

            //collapse expanded rows
            self.element.children()
              .filter('.datagrid-expandable-row.is-expanded')
                .removeClass('is-expanded').hide()
                .prev().removeClass('.is-expanded')
                  .find('.plus-minus').removeClass('active');

            expr = (self.activePage === 1 ? ':not(".is-filtered"):lt('+ rows +')' : ':not(".is-filtered"):lt('+ ((self.activePage) * rows) +'):gt('+ (((self.activePage-1) * rows) -1) +')');

            elements.filter(expr).show();
          } else {
            elements.show();
          }

          if (!self.settings.source) {
            self.element.trigger('afterpaging', request);
          }

        }, 0);
      },

      /**
       * Updates this instance of pager with externally-provided settings.
       * @param {Object} pagingInfo - contains settings that will change buttons on the pager.
       * @param {number} pagingInfo.pagesize - the number of items visible per page
       * @param {number} pagingInfo.total - the total number of pages
       * @param {number} pagingInfo.activePage - the currently visible page
       * @param {boolean} [pagingInfo.firstPage=false] - passed if the currently visible page is the first one
       * @param {boolean} [pagingInfo.lastPage=false] - passed if the currently visible page is the last one
       * @param {boolean} [pagingInfo.hideDisabledPagers=false] - causes the pager to become completely hidden if all buttons are disabled
       */
      updatePagingInfo: function(pagingInfo) {
        if (!pagingInfo) {
          return;
        }

        // Grab and retain the pagesize
        if (pagingInfo.pagesize) {
          this.settings.pagesize = pagingInfo.pagesize;
          if (this.isTable && this.settings.componentAPI) {
            this.settings.componentAPI.settings.pagesize = pagingInfo.pagesize;
          }
        }

        // Set a default total if none are defined.
        if (!pagingInfo.total) {
          pagingInfo.total = 0;
        }

        if (this.settings.source) {
          this._pageCount = Math.ceil(pagingInfo.total/this.settings.pagesize);
          //Set first and last page if passed
          // If we get a page number as a result, rendering has already happened and
          // we should not attempt to re-render.
          return this.setActivePage(pagingInfo, false, 'pageinfo');
        }

        this.renderBar(pagingInfo);
      },

      //Teardown
      destroy: function() {
        $.removeData(this.element[0], pluginName);
      }
    };

    // Initialize the plugin (Once)
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (!instance) {
        instance = $.data(this, pluginName, new Pager(this, settings));
      }
    });
  };


  //NOTE: Just this part will show up in SoHo Xi Builds.

  $.fn.place = function(options) {
    'use strict';

    // Settings and Options
    var pluginName = 'place',
        defaults = {
          bleedFromContainer: false, // If true, allows positioned content to bleed outside of a defined container.
          callback: null, // If defined, provides extra placement adjustments after the main calculation is performed.
          container: null, // If defined, contains the placement of the element to the boundaries of a specific container element.
          parent: null, // If defined, will be used as the reference element for placement this element.
          parentXAlignment: 'center',
          parentYAlignment: 'center', // Only used for parent-based placement. Determines the alignment of the placed element against its parent. value 0 === X, value 1 === Y
          placement: 'bottom', // If defined, changes the direction in which placement of the element happens
          strategies: ['nudge'] // Determines the "strategy" for alternatively placing the element if it doesn't fit in the defined boundaries.  Only matters when "parent" is a defined setting.  It's possible to define multiple strategies and execute them in order.
        },
        strategies = ['nudge', 'clockwise', 'flip', 'shrink', 'shrink-x', 'shrink-y'],
        placements = ['top', 'left', 'right', 'bottom', 'center'],
        xAlignments = ['left', 'center', 'right'],
        yAlignments = ['top', 'center', 'bottom'],
        settings = $.extend({}, defaults, options);

    /**
     * Object that contains coordinates along with temporary, changeable properties.
     * This object gets passed around the Place Behavior and modified during each phase of positioning.
     * This object is also passed to all callbacks and event listeners for further modification.
     * @constructor
     * @param {object} placementOptions
     */
    function PlacementObject(placementOptions) {
      var self = this,
        possibleSettings = [
          'x', 'y',
          'container', 'containerOffsetX', 'containerOffsetY',
          'callback',
          'parent', 'parentXAlignment', 'parentYAlignment',
          'useParentWidth', 'useParentHeight',
          'placement',
          'strategies'
        ];

      possibleSettings.forEach(function settingIterator(val) {
        if (placementOptions[val] === null) {
          return;
        }

        if (val === 'x' || val === 'y') {
          self.setCoordinate(val, placementOptions[val]);
          self['original' + val] = placementOptions[val];
          return;
        }

        self[val] = placementOptions[val];
      });

      this.modified = false;

      return this.sanitize();
    }

    PlacementObject.prototype = {
      isReasonableDefault: function(setting, limits) {
        return $.inArray(setting, limits) > -1;
      },

      sanitize: function() {
        var self = this;

        this.bleedFromContainer = this.bleedFromContainer === true;
        this.callback = (typeof this.callback === 'function') ? this.callback : settings.callback;
        this.container = (this.container instanceof $ && this.container.length) ? this.container : settings.container;
        this.containerOffsetX = !isNaN(parseInt(this.containerOffsetX)) ? this.containerOffsetX : 0;
        this.containerOffsetY = !isNaN(parseInt(this.containerOffsetY)) ? this.containerOffsetY : 0;
        this.parent = (this.parent instanceof $ && this.parent.length) ? this.parent : settings.parent;
        this.parentXAlignment = this.isReasonableDefault(this.parentXAlignment, xAlignments) ? this.parentXAlignment : settings.parentXAlignment;
        this.parentYAlignment = this.isReasonableDefault(this.parentYAlignment, yAlignments) ? this.parentYAlignment : settings.parentYAlignment;
        this.placement = this.isReasonableDefault(this.placement, placements) ? this.placement : settings.placement;
        this.useParentHeight = this.useParentHeight === true;
        this.useParentWidth = this.useParentWidth === true;

        if (!$.isArray(this.strategies) || !this.strategies.length) {
          this.strategies = ['nudge'];
        }
        this.strategies.forEach(function(strat, i) {
          self.strategies[i] = self.isReasonableDefault(strat, strategies) ? strat : self.strategies[i];
        });

      },

      setCoordinate: function(coordinate, value) {
        var coordinates = ['x', 'y'];
        if (!this.isReasonableDefault(coordinate, coordinates)) {
          return;
        }

        if (isNaN(value)) {
          value = 0;
        }

        this[coordinate] = parseInt(value, 10);
      }
    };

    // Place Behavior Constructor
    // This is the actual "thing" that is tied to a Placeable Element.
    function Place(element) {
      this.settings = $.extend({}, settings);
      this.element = $(element);
      this.init();
    }

    Place.prototype = {
      init: function() {
        //Do other init (change/normalize settings, load externals, etc)
        return this
          .build()
          .handleEvents();
      },

      // Add markup to the control
      build: function() {
        if (!this.element.hasClass('placeable')) {
          this.element.addClass('placeable');
        }

        // Setup a hash of original styles that will retain width/height whenever
        // the placement for this element is recalculated.
        this.originalStyles = {};
        var h = this.element[0].style.height,
          w = this.element[0].style.width;

        if (h) {
          this.originalStyles.height = h;
        }
        if (w) {
          this.originalStyles.width = w;
        }

        return this;
      },

      // Sets up event handlers for this control and its sub-elements
      handleEvents: function() {
        var self = this;

        this.element.on('place.' + pluginName, function placementEventHandler(e, x, y) {
          self.place(new PlacementObject({ x: x, y: y }));
        }).on('updated.' + pluginName, function updatedEventHandler() {
          self.updated();
        });

        return this;
      },

      // Actually renders an element with coordinates inside the DOM
      render: function(placementObj) {
        var unitRegex = /(px|%)/i;

        this.element.offset({
          'left': placementObj.x,
          'top': placementObj.y
        });

        if (placementObj.height) {
          this.element[0].style.height = placementObj.height + (unitRegex.test(placementObj.height + '') ? '' : 'px');
        }
        if (placementObj.width) {
          this.element[0].style.width = placementObj.width + (unitRegex.test(placementObj.width + '') ? '' : 'px');
        }
      },

      // Main placement API Method (external)
      // Can either take a PlacementObject as a single argument, or can take 2 coordinates (x, y) and
      // will use the pre-defined settings.
      place: function(placementObj) {
        var curr = [
          this.element[0].style.left,
          this.element[0].style.top,
        ];

        // Cancel placement with return:false; from a "beforeplace" event
        var canBePlaced = this.element.trigger('beforeplace', [curr]);
        if (!canBePlaced) {
          return curr;
        }

        if (!(placementObj instanceof PlacementObject)) {
          placementObj = new PlacementObject(placementObj);
        }

        // If no values are defined, simply return the current coordinates with a warning.
        if (placementObj.x == null && placementObj.y == null) {
          // TODO: Log a warning about not positioning stuff?
          return curr;
        }

        // Remove any previous placement styles
        this.clearOldStyles();

        // Use different methods if placement against a parent, versus straight-up coordinate placement
        if (placementObj.parent) {
          return this._placeWithParent(placementObj);
        }

        return this._placeWithCoords(placementObj);
      },

      // Placement Routine that expects a parent to be used as a base placement marking.
      // In this case, "x" and "y" integers are "relative" adjustments to the original numbers generated by the parent.
      // Can be modified by using a callback in the settings.
      _placeWithParent: function(placementObj) {
        if (!placementObj.parent || !placementObj.parent.length) {
          return [undefined, undefined]; // can't simply return x and y here because they are not coordinates, they are offsets
        }

        var self = this,
          parentRect = Soho.DOM.getDimensions(placementObj.parent[0]),
          elRect = Soho.DOM.getDimensions(this.element[0]),
          container = this.getContainer(placementObj),
          containerIsBody = container.length && container[0] === document.body,
          // NOTE: Usage of $(window) instead of $('body') is deliberate here - http://stackoverflow.com/a/17776759/4024149.
          // Firefox $('body').scrollTop() will always return zero.
          scrollX = containerIsBody ? $(window).scrollLeft() : container.scrollLeft(),
          scrollY = containerIsBody ? $(window).scrollTop() : container.scrollTop();

        if (placementObj.useParentWidth) {
          placementObj.width = parentRect.width;
        }
        if (placementObj.useParentHeight) {
          placementObj.height = parentRect.height;
        }

        function getCoordsFromPlacement(placementObj) {
          var cX, cY,
            p = placementObj.placement,
            aX = placementObj.parentXAlignment,
            aY = placementObj.parentYAlignment;

          // Set initial placements
          switch(p) {
            case 'top':
              cY = parentRect.top - elRect.height - placementObj.y + (containerIsBody ? scrollY : 0);
              break;
            case 'left':
              cX = parentRect.left - elRect.width - placementObj.x + (containerIsBody ? scrollX : 0);
              break;
            case 'right':
              cX = parentRect.right + placementObj.x + (containerIsBody ? scrollX : 0);
              break;
            default: // Bottom
              cY = parentRect.bottom + placementObj.y + (containerIsBody ? scrollY : 0);
              break;
          }

          // Set X alignments on bottom/top placements
          if (p === 'top' || p === 'bottom') {
            switch(aX) {
              case 'left':
                cX = parentRect.left - placementObj.x + (containerIsBody ? scrollX : 0);
                break;
              case 'right':
                cX = (parentRect.right - elRect.width) + placementObj.x + (containerIsBody ? scrollX : 0);
                break;
              default: // center
                cX = (parentRect.left + ((parentRect.width - elRect.width) / 2)) + placementObj.x + (containerIsBody ? scrollX : 0);
                break;
            }
          }

          // Set Y alignments on left/right placements
          if (p === 'right' || p === 'left') {
            switch(aY) {
              case 'top':
                cY = parentRect.top - placementObj.y + (containerIsBody ? scrollY : 0);
                break;
              case 'bottom':
                cY = (parentRect.bottom - elRect.height) + placementObj.y + (containerIsBody ? scrollY : 0);
                break;
              default: // center
                cY = (parentRect.top + ((parentRect.height - elRect.height) / 2)) + placementObj.y + (containerIsBody ? scrollY : 0);
                break;
            }
          }

          return [cX, cY];
        }

        function doPlacementAgainstParent(placementObj) {
          var coords = getCoordsFromPlacement(placementObj);
          placementObj.setCoordinate('x', coords[0]);
          placementObj.setCoordinate('y', coords[1]);
          self.render(placementObj);
          placementObj = self._handlePlacementCallback(placementObj);
          return placementObj;
        }

        // Simple placement logic
        placementObj = doPlacementAgainstParent(placementObj);

        // Adjusts the placement coordinates based on a defined strategy
        // Will only adjust the current strategy if bleeding outside the viewport/container are detected.
        placementObj.strategies.forEach(function(strat) {
          placementObj = self.checkBleeds(placementObj);

          if (placementObj.bleeds) {
            placementObj = (function(self) {
              switch(strat) {
                case 'nudge':
                  return self.nudge(placementObj);
                case 'clockwise':
                  return self.clockwise(placementObj);
                case 'flip':
                  placementObj = self.flip(placementObj);
                  placementObj.setCoordinate('x', placementObj.originalx);
                  placementObj.setCoordinate('y', placementObj.originaly);
                  placementObj = doPlacementAgainstParent(placementObj);
                  return placementObj;
                case 'shrink':
                  return self.shrink(placementObj);
                case 'shrink-x':
                  return self.shrink(placementObj, 'x');
                case 'shrink-y':
                  return self.shrink(placementObj, 'y');
                default:
                  return placementObj;
              }
            })(self);

            self.render(placementObj);
          }
        });

        // Trigger an event to notify placement has ended
        this.element.trigger('afterplace', [placementObj]);

        return placementObj;
      },

      // Basic Placement Routine that simply accepts X and Y coordinates.
      // In this case, "x" and "y" integers are "absolute" and will be the base point for placement.
      // Can be modified by using a callback in the settings.
      _placeWithCoords: function(placementObj) {
        this.render(placementObj);

        placementObj = this._handlePlacementCallback(placementObj);

        this.render(placementObj);

        // Coordinate placement can only be "nudged" (strategy is not used in this style of placement).
        placementObj = this.checkBleeds(placementObj);
        if (placementObj.bleeds) {
          placementObj = this.nudge(placementObj);
        }

        // Place again
        this.render(placementObj);

        placementObj = this.checkBleeds(placementObj);
        if (placementObj.bleeds) {
          placementObj = this.shrink(placementObj);
        }

        this.render(placementObj);

        this.element.trigger('afterplace', [
          placementObj
        ]);

        return placementObj;
      },

      // Perform callback, if it exists
      // Callback should return an array containing the modified coordinate values: [x, y];
      // NOTE: These are actual coordinates in all cases.  They are not relative values - they are absolute
      _handlePlacementCallback: function(placementObj) {
        var cb = placementObj.callback || this.settings.callback;

        if (cb && typeof cb === 'function') {
          placementObj = cb(placementObj);
        }

        this.render(placementObj);
        return placementObj;
      },

      // Gets a parent container element.
      getContainer: function(placementObj) {
        if (placementObj.container instanceof $ && placementObj.container.length) {
          return placementObj.container;
        }

        var modalParent = this.element.parents('.modal');
        if (modalParent.length) {
          return modalParent;
        }

        return $(document.body);
      },

      // Re-adjust a previously-placed element to account for bleeding off the edges.
      // Element must fit within the boundaries of the page or it's current scrollable pane.
      checkBleeds: function(placementObj) {
        var containerBleed = this.settings.bleedFromContainer,
          container = this.getContainer(placementObj),
          containerIsBody = container.length && container[0] === document.body,
          BoundingRect = this.element[0].getBoundingClientRect(),
          rect = {},
          containerRect = container ? container[0].getBoundingClientRect() : {},
          // NOTE: Usage of $(window) instead of $('body') is deliberate here - http://stackoverflow.com/a/17776759/4024149.
          // Firefox $('body').scrollTop() will always return zero.
          scrollX = containerIsBody ? $(window).scrollLeft() : container.scrollLeft(),
          scrollY = containerIsBody ? $(window).scrollTop() : container.scrollTop(),
          windowH = Math.max(document.documentElement.clientHeight, window.innerHeight || 0),
          windowW = Math.max(document.documentElement.clientWidth, window.innerWidth || 0),
          d;

          rect.width = BoundingRect.width;
          rect.height = BoundingRect.height;
          rect.top = BoundingRect.top;
          rect.right = BoundingRect.right;
          rect.bottom = BoundingRect.bottom;
          rect.left = BoundingRect.left;

        function getBoundary(edge) {
          switch(edge) {
            case 'top':
              return (containerBleed ? 0 : containerRect.top) - (!containerIsBody ? 0 : scrollY * -1); // 0 === top edge of viewport
            case 'left':
              return (containerBleed ? 0 : containerRect.left) - (!containerIsBody ? 0 : scrollX * -1); // 0 === left edge of viewport
            case 'right':
              return (containerBleed ? windowW : containerRect.right) - (!containerIsBody ? 0 : scrollX * -1);
            default: // bottom
              return (containerBleed ? windowH : containerRect.bottom) - (!containerIsBody ? 0 : scrollY * -1);
          }
        }

        // If element width is greater than window width, shrink to fit
        var rightViewportEdge = getBoundary('right');
        if (rect.width >= rightViewportEdge) {
          d = rect.width - rightViewportEdge;
          var newWidth = rect.width - d;
          placementObj.width = newWidth;

          this.element[0].style.width = newWidth + 'px';
          rect.width = newWidth; // reset the rect because the size changed
        }

        // If element height is greater than window height, shrink to fit
        var bottomViewportEdge = getBoundary('bottom');
        if (rect.height >= bottomViewportEdge) {
          d = rect.height - bottomViewportEdge;
          var newHeight = rect.height - d;
          placementObj.height = newHeight;

          this.element[0].style.height = newHeight + 'px';
          rect.height = newHeight; // reset the rect because the size changed
        }

        // build conditions
        var offRightEdge = rect.right > getBoundary('right'),
            offLeftEdge = rect.left < getBoundary('left'),
            offTopEdge = rect.top < getBoundary('top'),
            offBottomEdge = rect.bottom > getBoundary('bottom');

        // Return if no bleeding is detected (no need to fix anything!)
        if (!offRightEdge && !offLeftEdge && !offTopEdge && !offBottomEdge) {
          placementObj.bleeds = undefined;
          return placementObj;
        }

        // Keep a record of bleeds that need to be adjusted, and by what values
        placementObj.bleeds = {};
        placementObj.bleeds.right = offRightEdge ? (rect.right - getBoundary('right')) : null;
        placementObj.bleeds.left = offLeftEdge ? -(rect.left - getBoundary('left')) : null;
        placementObj.bleeds.top = offTopEdge ? -(rect.top - getBoundary('top')) : null;
        placementObj.bleeds.bottom = offBottomEdge ? (rect.bottom - getBoundary('bottom')) : null;

        return placementObj;
      },

      // Bumps the element around in each direction
      nudge: function(placementObj) {
        if (!placementObj.nudges) {
          placementObj.nudges = {x: 0, y: 0};
        }

        var d = 0;
        if (placementObj.bleeds.right) {
          d = Math.abs(placementObj.bleeds.right) + Math.abs(placementObj.containerOffsetX);
          placementObj.setCoordinate('x', placementObj.x - d);
          placementObj.nudges.x = placementObj.nudges.x - d;
        }
        if (placementObj.bleeds.left) {
          d = Math.abs(placementObj.bleeds.left) + Math.abs(placementObj.containerOffsetX);
          placementObj.setCoordinate('x', placementObj.x + d);
          placementObj.nudges.x = placementObj.nudges.x + d;
        }
        if (placementObj.bleeds.top) {
          d = Math.abs(placementObj.bleeds.top) + Math.abs(placementObj.containerOffsetY);
          placementObj.setCoordinate('y', placementObj.y + d);
          placementObj.nudges.y = placementObj.nudges.y + d;
        }
        if (placementObj.bleeds.bottom) {
          d = Math.abs(placementObj.bleeds.bottom) + Math.abs(placementObj.containerOffsetY);
          placementObj.setCoordinate('y', placementObj.y - d);
          placementObj.nudges.y = placementObj.nudges.y - d;
        }

        placementObj.wasNudged = true;
        placementObj.bleeds = undefined;

        return placementObj;
      },

      flip: function(placementObj) {
        // Don't attempt to flip if there was no bleeding on the edge we're attempting to leave from.
        if (!placementObj.bleeds[placementObj.placement]) {
          return placementObj;
        }

        if (!placementObj.attemptedFlips) {
          placementObj.attemptedFlips = [];
        }
        placementObj.attemptedFlips.push(placementObj.placement);

        // If we've tried flipping in all directions, give up and use the default placement.
        if (placementObj.attemptedFlips.length > 3) {
          placementObj = this.giveup(placementObj);
          return placementObj;
        }

        var isXCoord = ['left', 'right'].indexOf(placementObj.placement) > -1,
          containerBleed = this.settings.bleedFromContainer,
          container = this.getContainer(placementObj),
          containerIsBody = container.length && container[0] === document.body,
          containerRect = container ? container[0].getBoundingClientRect() : {},
          parentRect = placementObj.parent[0].getBoundingClientRect(),
          // NOTE: Usage of $(window) instead of $('body') is deliberate here - http://stackoverflow.com/a/17776759/4024149.
          // Firefox $('body').scrollTop() will always return zero.
          scrollX = containerIsBody ? $(window).scrollLeft() : container.scrollLeft(),
          scrollY = containerIsBody ? $(window).scrollTop() : container.scrollTop(),
          windowH = Math.max(document.documentElement.clientHeight, window.innerHeight || 0),
          windowW = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);

        function getOppositeDir(dir) {
          switch(dir) {
            case 'left':
              return 'right';
            case 'right':
              return 'left';
            case 'top':
              return 'bottom';
            default: // bottom
              return 'top';
          }
        }

        // Gets the distance between an edge on the target element, and its opposing viewport border
        function getDistance(dir) {
          var d = 0;

          switch (dir) {
            case 'left':
              d = (containerBleed ? 0 : containerRect.left) - (!containerIsBody ? scrollX : 0) - parentRect.left + placementObj.containerOffsetX;
              break;
            case 'right':
              d = ((containerBleed ? windowW : containerRect.right) - (!containerIsBody ? scrollX : 0)) - parentRect.right - placementObj.containerOffsetX;
              break;
            case 'top':
              d = (containerBleed ? 0 : containerRect.top) - (!containerIsBody ? scrollY : 0) - parentRect.top + placementObj.containerOffsetY;
              break;
            default: // bottom
              d = ((containerBleed ? windowH : containerRect.bottom) - (!containerIsBody ? scrollY : 0)) - parentRect.bottom - placementObj.containerOffsetY;
              break;
          }

          return Math.abs(d);
        }

        function tried(placement) {
          return $.inArray(placement, placementObj.attemptedFlips) > -1;
        }

        function performFlip(originalDir) {
          var newDir = getOppositeDir(originalDir),
            perpendicularDir = isXCoord ? 'top' : 'left',
            oppPerpendicularDir = getOppositeDir(perpendicularDir),
            originalDistance = getDistance(originalDir),
            targetDistance = getDistance(newDir);

          if (!tried(newDir)) {
            if (originalDistance >= targetDistance) {
              return originalDir;
            }

            placementObj.wasFlipped = true;
            return newDir;
          }

          // switch the coordinate definitions
          // since the axis for placement is flipped, our coordinate offsets should also flip
          var tmp = placementObj.originalx;
          placementObj.originalx = placementObj.originaly;
          placementObj.originaly = tmp;

          var perpendicularDistance = getDistance(perpendicularDir),
            oppPerpendicularDistance = getDistance(oppPerpendicularDir);

          if (!tried(perpendicularDir)) {
            if (perpendicularDistance >= oppPerpendicularDistance) {
              return perpendicularDir;
            }

            if (!tried(oppPerpendicularDir)) {
              return oppPerpendicularDir;
            }
          }

          return originalDir;
        }

        placementObj.placement = performFlip(placementObj.placement);

        return placementObj;
      },

      // TODO: Move Clockwise
      clockwise: function(placementObj) {
        return placementObj;
      },

      // If element height/width is greater than window height/width, shrink to fit
      shrink: function(placementObj, dimension) {
        var containerBleed = this.settings.bleedFromContainer,
          container = this.getContainer(placementObj),
          containerRect = container ? container[0].getBoundingClientRect() : {},
          containerIsBody = container.length && container[0] === document.body,
          rect = this.element[0].getBoundingClientRect(),
          useX = dimension === undefined || dimension === null || dimension === 'x',
          useY = dimension === undefined || dimension === null || dimension === 'y',
          // NOTE: Usage of $(window) instead of $('body') is deliberate here - http://stackoverflow.com/a/17776759/4024149.
          // Firefox $('body').scrollTop() will always return zero.
          scrollX = containerIsBody ? $(window).scrollLeft() : container.scrollLeft(),
          scrollY = containerIsBody ? $(window).scrollTop() : container.scrollTop(),
          windowH = Math.max(document.documentElement.clientHeight, window.innerHeight || 0),
          windowW = Math.max(document.documentElement.clientWidth, window.innerWidth || 0),
          leftViewportEdge = (containerBleed ? 0 : containerRect.left + placementObj.containerOffsetX) + scrollX,
          topViewportEdge = (containerBleed ? 0 : containerRect.top + placementObj.containerOffsetY) + scrollY,
          rightViewportEdge = (containerBleed ? windowW : containerRect.right - placementObj.containerOffsetX) + scrollX,
          bottomViewportEdge = (containerBleed ? windowH : containerRect.bottom - placementObj.containerOffsetY) + scrollY,
          d;

        // Shrink in each direction.
        // The value of the "containerOffsets" is "factored out" of each calculation, if for some reason the
        // element is larger than the viewport/container space allowed.
        placementObj.nudges = placementObj.nudges || {};

        if (useX) {
          // Left
          if (rect.left < leftViewportEdge) {
            d = Math.abs(leftViewportEdge - rect.left);
            if (rect.right >= rightViewportEdge) {
              d = d - placementObj.containerOffsetX;
            }
            placementObj.width = rect.width - d;
            placementObj.setCoordinate('x', placementObj.x + d);
            placementObj.nudges.x = placementObj.nudges.x + d;
          }

          // Right
          if (rect.right > rightViewportEdge) {
            d = Math.abs(rect.right - rightViewportEdge);
            if (rect.left <= leftViewportEdge) {
              d = d - placementObj.containerOffsetX;
            }
            placementObj.width = rect.width - d;
          }
        }

        if (useY) {
          // Top
          if (rect.top < topViewportEdge) {
            d = Math.abs(topViewportEdge - rect.top);
            if (rect.bottom >= bottomViewportEdge) {
              d = d - placementObj.containerOffsetY;
            }
            placementObj.height = rect.height - d;
            placementObj.setCoordinate('y', placementObj.y + d);
            placementObj.nudges.y = placementObj.nudges.y + d;
          }

          // Bottom
          if (rect.bottom > bottomViewportEdge) {
            d = Math.abs(rect.bottom - bottomViewportEdge);
            if (rect.top <= topViewportEdge) {
              d = d - placementObj.containerOffsetY;
            }
            placementObj.height = rect.height - d;
          }
        }

        return placementObj;
      },

      // Giving up causes all the placementObj settings to revert
      giveup: function(placementObj) {
        placementObj.giveup = true;
        placementObj.strategy = this.settings.strategy;
        placementObj.placement = this.settings.placement;
        return placementObj;
      },

      // Clears the old styles that may be present
      clearOldStyles: function() {
        this.element[0].style.left = '';
        this.element[0].style.top = '';
        this.element[0].style.width = '';
        this.element[0].style.height = '';

        var os = this.originalStyles;
        if (os) {
          if (os.width) {
            this.element[0].style.width = os.width;
          }

          if (os.height) {
            this.element[0].style.height = os.height;
          }
        }

        return this;
      },

      // Built-in method for handling positon of optional arrow elements.
      // Used for tooltip/popovers/popupmenus
      setArrowPosition: function(e, placementObj, element) {
        var target = placementObj.parent,
          arrow = element.find('div.arrow'),
          dir = placementObj.placement,
          isXCoord = ['left', 'right'].indexOf(dir) > -1,
          targetRect = {},
          elementRect = element[0].getBoundingClientRect(),
          arrowRect = {},
          newArrowRect = {},
          hideArrow = false;

        if (!target || !target.length || !arrow.length) {
          return;
        }

        arrow[0].removeAttribute('style');

        //if (placementObj.attemptedFlips) { TJM Removed for pager bug. Seems to work.
          element.removeClass('top right bottom left').addClass(dir);
        //}

        // Flip the arrow if we're in RTL mode
        if (this.isRTL && isXCoord) {
          var opposite = dir === 'right' ? 'left' : 'right';
          element.removeClass('right left').addClass(opposite);
        }

        // Custom target for some scenarios
        if (target.is('.colorpicker')) {
          target = target.next('.trigger');
        }
        if (target.is('.datepicker, .timepicker')) {
          target = target.next('.icon');
        }
        if (target.is('.btn-split-menu, .btn-menu, .btn-actions, .btn-filter, .tab, .tab-more')) {
          target = target.find('.icon').last();
        }
        if (target.is('.searchfield-category-button')) {
          target = target.find('.icon.icon-dropdown');
        }
        if (target.is('.colorpicker-editor-button')) {
          target = target.find('.trigger .icon');
        }

        // reset if we borked the target
        if (!target.length) {
          target = placementObj.parent;
        }

        targetRect = target.length ? target[0].getBoundingClientRect() : targetRect;
        arrowRect = arrow.length ? arrow[0].getBoundingClientRect() : arrowRect;
        newArrowRect = {};

        function getMargin(placement) {
          return (placement === 'right' || placement === 'left') ? 'margin-top' : 'margin-left';
        }

        function getDistance() {
          var targetCenter = 0,
            currentArrowCenter = 0,
            d = 0;

          if (dir === 'left' || dir === 'right') {
            targetCenter = targetRect.top + (targetRect.height/2);
            currentArrowCenter = arrowRect.top + (arrowRect.height/2);
            d = targetCenter - currentArrowCenter;
            newArrowRect.top = arrowRect.top + d;
            newArrowRect.bottom = arrowRect.bottom + d;

            if (newArrowRect.top <= elementRect.top || newArrowRect.bottom >= elementRect.bottom) {
              hideArrow = true;
            }
          }
          if (dir === 'top' || dir === 'bottom') {
            targetCenter = targetRect.left + (targetRect.width/2);
            currentArrowCenter = arrowRect.left + (arrowRect.width/2);
            d = targetCenter - currentArrowCenter;
            newArrowRect.left = arrowRect.left + d;
            newArrowRect.right = arrowRect.right + d;

            if (newArrowRect.left <= elementRect.left || newArrowRect.right >= elementRect.right) {
              hideArrow = true;
            }
          }

          return d;
        }

        // line the arrow up with the target element's "dropdown icon", if applicable
        var positionOpts = {};
        positionOpts[getMargin(dir)] = getDistance();
        if (hideArrow) {
          positionOpts.display = 'none';
        }
        arrow.css(positionOpts);
      },

      //Handle Updating Settings
      updated: function() {
        return this
          .teardown()
          .init();
      },

      // Simple Teardown - remove events & rebuildable markup.
      teardown: function() {
        this.clearOldStyles();
        this.element.removeClass('placeable');

        this.element.off('updated.' + pluginName + ' place.' + pluginName);

        this.element.trigger('afterteardown');
        return this;
      },

      // Teardown - Remove added markup and events
      destroy: function() {
        this.teardown();
        $.removeData(this.element[0], pluginName);
      }
    };

    // Initialize the plugin (Once)
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (instance) {
        instance.settings = $.extend({}, instance.settings, options);
        instance.updated();
      } else {
        instance = $.data(this, pluginName, new Place(this, settings));
      }
    });
  };


  //NOTE: Just this part will show up in SoHo Xi Builds.

  $.fn.popdown = function(options) {

    'use strict';

    // Settings and Options
    var pluginName = 'popdown',
        defaults = {},
        settings = $.extend({}, defaults, options);

    /**
     * @constructor
     * @param {Object} element
     */
    function Popdown(element) {
      this.settings = $.extend({}, settings);
      this.element = $(element);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    // Plugin Methods
    Popdown.prototype = {

      init: function() {
        return this
          .setup()
          .build()
          .handleEvents();
      },

      setup: function() {
        var self = this;
        this.popdown = $();

        // Setup the proper trigger element to use
        this.trigger = this.element;
        if (this.trigger.is('.dropdown, .multiselect')) {
          this.trigger = $('#' + this.element.attr('id') + '-shdo');
        }

        // Find the correct element to use as the popdown's view.
        function tryPopdownElement(elem) {
          if (!elem) { return false; }

          if (typeof elem === 'string') {
            if (!elem.match('#') || elem.indexOf('#') !== 0) {
              elem = '#' + elem;
            }
            elem = $(elem);
          }

          if (elem.length) {
            self.popdown = elem;
            return true;
          }

          return false;
        }

        var popdownElem = tryPopdownElement(this.trigger.attr('data-popdown'));
        if (!popdownElem) {
          tryPopdownElement(this.trigger.next('.popdown'));
        }

        // Setup an ID for this popdown if it doesn't already have one
        this.id = this.popdown.attr('id');
        if (!this.id) {
          this.id = 'popdown-' + $('body').find('.popdown').index(this.popdown);
          this.popdown.attr('id', this.id);
        }

        return this;
      },

      build: function() {
        // Ensure the popdown window is a popdown, and remove any hidden classes from it.
        this.popdown.addClass('popdown').removeClass('hidden');

        // Wrap the contents inside for spacing purposes
        var contents = this.popdown.children('.popdown-contents');
        if (!contents.length) {
          this.popdown.children().wrap('<div class="popdown-contents"></div>');
        }

        // Add the arrow markup if it doesn't already exist
        this.arrow = $('<div class="arrow"></div>').prependTo(this.popdown);

        this.place();

        // Expand if necessary
        var ariaExpanded = this.trigger.attr('aria-expanded');
        if (!ariaExpanded || ariaExpanded === undefined) {
          this.trigger.attr('aria-expanded', '');
        }
        if (ariaExpanded === 'true') {
          this.open();
        }

        // aria-controls for the trigger element
        this.trigger.attr('aria-controls', this.id);

        return this;
      },

      handleEvents: function() {
        var self = this;

        this.trigger
          .onTouchClick('popdown')
          .on('click.popdown', function() {
            self.toggle();
          })
          .on('updated.popdown', function() {
            self.updated();
          });

        return this;
      },

      isOpen: function() {
        return this.trigger.attr('aria-expanded') === 'true';
      },

      open: function() {
        if (this.isAnimating) {
          return;
        }

        var self = this,
          setFocusinEvent = false;

        this.isAnimating = true;
        this.trigger.attr('aria-expanded', 'true');
        this.position();
        this.popdown.addClass('visible');

        // Setup events that happen on open
        // Needs to be on a timer to prevent automatic closing of popdown.
        setTimeout(function() {
          self.popdown.one('focusin.popdown', function() {
            if (!setFocusinEvent) {
              setFocusinEvent = true;
              $(document).on('focusin.popdown', function(e) {
                var target = e.target;
                if (!$.contains(self.popdown[0], target)) {
                  self.close();
                }
              });
            }
          });

          $('body').on('resize.popdown', function() {
            if (!$(document.activeElement).closest('.popdown').length) {
              self.close();
            }
          });

          $(document).on('click.popdown', function(e) {
            var target = $(e.target);

            if (!target.is('.popdown') && !target.closest('.popdown').length) {
              self.close();
            }
          });

          self.isAnimating = false;
        }, 400);
      },

      close: function() {
        if (this.isAnimating) {
          return;
        }

        var self = this;
        this.isAnimating = true;
        this.trigger.attr('aria-expanded', 'false');
        this.popdown.removeClass('visible');

        // Turn off events
        this.popdown.off('focusin.popdown');
        $('body').off('resize.popdown');
        $(document).off('click.popdown focusin.popdown');

        // Sets the element to "display: none" to prevent interactions while hidden.
        setTimeout(function() {
          self.popdown[0].style.display = 'none';
          self.isAnimating = false;
        }, 400);
      },

      toggle: function() {
        if (this.isOpen()) {
          this.close();
          return;
        }
        this.open();
      },

      // Detaches Popdown Element and places at the body tag root, or at the root of the nearest
      // scrollable parent.
      place: function() {
        this.scrollparent = $('body');
        this.popdown.detach().appendTo(this.scrollparent);
      },

      position: function() {
        var parent = {
          offset: {
            left: 0,
            top: 0
          },
          scrollDistance: {
            left: 0,
            top: 0
          }
        },
        winH = window.innerHeight + $(document).scrollTop(),
        // subtract 2 from the window width to account for the tooltips
        // resizing themselves to fit within the CSS overflow boundary.
        winW = (window.innerWidth - 2) + $(document).scrollLeft();

        // Reset adjustments to panel and arrow
        this.popdown.removeAttr('style');
        this.arrow.removeAttr('style');

        // Add/subtract offsets if a scrollable parent element is involved
        if (this.scrollparent.length) {
          parent.offset = this.scrollparent.offset();
          parent.scrollDistance.top = this.scrollparent.scrollTop();
          parent.scrollDistance.left = this.scrollparent.scrollLeft();
          winH = winH - (parent.offset.top + parent.scrollDistance.top);
          winW = winW - (parent.offset.left + parent.scrollDistance.left);
        }

        var adjustX = false,
          adjustY = false,
          t = this.trigger,
          to = t.offset(), // Trigger offset
          arrowHeight = 11,
          XoffsetFromTrigger = 0,
          YoffsetFromTrigger = 0,
          po; // Popover offset

        // Place the popdown below to start
        this.popdown.addClass('bottom');

        this.popdown[0].style.left = to.left + 'px';
        this.popdown[0].style.top = (to.top + t.outerHeight(true) + arrowHeight) + 'px';

        this.arrow[0].style.left = (t.outerWidth(true)/2) + 'px';
        this.arrow[0].style.top = (0 - arrowHeight) + 'px';

        // Get the newly-set values for the popdown's offset
        po = this.popdown.offset();

        // Get deltas for popdown position if the button is off either X edge
        if (po.left < 0) { // Checking the left edge
          adjustX = true;
          XoffsetFromTrigger = 0 - po.left;
        }
        var rightEdgePos = po.left + this.popdown.outerWidth(true);
        if (rightEdgePos > winW) { // Checking the right edge
          adjustX = true;
          XoffsetFromTrigger = rightEdgePos - winW + (Locale.isRTL() ? 20 : 0);
        }

        if (adjustX) {
          // Adjust the X position based on the deltas
          this.popdown[0].style.left = (po.left + (XoffsetFromTrigger * -1)) + 'px';

          var popdownRect = this.popdown[0].getBoundingClientRect(),
            triggerRect = t[0].getBoundingClientRect(),
            deltaRightEdge = popdownRect.right - triggerRect.right + 10;

          this.arrow[0].style.left = 'auto';
          this.arrow[0].style.right = deltaRightEdge+ 'px';


          // Get the newly set values
          po = this.popdown.offset();
        }

        // Get the deltas for popdown position if the button is off either Y edge
        if (po.top < 0) { // Checking top edge
          adjustY = true;
          YoffsetFromTrigger = 0 - po.top;
        }
        var bottomEdgePos = po.top + this.popdown.outerHeight(true);
        if (bottomEdgePos > winH) { // Checking the bottom edge
          adjustY = true;
          YoffsetFromTrigger = bottomEdgePos - winH;
        }

        // Remove the arrow if we need to adjust this, since it won't line up anymore
        if (adjustY) {
          this.arrow[0].style.display = 'none';

          // Adjust the Y position based on the deltas
          this.popdown[0].style.top = (po.top + (YoffsetFromTrigger * -1)) + 'px';
          this.arrow[0].style.top = (parseInt(this.arrow[0].style.top) - (YoffsetFromTrigger * -1)) + 'px';

          // Get the values again
          po = this.popdown.offset();
        }

        // One last check of the Y edges.  At this point, if either edge is out of bounds, we need to
        // shrink the height of the popdown, as it's too tall for the viewport.
        if (po.top < 0 || po.top + this.popdown.outerHeight(true) > winH) {
          this.popdown[0].style.top = 0;
          po = this.popdown.offset();

          bottomEdgePos = po.top + this.popdown.outerHeight(true);
          this.popdown[0].style.height = (parseInt(this.popdown[0].style.height) - (bottomEdgePos - winH)) + 'px';
        }
      },

      updated: function() {
        return this;
      },

      teardown: function() {
        if (this.isOpen()) {
          this.close();
        }

        this.trigger
          .offTouchClick('popdown')
          .off('updated.popdown click.popdown')
          .removeAttr('aria-controls')
          .removeAttr('aria-expanded');

        if (this.originalParent && this.originalParent.length) {
          this.popdown.detach().appendTo(this.originalParent);
        }

        this.arrow.remove();

        return this;
      },

      // Teardown - Remove added markup and events
      destroy: function() {
        this.teardown();
        $.removeData(this.element[0], pluginName);
      }
    };

    // Initialize the plugin (Once)
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (instance) {
        instance.settings = $.extend({}, instance.settings, options);
        instance.updated();
      } else {
        instance = $.data(this, pluginName, new Popdown(this, settings));
      }
    });
  };


  $.fn.popupmenu = function(options) {

    // Settings and Options
    var pluginName = 'popupmenu',
      defaults = {
        menu: null,  //Menu's ID Selector, or a jQuery object representing a menu
        trigger: 'click',  //click, rightClick, immediate ect
        autoFocus: true,
        mouseFocus: true,
        attachToBody: false,
        beforeOpen: null, //Ajax callback for open event
        ariaListbox: false,   //Switches aria to use listbox construct instead of menu construct (internal)
        useCoordsForClick: false, //By default, menus open up underneath their target element.  Set this to true to use mouse coordinates for positioning a menu inside of its target element.
        eventObj: undefined,  //Can pass in the event object so you can do a right click with immediate,
        placementOpts: { // Gets passed to this control's Place behavior
          containerOffsetX: 10,
          containerOffsetY: 10,
          strategies: ['flip', 'shrink']
        },
        offset: {
          x: 0,
          y: 0,
        }
      },
      settings = $.extend({}, defaults, options);

    /**
     * Responsive Popup Menu Control (Context)
     * @constructor
     * @param {Object} element
     */
    function PopupMenu(element) {
      this.settings = $.extend({}, settings);
      this.element = $(element);
      this.isOldIe  = $('html').is('.ie11, .ie10, .ie9');
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    // Plugin Object
    PopupMenu.prototype = {
      init: function() {
        this.setup();
        this.addMarkup();
        this.handleEvents();
        this.iconFilteringSetup();

        // Allow for an external click event to be passed in from outside this code.
        // This event can be used to pass clientX/clientY coordinates for mouse cursor positioning.
        if (this.settings.trigger === 'immediate') {
          this.open(this.settings.eventObj);
        }

        // Use some css rules on submenu parents
        if (this.menu.find('.submenu').length) {
          this.menu.addClass('has-submenu');
        }
      },

      isRTL: function() {
        return $('html').attr('dir') === 'rtl';
      },

      setup: function() {
        if (this.element.attr('data-popupmenu') && !this.settings.menu) {
          this.settings.menu = this.element.attr('data-popupmenu').replace(/#/g, '');
        }
        // Backwards compatibility for "menuId" menu options coming from other controls
        // that utilize the Popupmenu.
        if (this.settings.menuId) {
          this.settings.menu = this.settings.menuId;
          this.settings.menuId = undefined;
        }

        // keep track of how many popupmenus there are with an ID.
        // Used for managing events that are bound to $(document)
        if (!this.id) {
          this.id = (parseInt($('.popupmenu-wrapper').length, 10)+1).toString();
        }
      },

      //Add markip including Aria
      addMarkup: function () {
        var id,
          leftClick = this.settings.trigger !== 'rightClick',
          immediate = this.settings.trigger === 'immediate';

        switch(typeof this.settings.menu) {
          case 'string': // ID Selector
            id = this.settings.menu;
            this.menu = $('#' + this.settings.menu);
            break;
          case 'object': // jQuery Object
            if (this.settings.menu === null) {
              this.menu = this.element.next('.popupmenu, .popupmenu-wrapper');
            } else {
              this.menu = $(this.settings.menu);
            }

            id = this.menu.attr('id');
            if (!id || id === '') {
              this.menu.attr('id', 'popupmenu-' + this.id);
              id = this.menu.attr('id');
            }
            break;
        }

        // If markup already exists for the wrapper, use that instead of rebuilding.
        if (this.menu.is('.popupmenu-wrapper')) {
          this.preExistingWrapper = true;
          this.wrapper = this.menu;
          this.menu = this.wrapper.children('.popupmenu').first();
        }

        // Similar check as above, assuming the menu wasn't a popupmenu wrapper.
        if (this.menu.parent().is('.popupmenu-wrapper')) {
          this.preExistingWrapper = true;
          this.wrapper = this.menu.parent();
        }

        // If we still don't have a menu reference at this point, fail gracefully by returning out
        // and simply acting like a button.
        if (this.menu.length === 0) {
          return false;
        }

        // if the menu is deeply rooted inside the markup, detach it and append it to the <body> tag
        // to prevent containment issues. (Now a Preference)
        if (this.settings.attachToBody && this.menu.parent().not('body').length > 0) {
          this.originalParent = this.menu.parent();
          this.menu.detach().appendTo('body');
        }

        if (!this.menu.is('.popupmenu')) {
          this.menu.addClass('popupmenu')
            .attr('role', (this.settings.ariaListbox ? 'listbox' : 'menu'));
        }

        // Always store a reference to the trigger element under jQuery data.
        this.menu.data('trigger', this.element);

        this.wrapper = this.menu.parent('.popupmenu-wrapper');
        if (!this.wrapper.length) {
          this.wrapper = this.menu.wrap('<div class="popupmenu-wrapper"></div>');
        }

        // Invoke all icons as icons
        this.wrapper.find('svg').each(function() {
          if (!$(this).data('icon')) {
            $(this).icon();
          }
        });

        //Enforce Correct Modality
        this.menu.parent('.popupmenu-wrapper').attr('role', 'application').attr('aria-hidden', 'true');

        // Use "absolute" positioning on the menu insead of "fixed", only when the
        // menu lives <body> tag and we have a <body> element that is tall enough to
        // scroll and is allowed to scroll.
        function scrollableFilter() {
          var c = this ? this.style.overflow : null;
          return c !== 'auto' && c !== 'visible' && c !== 'scroll';
        }
        if (this.wrapper.parents().filter(scrollableFilter).length === 0) {
          this.wrapper[0].style.position = 'absolute';
        }

        // Wrap submenu ULs in a 'wrapper' to help break it out of overflow.
        this.menu.find('.popupmenu').each(function(i, elem) {
          var popup = $(elem);

          if (!(popup.parent().hasClass('wrapper'))) {
            popup.wrap('<div class="wrapper"></div>');
          }
        });

        // If the trigger element is a button with no border append arrow markup
        var containerClass = this.element.parent().attr('class');
        if ((this.element.hasClass('btn-menu') ||
            this.element.hasClass('btn-actions') ||
            this.settings.menu === 'colorpicker-menu' ||
            this.element.closest('.toolbar').length > 0 ||
            this.element.closest('.masthead').length > 0 ||
            this.element.is('.searchfield-category-button') ||
            (containerClass && containerClass.indexOf('more') >= 0) ||
            containerClass && containerClass.indexOf('btn-group') >= 0)) {

          var arrow = $('<div class="arrow"></div>'),
            wrapper = this.menu.parent('.popupmenu-wrapper');

          wrapper.addClass('bottom').append(arrow);
        }

        // If inside of a ".field-short" container, make smaller
        var addFieldShort = this.element.closest('.field-short').length;
        this.menu[addFieldShort ? 'addClass' : 'removeClass']('popupmenu-short');

        // If button is part of a header/masthead or a container using the "alternate" UI color, add the "alternate" class.
        if (containerClass !== undefined &&
          (this.element.closest('.masthead').not('.search-results .masthead').length > 0)) {
          this.menu.parent('.popupmenu-wrapper').addClass('alternate');
        }

        this.element.attr('aria-haspopup', true);
        this.element.attr('aria-controls', id);

        this.markupItems();

        //Add an Audible Label
        if (!leftClick && !immediate) {
          var audibleSpanId = 'popupmenu-f10-label';
          if ($('#'+audibleSpanId).length === 0) {
            this.element.after('<span style="display:none;" id="' + audibleSpanId + '">' + Locale.translate('PressShiftF10') + '</span>');
          }
          //PressShiftF10
          this.element.attr('aria-describedby', audibleSpanId);
        }
      },

      markupItems: function () {
        var self = this,
          lis = this.menu.find('li:not(.heading):not(.separator)'),
          menuClassName = this.menu[0].className,
          isTranslatable = Soho.DOM.classNameHas(menuClassName, 'isTranslatable');

        lis.each(function(i, li) {
          var a = $(li).children('a')[0], // TODO: do this better when we have the infrastructure
            span = $(a).children('span')[0],
            submenuWrapper = $(li).children('.wrapper')[0];
          li.setAttribute('role', 'presentation');

          if (a) {
            a.setAttribute('tabindex', '-1');
            a.setAttribute('role', (self.settings.ariaListbox ? 'option' : 'menuitem'));

            // Should be translated
            if (isTranslatable) {
              span.innerText = Locale.translate(span.innerText) || span.innerText;
            }

            // disabled menu items, by prop and by className
            if (Soho.DOM.classNameHas(li.className, 'is-disabled')) {
              a.setAttribute('aria-disabled', 'true');
              a.disabled = true;
            }

            if (a.hasAttribute('disabled')) {
              Soho.DOM.addClass(li, 'is-disabled');
              a.setAttribute('aria-disabled', 'true');
              a.disabled = true;
            }

            // menu items that contain submenus
            if (submenuWrapper instanceof HTMLElement) {
              li.className += (Soho.DOM.classNameExists(li) ? ' ' : '') + 'submenu';
            }
            if (Soho.DOM.classNameHas(li.className, 'submenu')) {
              var $a = $(a);

              // Add a span
              if (!span) {
                a.innerHTML = '<span>' + a.innerHTML + '</span>';
                span = $a.children('span')[0];
              }

              if ($a.find('svg.arrow').length === 0) {
                $a.append($.createIconElement({ classes: ['arrow', 'icon-dropdown'], icon: 'dropdown' }));
              }
              a.setAttribute('aria-haspopup', 'true');
            }

            // is-checked
            if (Soho.DOM.classNameHas(li.className, 'is-checked')) {
              a.setAttribute('role', 'menuitemcheckbox');
              a.setAttribute('aria-checked', true);
            }

            // is-not-checked
            if (Soho.DOM.classNameHas(li.className, 'is-not-checked')) {
              li.className = li.className.replace('is-not-checked', '');
              a.setAttribute('role', 'menuitemcheckbox');
              a.removeAttribute('aria-checked');
            }
          }
        });
      },

      handleEvents: function() {
        var self = this,
          leftClick = this.settings.trigger !== 'rightClick',
          immediate = this.settings.trigger === 'immediate';

        function disableBrowserContextMenu(e) {
          e.stopPropagation();
          e.preventDefault();
          return false;
        }

        function doOpen(e) {
          var rightClick = self.settings.trigger === 'rightClick';

          e.stopPropagation();
          e.preventDefault();

          if (rightClick && self.menu.hasClass('is-open')) {
            self.close();
            self.open(e);
            return;
          }

          if (self.menu.hasClass('is-open')){
            self.close();
          } else {
            self.open(e);
          }
        }

        if (leftClick && !immediate) {
          this.element
            .on('mousedown.popupmenu', function (e) {
              if (e.button > 0 || self.element.is(':disabled')) {
                return;
              }
              doOpen(e);
          });
        }

        //settings.trigger
        if (!leftClick) {
          this.menu.parent().on('contextmenu.popupmenu', disableBrowserContextMenu);
          this.element
            .on('contextmenu.popupmenu', disableBrowserContextMenu)
            .on('mousedown.popupmenu', function (e) {
              if (e.button === 2 || (e.button === 0 & e.ctrlKey)) {
                doOpen(e);
              }
            });
        }

        // Setup these next events no matter what trigger type is
        this.element.not('.autocomplete')
          .on('keydown.popupmenu', function (e) {
            switch(e.which) {
              case 13:
              case 32:
                self.open(e);
                break;
              case 121:
                if (e.shiftKey) { //Shift F10
                  self.open(e);
                }
                break;
            }
          })
          .off('updated.popupmenu')
          .on('updated.popupmenu', function(e) {
            e.stopPropagation();
            self.updated();
          });

          // Media Query Listener to detect a menu closing on mobile devices that change orientation.
          if (window.matchMedia) {
            this.matchMedia = window.matchMedia('(orientation: landscape)');
            this.mediaQueryListener = function() {
              // Match every time.
              if (!self.menu.hasClass('is-open')) {
                return;
              }
              self.close();
            };
            this.matchMedia.addListener(this.mediaQueryListener);
          }
      },

      handleKeys: function () {
        var self = this;
        //http://access.aol.com/dhtml-style-guide-working-group/#popupmenu

        //Handle Events in Anchors
        this.menu.onTouchClick('popupmenu', 'a')
          .on('click.popupmenu', 'a', function(e) {
            self.handleItemClick(e, $(this));
          });

        var excludes = 'li:not(.separator):not(.hidden):not(.heading):not(.group):not(.is-disabled)';

        //Select on Focus
        if (this.settings.mouseFocus) {
          this.menu.on('mouseenter.popupmenu', 'li', function () {
            self.highlight($(this).children('a'));
          });
        }

        $(document).off('keydown.popupmenu.' + this.id).on('keydown.popupmenu.' + this.id, function (e) {
          var key = e.which,
            focus;

          //Close on escape
          if (key === 27) {
            e.stopPropagation();
            e.stopImmediatePropagation();
            self.close(true);
            return false;
          }

          //Close on tab
          if (key === 9) {
            e.stopPropagation();
            self.close(true);
          }

          //Select Checkboxes
          if (key === 32) {
            e.stopPropagation();

            var target = $(e.target),
              checkbox = target.find('input:checkbox');
            if (checkbox.length) {
              checkbox.trigger('click');
              return;
            }

            var a = $();

            // Return here and let Tabs control handle the spacebar
            if (target.is('.tab') || target.parent().is('.tab') || target.is('.tab-more')) {
              // Spacebar acts like Enter if there aren't any checkboxes (trigger links, etc)
              e.preventDefault();
              return;
            }

            if (target.is('li')) {
              a = target.children('a');
            }

            if (target.is('a')) {
              a = target;
            }

            if (a.length) {
              a.trigger('click');
              return;
            }
          }

          focus = self.menu.find(':focus');

          var isPicker = (self.settings.menu === 'colorpicker-menu'),
            isAutocomplete = self.element.is('.autocomplete');

          // Close Submenu
          if (key === 37 && !isAutocomplete) {
            e.stopPropagation();
            e.preventDefault();

            if (focus.closest('.popupmenu')[0] !== self.menu[0] && focus.closest('.popupmenu').length > 0) {
              focus.closest('.popupmenu').removeClass('is-open').parent().parent().removeClass('is-submenu-open');
              self.highlight(focus.closest('.popupmenu').parent().prev('a'));
            }
          }

          //Up on Up
          if ((!isPicker && key === 38) || (isPicker && key === 37)) {
             e.stopPropagation();
             e.preventDefault();

            //Go back to Top on the last one
            if (focus.parent().prevAll(excludes).length === 0) {
              if (focus.length === 0) {
                self.highlight(self.menu.children(excludes).last().find('a'));
              } else {
                self.highlight(focus.closest('.popupmenu').children(excludes).last().find('a'));
              }
              return;
            }
            self.highlight(focus.parent().prevAll(excludes).first().find('a'));
          }

          //Up a square
          if (isPicker && key === 38) {
            e.stopPropagation();
            e.preventDefault();

            if (focus.parent().prevAll(excludes).length > 0) {
              self.highlight($(focus.parent().prevAll(excludes)[9]).find('a'));
            }
          }

          //Right Open Submenu
          if (key === 39  && !isAutocomplete) {
            e.stopPropagation();
            e.preventDefault();

            if (focus.parent().hasClass('submenu')) {
              self.showSubmenu(focus.parent());
              self.highlight(focus.parent().find('.popupmenu a:first'));
            }
          }

          //Down
          if ((!isPicker && key === 40) || (isPicker && key === 39 && !isAutocomplete)) {
            e.stopPropagation();
            e.preventDefault();

            //Go back to Top on the last one
            if (focus.parent().nextAll(excludes).length === 0) {
              if (focus.length === 0) {
                self.highlight(self.menu.children(excludes).first().find('a'));
              } else {
                self.highlight(focus.closest('.popupmenu').children(excludes).first().find('a'));
              }
              return;
            }
            self.highlight(focus.parent().nextAll(excludes).first().find('a'));
          }

          //Down a square
          if ((isPicker && key === 40)) {
            e.stopPropagation();
            e.preventDefault();

            if (focus.parent().nextAll(excludes).length > 0) {
              self.highlight($(focus.parent().nextAll(excludes)[9]).find('a'));
            }
          }

        });
      },

      /**
       * Handles the action of clicking items in the popupmenu.
       * @param {$.Event} [e] - The jQuery Event object.
       * @return undefined;
       */
      handleItemClick: function(e, anchor) {
        var href = anchor.attr('href'),
          selectionResult = [anchor];

        if (!e && !anchor) {
          return;
        }

        if (anchor.parent().is('.submenu, .hidden, .is-disabled') || anchor[0].disabled) {
          //Do not close parent items of submenus on click
          e.preventDefault();
          return;
        }

        if (anchor.find('input[checkbox]').length > 0) {
          return;
        }

        if (this.element.hasClass('btn-filter')) {
          this.iconFilteringUpdate(anchor);
          e.preventDefault();
        }

        if (this.isInSelectableSection(anchor) || this.menu.hasClass('is-selectable') || this.menu.hasClass('is-multiselectable')) {
          selectionResult = this.select(anchor);
        }

        // Single toggle on off of checkbox class
        if (anchor.parent().hasClass('is-toggleable')) {
          anchor.parent().toggleClass('is-checked');
        }

        // Trigger a selected event containing the anchor that was selected
        // If an event object is not passed to `handleItemClick()`, assume it was due to this
        // event being triggered already, making it not necessary to re-trigger it.
        if (e) {
          if (selectionResult.length === 1) {
            selectionResult.push(undefined);
          }

          selectionResult.push(true);
          this.element.triggerHandler('selected', selectionResult);
        }

        // MultiSelect Lists should act like other "multiselect" items and not close the menu when options are chosen.
        if (this.menu.hasClass('is-multiselectable') || this.isInMultiselectSection(anchor)) {
          return;
        }

        this.close();

        if (this.element.is('.autocomplete')) {
          return;
        }

        if (href && href.charAt(0) !== '#') {
          if (anchor.attr('target') === '_blank') {
            window.open(href, '_blank');
          } else {
            window.location.href = href;
          }
          return true;
        }

        if (e) {
          e.preventDefault();
          e.stopPropagation();
        }
      },

      // Filtering icon initial setup
      iconFilteringSetup: function(alink) {
        if (this.element.hasClass('btn-filter')) {
          var svg = this.element.find('svg.icon-dropdown'),
            link = alink || $('li:first a', this.menu),
            audibleText = link.find('span').text();

          if (svg.length === 1) {
            this.element.append($.createIconElement({ classes: 'icon-dropdown', icon: 'dropdown' }));
          }

          svg.first().changeIcon(link.find('svg').getIconName());
          this.element.find('.audible').text(audibleText);
        }
      },

      // Filtering icon update
      iconFilteringUpdate: function(alink) {
        if (this.element.hasClass('btn-filter')) {
          var link = alink || $('li:first a', this.menu),
            audibleText = link.find('span').text();

          this.element.find('.audible').text(audibleText);
          this.element.find('svg:not(.ripple-effect):first').changeIcon(link.find('svg').getIconName());
        }
      },

      position: function(e) {
        var self = this,
          target = this.element,
          isRTL = this.isRTL(),
          wrapper = this.menu.parent('.popupmenu-wrapper'),
          mouse =  {
            x: e && e.clientX ? e.clientX : (window.event && window.event.clientX) ? window.event.clientX : 0,
            y: e && e.clientY ? e.clientY : (window.event && window.event.clientY) ? window.event.clientY : 0
          },
          menuDimensions = {
            width: this.menu.outerWidth(),
            height: this.menu.outerHeight()
          };

        if (!wrapper.length) {
          return;
        }

        if (target.is('svg, .icon') && target.closest('.tab').length) {
          target = target.closest('.tab');
        }

        function getCoordinates(e, axis) {
          axis = ((axis === 'x' || axis === 'y') ? axis : 'x');
          return mouse[axis]; // use mouseX/mouseY if this doesn't work
        }

        // Reset the arrow
        wrapper.find('.arrow').removeAttr('style');

        var opts = $.extend({}, this.settings.placementOpts),
          strategies = ['flip'];

        if (!target.is('.autocomplete, .searchfield')) {
          strategies.push('nudge');
        }
        strategies.push('shrink-y');

        // If right-click or immediate (with an incoming event object), use coordinates from the event
        if ((this.settings.trigger === 'immediate' && this.settings.eventObj) || this.settings.trigger === 'rightClick') {
          opts.x = getCoordinates(e, 'x') - (isRTL ? menuDimensions.width : 0) + ((isRTL ? -1 : 1) * this.settings.offset.x);
          opts.y = getCoordinates(e, 'y') + this.settings.offset.y;

        } else {
          opts.x = this.settings.offset.x || 0;
          opts.y = this.settings.offset.y || 0;
          opts.parent = this.element;
          opts.placement = 'bottom';
        }
        opts.strategies = strategies;

        //=======================================================
        // BEGIN Temporary stuff until we sort out passing these settings from the controls that utilize them
        //=======================================================

        var toolbarParent = target.parents('.toolbar'),
          insideToolbar = toolbarParent.length > 0,
          insideToolbarTitle = target.parents('.title').length > 0,
          isNotFullToolbar = insideToolbar && toolbarParent.children('.buttonset, .title').length > 1,
          isPagerMenu = target.parents('.pager-pagesize').length > 0;

        function alignLeft() {
          opts.parentXAlignment = (isRTL ? 'right': 'left');
        }

        function alignRight() {
          opts.parentXAlignment = (isRTL ? 'left' : 'right');
        }

        function shiftDown() {
          opts.y = opts.y + 15;
        }

        // Change the alignment of the popupmenu based on certain conditions
        (function doAlignment() {
          if (target.is('.btn-menu')) {
            if (isPagerMenu) {
              return alignRight();
            }

            if (insideToolbar) {
              if (!isNotFullToolbar) {
                return alignLeft();
              }
              if (insideToolbarTitle) {
                return alignLeft();
              }
              return alignRight();
            }

            return alignLeft();
          }

          if (target.is('.btn-actions')) {
            return alignRight();
          }

          if (target.is('.tab-more')) {
            return alignRight();
          }

          if ((target.is('.btn-split-menu, .tab, .searchfield-category-button') &&
            !target.parent('.pager-pagesize').length)) {
              return alignLeft();
            }
        })();

        if (target.parents('.masthead').length > 0) {
          shiftDown();
        }

        //=======================================================
        // END Temporary stuff until we sort out passing these settings from the controls that utilize them
        //=======================================================

        wrapper.one('afterplace.popupmenu', function(e, positionObj) {
          self.handleAfterPlace(e, positionObj);
        });

        wrapper.place(opts);
        wrapper.data('place').place(opts);
      },

      handleAfterPlace: function(e, placementObj) {
        var wrapper = this.menu.parent('.popupmenu-wrapper');
        wrapper.data('place').setArrowPosition(e, placementObj, wrapper);

        if (placementObj.height) {
          wrapper[0].style.height = '';
          this.menu[0].style.height = (placementObj.height) + (/(px|%)/i.test(placementObj.height + '') ? '' : 'px');
        }
        if (placementObj.width) {
          wrapper[0].style.width = '';
          this.menu[0].style.width = (placementObj.width) + (/(px|%)/i.test(placementObj.width + '') ? '' : 'px');
        }

        wrapper.triggerHandler('popupmenuafterplace', [placementObj]);
        return placementObj;
      },

      open: function(e, ajaxReturn) {
        var self = this;

        var canOpen = this.element.triggerHandler('beforeopen', [this.menu]);
        if (canOpen === false) {
          return;
        }

        if (this.settings.beforeOpen && !ajaxReturn) {
          var response = function(content) {
            if (self.ajaxContent instanceof $) {
              self.ajaxContent.off().remove();
            }
            self.ajaxContent = $(content);
            self.menu.append(self.ajaxContent);
            self.markupItems();
            self.open(e, true);
          };

          if (typeof this.settings.beforeOpen === 'string') {
            window[this.settings.beforeOpen](response);
            return;
          }

          this.settings.beforeOpen(response);
          return;
        }

        var otherMenus = $('.popupmenu.is-open').filter(function() {
          return $(this).parents('.popupmenu').length === 0;
        }).not(this.menu);  //close others.

        otherMenus.each(function() {
          var trigger = $(this).data('trigger');
          if (!trigger || !trigger.length) {
            return;
          }

          var api = $(this).data('trigger').data('popupmenu');
          if (api && typeof api.close === 'function') {
            api.close();
          }
        });

        this.element.addClass('is-open');
        this.menu.addClass('is-open').attr('aria-hidden', 'false');

        this.position(e);

        if (this.element.closest('.header').length > 0) {
          this.menu.parent()[0].style.zIndex =  '9001';
        }

        //Close on Document Click ect..
        setTimeout(function () {
          $(document).on('touchend.popupmenu.' + self.id +' click.popupmenu.' + self.id, function (e) {
            if (e.button === 2) {
              return;
            }

            //Click functionality will toggle the menu - otherwise it closes and opens
            if ($(e.target).is(self.element)) {
              return;
            }

            if ($(e.target).closest('.popupmenu').length === 0) {
              self.close(true, self.settings.trigger ==='rightClick');
            }
          });

          if (window.orientation === undefined) {
            $('body').on('resize.popupmenu', function() {
              self.close();
            });
          }

          $(window).on('scroll.popupmenu', function () {
            self.close();
          });

          $('.scrollable').on('scroll.popupmenu', function () {
            self.close();
          });

          self.element.triggerHandler('open', [self.menu]);

          if (self.settings.trigger === 'rightClick') {
            self.element.on('click.popupmenu touchend.popupmenu', function () {
              self.close();
            });
          }
        }, 300);

        //Hide on iFrame Clicks - only works if on same domain
        $('iframe').each(function () {
          var frame = $(this);
          frame.ready(function () {

            try {
              frame.contents().find('body').on('click.popupmenu', function () {
                self.close();
              });
            } catch (e)  {
              //Ignore security errors on out of iframe
            }

          });
        });

        this.handleKeys();

        //hide and decorate submenus - we use a variation on
        var tracker = 0, startY, menuToClose, timeout;

        self.menu.find('.popupmenu').removeClass('is-open');
        self.menu.on('mouseenter.popupmenu touchstart.popupmenu', '.submenu', function (e) {
          var menuitem = $(this);
          startY = e.pageX;

          clearTimeout(timeout);
          timeout = setTimeout(function () {
            self.showSubmenu(menuitem);
          }, 300);

          $(document).on('mousemove.popupmenu.' + this.id, function (e) {
            tracker = e.pageX;
          });
        }).on('mouseleave.popupmenu', '.submenu', function () {
          $(document).off('mousemove.popupmenu.' + this.id);

          menuToClose = $(this).find('ul');

          var isLeft = parseInt(menuToClose.parent('.wrapper')[0].style.left) < 0,
            canClose = (tracker - startY) < 3.5;

          if (isLeft) {
            canClose = (tracker - startY) >= 0;
          }

          if (canClose) { //We are moving slopie to the menu
            menuToClose.removeClass('is-open').removeAttr('style');
            menuToClose.parent('.wrapper').removeAttr('style');
            menuToClose.parent().parent().removeClass('is-submenu-open');
            menuToClose = null;
          }
          clearTimeout(timeout);
        });

        if (self.settings.autoFocus) {
          setTimeout(function () {
            var excludes = ':not(.separator):not(.hidden):not(.heading):not(.group):not(.is-disabled)',
              selection = self.menu.children(excludes).find('.is-selected').children('a');

            if (!selection.length) {
              selection = self.menu.children(excludes).first().children('a');
            }

            self.highlight(selection);
            self.element.triggerHandler('afteropen', [self.menu]);
          }, 1);
        }
      },

      showSubmenu: function (li) {
        if (Soho.DOM.classNameHas(li[0].className, 'is-disabled') || li[0].disabled) {
          return;
        }

        var wrapper = li.children('.wrapper').filter(':first');

        // Wrap if not wrapped (dynamic menu situation)
        if (wrapper.length === 0) {
          var ul = li.children('ul').filter(':first');
          ul.wrap('<div class="wrapper"></div>');
          wrapper = ul.parent();
        }

        var menu = wrapper.children('.popupmenu'),
          mainWrapperOffset = li.parents('.popupmenu-wrapper:first').offset().top;
        li.parent().find('.popupmenu').removeClass('is-open').removeAttr('style');

        wrapper[0].style.left = (li.position().left + li.outerWidth()) + 'px';
        wrapper[0].style.top = (parseInt(li.position().top) - 5) + 'px';

        wrapper.children('.popupmenu').addClass('is-open');

        //Handle Case where the menu is off to the right
        var menuWidth = menu.outerWidth();
        if ((wrapper.offset().left + menuWidth) > ($(window).width() + $(document).scrollLeft())) {
          wrapper[0].style.left = '-9999px';
          menuWidth = menu.outerWidth();
          wrapper[0].style.left = (li.position().left - menuWidth) + 'px';
          //Did it fit?
          if (wrapper.offset().left < 0) {
            //No. Push the menu's left offset onto the screen.
            wrapper[0].style.left = (li.position().left - menuWidth + Math.abs(wrapper.offset().left) + 40) + 'px';
            menuWidth = menu.outerWidth();
          }
          // Do one more check to see if the right edge bleeds off the screen.
          // If it does, shrink the menu's X size.
          if ((wrapper.offset().left + menuWidth) > ($(window).width() + $(document).scrollLeft())) {
            var differenceY = (wrapper.offset().left + menuWidth) - ($(window).width() + $(document).scrollLeft());
            menuWidth = menuWidth - differenceY;
            menu[0].style.width = menuWidth + 'px';
          }
        }

        //Handle Case where menu is off bottom
        var menuHeight = menu.outerHeight();
        if ((wrapper.offset().top + menuHeight) > ($(window).height() + $(document).scrollTop())) {
          // First try bumping up the menu to sit just above the bottom edge of the window.
          var bottomEdgeCoord = wrapper.offset().top + menuHeight,
            differenceFromBottomY = bottomEdgeCoord - ($(window).height() + $(document).scrollTop());

          wrapper[0].style.top = (wrapper.position().top - differenceFromBottomY) + 'px';

          // Does it fit?
          if ((wrapper.offset().top + menuHeight) > ($(window).height() + $(document).scrollTop())) {
            // No. Bump the menu up higher based on the menu's height and the extra space from the main wrapper.
            wrapper[0].style.top = (($(window).height() + $(document).scrollTop()) - menuHeight - mainWrapperOffset) + 'px';
          }

          // Does it fit now?
          if ((wrapper.offset().top - $(document).scrollTop()) < 0) {
            // No. Push the menu down onto the screen from the top of the window edge.
            wrapper[0].style.top = 0;
            wrapper[0].style.top = (wrapper.offset().top * -1) + 'px';
            menuHeight = menu.outerHeight();
          }

          // Do one more check to see if the bottom edge bleeds off the screen.
          // If it does, shrink the menu's Y size and make it scrollable.
          if ((wrapper.offset().top + menuHeight) > ($(window).height() + $(document).scrollTop())) {
            var differenceX = (wrapper.offset().top + menuHeight) - ($(window).height() + $(document).scrollTop());
            menuHeight = menuHeight - differenceX - 32;
            menu[0].style.height = menuHeight + 'px';
          }
        }

        li.parent().find('.is-submenu-open').removeClass('is-submenu-open');
        li.addClass('is-submenu-open');
      },

      highlight: function(anchor) {
        if (!anchor || !anchor.length) {
          return false;
        }

        var li = anchor.parent();

        li.parent().children('li').removeClass('is-focused');
        li.addClass('is-focused');

        //Prevent chrome from scrolling - toolbar
        anchor.focus();
        li.closest('.header').scrollTop(0);

      },

      // adds/removes checkmarks that are in selectable groups inside the popupmenu
      select: function(anchor) {
        var singleMenu = this.menu.is('.is-selectable'),
          multipleMenu = this.menu.is('.is-multiselectable'),
          singleSection = this.isInSingleSelectSection(anchor),
          multipleSection = this.isInMultiselectSection(anchor),
          parent = anchor.parent(),
          returnObj = [anchor, 'selected'];

        if (!singleMenu && !multipleMenu && !singleSection && !multipleSection) {
          return;
        }

        // If the entire menu is "selectable", place the checkmark where it's supposed to go.
        if (singleMenu || singleSection) {
          parent.prevUntil('.heading, .separator').add(parent.nextUntil('.heading, .separator')).removeClass('is-checked');
          parent.addClass('is-checked');
          return returnObj;
        }

        if (multipleMenu || multipleSection) {
          if (parent.hasClass('is-checked')) {
            returnObj[1] = 'deselected';
            parent.removeClass('is-checked');
            return returnObj;
          }
          parent.addClass('is-checked');
          return returnObj;
        }
      },

      getSelected: function() {
        if (!this.menu.is('.is-selectable, .is-multiselectable')) {
          return $();
        }

        return this.menu.children('.is-checked').children('a');
      },

      isInSelectableSection: function(anchor) {
        var separator = anchor.parent().prevAll().filter('.separator').first();
        return (separator.hasClass('multi-selectable-section') || separator.hasClass('single-selectable-section'));
      },

      isInSingleSelectSection: function(anchor) {
        return anchor.parent().prevAll().filter('.separator').first().hasClass('single-selectable-section');
      },

      isInMultiselectSection: function(anchor) {
        return anchor.parent().prevAll().filter('.separator').first().hasClass('multi-selectable-section');
      },

      detach: function () {

        $(document).off('touchend.popupmenu.' + this.id +' click.popupmenu.' + this.id +' keydown.popupmenu');
        $(window).off('scroll.popupmenu orientationchange.popupmenu');
        $('body').off('resize.popupmenu');
        $('.scrollable').off('scroll.popupmenu');

        this.menu.off('click.popupmenu touchend.popupmenu touchcancel.popupmenu');

        if (this.settings.trigger === 'rightClick') {
          this.element.off('click.popupmenu touchend.popupmenu');
        }

        $('iframe').each(function () {
          var frame = $(this);
          try {
            frame.contents().find('body').off('click.popupmenu touchend.popupmenu touchcancel.popupmenu');
          } catch (e) {
            //Ignore security errors on out of iframe
          }
        });
      },

      close: function (isCancelled, noFocus) {
        if (!isCancelled || isCancelled === undefined) {
          isCancelled = false;
        }

        var self = this,
          wrapper = this.menu.parent('.popupmenu-wrapper'),
          menu = this.menu.find('.popupmenu');

        this.menu.removeClass('is-open').attr('aria-hidden', 'true');
        if (this.menu[0]) {
          this.menu[0].style.height = '';
          this.menu[0].style.width = '';
        }

        if (wrapper[0]) {
          wrapper[0].style.left = '-999px';
          wrapper[0].style.height = '';
          wrapper[0].style.width = '';
        }

        this.menu.find('.submenu').off('mouseenter mouseleave').removeClass('is-submenu-open');
        if (menu[0]) {
          menu[0].style.left = '';
          menu[0].style.top = '';
          menu[0].style.height = '';
          menu[0].style.width = '';
        }

        this.menu.find('.is-focused').removeClass('is-focused');

        // Close all events
        $(document).off('keydown.popupmenu.' + this.id + ' click.popupmenu.' + this.id + ' mousemove.popupmenu.' + this.id);
        this.menu.off('click.popupmenu touchend.popupmenu touchcancel.popupmenu mouseenter.popupmenu mouseleave.popupmenu');

        this.element.removeClass('is-open').triggerHandler('close', [isCancelled]);
        this.detach();

        if (this.settings.trigger === 'immediate') {
          this.destroy();
        }

        if (noFocus) {
          return;
        }

        self.element.removeClass('hide-focus').focus();
      },

      teardown: function() {
        var wrapper = this.menu.parent('.popupmenu-wrapper');

        if (this.ajaxContent) {
          this.ajaxContent.off().remove();
        }

        this.menu.parent().off('contextmenu.popupmenu');
        if (this.element.hasClass('btn-actions')) {
          this.menu.parent().removeClass('bottom').find('.arrow').remove();
        }

        if (this.originalParent) {
          this.menu.appendTo(this.originalParent);
        } else {
          this.menu.insertAfter(this.element);
        }

        this.menu.find('.submenu').children('a').each(function(i, item) {
          var text = $(item).find('span').text();
          $(item).find('span, svg').remove();
          $(item).text(text);
        });

        function unwrapPopup(menu) {
          if (!this.preExistingWrapper) {
            return;
          }

          var wrapper = menu.parent();
          if (wrapper.is('.popupmenu-wrapper, .wrapper')) {
            if (wrapper.data('place')) {
              wrapper.data('place').destroy();
            }
            menu.unwrap();
          }
        }

        //unwrapPopup(this.menu);
        this.menu.find('.popupmenu').each(function() {
          unwrapPopup($(this));
        });

        if (this.menu[0]) {
          $.removeData(this.menu[0], 'trigger');
        }

        if (wrapper.data('place')) {
          wrapper.data('place').destroy();
        }
        wrapper.off().remove();

        if (this.matchMedia) {
          this.matchMedia.removeListener(this.mediaQueryListener);
        }

        this.detach();
        this.element
          .removeAttr('aria-controls')
          .removeAttr('aria-haspopup')
          .off('touchend.popupmenu touchcancel.popupmenu click.popupmenu keypress.popupmenu contextmenu.popupmenu mousedown.popupmenu');

        return this;
      },

      updated: function() {
        this.teardown().init();
      },

      destroy: function() {
        this.teardown();
        this.menu.trigger('destroy');
        $.removeData(this.element[0], pluginName);
      }
    };

    // Initializing the Control Once or Call Methods.
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (instance) {
        if (typeof instance[options] === 'function') {
          instance[options]();
        }
        instance.settings = $.extend({}, instance.settings, options);
        instance.updated();
      } else {
        instance = $.data(this, pluginName, new PopupMenu(this, settings));
      }
    });
  };


  $.fn.progress = function(options) {

    // Settings and Options
    var pluginName = 'progress',
        defaults = {
        },
        settings = $.extend({}, defaults, options);

    /**
     * Progress Indicator Control
     * @constructor
     * @param {Object} element
     */
    function Progress(element) {
      this.element = $(element);
      this.settings = settings;
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    // Actual Progress Code
    Progress.prototype = {

      init: function() {
        var self = this;
        self.update();

        this.element.off('updated.progress').on('updated.progress', function (e) {
          e.stopPropagation();
          self.update();
        });
      },

      updateAria: function (value) {
        this.element.attr({'role': 'progressbar', 'aria-valuenow': value, 'aria-maxvalue':'100'});

        var container = this.element.parent();
        if (container.data('tooltip')) {
          container.data('tooltip').content = value + '%';
        } else {
          container.attr('title', value + '%').tooltip();
        }
      },

      update: function (value) {

        var perc = this.element.attr('data-value');

        if (value) {
          perc = value;
          this.element.attr('data-value', value);
        }

        this.element[0].style.width = perc + '%';
        this.updateAria(perc);
      },

      //Teardown
      destroy: function() {
        $.removeData(this.element[0], pluginName);
        this.element.off('updated.progress');
      }
    };

    // Initialize the plugin (Once)
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (instance) {
        instance.settings = $.extend({}, defaults, options);
      } else {
        instance = $.data(this, pluginName, new Progress(this, settings));
      }
    });
  };


  var DECIMAL_SYMBOL = '.';
  var THOUSANDS_SEPARATOR = ',';

  $.fn.mask = function(options) {

    // Tab Settings and Options
    var pluginName = 'mask',
        defaults = {
          pattern: '',
          placeholder: '_',
          definitions: {
            '#': /[0-9]/,
            '0': /[0-9]/,
            'x': /[\u00C0-\u017Fa-zA-Z]/,
            '*': /[\u00C0-\u017Fa-zA-Z0-9]/,
            '?': /./,
            '~': /[-0-9]/,
            'a': /[APap]/,
            'm': /[Mm]/
          },
          groupComplete: false,
          mode: undefined,
          mustComplete: false,
          negative: false,
          number: false,
          processOnInitialize: true, // If set to false, will not initialially mask the value of the input field.
          processOnBlur: true, // If set to false, will not mask the value of the input field upon blur.
          thousandsSeparator: false,
          showSymbol: undefined, // can be 'currency', 'percent'
        },
        maskModes = ['group', 'number', 'date', 'time'],
        symbols = ['currency', 'percent'],
        settings = $.extend({}, defaults, options);

    /**
     * Inline Field Formatter (Mask) Control
     * Adds a text-based formatting "mask" to input fields that displays how data should be entered into the field.
     * Does not allow text entry that does not match the provided mask.
     * @constructor
     * @param {Object} element
     */
    function Mask(element) {
      this.settings = $.extend({}, settings);
      this.element = $(element);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    Mask.prototype = {
      init: function(){
        var self = this;
        self.buffer = '';

        this.element.addClass('is-mask');

        // Order of operations when choosing pattern strings:
        // HTML5 'data-mask' attribute > Generic pattern string based on "type" attribute > nothing.
        //
        // if no pattern is provided in settings, use a pre-determined pattern based
        // on element type, or grab the pattern from the element itself.
        var html5DataMask = this.element.attr('data-mask') || false;
        if (html5DataMask) {
          this.settings.pattern = html5DataMask;
        }

        // If a "mode" is defined, special formatting rules may apply to this mask.
        // Otherwise, the standard single-character pattern match will take place.
        var html5DataMaskMode = this.element.attr('data-mask-mode') || false;
        if (html5DataMaskMode) {
          this.settings.mode = html5DataMaskMode;
        }
        if (this.settings.mode) {
          if ($.inArray(this.settings.mode, maskModes) === -1) {
            this.settings.mode = 'group';
          }
        }

        // If "thousands" is defined, the thousands separator for numbers (comma or decimal, based on
        // localization) will be inserted wherever necessary during typing. Will automatically set to
        // "true" if the localized thousands separator is detected inside the mask.
        var html5DataThousands = this.element.attr('data-thousands') || false;
        if (html5DataThousands) {
          this.settings.thousandsSeparator = (html5DataThousands === 'true');
        }

        // If "negative" is defined, you can type the negative symbol in front of the number.
        // Will automatically set to "true" if a negative symbol is detected inside the mask.
        this.settings.negative = this.settings.mode === 'number' && this.settings.pattern.indexOf('-') !== -1;

        // If 'mustComplete' is defined, you MUST complete the full mask, or the mask will revert to empty
        // once the field is blurred.
        var html5DataMustComplete = this.element.attr('data-must-complete') || false;
        if (html5DataMustComplete) {
          this.settings.mustComplete = html5DataMustComplete;
        }

        // If 'showCurrency' is defined and the mask mode is 'number', a span will be drawn that will show the
        // localized currency symbol.
        var symbolType = this.settings.showSymbol,
          symbol;

        // Backwards compat with the old "data-show-currency"
        if (symbolType === true) {
          symbolType = 'currency';
        }

        if (symbolType && symbolType !== undefined && symbols.indexOf(symbolType) !== -1 && this.settings.mode === 'number') {
          switch(symbolType) {
            case 'currency':
              symbol = (Locale.currentLocale.data ? Locale.currentLocale.data.currencySign : '$');
              break;
            case 'percent':
              symbol = '%';
              break;
          }

          $('<span class="audible ' + symbolType + '"></span>').text(' ' + symbol).appendTo(self.element.prev('label'));
          this.element.parent('.field, .datagrid-filter-wrapper')
            .attr('data-currency-symbol', '' + symbol)
            .addClass(symbolType);
        }

        // If we are doing a grouped pattern match (for dates/times/etc), we need to store an object that contains
        // separated pieces of "editable" and "literal" parts that are used for checking validity of mask pieces.
        var modeClassMethod = 'addClass';
        if (self.settings.mode !== 'number') {
          self.maskParts = self.getPatternParts();
          modeClassMethod = 'removeClass';
        }
        this.element[modeClassMethod]('is-number-mask');

        // If 'self.groupComplete' is active, each section of the group pattern match must be full in order for the
        // literals in-between each section to be automatically added (meaning, you can't type a literal to end that
        // group until all characters in that group are entered).  This is used for some group matching and for time.
        var html5DataGroupComplete = self.element.attr('data-group-complete');
        if (html5DataGroupComplete) {
          this.settings.groupComplete = true;
        }
        // Backwards Compat with the old "time" mode
        if (this.settings.mode === 'time') {
          this.settings.mode = 'group';
        }

        // Point all keyboard related events to the handleKeyEvents() method, which knows how to
        // deal with key syphoning and event propogation.
        self.element.on('keypress.mask keydown.mask keyup.mask ' + self.getPasteEvent(), function(e) {
          if (self.element.prop('readonly')) {
            e.preventDefault();
            return false;
          }
          self.handleKeyEvents(self, e);
        });

        // when the element is focused, store its initial value.
        self.element.on('focus.mask', function(e) {
          if (self.element.prop('disabled') || self.element.prop('readonly')) {
            e.preventDefault();
            return false;
          }
          self.initValue = self.element.val();
        });

        // listen for an event called "updated" that can be triggered by other plugins, that forces the mask
        // to completely re-evaluate itself.
        self.element.on('updated.mask', function(e) {
          self.evaluateCurrentContents(undefined, e);
        });

        function reprocess(isRemask) {
          var val = self.element.val();

          if (self.settings.mustComplete) {
            self.checkCompletion();
          }
          if (val && self.initValue !== val) {
            if (isRemask || self.settings.processOnBlur) {
              self.remask( !isRemask );
            }
            self.element.trigger('change');
          }
        }

        // custom event that can be triggered for forcing a remasking of the input field
        self.element.on('remask.mask', function() {
          reprocess(true);
        });

        // remove the value when blurred
        self.element.on('blur.mask', function(e) {
          if (self.element.prop('readonly')) {
            e.preventDefault();
            return false;
          }

          reprocess();
          self.initValue = null;
          return true;
        });

        // Don't continue if the field is hidden -OR- we disallow the masking of contents during initialization.
        if (this.element.is(':hidden') || !this.settings.processOnInitialize) {
          return this;
        }

        // Test contents of the input field.  If there are characters, run them
        // against the mask and fill them in as necessary.
        var val = self.element.val();
        if (val.length > 0) {
          self.element.val('');
          self.processStringAgainstMask(val);
        }

        return this;
      },

      // Builds a fake element and gets the name of the event that will be used for "paste"
      // Used for cross-browser compatability.
      getPasteEvent: function() {
        return window.Soho.env.pasteEvent + '.mask';
      },

      // Gets rid of event firing and bubbling in all browsers.
      killEvent: function(e) {
        if (e) {
          e.returnValue = false;
          if (e.preventDefault) {
            e.preventDefault();
          }
        }
        return false;
      },

      // Helper Function for Caret positioning.  If you provide "begin" and "end" arguments, the caret position
      // will change.  If you simply call the method with no arguments, it returns an object containing the cursor's
      // beginning and ending posititons.
      caret: function(begin, end) {
        var self = this,
          range;
        if (self.element.val().length === 0 || self.element.is(':hidden')) {
          return {
            begin: 0,
            end: 0
          };
        }
        if (typeof begin === 'number') {
          end = (typeof end === 'number') ? end : begin;
          return self.element.each(function() {
            if (this.setSelectionRange) {
              this.setSelectionRange(begin, end);
            } else if (this.createTextRange) {
              range = this.createTextRange();
              range.collapse(true);
              range.moveEnd('character', end);
              range.moveStart('character', begin);
              range.select();
            }
          });
        } else {
          if (self.element[0].setSelectionRange) {
            begin = self.element[0].selectionStart;
            end = self.element[0].selectionEnd;
          } else if (document.selection && document.selection.createRange) {
            range = document.selection.createRange();
            begin = 0 - range.duplicate().moveStart('character', -100000);
            end = begin + range.text.length;
          }
          return {
            begin: begin,
            end: end
          };
        }
      },

      // Moves the text input cursor a specified distance in a specified direction
      moveCursor: function(direction, distance) {
        var self = this,
          pos = self.caret();

        direction = self.evaluateDirecton(direction);
        distance = distance || 1;

        switch(direction) {
          case 'next':
            self.caret(pos.begin + distance);
            break;
          case 'prev':
            self.caret(pos.begin - distance);
            break;
          default:
            break;
        }
      },

      // Get the direction in which to position the cursor (if necessary)
      // defaults to 'current', which will not move the cursor.
      evaluateDirecton: function(direction) {
        if (!direction) {
          return 'current';
        }
        var directions = ['current', 'next', 'prev'],
          i = $.inArray(direction, directions);
        return directions[i];
      },

      // If the mask isn't completed to the end, erase the contents of the input field
      // Used on Blur if the "mustComplete" flag is set
      checkCompletion: function() {
        var inputLength = this.element.val().length,
          maskLength = this.settings.pattern.length;

        if (maskLength !== inputLength) {
          this.element.val('');
        }
      },

      // Evaluates the entire current contents of the input field against its mask.
      // Used when the field is blurred, and after a Backspaced character is removed
      evaluateCurrentContents: function(newValue, e) {
        if (newValue === null || newValue === undefined) {
          newValue = this.element.val();
        }
        if (!e) {
          e = $.Event();
        }

        this.element.val('');

        if (document.activeElement === e.target) {
          this.caret(0);
        }
        this.processStringAgainstMask(newValue, e);
      },

      // The catch-all event for handling keyboard events within this input field. Grabs information about the keys
      // being pressed, event type, matching pattern characters, and determines what to do with them.
      handleKeyEvents: function(self, e) {
        var evt = e || window.event,
          eventType = evt.originalEvent.type,
          key = e.which,
          typedChar = $.actualChar(e);

        // Remove modifiers on "keyup"
        if (eventType === 'keyup') {
          if (key === 8) {
            return this.handleBackspace(e);
          }

          return;
        }

        // Handle most input on "keypress"
        if (eventType === 'keypress') {
          // Ignore all of these keys or combinations containing these keys
          if (evt.ctrlKey || evt.metaKey || key < 32) {
            return;
          // Never allow any combinations with the alt key, since on Mac OSX it's used to create special characters
          } else if (evt.altKey) {
            self.killEvent(e);
          }

          if (self.settings.mode === 'number') {
            self.processNumberMask(typedChar, evt);
          } else {
            self.processMask(typedChar, evt);
          }

        }

        if (eventType === 'paste') {
          self.handlePaste(evt);
        }
      },

      // When using Backspace, correctly remove the intended text content and place the caret
      // in the correct place.
      handleBackspace: function() {
        var val = this.element.val();
        this.element.trigger('write.mask', [val]);
        return;
      },

      // When escaping from a modified field, place the initial value of the field
      // back in place of the discarded edits.
      handleEscape: function(e) {
        var self = this;
        self.element.val(self.initValue);
        self.caret(0, self.initValue.length);
        self.initValue = null;
        return self.killEvent(e);
      },

      // Pressing Tab changes field focus, but we run a check on the field beforehand to fix any mask errors.
      // Similar to running on "blur" but prevents issues in IE where focus traps would happen.
      handleTab: function(e) {
        return this.evaluateCurrentContents(undefined, e);
      },

      // Intercepts the Paste event, modifies the contents of the clipboard to fit within the size
      // and character limits of the mask, and writes the result to the input field.
      handlePaste: function(e) {
        var paste = e.originalEvent.clipboardData && e.originalEvent.clipboardData.getData ?
          e.originalEvent.clipboardData.getData('text/plain') : // Standard
          window.clipboardData && window.clipboardData.getData ?
          window.clipboardData.getData('Text') : // MS
          false;

        if (paste) {
          // cut down the total size of the paste input to only be as long as the pattern allows * 2.
          var pasteLimiter = (this.settings.pattern.length * 2) > paste.length ? paste.length : this.settings.pattern.length * 2,
            maxPasteInput = paste.substring(0, pasteLimiter);
          this.processStringAgainstMask(maxPasteInput, e);
        }
        this.element.trigger('afterpaste.mask');
        this.killEvent(e);
      },

      // Attempts to match the character provided from a pattern against the array of
      // pattern matching characters ("definitions"). If the character is not in the array,
      // it is considered "literal", and will be placed into the input field as part of the mask.
      isCharacterLiteral: function(patternChar) {
        return $.inArray(patternChar, Object.keys(this.settings.definitions)) === -1;
      },

      // Tests the character provided against the current langauge's decimal selector
      // TODO: Add globalization support for the decimal selector
      isCharacterDecimal: function(patternChar) {
        return patternChar === '.';
      },

      // The following methods are used for modifying the contents of strings based on caret position.
      // TODO: Move these to a more global space for use in other plugins?
      insertAtIndex: function(string, value, index) {
          return string.substring(0, index) + value + string.substring(index);
      },
      replaceAtIndex: function(string, value, indexStart, indexEnd) {
        return string.substr(0, indexStart) + value + string.substr(isNaN(indexEnd) ? (indexStart + value.length) : indexEnd);
      },
      deleteAtIndex: function(string, value, index) {
        return string.substr(0, index) + string.substr(index + value.length);
      },

      getCharacterAtIndex: function(string, index) {
        return string.substr(index, 1);
      },

      // Resets properties used for internal storage between keypresses to their default values
      resetStorage: function() {
        this.originalPos = null;
        this.currentMaskBeginIndex = null;
        this.buffer = '';
      },

      // Writes the current value of the internal text buffer out to the Input Field.
      // Additionally, resets the Caret to the right position.
      writeInput: function(reprocess) {
        var self = this,
          val = this.element.val(),
          pos = this.originalPos,
          buffer = reprocess === true ? '' : this.buffer,
          buffSize = reprocess === true ? 0 : buffer.length,
          workingPattern = '' + this.settings.pattern, // copy the pattern, don't reference it
          pattSize = workingPattern.length,
          isNumberMask = (this.settings.mode === 'number'),
          replaceAtIndex = this.replaceAtIndex;

        var DASH_SYMBOL = '-';
        var DASH_REGEX = new RegExp(DASH_REGEX, 'g'); // original: \-\g
        var DECIMAL_REGEX = new RegExp('\\' + DECIMAL_SYMBOL, 'g'); // original: /\./g
        var LEADING_ZERO_REGEX = new RegExp('^0+(?!\\'+ DECIMAL_SYMBOL +'|$)'); // original: /^0+(?!\.|$)/
        var THOUSANDS_SEP_REGEX = new RegExp(THOUSANDS_SEPARATOR, 'g');
        var PUNCTUATION_REGEX = new RegExp('(\\' + DECIMAL_SYMBOL + '|' + THOUSANDS_SEPARATOR + ')', 'g'); // original: /(\.|,)/g

        function moveCaret(amount) {
          pos.begin = pos.begin + amount;
          pos.end = pos.end + amount;
        }

        function stripSelection() {
          if (reprocess === true) {
            return;
          }

          var selection = val.substring(pos.begin, pos.end);
          val = replaceAtIndex(val, '', pos.begin, pos.end);
          pos.end = pos.end - selection.length;
        }

        function insertBuffer() {
          if (reprocess === true) {
            return;
          }

          val = self.insertAtIndex(val, buffer, pos.begin);
          moveCaret(buffSize);
        }

        // Remove the thousands separator from the working pattern if its setting is disabled
        if (!this.settings.thousandsSeparator) {
          workingPattern = workingPattern.replace(THOUSANDS_SEP_REGEX, '');
          pattSize = workingPattern.length;
        }

        if (!isNumberMask) {
          // strip out the portion of the text that would be selected by the caret
          stripSelection();

          // insert the buffer's contents
          insertBuffer();

          // cut down the total length of the string to make it no larger than the pattern mask
          val = val.substring(0, pattSize);

          // put it back!
          this.element.val(val);

          // reposition the caret to be in the correct spot (after the content we just added).
          if (reprocess !== true) {
            this.caret(pos.begin >= pattSize ? pattSize : pos.begin);
          }

          // trigger the 'write' event
          this.element.trigger('write.mask', [val]);
          return;
        }

        //================================================
        // Handle Number Inputs with a bit more scaffolding

        stripSelection();

        var originalVal = val,
          patternHasDecimal = workingPattern.indexOf(DECIMAL_SYMBOL) > -1,
          currentDecimalIndex = val.indexOf(DECIMAL_SYMBOL),
          decimalInBuffer = buffer.indexOf(DECIMAL_SYMBOL) > -1,
          insertBufferBeforeDecimal = true,
          decimalAlreadyExists = false;

        // Does it already exist?
        decimalAlreadyExists = currentDecimalIndex !== -1;
		
		if (decimalAlreadyExists) {
          // Are we placing the new content after the decimal?
          insertBufferBeforeDecimal = currentDecimalIndex >= pos.begin;
        }

        // insert the buffer's contents
        insertBuffer();

        // If the mask supports negative numbers, but a positive number is present,
        // don't calculate the negative symbol as part of the current pattern.
        // Also, Reduce the size of the buffer to the new maximum (pattern size minus one, representing the newly removed minus)
        if (this.settings.negative && val.indexOf(DASH_SYMBOL) === -1) {
          workingPattern = workingPattern.substring(1);
          pattSize = workingPattern.length;
          val = val.substring(0, pattSize);
        }

        // cut all but the first occurence of the negative symbol and decimal
        val = this.replaceAllButFirst(DASH_REGEX, val, '');
        val = this.replaceAllButFirst(DECIMAL_REGEX, val, '');

        // cut any extra leading zeros.
        var valWithoutLeadZeros = val.replace(LEADING_ZERO_REGEX, ''),
          numLeadingZeros = val.length - valWithoutLeadZeros.length;

        val = valWithoutLeadZeros;
        moveCaret(-(numLeadingZeros));

        var maskParts = workingPattern.replace(THOUSANDS_SEP_REGEX, '').split(DECIMAL_SYMBOL),
          totalLengthMinusSeparators = maskParts[0].length + (maskParts[1] ? maskParts[1].length : 0),
          separatorLength;

        // move the caret backward only the number of punctuation marks that were removed
        // up to the current caret position.
        var currentSliceUpToCaret = val.substring(0, pos.begin),
          commasUpToCaret = currentSliceUpToCaret.length - currentSliceUpToCaret.replace(THOUSANDS_SEP_REGEX, '').length;

        moveCaret(-(commasUpToCaret));

        // strip out the decimal and any commas from the current value
        val = val.replace(PUNCTUATION_REGEX, '');
        separatorLength = originalVal.length - val.length;

        // cut down the total length of the number if it's longer than the total number of integer
        // and decimal places
        if (val.length > totalLengthMinusSeparators) {
          val = val.substring(0, totalLengthMinusSeparators);
        }

        // if the original value had a decimal point, place it back in the right spot
        if (patternHasDecimal) {
          if (decimalAlreadyExists) {
            var inputParts = originalVal.replace(THOUSANDS_SEP_REGEX, '').split(DECIMAL_SYMBOL),
              targetDecimalIndex;

            
            // reposition the decimal in the correct spot based on total number of characters
            // in either part of the mask.
            if (inputParts[1].length < maskParts[1].length) {
              if (inputParts[0].length >= maskParts[0].length) {
                targetDecimalIndex = maskParts[0].length;
              } else {
                targetDecimalIndex = inputParts[0].length;
              }
            } else if (inputParts[1].length === maskParts[1].length) {
			  if (!insertBufferBeforeDecimal) {
			    val = val.substring(0, inputParts[0].length + maskParts[1].length);
			  }
			  targetDecimalIndex = (val.length - maskParts[1].length);
            } else {
              targetDecimalIndex = (val.length - maskParts[1].length);
            }

            val = this.insertAtIndex(val, DECIMAL_SYMBOL, targetDecimalIndex);
          } else {
            // The decimal doesn't already exist in the value string.
            // if the current value has more characters than the "integer" portion of the mask,
            // automatically add the decimal at index of the last pre-decimal pattern character.
			if (decimalInBuffer){
				if ((val.length - (pos.begin - 1)) > maskParts[1].length) {
				  val = val.substring(0, (pos.begin - 1) + maskParts[1].length);
				}
				if (buffer.indexOf(DECIMAL_SYMBOL) === 0) {
				  val = this.insertAtIndex(val, DECIMAL_SYMBOL, pos.begin - 1);
				}
				else
				{
				  val = this.insertAtIndex(val, DECIMAL_SYMBOL, buffer.indexOf(DECIMAL_SYMBOL));
				}
			}
            else if (val.length > maskParts[0].length) {
              val = this.insertAtIndex(val, DECIMAL_SYMBOL, maskParts[0].length);
              if (pos.begin === maskParts[0].length) {
                moveCaret(1);
              }
            }
          }
        }

        // Only do this part if the thousands separator should be present.
        if (this.settings.thousandsSeparator) {
          // Reposition all the commas before the decimal point to be in the proper order.
          // Store the values of "added" and "removed" commas.
          var valHasDecimal = val.length - val.replace(DECIMAL_REGEX, '').length > 0,
            parts = valHasDecimal ? val.split(DECIMAL_SYMBOL) : [val],
            reAddTheCommas = parts[0].replace(/\B(?=(\d{3})+(?!\d))/g, THOUSANDS_SEPARATOR);

          // add the commas back in
          parts[0] = reAddTheCommas;
          val = valHasDecimal ? parts.join(DECIMAL_SYMBOL) : parts[0] + (valHasDecimal ? DECIMAL_SYMBOL : '');

          currentSliceUpToCaret = reAddTheCommas.substring(0, this.originalPos.begin + separatorLength);
          commasUpToCaret = currentSliceUpToCaret.length - currentSliceUpToCaret.replace(THOUSANDS_SEP_REGEX, '').length;

          if (commasUpToCaret > 0) {
            moveCaret(commasUpToCaret);
          }

          // Manual adjustment for situations where the cursor won't move if you type a number while the
          // cursor sits in the position immediately after a thousands separator.
          if (val.substring(pos.begin - 1, pos.begin) === THOUSANDS_SEPARATOR && val.substr(pos.begin, buffSize) === buffer) {
            moveCaret(buffSize);
          }
        }

        // put it back!
        this.element.val(val);

        // reposition the caret to be in the correct spot (after the content we just added).
        if (reprocess !== true) {
          this.caret(pos.end >= pattSize ? pattSize : pos.end);
        }

        // trigger the 'write' event
        this.element.trigger('write.mask', [val]);
      },

      // Method for processing number masks
      // TODO:  Flesh out content and docs
      processNumberMask: function(typedChar, e) {
        var self = this,
          val = self.element.val(),
          maskWithoutInts = self.settings.pattern.replace(/#/g, ''),
          numMaskInts = self.settings.pattern.length - maskWithoutInts.length,
          match,
          patternChar;

        self.originalPos = self.caret();
        self.currentMaskBeginIndex = self.currentMaskBeginIndex || self.originalPos.begin;

        // don't do anything if you're at the end of the pattern.  You can't type anymore.
        if (self.currentMaskBeginIndex >= self.settings.pattern.length) {
          self.resetStorage();
          return self.killEvent(e);
        }

        // Get the currently typed string up to the beginning of the caret.
        var sliceUpToCaret = val.substring(0, self.originalPos.begin),
          sliceHasDecimal = sliceUpToCaret.length !== sliceUpToCaret.replace(/\./g, '').length,
          inputWithoutDec = val.replace(/\./g, ''),
          valHasDecimal = val.length !== inputWithoutDec.length,
        // Do a check to see if the character typed matches the mask pattern character.
        // This is done against the mask WITHOUT COMMAS.  The caret's position is adjusted
        // for the difference in position.
          commasUpToCaret = sliceUpToCaret.length - sliceUpToCaret.replace(/,/g, '').length,
          trueMaskIndex = sliceUpToCaret.length - commasUpToCaret;
        patternChar = self.getCharacter('current', trueMaskIndex);

        // Is the decimal already in the slice up to the caret?
        // If it is, only work with the "post-decimal" portion of the mask
        if (sliceHasDecimal) {
          var postDecMask = self.settings.pattern.split('.')[1],  // tests all mask characters after the decimal
            postDecSlice = sliceUpToCaret.split('.')[1], // tests only typed characters after the decimal up to the caret
            distanceFromDec = (self.originalPos.begin - 1) - sliceUpToCaret.indexOf('.');
          patternChar = postDecMask.charAt(distanceFromDec);

          // if there are as many or more characters in the slice as the mask, don't continue.
          // The decimal place maximum has been hit.  Only do this if the "entire" mask isn't selected.
          var selectedChars = val.substring(self.originalPos.begin, self.originalPos.end);
          if (selectedChars.length < val.length && postDecSlice.length >= postDecMask.length) {
            self.resetStorage();
            return self.killEvent(e);
          }

          // Test the correct pattern character against the typed character
          match = self.testCharAgainstRegex(typedChar, patternChar);
          if (!match) {
            self.resetStorage();
            return self.killEvent(e);
          }

          // The character belongs in the post-decimal portion of the mask.  Add it and move on.
          self.buffer += typedChar;
          self.writeInput();
          self.resetStorage();
          return self.killEvent(e);
        }

        // The decimal point is not currently in the portion of the string we're working with.
        var patternHasDecimal = self.settings.pattern.length !== self.settings.pattern.replace(/\./g, '').length;

        // Check the character to see if it's a decimal
        if (self.isCharacterDecimal(typedChar)) {
          // Don't allow the decimal to be added if the pattern doesn't contain one.
          if (!patternHasDecimal) {
            self.resetStorage();
            return self.killEvent(e);
          }
          if (valHasDecimal) {
            var caretSlice = val.substring(self.originalPos.begin, self.originalPos.end),
              caretSliceHasDecimal = caretSlice.length !== caretSlice.replace(/\./g, '').length;
            if (caretSliceHasDecimal) {
              if (caretSlice.length === val.length) {
                self.buffer += '0';
              }
              self.buffer += typedChar;
              self.writeInput();
            }
            self.resetStorage();
            return self.killEvent(e);
          }

          // The decimal is OK to add to the string.
          // if the current input is empty or if the caret position is at the beginning, add a leading zero
          if (val.length === 0 || self.originalPos.begin === 0) {
            self.buffer += '0';
          }
          self.buffer += typedChar;
          self.writeInput();
          self.resetStorage();
          return self.killEvent(e);
        }

        // If the new pattern char is the decimal, add it.
        if (self.isCharacterDecimal(patternChar)) {
          if (!valHasDecimal) {
            self.buffer += patternChar;
          }
          // Test the next character in the mask to see
          patternChar = self.getCharacter('next', trueMaskIndex);
          match = self.testCharAgainstRegex(typedChar, patternChar);
          if (match) {
            self.buffer += typedChar;
          }
          self.writeInput();
          self.resetStorage();
          return self.killEvent(e);
        }

        // Test to see if the character is the negative symbol
        if (typedChar === '-') {
          if (!self.settings.negative || self.originalPos.begin > 0) {
            self.resetStorage();
            return self.killEvent(e);
          }

          self.buffer += typedChar;
          self.writeInput();
          self.resetStorage();
          return self.killEvent(e);
        }

        var inputParts = val.split('.'),
          inputWithoutCommas = inputParts[0].replace(/,/g, ''),
          inputWithoutOperators = inputWithoutCommas.replace(/-/g, ''),
          numInputInts = inputWithoutOperators.length;

        // Actually test the typed character against the correct pattern character.
        match = self.testCharAgainstRegex(typedChar, patternChar);
        if (!match) {
          if (self.settings.negative && self.testCharAgainstRegex(typedChar, '~')) {
            // Let it go
          } else {
            self.resetStorage();
            return self.killEvent(e);
          }
        }

        // Is the "integer" portion of the mask filled?
        if (numInputInts >= numMaskInts) {
          // Add the decimal if the value doesn't already have it
          self.buffer += !valHasDecimal && patternHasDecimal ? '.' + typedChar : typedChar;
          self.writeInput();
          self.resetStorage();
          return self.killEvent(e);
        }

        // Add the character to the "integer" part of the mask
        // Get the current value of the pre-decimal mask, strip out commas, add them back in the
        // Appropriate spots, and move the caret position appropriately.
        self.buffer += typedChar;
        self.writeInput();
        self.resetStorage();
        return self.killEvent(e);
      },

      // Processes the pattern string and returns an object that contains that string's sections of matchable patterns
      // and its unmatchable literals.
      getPatternParts: function() {
        var self = this,
          defKeys = Object.keys(this.settings.definitions),
          patternEditableParts = [],
          patternLiteralParts = [],
          patternStartsWithLiteral = false,
          i = 0,
          regexString = '',
          regexObj;

        // Build the string of "editable" matches dynamically from settings,
        // and match it against the incoming pattern to determine each editable group.
        $.each(defKeys, function(i, def) {
          regexString += def;
        });
        regexString = '[' + regexString + ']+';
        regexObj = new RegExp(regexString, 'g');
        patternEditableParts = self.settings.pattern.match(regexObj) || [];

        // check for literal characters at the beginning of the string before the first matchable pattern
        if (patternEditableParts[0] && self.settings.pattern.substring(0, 1) !== patternEditableParts[0].substring(0, 1)) {
          patternLiteralParts.push( self.settings.pattern.substring( 0, self.settings.pattern.indexOf( patternEditableParts[0] )));
          patternStartsWithLiteral = true;
        }

        // set a starting index for our literal checking... may not be 0 if there were literals before the first match
        var prevLiteralEndIndex = (patternLiteralParts && patternLiteralParts[0]) ? (self.settings.pattern.indexOf(patternLiteralParts[0]) + patternLiteralParts[0].length) : 0;

        // get all sets of literal characters in the pattern and store them
        while (i < patternEditableParts.length) {
          // start cutting the string here
          var currLiteralStartIndex = prevLiteralEndIndex + patternEditableParts[i].length,
            // get a fresh cut of the pattern minus the parts we've already dealt with
            nextCut = self.settings.pattern.substring(currLiteralStartIndex, self.settings.pattern.length),
            cutChars = self.settings.pattern.length - nextCut.length,
            // finish cutting the string at the end of the next piece of editable pattern OR the end of the pattern
            currLiteralEndIndex = cutChars + (patternEditableParts[i+1] ? nextCut.indexOf(patternEditableParts[i+1]) : nextCut.length),
            // should contain the next literal
            currLiteral = self.settings.pattern.substring(currLiteralStartIndex, currLiteralEndIndex);
          if (currLiteral !== '') {
            patternLiteralParts.push(currLiteral);
          }
          prevLiteralEndIndex = currLiteralEndIndex;
          i++;
        }

        // build an array that contains one of each character in the literals sections for testing
        var allLiterals = '';
        for (var a = 0; a < patternLiteralParts.length; a++) {
          allLiterals += patternLiteralParts[a];
        }
        var containedLiterals = self.removeDuplicates(allLiterals);

        var allEditables = '';
        for (var b = 0; b < patternEditableParts.length; b++) {
          allEditables += patternEditableParts[b];
        }
        var containedEditables = self.removeDuplicates(allEditables);

        return {
          editable: patternEditableParts,
          literal: patternLiteralParts,
          allLiterals: allLiterals,
          allEditables: allEditables,
          containedLiterals: containedLiterals,
          containedEditables: containedEditables,
          startsWithLiteral: patternStartsWithLiteral
        };
      },

      // Processes the current input value against the pre-processed mask, and returns an array containing the values
      // inside of each editable piece of the group pattern.
      analyzeInput: function(inputSlice) {
        var self = this,
          val = inputSlice !== undefined ? inputSlice : self.element.val(),
          currentMaskPartIsLiteral = false,
          editables = self.maskParts.editable,
          literals = self.maskParts.literal,
          totalMaskParts = editables.length + literals.length,
          editableParts = [],
          literalParts = [],
          valFromLastIndex = '',
          allEditables = '',
          allLiterals = '',
          nextLiteralIndex = 0,
          nextEditableIndex = 0,
          editablePart = '',
          literalPart = '',
          valIndex = 0,
          editableCount = 0,
          literalCount = 0,
          i = 0,
          a = 0;

        // More literals than editables means that there is a literal pattern BEFORE the first editable pattern.
        if (self.maskParts.startsWithLiteral) {
          currentMaskPartIsLiteral = true;
        }

        // Loop through all parts, and retrieve the values inside the editable parts.
        for (i; i < totalMaskParts; i++) {
          if (currentMaskPartIsLiteral) {
            valFromLastIndex = val.substring(valIndex, val.length);
            nextEditableIndex = valIndex + valFromLastIndex.length;
            literalPart = '';

            // find next literal character and grab its index.
            for (a = 0; a < valFromLastIndex.length; a++) {
              if ($.inArray(valFromLastIndex[a], self.maskParts.containedLiterals) === -1) {
                nextEditableIndex = valIndex + a;
                break;
              }
            }

            literalPart = val.substring(valIndex, nextEditableIndex);
            if (literalPart.length > 0) {
              literalParts.push(literalPart);
            }

            allLiterals += literalPart;
            valIndex = valIndex + literalPart.length;
            currentMaskPartIsLiteral = false;
            literalCount++;
          } else {
            valFromLastIndex = val.substring(valIndex, val.length);
            nextLiteralIndex = valIndex + valFromLastIndex.length;
            editablePart = '';

            // find next literal character and grab its index.
            for (a = 0; a < valFromLastIndex.length; a++) {
              if ($.inArray(valFromLastIndex[a], self.maskParts.containedLiterals) !== -1) {
                nextLiteralIndex = valIndex + a;
                break;
              }
            }

            editablePart = val.substring(valIndex, nextLiteralIndex);
            if (editablePart.length > 0) {
              editableParts.push(editablePart);
            }

            allEditables += editablePart;
            valIndex = valIndex + editablePart.length;
            currentMaskPartIsLiteral = true;
            editableCount++;
          }
        }

        // make sure there is at least one empty entry in the array.
        if (editableParts.length === 0) {
          editableParts.push('');
        }

        return {
          editables: editableParts,
          allEditables: allEditables,
          literals: literalParts,
          allLiterals: allLiterals
        };
      },

      // Returns a reconstructed pattern based on the parts dissected from the getPatternParts() method.
      // Used for testing and sanity-checking.
      buildPatternFromParts: function() {
        var parts = this.getPatternParts(),
          pattern = '',
          literalCount = 0,
          editableCount = 0;

        // there is a literal BEFORE and AFTER the first match.
        if (parts.startsWithLiteral) {
          pattern += parts.literal[0];
          literalCount++;
        }
        // there are no literals BEFORE the first match, but there is a literal AFTER the last match.
        if (parts.literal === parts.editable) {}
        while (editableCount < parts.editable.length) {
          pattern += parts.editable[editableCount];
          if (parts.literal[literalCount]) {
            pattern += parts.literal[literalCount];
          }
          editableCount++;
          literalCount++;
        }

        return pattern;
      },

      // takes a string of character literals and returns an array containing each unique literal found.
      removeDuplicates: function(string) {
        var unique = [];
        for (var i = 0; i < string.length; i++) {
          if ($.inArray(string[i], unique) === -1) {
            unique.push(string[i]);
          }
        }
        return unique;
      },

      processMask: function(typedChar, e) {
        var self = this,
          maskEditables = self.maskParts.editable,
          maskLiterals = self.maskParts.literal,
          match,
          i = 0;

        self.originalPos = self.caret();
        self.currentMaskBeginIndex = self.currentMaskBeginIndex || self.originalPos.begin;

        var val = self.element.val().substring(0, self.originalPos.begin),
          input = self.analyzeInput(val);

        // If the input is full, don't continue.
        if (self.originalPos.begin === self.originalPos.end && input.allEditables.length >= self.maskParts.allEditables.length) {
          self.resetStorage();
          return self.killEvent(e);
        }

        // don't continue at all if the character typed isn't a valid editable or literal in this pattern
        for (var b = 0; b < self.maskParts.containedEditables.length; b++) {
          match = self.testCharAgainstRegex(typedChar, self.maskParts.containedEditables[b]);
          if (match) {
            break;
          }
        }
        if (!match && $.inArray(typedChar, self.maskParts.containedLiterals) === -1) {
          self.resetStorage();
          return self.killEvent(e);
        }

        // "i" increments the literal section checks by one.  This is necessary if you have a literal pattern group
        // starting the pattern.
        i = 0;
        if (self.maskParts.startsWithLiteral) {
          i = i + 1;
        }


        // Fail out if we try to type too many characters
        var currentSection = (input.editables.length - 1) > 0 ? input.editables.length - 1 : 0;
        if (input.editables[currentSection].length > maskEditables[currentSection].length) {
          self.resetStorage();
          return self.killEvent(e);
        }

        // Constant boolean for checking on literals (used by the two checks below)
        var typedLiteralsAreValid = (maskLiterals[currentSection+i] !== undefined) &&
          $.inArray(typedChar, self.maskParts.containedLiterals) !== -1 &&
          !(input.literals[currentSection+i]);

        // If the character typed is a literal, allow it to go through if there is still a section of unmatched literals
        // and there has been at least one editable character entered in this section.  This only works if the flag
        // 'self.settings.groupComplete' is set to 'false' (generally used for dates).
        if (typedLiteralsAreValid &&
          !self.settings.groupComplete &&
          input.editables[currentSection].length > 0) {

          self.checkSectionForLiterals(e, typedChar, maskLiterals[currentSection+i]);
          self.writeInput();
          self.resetStorage();
          return self.killEvent(e);
        }

        // If 'self.settings.groupComplete' is true, but all characters for this particular group have already been entered,
        // Allow a typed literal character to pass
        if (typedLiteralsAreValid &&
          self.settings.groupComplete &&
          input.editables[currentSection].length === maskEditables[currentSection].length) {

          self.checkSectionForLiterals(e, typedChar, maskLiterals[currentSection+i]);
          self.writeInput();
          self.resetStorage();
          return self.killEvent(e);
        }

        // If the "literals" are shifted forward due to the mask beginning with a literal pattern instead of an
        // editable pattern, automatically append that literal character at this point, since it hasn't been typed
        if (i > 0 && currentSection === 0 && !(input.literals[0])) {
          self.buffer += maskLiterals[0];
          if ($.inArray(typedChar, self.maskParts.containedLiterals) !== -1) {
            self.writeInput();
            self.resetStorage();
            return self.killEvent(e);
          }
        }

        // Define the section, as well as the correct pattern character to match against.
        var section = input.editables[currentSection] || '',
          currVal,
          patternChar,
          remainder;

        if (section.length < maskEditables[currentSection].length) {

          patternChar = maskEditables[currentSection].substring(input.editables[currentSection].length, (input.editables[currentSection].length + 1));

          // If we're typing inside of an existing literal pattern, this editable pattern has been pre-maturely completed
          // already, and we need to complete this literal pattern, while checking the match against the next editable group
          if (input.literals[currentSection+i] && maskLiterals[currentSection+i] !== input.literals[currentSection+i]) {
            currVal = self.element.val();
            remainder = currVal.substring(self.originalPos.begin, currVal.length);
            val = val.substring(0, (val.length - input.literals[currentSection+i].length));
            self.caret(self.originalPos.begin - input.literals[currentSection+i].length);
            self.originalPos = self.caret();
            self.element.val(val + remainder);
            self.buffer += maskLiterals[currentSection+i];
            patternChar = maskEditables[currentSection+1].substring(0, 1);
          }

          match = self.testCharAgainstRegex(typedChar, patternChar);

          // Simply add the character if its a match
          if ($.inArray(typedChar, self.maskParts.containedLiterals) === -1 && match) {
            self.buffer += typedChar;
            self.writeInput();
          }
        } else if (section.length === maskEditables[currentSection].length) {
          // Check that conditions are right for the next set of literal characters to be added
          if (maskEditables[currentSection+1] &&
              maskLiterals[currentSection+i]) {

            // check to make sure that the existing literals in the set are correctly formed,
            // and fix them if they aren't.
            if (input.literals[currentSection+i] && maskLiterals[currentSection+i] !== input.literals[currentSection+i]) {
              currVal = self.element.val();
              remainder = currVal.substring(self.originalPos.begin, currVal.length);
              val = val.substring(0, (val.length - input.literals[currentSection+i].length));
              self.caret(self.originalPos.begin - input.literals[currentSection+i].length);
              self.originalPos = self.caret();
              self.element.val(val + remainder);
              self.buffer += maskLiterals[currentSection+i];
            }

            // add the mask literals to the beginning of the buffer if they are not already there
            if (!input.literals[currentSection+i]) {
              self.buffer += maskLiterals[currentSection+i];
            }

            patternChar = maskEditables[currentSection+1].substring(0, 1);
            match = self.testCharAgainstRegex(typedChar, patternChar);

            // add the typed character if it's valid
            if ($.inArray(typedChar, self.maskParts.containedLiterals) === -1 && match) {
              self.buffer += typedChar;
            }
          } else {
            // We've technically completed the pattern, but the pattern may be shorter if each group isn't
            // 'complete'.  This section checks to see if we have leftover characters at the end of the input
            // and removes them.
            currVal = self.element.val();
            remainder = currVal.substring(self.originalPos.begin, currVal.length);

            if (remainder.length > 0) {
              self.element.val(currVal.substring(0, self.originalPos.begin));
            }
          }

          if (self.buffer.length > 0) {
            self.writeInput();
          }
        }

        self.resetStorage();
        return self.killEvent(e);
      },

      checkSectionForLiterals: function(e, typedChar, section) {
        for (var a = 0; a < section.length; a++) {
          if (typedChar === section[a]) {
            this.buffer += section;
            break;
          }
        }
      },

      // Takes an entire string of characters and runs each character against the processMask()
      // method until it's complete.
      processStringAgainstMask: function(string, originalEvent) {
        if (this.element.is(':hidden')) {
          return this;
        }

        switch(this.settings.mode) {
          case 'number':
            if (!this.originalPos) {
              this.originalPos = this.caret();
            }
            this.buffer = string;
            this.writeInput();
            this.resetStorage();
            break;
          default:
            var charArray = string.split('');
            for(var i = 0; i < charArray.length; i++) {
              var patternChar = this.getCharacter();
              this.processMask(charArray[i], patternChar, originalEvent);
            }
            break;
        }

        return this;
      },

      /**
       * Re-masks the current contents of the field.
       * @returns { this }
       **/
      remask: function(remaskingOnBlur) {
        if (!this.originalPos) {
          if (remaskingOnBlur) {
            this.originalPos = { begin: 0, end: this.element.val().length };
          } else {
            this.originalPos = this.caret();
          }
        }
        this.writeInput(true);
        this.resetStorage();

        return this;
      },

      // Takes a character from the pattern string in Settings, gets the corresponding Regex string
      // from the definitions array in Settings, and tests the character against the Regex.
      testCharAgainstRegex: function(typedChar, patternChar) {
        var regex = this.settings.definitions[patternChar];
        return !regex ? false : regex.test(typedChar);
      },

      // Replaces all but the first occurence of a regex with nothing.
      replaceAllButFirst: function(regex, textString, replacement) {
        if (!replacement) {
          replacement = '';
        }
        var count = 0;
        textString = textString.replace(regex, function(match) {
          if (count > 0) {
            return replacement;
          }
          return match;
        });
        return textString;
      },

      // Returns the character at the current/next/previous cursor position.
      // If no direction is provided, it defaults to the current position.
      // If an optional index is provided, the cursor position will shift to that index value.
      getCharacter: function(direction, maskIndex) {
        var mask = this.settings.mode === 'number' ? this.settings.pattern.replace(/,/g, '') : this.settings.pattern,
          index = maskIndex ? maskIndex : this.caret().begin;
        direction = this.evaluateDirecton(direction);

        switch(direction) {
          case 'next':
            return mask.substring(index + 1, index + 2);
          case 'prev':
            return mask.substring(index - 1, index);
          default: // current
            return mask.substring(index, index + 1);
        }
      },

      updated: function() {
        return this
          .teardown()
          .init();
      },

      teardown: function() {
        if (this.settings.showCurrency) {
          this.element.parent('.field').removeClass('currency').attr('data-currency-symbol', '');
          this.element.prev('label').find('.currency').remove();
        }
        this.element.off('updated.mask keydown.mask keypress.mask keyup.mask focus.mask blur.mask ' + this.getPasteEvent());

        this.element.removeClass('is-mask').removeClass('is-number-mask');

        return this;
      },

      destroy: function() {
        this.teardown();
        $.removeData(this.element[0], pluginName);

        return this;
      }
    };

    // Keep the Chaining while Initializing the Control (Only Once)
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (instance) {
        instance.settings = $.extend({}, instance.settings, options);
        instance.updated();
      } else {
        instance = $.data(this, pluginName, new Mask(this, settings));
      }
    });
  };


  $.fn.multiselect = function(options) {

    'use strict';

    // Settings and Options
    var pluginName = 'multiselect',
        defaults = {
          filterMode: 'contains',
          maxSelected: undefined,
          moveSelected: 'all',
          showEmptyGroupHeaders: false,
          showSelectAll: false,
          source: undefined
        },
        settings = $.extend({}, defaults, options);

    /**
     * @constructor
     * @param {Object} element
     */
    function MultiSelect(element) {
      this.settings = $.extend({}, settings);
      this.element = $(element);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    // Plugin Methods
    MultiSelect.prototype = {

      init: function() {
        this.build();
      },

      build: function() {
        var ddOpts = {
            closeOnSelect: false,
            empty: true,
            moveSelected: 'all',
            multiple: true
          };

        if (this.settings.filterMode) {
          ddOpts.filterMode = this.settings.filterMode;
        }

        if (this.settings.source) {
          ddOpts.source = this.settings.source;
        }

        if (this.settings.maxSelected) {
          ddOpts.maxSelected = this.settings.maxSelected;
        }

        if (this.settings.moveSelected) {
          ddOpts.moveSelected = this.settings.moveSelected;
        }

        if (this.settings.showEmptyGroupHeaders) {
          ddOpts.showEmptyGroupHeaders = this.settings.showEmptyGroupHeaders;
        }

        if (this.settings.showSelectAll) {
          ddOpts.showSelectAll = this.settings.showSelectAll;
        }

        this.element.dropdown(ddOpts);
        this.dropdown = this.element.data('dropdown');

        return this;
      },

      enable: function() {
        this.dropdown.enable();
      },

      disable: function() {
        this.dropdown.disable();
      },

      updated: function() {
        this.build();
      },

      // Teardown - Remove added markup and events
      destroy: function() {
        this.dropdown.destroy();
        this.element.off();
        $.removeData(this.element[0], pluginName);
      }
    };

    // Initialize the plugin (Once)
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (instance) {
        instance.settings = $.extend({}, instance.settings, options);
        instance.updated();
      } else {
        instance = $.data(this, pluginName, new MultiSelect(this, settings));
      }
    });
  };


  $.fn.message = function(options) {

    // Settings and Options
    var pluginName = 'message',
      defaults = {
          title: 'Message Title', //Title text or content shown in the message
          isError: false, //Show Title as an Error with an Icon
          message: 'Message Summary', //The message content or text
          width: 'auto',  //specify a given width or fit to content with auto
          buttons: null, //Passed through to modal
          cssClass: null,
          returnFocus: null //Element to focus on return
        },
        settings = $.extend({}, defaults, options);

    /**
     * Responsive Messages
     * @constructor
     * @param {Object} element
     */
    function Message(element) {
      this.element = $(element);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    // Actual Plugin Code
    Message.prototype = {

      init: function() {
        var self = this,
          content;

        //Create the Markup
        this.message = $('<div class="modal message"></div>');
        this.messageContent = $('<div class="modal-content"></div>');
        this.title = $('<h1 class="modal-title" id="message-title">' + settings.title + '</h1>').appendTo(this.messageContent).wrap('<div class="modal-header"></div>');
        this.content = $('<div class="modal-body"><p class="message" id="message-text">'+ settings.message +'</p></div>').appendTo(this.messageContent);

        //Append The Content if Passed in
        if (!this.element.is('body')) {
          content = this.element;
          this.content.empty().append(content.show());
        }

        this.message.append(this.messageContent).appendTo('body');
        this.message.modal({trigger: 'immediate', buttons: settings.buttons,
          resizable: settings.resizable, close: settings.close, isAlert: true});

        //Adjust Width if Set as a Setting
        if (settings.width !== 'auto') {
          this.content.closest('.modal')[0].style.maxWidth = 'none';
          this.content.closest('.modal')[0].style.width = settings.width + (/(px|%)/i.test(settings.width + '') ? '' : 'px');
        }

        if (settings.cssClass) {
          this.message.addClass(settings.cssClass);
        }

        //Setup the destroy event to fire on close.  Needs to fire after the "close" event on the modal.
        this.message.on('beforeclose.message', function () {
          var ok = self.element.triggerHandler('beforeclose');
          return ok;
        }).on('beforeopen.message', function () {
          var ok = self.element.triggerHandler('beforeopen');
          return ok;
        }).on('open.message', function () {
          self.element.trigger('open');
        }).on('afterclose.message', function() {
          self.destroy();
          if (settings.returnFocus) {
            settings.returnFocus.focus();
          }

          $(document).off('keypress.message keydown.message');
        });

        $(document).on('keypress.message keydown.message', function (e) {
          var keyCode = e.which || e.keyCode;

          if (keyCode === 27) {
            setTimeout(function () {
              var modalData = self.message.data('modal');
              if (modalData !== undefined) {
                modalData.close();
              }
            }, 0);
          }
        });

        if (settings.isError) {
          this.title.addClass('is-error').prepend($.createIconElement('error'));
        } else {
          this.title.removeClass('is-error').find('svg').remove();
        }
      },

      destroy: function() {
        var modalData = this.message.data('modal');
        if (modalData !== undefined) {
          modalData.destroy();
        }

        this.message
          .off('beforeclose.message beforeopen.message open.message afterclose.message')
          .remove();
      }
    };

    // Support Chaining and Init the Control or Set Settings
    return this.each(function() {
      new Message(this, settings);
    });
  };


  $.fn.modal = function(options) {

    // Settings and Options
    var pluginName = 'modal',
      defaults = {
        trigger: 'click', //Supports click, immediate
        buttons: null,  //Pass in the Buttons
        isAlert: false, //Adds alertdialog role
        content: null, //Ability to pass in dialog html content
        cssClass: null,  //Append a css class to top level
        autoFocus: true,
        id: null,  //Optionally tag a dialog with an id
        frameHeight: 180, //Extra Height
        frameWidth: 46 //Extra Width
      },
      settings = $.extend({}, defaults, options);

    /**
     * Responsive and Accessible Modal Control
     * @constructor
     * @param {Object} element
     */
    function Modal(element) {
      this.settings = $.extend({}, settings);
      this.element = $(element);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
      this.reStructure();
    }

    // Actual Plugin Code
    Modal.prototype = {
      init: function() {
        var self = this;
        this.isIeOrEdge = /ie|edge/i.test(Soho.env.browser.name);

        // Used for tracking events tied to the Window object
        this.id = (parseInt($('.modal').length, 10)+1);
        this.trigger = $('button[data-modal="' + this.element.attr('id') + '"]');  //Find the button with same dialog ID
        this.overlay = $('<div class="overlay"></div>');
        this.oldActive = this.trigger;

        if (this.settings.trigger === 'click') {
          this.trigger.on('click.modal', function() {
            self.open();
          });
        }

        if (this.settings.trigger === 'immediate') {
          setTimeout(function() {
            self.open();
          }, 1);
        }

        self.isCancelled = false;

        //ensure is appended to body for new dom tree
        if (this.settings.content) {

          this.settings.trigger = this.settings.content instanceof jQuery ? this.settings.trigger : 'immediate';
          this.appendContent();
          setTimeout(function () {
            self.open();
          }, 1);
          return;
        }

        self.addButtons(this.settings.buttons);
        this.element.appendTo('body');
        this.element[0].style.display = 'none';
      },

      appendContent: function () {
        var isAppended = false;

        this.element = $(
          '<div class="modal">' +
            '<div class="modal-content">'+
              '<div class="modal-header"><h1 class="modal-title">'+ this.settings.title +'</h1></div>' +
              '<div class="modal-body-wrapper">'+
                '<div class="modal-body"></div>'+
              '</div>'+
            '</div>'+
          '</div>');

        if (this.settings.id) {
          this.element.attr('id', this.settings.id);
        }

        if ($(this.settings.content).is('.modal')) {
          this.element = $(this.settings.content);
        } else if (this.settings.content && this.settings.content.length > 0) {

          if (this.settings.content instanceof jQuery && this.settings.content.parent().is('.modal-body')) {
            isAppended = true;
            this.element = this.settings.content.closest('.modal');
          } else {
            var self = this,
              body = self.element.find('.modal-body');

            body.append(self.settings.content);
            Soho.utils.fixSVGIcons(body);
          }

          if (this.settings.content instanceof jQuery){
            this.settings.content.show();
          }
        }

        if (!isAppended) {
          this.element.appendTo('body');
        }

        if (this.settings.cssClass) {
          this.element.addClass(this.settings.cssClass);
        }

        if (this.settings.title) {
          this.element.find('.modal-title').text(this.settings.title);
        }

        if (!isAppended) {
          this.addButtons(this.settings.buttons);
        }
      },

      reStructure: function() {
        var body = $('.modal-body', this.element),
          hr = $('hr:first-child', body),
          buttonset = $('.modal-buttonset', this.element);

        if (body && body.length && !body.parent().hasClass('modal-body-wrapper')) {
          body.wrap('<div class="modal-body-wrapper"></div>');
        }
        if (hr && hr.length && !hr.parent().hasClass('modal-content')) {
          hr.insertAfter(this.element.find('.modal-header'));
        }
        if (buttonset && buttonset.length && !buttonset.parent().hasClass('modal-content')) {
          buttonset.insertAfter(this.element.find('.modal-body-wrapper'));
        }

      },

      disableSubmit: function () {
        var body = this.element,
          fields = body.find('[data-validate]:visible'),
          inlineBtns = body.find('.modal-buttonset button'),
          primaryButton = inlineBtns.filter('.btn-modal-primary').not('.no-validation');

        if (fields.length > 0) {
          primaryButton.removeAttr('disabled');

          var allValid = true;
          fields.each(function () {

            var field = $(this);
            if (field.closest('.datagrid-filter-wrapper').length > 0) {
              return;
            }

            var isVisible = field[0].offsetParent !== null;

            if (field.is('.required')) {
              if (isVisible && !field.val()) {
                allValid = false;
              }
            } else {
              field.checkValidation();
              if (isVisible && !field.isValid()) {
                allValid = false;
              }

            }

            if (allValid) {
              primaryButton.removeAttr('disabled');
            }
          });

          if (!allValid && !primaryButton.is(':disabled')) {
             primaryButton.attr('disabled', 'true');
          }
        }

      },

      addButtons: function(buttons) {
        var self = this,
          body = this.element.find('.modal-body'),
          bodywrapper = body.parent(),
          btnWidth = 100,
          isPanel = false,
          buttonset;

        this.modalButtons = buttons;

        if (!buttons) {
          var inlineBtns = this.element.find('.modal-buttonset button');
          // Buttons in markup
          btnWidth = 100/inlineBtns.length;
          for (var i = 0, l = inlineBtns.length; i < l; i++) {
            inlineBtns[i].style.width = btnWidth + '%';
          }
          inlineBtns.button();
          inlineBtns.not('[data-ng-click], [ng-click], [onclick], :submit').on('click.modal', function (e) {
            if ($(e.target).is('.btn-cancel')) {
              self.isCancelled = true;
            }
            self.close();
          });
          return;
        }

        if (this.element.is('.contextual-action-panel')) {
          isPanel = true;
          // construct the toolbar markup if a toolbar isn't found
          buttonset = this.element.find('.buttonset');
          if (!buttonset.length) {
            var toolbar = this.element.find('.toolbar');
            if (!toolbar.length) {
              $('<div class="toolbar"></div>').appendTo(this.element.find('.modal-header'));
            }
            buttonset = $('<div class="buttonset"></div>').appendTo(this.element.find('.toolbar'));
          }
        } else {
          buttonset = this.element.find('.modal-buttonset');
          if (!buttonset.length) {
            buttonset = $('<div class="modal-buttonset"></div>').insertAfter(bodywrapper);
          }
        }

        btnWidth = 100/buttons.length;

        if (buttons) {
          buttonset.empty();
        }

        $.each(buttons, function (name, props) {
          var btn = $('<button type="button"></button>');
          btn.text(props.text);

          if (props.cssClass === 'separator') {
            btn = $('<div class="separator"></div>');
          }

          if (props.cssClass) {
            btn.attr('class', props.cssClass);
          } else {
            if (props.isDefault) {
              btn.addClass('btn-modal-primary');
            } else {
              btn.addClass('btn-modal');
            }
          }

          if (props.validate !== undefined && !props.validate) {
            btn.addClass('no-validation');
          }

          var attrs = {},
            attrTypes = ['id', 'name', 'text'];

          for (var i = 0; i < attrTypes.length; i++) {
            if (props[attrTypes[i]]) {
              attrs[attrTypes[i]] = props[attrTypes[i]];
            }
          }

          if (props.type === 'input') {
            var label = $('<label class="audible" for="filter">' + props.text + '</label>'),
              input = $('<input class="searchfield">').attr(attrs);

            buttonset.append(label, input);
            return;
          }

          if (props.icon && props.icon.charAt(0) === '#') {
            btn.html('<span>' + btn.text() + '</span>');
            $.createIconElement({
              classes: [props.icon === '#icon-close' ? 'icon-close' : ''],
              icon: props.icon.substr('#icon-'.length)
            }).prependTo(btn);
          }

          if (props.id) {
            btn.attr('id', props.id);
          }

          btn.on('click.modal', function(e) {
            if (props.click) {
              props.click.apply(self.element[0], [e, self]);
              return;
            }
            self.close();
          });

          if (!isPanel) {
            btn[0].style.width = btnWidth + '%';
          }

          btn.button();
          buttonset.append(btn);

        });

      },

      sizeInner: function () {
        var messageArea;
        messageArea = this.element.find('.detailed-message');
        //Set a max width
        var h = $(window).height() - messageArea.offset().top - 150;
        messageArea[0].style.maxHeight = h + 'px';
        messageArea[0].style.overflow = 'auto';
        messageArea[0].style.width = messageArea.width() + 'px';
      },

      open: function () {
        var self = this, messageArea,
          elemCanOpen = true;

        if (!this.trigger || this.trigger.length ===0) {
          this.oldActive = $(':focus');  //Save and restore focus for A11Y
        }

        this.element.after(this.overlay);
        if (this.element && !this.element.parent().hasClass('modal-wrapper')) {
          this.element.wrap('<div class="modal-page-container"><div class="modal-wrapper"></div>');
        }
        this.root = this.element.closest('.modal-page-container');

        messageArea = self.element.find('.detailed-message');
        if (messageArea.length === 1) {
          $('body').on('resize.modal-' + this.id, function () {
            self.sizeInner();
          });
          self.sizeInner();
        }

        elemCanOpen = this.element.triggerHandler('beforeopen');
        self.isCancelled = false;

        if (elemCanOpen === false) {
          self.overlay.remove();
          self.root[0].style.display = 'none';
          return false;
        }

        //Look for other nested dialogs and adjust the zindex.
        $('.modal').each(function (i) {
          var modal = $(this);
          this.style.zIndex = (1020 + (i + 1)).toString();

          if (modal.data('modal') && modal.data('modal').overlay) {
            modal.data('modal').overlay[0].style.zIndex = (1020 + i).toString();
          }
        });

        $('body > *').not(this.element).not('.modal, .overlay, .modal-page-container').attr('aria-hidden', 'true');

        // Ensure aria-labelled by points to the id
        if (this.settings.isAlert) {
          this.element.attr('aria-labeledby', 'message-title');
          this.element.attr('aria-describedby', 'message-text');
        } else {
          var h1 = this.element.find('h1:first'),
            id = h1.attr('id');

          if (!id) {
            id = (this.element.attr('id') ? this.element.attr('id') : 'h1')  + '-title';
            h1.attr('id', id);
          }

          var body = this.element.find('.modal-body'),
            descById = (this.element.attr('id') ? this.element.attr('id') : 'message') + '-text';

          this.element.attr('aria-labeledby', id);

          //Contextual Action Panel Case - Has a toolbar
          if (this.element.find('.toolbar .title').length) {
            this.element.find('.toolbar .title').attr('id', descById);
            this.element.attr('aria-describedby', descById);
          } else {
            body.attr('id', descById);
            this.element.attr('aria-describedby', descById);
          }

        }

        this.mainContent = $('body').children('.scrollable-container');
        if (!this.mainContent.length) {
          this.mainContent = $('body');
        }

        this.removeNoScroll = !this.mainContent.hasClass('no-scroll');
        this.mainContent.addClass('no-scroll');

        $('body').on('resize.modal-' + this.id, function() {
          self.resize();
        });

        //Center
        this.root[0].style.display = '';
        this.element[0].style.display = '';

        setTimeout(function() {
          self.resize();
          self.element.addClass('is-visible').attr('role', (self.settings.isAlert ? 'alertdialog' : 'dialog'));
          self.root.attr('aria-hidden', 'false');
          self.overlay.attr('aria-hidden', 'true');
          self.element.attr('aria-modal', 'true'); //This is a forward thinking approach, since aria-modal isn't actually supported by browsers or ATs yet
        }, 1);

        // Add the 'modal-engaged' class after all the HTML markup and CSS classes have a chance to be established
        // (Fixes an issue in non-V8 browsers (FF, IE) where animation doesn't work correctly).
        // http://stackoverflow.com/questions/12088819/css-transitions-on-new-elements
        $('body').addClass('modal-engaged');

        //Handle Default button.
        $(this.element).on('keypress.modal', function (e) {
          var target = $(e.target);

          if (target.is('.searchfield') || target.is('textarea') || target.is(':button') || target.is('.dropdown') || target.closest('.tab-list').length) {
            return;
          }

          if (e.which === 13 && self.isOnTop() &&
              !target.closest('form').find(':submit').length &&
              self.element.find('.btn-modal-primary:enabled').length) {

            e.stopPropagation();
            e.preventDefault();
            self.element.find('.btn-modal-primary:enabled').trigger('click');
          }
        });

        // Override this page's skip-link default functionality to instead focus the top
        // of this element if it's clicked.
        $('.skip-link').on('focus.modal', function(e) {
          e.preventDefault();
          self.getTabbableElements().first.focus();
        });

        function focusElement() {
          var focusElem = self.element.find(':focusable').not('.modal-header .searchfield').first();
          self.keepFocus();
          self.element.trigger('open', [self]);

          if (focusElem.length === 0) {
            focusElem = self.element.find('.btn-modal-primary');
          }

          if (focusElem.length === 1 && focusElem.is('.btn-modal')) {
            focusElem = self.element.find('.btn-modal-primary');
          }

          if (focusElem.length === 1 && focusElem.is('button') && !focusElem.is(':disabled')) {
            focusElem.addClass('hide-focus');
          }

          if (!self.settings.autoFocus) {
            return;
          }

          // If the selected element is a tab, actually make sure it's the "selected" tab.
          var selected, tabParent;
          if (focusElem.is('.tab:not(.is-selected) a')) {
            tabParent = focusElem.closest('.tab-container');
            selected = tabParent.find('.is-selected');
            if (selected.length) {
              focusElem = selected;
              tabParent.data('tabs').select(selected.children('a').attr('href'));
              return;
            }
          }

          // Otherwise, just focus
          focusElem.focus();

        }

        var pagerElem = self.element.find('.paginated');
        pagerElem.on('afterpaging', function () {
          self.resize();
        });

        setTimeout(function () {
          self.disableSubmit();
        }, 10);

        var fields = this.element.find('[data-validate]');
        fields.removeClass('disable-validation');

        setTimeout(function () {
          focusElement();
        }, 200);

        setTimeout(function () {
          self.element.trigger('afteropen');
        }, 300);

      },

      resize: function() {
        var calcHeight = ($(window).height()* 0.9)-this.settings.frameHeight, //90% -(180 :extra elements-height)
          calcWidth = ($(window).width()* 1)-this.settings.frameWidth;

        var wrapper = this.element.find('.modal-body-wrapper');

        //Remove width for backwards compat
        this.element.find('.modal-contents').css('width', '');

        if (wrapper.length) {
          // FIX: IE extra padding made modal width jump
          if (this.isIeOrEdge) {
            wrapper[0].style.width = wrapper.width() + 60 +'px';
          }
          wrapper[0].style.maxHeight = calcHeight + 'px';
          wrapper[0].style.maxWidth = calcWidth + 'px';
        }

        if (this.element.hasClass('lookup-modal')) {
          var table = this.element.find('.datagrid-body'),
            hasPager = this.element.find('.pager-toolbar'),
            container = table.closest('.datagrid-container');

          calcHeight = calcHeight - (container.prev().is('.toolbar') ? 130 : 60) - (container.next().is('.pager-toolbar') ? 35 : 0);
          table[0].style.maxHeight = calcHeight + (hasPager.length ? -15 : 0) + 'px';
          table[0].style.maxWidth = calcWidth + 'px';
        }

      },

      isOpen: function() {
        return this.element.is('.is-visible');
      },

      isOnTop: function () {
        var max = 0,
          dialog = this.element;

        $('.modal.is-visible').each(function () {
          var zIndex = this.style.zIndex;
          if (max < zIndex) {
            max = zIndex;
          }
        });

        return max === dialog[0].style.zIndex;
      },

      getTabbableElements: function() {
        var allTabbableElements = $(this.element).find('a[href], area[href], input:not([disabled]),' +
          'select:not([disabled]), textarea:not([disabled]),' +
          'button:not([disabled]), iframe, object, embed, *[tabindex],' +
          '*[contenteditable]').filter(':visible');
        return {
          first: allTabbableElements[0],
          last: allTabbableElements[allTabbableElements.length - 1]
        };
      },

      keepFocus: function() {
        var self = this, tabbableElements;

          $(self.element).on('keypress.modal keydown.modal', function (e) {
            var keyCode = e.which || e.keyCode;

            if (keyCode === 27) {
              setTimeout(function () {
                self.close();
              }, 0);
            }

            if (keyCode === 9) {
              tabbableElements = self.getTabbableElements();

              // Move focus to first element that can be tabbed if Shift isn't used
              if (e.target === tabbableElements.last && !e.shiftKey) {
                e.preventDefault();
                tabbableElements.first.focus();
              } else if (e.target === tabbableElements.first && e.shiftKey) {
                e.preventDefault();
                tabbableElements.last.focus();
              }

              self.element.find('#message-title').removeAttr('tabindex');
            }

          });
      },

      close: function (destroy) {
        if (!this.isOpen()) {
          return true;
        }

        var elemCanClose = this.element.triggerHandler('beforeclose'),
          self = this,
          fields = this.element.find('[data-validate]');

        this.root = this.element.closest('.modal-page-container');
        fields.addClass('disable-validation');

        if (elemCanClose === false) {
          return false;
        }

        if (this.mainContent && this.removeNoScroll) {
          this.mainContent.removeClass('no-scroll');
        }
        $('body').off('resize.modal-' + this.id);

        this.element.off('keypress.modal keydown.modal');
        this.element.removeClass('is-visible');

        this.overlay.attr('aria-hidden', 'true');
        if (this.root) {
          this.root.attr('aria-hidden', 'true');
        }

        if ($('.modal-page-container[aria-hidden="false"]').length < 1) {
          $('body').removeClass('modal-engaged');
          $('body > *').not(this.element.closest('.modal-page-container')).removeAttr('aria-hidden');
          $('.overlay').remove();
        }

        //Fire Events
        self.element.trigger('close', self.isCancelled);

        if (this.oldActive && $(this.oldActive).is('button:visible')) {
          this.oldActive.focus();
          this.oldActive = null;
        } else if (this.trigger.parents('.toolbar, .formatter-toolbar').length < 1) {
          this.trigger.focus();
        }

        //close tooltips
        $('#validation-errors, #tooltip, #validation-tooltip').addClass('is-hidden');

        // remove the event that changed this page's skip-link functionality in the open event.
        $('.skip-link').off('focus.modal');

        setTimeout( function() {
          self.overlay.remove();
          self.root[0].style.display = 'none';
          self.element.trigger('afterclose');

          if (self.settings.trigger === 'immediate' || destroy) {
            self.destroy();
          }
        }, 300); // should match the length of time needed for the overlay to fade out
      },

      // NOTE: Destroy method needs to function as a callback because it's
      destroy: function() {
        var self = this,
          canDestroy = this.element.trigger('beforedestroy');

        if (!canDestroy) {
          return;
        }

        function destroyCallback() {
          if (self.modalButtons) {
            self.element.find('button').off('click.modal');
          }

          if (self.element.find('.detailed-message').length === 1) {
            $('body').off('resize.modal-' + this.id);
          }

          if (self.settings.trigger === 'click') {
            self.trigger.off('click.modal');
          }

          self.element.closest('.modal-page-container').remove();
          $.removeData(self.element[0], 'modal');
        }

        if (!this.isOpen()) {
          destroyCallback();
          return;
        }

        this.element.one('afterclose.modal', function() {
          destroyCallback();
        });

        this.close(true);
      }
    };

    // Support Chaining and Init the Control or Set Settings
    return this.each(function() {
      var instance = $.data(this, pluginName),
        elem = $(this);

      if (!elem.is('.modal')) {
        instance = elem.closest('.modal').data(pluginName);
      }

      if (instance) {
        if (typeof instance[options] === 'function') {
          instance[options]();
        }
        instance.settings = $.extend({}, instance.settings, options);

        if (settings.trigger === 'immediate') {
          instance.open();
        }
        return;
      }

      instance = $.data(this, pluginName, new Modal(this, settings));
    });
  };


  $.fn.modalsearch = function(options) {
    'use strict';

    // Settings and Options
    var pluginName = 'modalsearch',
        defaults = {},
        settings = $.extend({}, defaults, options);

    /**
     * Used Mostly for the Site, but could be used elsewhere with some modifications
     * @constructor
     * @param {Object} element
     */
    function ModalSearch(element) {
      this.settings = $.extend({}, settings);
      this.element = $(element);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    // Plugin Methods
    ModalSearch.prototype = {
      init: function() {
        this
          .setup()
          .build()
          .handleEvents();
      },

      setup: function() {
        return this;
      },

      build: function() {
        this.element.modal({autoFocus: false});
        this.modal = this.element.data('modal');
        this.overlay = this.modal.overlay;
        this.searchInput = this.modal.element.find('#big-search-field');
        this.searchResults = this.modal.element.find('.search-all');

        this.modal.element.add(this.overlay).addClass('modal-search');

        this.searchResults.empty().append($('<p class="search-result none">' + Locale.translate('NoResults') + '</p>'));

        return this;
      },

      handleEvents: function() {
        var self = this;

        // Disconnect the Modal plugin's resize event, because CSS can completely handle window resizing
        // now that we don't need to calculate margins.
        $('body').off('resize.modal-' + this.modal.id);

        $(document).on('keydown.modalsearch', function(e) {
          var key = e.which;
          if (key === 27) { // Escape
            if (self.modal.isOpen()) {
              self.modal.close();
            }
          }
        });

        this.searchInput.on('keydown.modalsearch', function(e) {
          var key = e.which;
          if (key === 13) { // Enter
            self.handleAjax();
          }
        });

        // Listen for the 'requestend' event produced by this Control in order to render Search Results.
        this.modal.element.on('requestend.modalsearch', function(e, term, results) {
          self.renderSearchResults(e, term, results);
        }).on('open.modalsearch', function() {
          self.searchInput.focus();
        }); // triggered by the Modal Control

        // Moved from 'js/initialize.js'
        this.modal.element.find('.close').on('click.modalsearch', function() {
          self.modal.close();
        });

        return this;
      },

      // NOTE: Duplicates some code that's also found in Autocomplete AJAX request... not super DRY
      // TODO: Make the AJAX code more DRY
      handleAjax: function() {
        var self = this,
          sourceURL = this.searchInput.attr('data-source') || undefined,
          term = this.searchInput.val();

        if (!sourceURL || sourceURL === undefined) {
          return false;
        }

        sourceURL = sourceURL.toString();

        var done = function(searchTerm, response) {
          self.element.removeClass('is-busy');  //TODO: Need style for this
          self.element.trigger('requestend', [searchTerm, response]);
        };

        self.element
          .addClass('busy')
          .trigger('requeststart', [term]);

        // Source is always a URL
        var request = $.get(sourceURL + term);
        request.done(function(data) {
          done(term, data);
        }).fail(function() {
          done(term, []);
        });
      },

      // Gets results from the Site Search (powered by Craft CMS) and renders it into the search results section.
      // CraftCMS returns a pre-rendered HTML template, so just append the results to the Search Results section.
      renderSearchResults: function(e, term, results) {
        this.searchResults
          .empty()
          .append(results);
      },

      // Teardown - Remove added markup and events
      destroy: function() {
        $(document).off('keydown.modalsearch');
        this.modal.element.off('requestend.modalsearch open.modalsearch');
        this.searchInput.off('keydown.modalsearch');
        this.element.data('modal').destroy();
        $.removeData(this.element[0], pluginName);
      }
    };

    // Initialize the plugin (Once)
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (instance) {
        instance.settings = $.extend({}, instance.settings, options);
      } else {
        instance = $.data(this, pluginName, new ModalSearch(this, settings));
      }
    });
  };


  $.fn.rating = function(options) {

     // Tab Settings and Options
    var pluginName = 'rating',
        defaults = {},
        settings = $.extend({}, defaults, options);

    /**
     * @constructor
     * @param {Object} element
     */
    function Rating(element) {
      this.element = $(element);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    // Actual Rating Code
    Rating.prototype = {
      init: function() {
        this.handleEvents();
        this.allInputs = this.element.find('input');
        this.readonly();
      },
      handleEvents: function () {
        var self = this;

        $('input', self.element).each(function(index) {
          $(this).on('change', function () {
            if (!self.element.hasClass('is-readonly')) {
              self.val(index + 1);
            }
          });
        });
      },
      val: function(value) {
        var i, chkIdx, self = this;
        if (!value) {
          return this.currentValue;
        }

        this.currentValue = parseFloat(value, 10);
        chkIdx = Math.round(this.currentValue);

        for (i = 0; i < this.allInputs.length; i++) {
          var input = $(this.allInputs[i]),
            svgSelector = input.parent().is('.inline') ? 'svg' : 'label';

          if (i < value) {
            input.addClass('is-filled').removeClass('is-half');
          } else {
            input.removeClass('is-filled').removeClass('is-half');
          }

          //Handle Half Star
          input.next(svgSelector).find('svg').changeIcon('star-filled');

          if (i+1 === chkIdx) {
            input.prop('checked', true);
          }

          if (chkIdx !== self.currentValue && i+1 === chkIdx) {
           input.addClass('is-half').next(svgSelector).find('svg').changeIcon('star-half');
          }
        }
        if (chkIdx <= 0) {
          $(this.allInputs[0]).prop('checked', true);
        }

        return this.currentValue;
      },
      readonly: function() {
        var elem = $(this.element);
        if (elem.hasClass('is-readonly')) {
          elem.find('input').attr('disabled','');
        }
      },
      enable: function() {
        var elem = $(this.element);
        elem.removeClass('is-readonly').find('input').removeAttr('disabled');
      }
    };

    // Keep the Chaining while Initializing the Control (Only Once)
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (instance) {
        instance.settings = $.extend({}, defaults, options);
      } else {
        instance = $.data(this, pluginName, new Rating(this, settings));
      }
    });
  };


  $.fn.resize = function(options) {
    'use strict';

    // Settings and Options
    var pluginName = 'resize',
        defaults = {
          axis: 'x'
        },
        settings = $.extend({}, defaults, options);

    /**
     * @constructor
     * @param {Object} element
     */
    function Resize(element) {
      this.element = $(element);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    // Resize Methods
    Resize.prototype = {

      init: function() {
        //Original Prototype http://jsfiddle.net/41h9pcpb/2/
        this.handleEvents();
      },

      // Handle Touch/Mouse Resize
      handleEvents: function() {
        var self = this;
        self.handle = null;

        this.element.find('.resize-handle').drag({axis: settings.axis}).on('drag.resziable', function (e, args) {
          self.element[0].style.width = args.left;
        });
      },

      // Teardown
      destroy: function() {
        $.removeData(this.element[0], pluginName);
      }
    };

    // Initialize the plugin (Once)
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (instance) {
        instance.settings = $.extend({}, defaults, options);
        instance.show();
      } else {
        instance = $.data(this, pluginName, new Resize(this, settings));
      }
    });
  };


  $.fn.searchfield = function(options) {
    'use strict';

    // Settings and Options
    var pluginName = 'searchfield',
        defaults = {
          allResultsCallback: undefined,
          showAllResults: true,
          categories: undefined, // If defined as an array, displays a dropdown containing categories that can be used to filter results.
          categoryMultiselect: false, // If true, creates a multiselectable Categories list
          showCategoryText: false, // If true, will show any available categories that are selected to the left of the Dropdown field.
          source: undefined,
          template: undefined, // Template that can be passed
          clearable: false //Has an X to clear
        },
        settings = $.extend({}, defaults, options);

    /**
     * Searchfield Control
     * @constructor
     * @param {Object} element
     */
    function SearchField(element) {
      this.settings = $.extend({}, settings);
      this.element = $(element);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    SearchField.prototype = {
      /**
       * Initialization Kickoff
       * @returns {this}
       */
      init: function() {
        this.inlineLabel = this.element.closest('label');
        this.inlineLabelText = this.inlineLabel.find('.label-text');
        this.isInlineLabel = this.element.parent().is('.inline');
        this.build().setupEvents();
      },

      /**
       * Builds the markup for this component.
       * @private
       * @returns {this}
       */
      build: function() {
        this.optionsParseBoolean();
        this.label = this.element.prev('label, .label');

        // Invoke Autocomplete and store references to that and the popupmenu created by autocomplete.
        // Autocomplete settings are fed the same settings as Searchfield
        if (this.settings.source || this.element.attr('data-autocomplete')) {
          this.element.autocomplete(this.settings);
        }
        this.autocomplete = this.element.data('autocomplete');

        //Prevent browser typahead
        this.element.attr('autocomplete','off');

        this.wrapper = this.element.parent('.searchfield-wrapper');
        if (!this.wrapper || !this.wrapper.length) {
          if (this.isInlineLabel) {
            this.wrapper = this.inlineLabel.addClass('searchfield-wrapper');
          }
          else {
            this.wrapper = this.element.wrap('<span class="searchfield-wrapper"></span>').parent();
          }

          // Label for toolbar-inlined searchfields needs to be inside the wrapper to help with positioning.
          if (this.element.closest('.toolbar').length) {
            this.label.prependTo(this.wrapper);
          }

          var customClasses = ['context', 'alternate'],
            c;
          for (var i = 0; i < customClasses.length; i++) {
            if (this.element.hasClass(customClasses[i])) {
              c = customClasses[i];
              this.wrapper.addClass(c);
              this.element.removeClass(c);
            }
          }
        }

        // Add Icon
        var icon = this.wrapper.find('.icon:not(.icon-dropdown)');
        if (!icon || !icon.length) {
          icon = $.createIconElement('search').insertAfter(this.element).icon();
        }

        // Change icon to a trigger button if we're dealing with categories
        if (this.hasCategories()) {
          this.wrapper.addClass('has-categories');

          this.button = icon.parent('.searchfield-category-button');
          if (!this.button.length) {
            this.button = icon.wrap('<button type="button" class="btn searchfield-category-button"></button>').parent();
          }
          icon = this.button;

          if (this.settings.showCategoryText) {
            this.wrapper.addClass('show-category');
          }

          var ddIcon = icon.find('.icon-dropdown');
          if (!ddIcon.length) {
            ddIcon = $.createIconElement({ classes: 'icon-dropdown', icon: 'dropdown' }).icon();
          }
          ddIcon.appendTo(icon);

          this.list = this.wrapper.find('ul.popupmenu');
          if (!this.list || !this.list.length) {
            this.list = $('<ul class="popupmenu"></ul>');
          }

          // Handle Single vs Multi-Selectable Lists
          var categoryListType = this.settings.categoryMultiselect ? 'is-multiselectable' : 'is-selectable';
          this.list.addClass(categoryListType);
          var removeListType = 'is-selectable';
          if (!this.settings.categoryMultiselect) {
            removeListType = 'is-multiselectable';
          }
          this.list.removeClass(removeListType);

          this.setCategories(this.settings.categories);

          this.list.insertAfter(this.button);
          this.button.popupmenu({
            menu: this.list,
            offset: {
              y: 10
            }
          });

          this.setCategoryButtonText();
        }

        // Swap icon position to in-front if we have an "alternate" class.
        if (this.wrapper.hasClass('context') || this.wrapper.hasClass('has-categories') ) {
          icon.insertBefore(this.element);
        }

        if (this.settings.clearable) {
          this.element.clearable();
        }

        return this;
      },

      /**
       * Set boolean value if strings
       * @private
       * @returns {undefined}
       */
      optionsParseBoolean: function() {
        var i, l,
          arr = [
            'showAllResults',
            'categoryMultiselect',
            'showCategoryText',
            'clearable'
          ];
        for (i=0,l=arr.length; i<l; i++) {
          this.settings[arr[i]] = this.parseBoolean(this.settings[arr[i]]);
        }
      },

      /**
       * Reveals whether or not categories are active on this searchfield
       * @returns {boolean}
       */
      hasCategories: function() {
        return this.settings.categories && $.isArray(this.settings.categories) && this.settings.categories.length > 0;
      },

      /**
       * Sets up the event-listening structure for this component instance.
       * @private
       * @returns {this}
       */
      setupEvents: function() {
        var self = this;

        this.element.on('updated.searchfield', function() {
          self.updated();
        }).on('focus.searchfield', function(e) {
          self.handleFocus(e);
        }).on('blur.searchfield', function(e) {
          self.handleBlur(e);
        }).onTouchClick('searchfield', '.searchfield')
        .on('click.searchfield', function(e) {
          self.handleClick(e);
        }).on('keydown.searchfield', function(e) {
          self.handleKeydown(e);
        }).on('beforeopen.searchfield', function(e, menu) { // propagates from Autocomplete's Popupmenu
          self.handlePopupBeforeOpen(e, menu);
        }).on('safe-blur.searchfield listclose.searchfield', function() {
          self.wrapper.removeClass('popup-is-open');
        });

        this.wrapper.on('mouseenter.searchfield', function() {
          $(this).addClass('is-hovered');
        }).on('mouseleave.searchfield', function() {
          $(this).removeClass('is-hovered');
        });

        if (this.hasCategories()) {
          this.button.on('selected.searchfield', function(e, anchor) {
            self.handleCategorySelected(e, anchor);
          }).on('focus.searchfield', function(e) {
            self.handleCategoryFocus(e);
          }).on('blur.searchfield', function(e) {
            self.handleCategoryBlur(e);
          }).on('close.searchfield', function(e) { // Popupmenu Close
            self.handlePopupClose(e);
          });
        }

        // Insert the "view more results" link on the Autocomplete control's "populated" event
        this.element.off('populated.searchfield').on('populated.searchfield', function(e, items) {
          if (items.length > 0) {
            if (self.settings.showAllResults) {
              self.addMoreLink();
            }
          } else {
            self.addNoneLink();
          }
        });

        // Override the 'click' listener created by Autocomplete (which overrides the default Popupmenu method)
        // to act differntly when the More Results link is activated.
        this.element.on('listopen.searchfield', function(e, items) {
          var list = $('#autocomplete-list');

          // Visual indicator class
          self.wrapper.addClass('popup-is-open');

          list.off('click').on('click.autocomplete', 'a', function (e) {
            var a = $(e.currentTarget),
              ret = a.text().trim(),
              isMoreLink = a.hasClass('more-results'),
              isNoneLink = a.hasClass('no-results');

            if (!isMoreLink && !isNoneLink) {
              // Only write text into the field on a regular result pick.
              self.element.attr('aria-activedescendant', a.parent().attr('id'));
            }

            if (isMoreLink) {
              // Trigger callback if one is defined
              var callback = self.settings.allResultsCallback;
              if (callback && typeof callback === 'function') {
                callback(ret);
              }
            }

            if (a.parent().attr('data-value')) {
              for (var i = 0; i < items.length; i++) {
                if (items[i].value.toString() === a.parent().attr('data-value')) {
                  ret = items[i];
                }
              }
            }

            self.element.trigger('selected', [a, ret]);
            self.element.data('popupmenu').close();
            e.preventDefault();
            return false;
          });

          // Override the focus event created by the Autocomplete control to make the more link
          // and no-results link blank out the text inside the input.
          list.find('.more-results, .no-results').off('focus').on('focus.searchfield', function () {
            var anchor = $(this);
            list.find('li').removeClass('is-selected');
            anchor.parent('li').addClass('is-selected');
            self.element.val('');
          });

        });

        return this;
      },

      /**
       * If located inside a toolbar element, setup a timed event that will send a signal to the parent toolbar,
       * telling it to recalculate which buttons are visible. Needs to be done after a CSS animation on the searchfield finishes.
       * @private
       * @returns {undefined}
       */
      recalculateParent: function() {
        var toolbar = this.element.closest('.toolbar');
        if (toolbar.length) {
          // TODO: Bolster this to work with CSS TransitonEnd
          setTimeout(function() {
            toolbar.triggerHandler('recalculate-buttons');
          }, 300);
        }
      },

      /**
       * Activates a toolbar-based searchfield and keeps it "open".  Instead of closing it on blur, sets up
       * an explicit, out-of-bounds click/tap that will serve to close it when the user acts.
       * @private
       * @returns {undefined}
       */
      setAsActive: function() {
        if (this.element.hasClass('active')) {
          return;
        }

        var self = this;

        // Activate
        this.element.addClass('active');
        var toolbar = this.element.closest('.toolbar, [class$="-toolbar"]');
        if (toolbar.length) {
          toolbar.addClass('searchfield-active');
        }

        // if Toolbar Searchfield, allow that control to handle adding this class
        if (!this.isToolbarSearchfield()) {
          this.wrapper.addClass('has-focus');
        }

        setTimeout(function() {
          function deactivate(e) {
            var target = $(e.target),
              elems = self.element.add(self.element.parent('.searchfield-wrapper'));
            if (target.is(elems)) {
              return;
            }

            //self.element.removeClass('active').blur();
            toolbar.removeClass('searchfield-active');
            $(document).offTouchClick('searchfield').off('click.searchfield');
          }

          $(document).onTouchClick('searchfield', '.searchfield').on('click.searchfield', function(e) {
            deactivate(e);
          });

          self.element.one('blur.searchfield', function(e) {
            deactivate(e);
          });
        }, 100);
        this.recalculateParent();
      },

      /**
       * Focus event handler
       * @private
       * @returns {undefined}
       */
      handleFocus: function() {
        this.setAsActive();
      },

      /**
       * Blur event handler
       * @private
       * @returns {undefined}
       */
      handleBlur: function() {
        var self = this;
        this.recalculateParent();

        if (!this.isToolbarSearchfield()) {
          setTimeout(function() {
            self.wrapper.removeClass('has-focus');
          }, 10);
        }
      },

      /**
       * Click event handler
       * @private
       * @returns {undefined}
       */
      handleClick: function() {
        this.setAsActive();
      },

      /**
       * Keydown event handler
       * @private
       * @returns {undefined}
       */
      handleKeydown: function(e) {
        var key = e.which;

        if (key === 27) {
          this.clear();
        }
      },

      /**
       * Modifies the menu at $('#autocomplete-list') to propagate/remove style classes on the Searchfield element.
       * @private
       * @returns {boolean}
       */
      handlePopupBeforeOpen: function(e, menu) {
        if (!menu) {
          return;
        }

        var contextClassMethod = this.wrapper.hasClass('context') ? 'addClass' : 'removeClass',
          altClassMethod = this.wrapper.hasClass('alternate') ? 'addClass' : 'removeClass';

        menu[contextClassMethod]('context');
        menu[altClassMethod]('alternate');

        return true;
      },

      /**
       * Sets the text content on the category button.  Will either display a single category name, or a translated "[x] Selected." string.
       * @param {string} [textContent] - Optional incoming text that will be subtituted for the selected element count.
       * @returns {undefined}
       */
      setCategoryButtonText: function(textContent) {
        if (!this.settings.showCategoryText || !this.hasCategoryButton()) {
          return;
        }

        var text = '',
          button = this.wrapper.find('.btn'),
          span = button.find('span');

        if (!span || !span.length) {
          span = $('<span class="category"></span>').insertAfter(button.find('.icon').first());
        }

        span.empty();

        // incoming text takes precedent
        if (typeof textContent === 'string' && textContent.length) {
          span.text(textContent.trim());
          return;
        }

        // Otherwise, grab currently selected categories and set text
        // (or clear, if no options are selected).
        var item = this.getSelectedCategories();
        if (!item.length) {
          return;
        }

        if (item.length > 1) {
          text = item.length + ' ' + Locale.translate('Selected');
        } else {
          text = item.text().trim();
        }

        span.text(text);
      },

      /**
       * Detects whether or not this component is a Toolbar Searchfield
       * @returns {boolean}
       */
      isToolbarSearchfield: function() {
        return this.wrapper.is('.toolbar-searchfield-wrapper');
      },

      /**
       * Category Selection event handler
       * @private
       * @returns {undefined}
       */
      handleCategorySelected: function(e, anchor) {
        this.setCategoryButtonText(e, anchor.text().trim());

        // If this is a toolbar searchfield, run the size check that fixes the
        // trigger button and input field size.
        var tsAPI = this.element.data('toolbarsearchfield');
        if (tsAPI && typeof tsAPI.setOpenWidth === 'function') {
          tsAPI.calculateOpenWidth();
          tsAPI.setOpenWidth();
        }
      },

      /**
       * Category Button Focus event handler
       * @private
       * @returns {undefined}
       */
      handleCategoryFocus: function() {
        // if Toolbar Searchfield, allow that control to handle adding this class
        if (this.isToolbarSearchfield()) {
          return;
        }

        this.wrapper.addClass('has-focus');
      },

      /**
       * Category Button Blur event handler
       * @private
       * @returns {undefined}
       */
      handleCategoryBlur: function() {
        // if Toolbar Searchfield, allow that control to handle adding this class
        if (this.isToolbarSearchfield()) {
          return;
        }

        this.wrapper.removeClass('has-focus');
      },

      /**
       * Gets a complete list of categories in jQuery-collection form.
       * @return {jQuery} categories
       */
      getCategories: function() {
        return this.list.children('li:not(.separator)');
      },

      /**
       * Gets the currently selected list of categories in jQuery-collection form.
       * @return {jQuery} selectedCategories
       */
      getSelectedCategories: function() {
        return this.getCategories().filter('.is-checked');
      },

      /**
       * Gets the currently selected categories as data.
       * @param {boolean} [onlyReturnSelected=false] - If set to true, will only return checked list items.
       * @returns {Object[]} data -
       * @returns {string} name - Category name
       * @returns {string|number} id - Category element's ID (if applicable)
       * @returns {string|number} value - Category element's value (if applicable)
       * @returns {boolean} [checked=true] - Category's selection status
       */
      getCategoryData: function(onlyReturnSelected) {
        var categories = this.getCategories(),
          data = [];

        categories.each(function() {
          var classList = this.classList,
            checked = classList.contains('is-checked');

          if (onlyReturnSelected === true && checked === false) {
            return;
          }

          var category = {
            name: this.innerText,
            checked: checked
          };

          if (this.id) {
            category.id = this.id;
          }

          var value = this.getAttribute('data-value');
          if (value !== undefined) {
            category.value = value;
          }

          data.push(category);
        });

        return data;
      },

      /**
       * Updates just the categories setting and rerenders the category list.
       * @param {Object[]} categories - Array of category object definitions.
       * @param {string} categories[].name - Category name.
       * @param {string|number} [id] - Category element's ID (if applicable).
       * @param {string|number} [value] - Category element's value (if applicable).
       * @param {boolean} [checked=true] - Category's selection status
       * @return {undefined}
       */
      updateCategories: function(categories) {
        this.settings.categories = categories;
        this.setCategories(this.settings.categories);
      },

      /**
       * Creates a new set of categories on the Searchfield and rerenders it.
       * @param {Object[]} categories - Array of category object definitions.
       * @param {string} categories[].name - Category name.
       * @param {string|number} [id] - Category element's ID (if applicable).
       * @param {string|number} [value] - Category element's value (if applicable).
       * @param {boolean} [checked=true] - Category's selection status
       * @return {undefined}
       */
      setCategories: function(categories) {
        this.list.empty();

        var self = this,
          previouslySelected = false;

        categories.forEach(function(val) {
          // if passed a string, typecast to an object.
          if (typeof val === 'string') {
            val = {
              name: val
            };
          }

          // Object types get a bit more customization.
          // Don't continue if there's no name present.
          if (!val.name) {
            return;
          }

          var id = '';
          if (typeof val.id === 'string' && val.id.length) {
            id = ' id="'+ val.id +'"';
          }

          var value = '',
            valueTypes = ['string', 'number'];
          if (valueTypes.indexOf(typeof val.value) > -1) {
            value = ' data-value="'+ val.value +'"';
          }

          var selected = '';
          if (val.checked === true && previouslySelected !== true) {
            selected = ' class="is-checked"';

            if (!self.settings.categoryMultiselect) {
              previouslySelected = true;
            }
          }

          self.list.append('<li'+ selected + id + value + '><a href="#">' + val.name + '</a></li>');
        });

        var api = this.button.data('popupmenu');
        if (api && typeof api.updated === 'function') {
          api.updated();
        }
      },

      /**
       * Determines whether or not a Category Trigger exists.
       * @returns {boolean}
       */
      hasCategoryButton: function() {
        return this.wrapper.find('.btn').length > 0;
      },

      /**
       * Category Button Close event handler
       * @private
       * @returns {function}
       */
      handlePopupClose: function() {
        return this.setAsActive();
      },

      /**
       * Clears the contents of the searchfield
       * @returns {undefined}
       */
      clear: function() {
        this.element.val('').trigger('change').focus();
      },

      /**
       * Adds a link at the bottom of a searchfield with more than (0) results that can be used to link out to a larger display of search results.
       * @private
       * @returns {undefined}
       */
      addMoreLink: function() {
        var list = $('#autocomplete-list'),
          val = this.element.val();

        if ($('.more-results', list).length > 0) {
          return;
        }

        $('<li class="separator" role="presentation"></li>').appendTo(list);
        var more = $('<li role="presentation"></li>').appendTo(list);
        this.moreLink = $('<a href="#" class="more-results" tabindex="-1" role="menuitem"></a>').html('<span>' + Locale.translate('AllResults') + ' "' + val + '"</span>').appendTo(more);
      },

      /**
       * Adds a link at the bottom of a searchfield with no results that announces no search results.
       * @private
       * @returns {undefined}
       */
      addNoneLink: function() {
        var list = $('#autocomplete-list');
        if ($('.no-results', list).length > 0) {
          return;
        }

        var none = $('<li role="presentation"></li>').appendTo(list);

        this.noneLink = $('<a href="#" class="no-results" tabindex="-1" role="menuitem"></a>').html('<span>' + Locale.translate('NoResults') + '</span>').appendTo(none);
      },

      /**
       * Tears down and rebuilds the Searchfield.
       * Can be called directly, but is also triggered by calling the "updated.searchfield" event on the searchfield element.
       * @returns {undefined}
       */
      updated: function() {
        this.teardown().init();
      },

      /**
       * Enables the Searchfield
       * @returns {undefined}
       */
      enable: function() {
        this.element.prop('disabled', false);
      },

      /**
       * Disables the Searchfield
       * @returns {undefined}
       */
      disable: function() {
        this.element.prop('disabled', true);
      },

      /**
       * Performs the usual Boolean coercion with the exception of the strings "false" (case insensitive) and "0"
       * @private
       * @returns {boolean}
       */
      parseBoolean: function(b) {
        return !(/^(false|0)$/i).test(b) && !!b;
      },

      /**
       * Unbinds events and removes unnecessary markup.
       * @private
       * @returns {this}
       */
      teardown: function() {
        this.element.off('updated.searchfield focus.searchfield blur.searchfield click.searchfield keydown.searchfield beforeopen.searchfield listopen.searchfield listclose.searchfield safe-blur.searchfield');

        if (this.autocomplete) {
          this.autocomplete.destroy();
        }

        if (this.wrapper.hasClass('context')) {
          this.element.addClass('context');
        }

        this.element.next('.icon').remove();
        if (this.element.parent().hasClass('searchfield-wrapper')) {
          this.element.parent().find('ul').remove();
          this.element.parent().find('.icon').remove();
        }

        return this;
      },

      /**
       * Destroys the Searchfield and removes all jQuery component instancing.
       * @returns {undefined}
       */
      destroy: function() {
        this.teardown();
        $.removeData(this.element[0], pluginName);
      }
    };

    // Initialize the plugin (Once)
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (instance) {
        instance.settings = $.extend({}, instance.settings, options);
        instance.updated();
      } else {
        instance = $.data(this, pluginName, new SearchField(this, settings));
      }
    });
  };


  $.fn.signin = function(options) {
    'use strict';

    // Settings and Options
    var pluginName = 'signin',
        defaults = {},
        settings = $.extend({}, defaults, options);

    /**
     * @constructor
     * @param {Object} element
     */
    function SignIn(element) {
      this.element = $(element);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    // Plugin Methods
    SignIn.prototype = {

      init: function() {
        this.settings = settings;
        this.handleKeys();
      },

      handleKeys: function() {
        var self = this,
          cssIcon = $.createIconElement({ classes: 'icon-capslock', icon: 'capslock' });

        // Disable default [caps lock on] popup in IE
        document.msCapsLockWarningOff = true;

        this.element
        .on('keypress.signin', '[type="password"]', function (e) {
          var field = $(this),
            fieldParent = field.parent('.field'),
            iconCapslock = $('.icon-capslock', fieldParent);

          if (self.isCapslock(e) && !field.hasClass('error')) {
            if(!iconCapslock.length) {
              fieldParent.append(cssIcon);
              $('body').toast({audibleOnly: true, message: Locale.translate('CapsLockOn')});
            }
          } else {
            iconCapslock.remove();
          }

        })
        .on('blur.signin change.signin', '[type="password"]', function () {
          var field = $(this),
            fieldParent = field.closest('.field'),
            iconCapslock = $('.icon-capslock', fieldParent);

          // Wait for error class to be added
          setTimeout(function() {
            if (iconCapslock && iconCapslock.length) {
              if (field.hasClass('error')) {
                iconCapslock.remove();
              } else {
                fieldParent.append(cssIcon);
              }
            }
          }, 150);

        });
      },

      isCapslock: function(e) {
        e = (e) ? e : window.event;
        var charCode = (e.which) ? e.which : ((e.keyCode) ? e.keyCode : false),
         shifton = (e.shiftKey) ? e.shiftKey : ((e.modifiers) ? (!!(e.modifiers & 4)) : false);

        if (charCode >= 97 && charCode <= 122 && shifton) {
          return true;
        }
        if (charCode >= 65 && charCode <= 90 && !shifton) {
          return true;
        }
        return false;
      },

      // Teardown - Remove added markup and events
      destroy: function() {
        $.removeData(this.element[0], pluginName);
        $('body').off('keypress.signin blur.signin change.signin');
      }
    };

    // Initialize the plugin (Once)
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (instance) {
        instance.settings = $.extend({}, defaults, options);
      } else {
        instance = $.data(this, pluginName, new SignIn(this, settings));
      }
    });
  };


  $.fn.slider = function(options) {
    'use strict';

    // Settings and Options
    var pluginName = 'slider',
        defaults = {
          value: [50],
          min: 0,
          max: 100,
          range: false,
          step: undefined,
          ticks: [],
          tooltipContent: undefined,
          persistTooltip: false
        };

    /**
     * Touch Enabled/Responsive and Accessible Slider Control
     * @constructor
     * @param {Object} element
     */
    function Slider(element) {
      this.settings = $.extend({}, defaults, options);
      this.element = $(element);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    // Check if is an integer
    function isInt(n) {
      return n % 1 === 0;
    }

    // Round a non-integer to an integer closest to the nearest increment/decrement.
    // If no increment is provided or the increment is 0, only round to the nearest whole number.
    function roundToIncrement(number, increment) {
      if (!increment || isNaN(increment) || increment === 0) {
        increment = 1;
      }
      return Math.round(number/increment) * increment;
    }

    // Get the distance between two points.
    // PointA & PointB are both arrays containing X and Y coordinates of two points.
    // Distance Formula:  http://www.purplemath.com/modules/distform.htm
    function getDistance(pointA, pointB) {
      var aX = pointA[0], aY = pointA[1],
        bX = pointB[0], bY = pointB[1];

      return Math.sqrt( Math.pow(bX - aX, 2) + Math.pow(bY - aY, 2) );
    }

    // Actual Plugin Code
    Slider.prototype = {

      init: function() {
        return this
          .buildSettings()
          .addMarkup()
          .bindEvents();
      },

      buildSettings: function() {
        var self = this;

        // Add "is-disabled" css class to closest ".field" if element is disabled
        if (this.element.is(':disabled')) {
          this.element.closest('.field').addClass('is-disabled');
        }

        if (!this.settings) {
          this.settings = {};
        }
        this.settings.value = this.element.attr('value') !== undefined ? this.element.attr('value') : this.settings.value;
        this.settings.min = this.element.attr('min') !== undefined ? parseInt(this.element.attr('min')) : this.settings.min;
        this.settings.max = this.element.attr('max') !== undefined ? parseInt(this.element.attr('max')) : this.settings.max;
        this.settings.range = this.element.attr('data-range') !== undefined ? (this.element.attr('data-range') === 'true') : this.settings.range;
        this.settings.step = !isNaN(this.element.attr('step')) ? Number(this.element.attr('step')) : this.settings.step;

        if (this.settings.value === '') {
          this.settings.value = this.settings.min;
        }

        // build tick list
        var parsedTicks;
        if (this.element.attr('data-ticks') !== undefined) {
          try {
            parsedTicks = JSON.parse(self.element.attr('data-ticks'));
          } catch (e) {
          }

          if ($.isArray(parsedTicks)) {
            this.settings.ticks = parsedTicks;
          }
        }

        // build tooltip content
        var isTooltipPersist = (this.element.attr('data-tooltip-persist') === 'true' || this.element.attr('data-tooltip-persist') === true);
        this.settings.persistTooltip = this.element.attr('data-tooltip-persist') !== undefined ? isTooltipPersist : this.settings.persistTooltip;
        this.settings.tooltip = this.settings.tooltipContent;
        if (this.element.attr('data-tooltip-content') !== undefined) {
          try {
            self.settings.tooltip = JSON.parse(self.element.attr('data-tooltip-content'));
          } catch (e) {
          }
        }
        if (typeof this.settings.tooltip === 'string') {
          if (this.settings.tooltip.indexOf(',') === -1) {
            this.settings.tooltip = [this.settings.tooltip, ''];
          } else {
            var strings = this.settings.tooltip.split(',');
            this.settings.tooltip = [strings[0]];
            this.settings.tooltip.push( strings[1] ? strings[1] : '');
          }
        }
        if (this.settings.tooltip && this.settings.tooltip.length === 1) {
          this.settings.tooltip.push('');
        }

        // Build ticks.  All sliders have a tick for minimum and maximum by default.  Some will be provided as extra.
        this.ticks = [];
        var minTick = {
          'value' : this.settings.min,
          'description' : self.getModifiedTextValue(this.settings.min)
        }, maxTick = {
          'value' : this.settings.max,
          'description' : self.getModifiedTextValue(this.settings.max)
        };

        if (!this.settings.ticks) {
          this.ticks.push(minTick, maxTick);
        } else {
          // Check the type of the data-ticks.  If it's not a complete array
          // and doesn't have at least one option, ignore it.
          var ticks = self.settings.ticks || [];

          if ($.isArray(ticks) && ticks.length > 0) {
            // Filter through the incoming ticks to figure out if any have been defined
            // That match the values of min and max.
            var equalsMin = ticks.filter(function(obj) {
              return obj.value === self.settings.min;
            }),
            equalsMax = ticks.filter(function(obj) {
              return obj.value === self.settings.max;
            });

            // Overwrite description and color for min/max if they've been found.
            if (equalsMin.length > 0) {
              minTick.description = equalsMin[0].description;
              minTick.color = equalsMin[0].color;
              ticks = $.grep(ticks, function(val) {
                return val !== equalsMin[0];
              });
            }
            if (equalsMax.length > 0) {
              maxTick.description = equalsMax[0].description;
              maxTick.color = equalsMax[0].color;
              ticks = $.grep(ticks, function(val) {
                return val !== equalsMax[0];
              });
            }
          }

          // Push the values of all ticks out to the ticks array
          self.ticks.push(minTick);
          for (var i = 0; i < ticks.length; i++) {
            var tick = {};
            if (ticks[i].value !== undefined) {
              tick.value = ticks[i].value;
              tick.description = ticks[i].description !== undefined ? ticks[i].description : '';
              tick.color = ticks[i].color;
              self.ticks.push(tick);
            }
          }
          self.ticks.push(maxTick);
        }

        // configure the slider to deal with an array of values, and normalize the values to make sure they are numbers.
        if ($.isArray(this.settings.value)) {
          this.settings.value[0] = isNaN(this.settings.value[0]) ? (this.settings.min + this.settings.max)/2 : parseInt(this.settings.value[0]);
        } else if (typeof this.settings.value === 'number') {
          this.settings.value = [this.settings.value];
        } else {
          // String
          if (this.settings.value.indexOf(',') === -1) {
            this.settings.value = [isNaN(this.settings.value) ? (this.settings.min + this.settings.max)/2 : parseInt(this.settings.value)];
          } else {
            var vals = this.settings.value.split(',');
            vals[0] = isNaN(vals[0]) ? this.settings.min : parseInt(vals[0]);
            vals[1] = isNaN(vals[1]) ? this.settings.max : parseInt(vals[1]);
            this.settings.value = vals;
          }
        }

        // Add a second value to the array if we're dealing with a range.
        if (this.settings.range && !this.settings.value[1]) {
          this.settings.value.push(this.settings.max);
        }

        return this;
      },

      addMarkup: function() {
        var self = this,
          isVertical = false;

        if (self.element[0].tagName !== 'INPUT') {
          throw new Error('Element with ID "' + self.element.id + '" cannot invoke a slider;  it\'s not an Input element.');
        }

        // store values and attributes on the original element
        self.originalElement = {
          'type': self.element.attr('type')
        };

        // Hide the input element
        self.element.attr('type', 'hidden');

        // Build the slider controls
        self.wrapper = $('<div class="slider-wrapper"></div>').attr('id', self.element.attr('id') + '-slider').insertAfter(self.element);
        self.hitarea = $('<div class="slider-hit-area"></div>').appendTo(self.wrapper);
        self.range = $('<div class="slider-range"></div>').appendTo(self.wrapper);

          // Set to a vertical slider if the class exists on the input
        if (this.element.hasClass('vertical')) {
          this.wrapper.addClass('vertical');
          isVertical = true;
        }

        // Set RTL
        this.isRtlHorizontal = (Locale.isRTL() && !isVertical);
        this.isRtlVertical = (Locale.isRTL() && isVertical);

        // Retain any width or height size properties from the original range element onto the Pseudo-markup
        var style = this.element.attr('style');
        if (style) {
          if (style.match(/min-height/)) {
            this.wrapper[0].style.minHeight = this.element[0].style.minHeight;
            style = style.replace('min-height', '');
          }
          if (style.match(/height/)) {
            this.wrapper[0].style.height = this.element[0].style.height;
          }
          if (style.match(/min-width/)) {
            this.wrapper[0].style.minWidth = this.element[0].style.minWidth;
            style = style.replace('min-width', '');
          }
          if (style.match(/width/)) {
            this.wrapper[0].style.width = this.element[0].style.width;
          }
        }

        // Handles
        self.handles = [];
        var labelText = self.element.prev('label').text(),
          handleLower = $('<div class="slider-handle' + (self.settings.range ? ' lower' : '') +'" tabindex="0"></div>')
          .attr('aria-label', (self.settings.range ? Locale.translate('SliderMinimumHandle') : Locale.translate('SliderHandle')) + ' ' + labelText);
        self.handles.push(handleLower);
        if (self.settings.range) {
          var handleHigher = $('<div class="slider-handle higher" tabindex="0"></div>')
            .attr('aria-label', Locale.translate('SliderMaximumHandle') + ' ' + labelText);
          self.handles.push(handleHigher);
        }
        $.each(self.handles, function(i, handle) {
          // Add WAI-ARIA to the handles
          handle.attr({
            'role' : 'slider',
            'aria-orientation' : (isVertical ? 'vertical' : 'horizontal'),
            'aria-valuemin' : self.settings.min,
            'aria-valuemax' : self.settings.max
          }).hideFocus();
          handle.appendTo(self.wrapper);
        });

        function positionTick(tick) {
          var convertValueToPercentage = self.isRtlHorizontal ?
              (100 - self.convertValueToPercentage(tick.value)) :
              self.convertValueToPercentage(tick.value),
            pos = 'calc(' + convertValueToPercentage + '% - 4px)';

          tick.element = $('<div class="tick" data-value="'+ tick.value +'"></div>');
          tick.label = $('<span class="label">' + tick.description + '</span>');
          tick.element[0].style[isVertical ? 'bottom' : 'left'] = pos;
          tick.element.append(tick.label);
          self.wrapper.append(tick.element);

          if (isVertical) {
            return;
          }
          tick.label[0].style.left = -(tick.label.outerWidth()/2 - tick.element.width()/2) + 'px';
        }

        // Ticks
        self.ticks.forEach(function(tick) {
          positionTick(tick);
        });

        self.value(self.settings.value);
        self.updateRange();

        // Tooltip on handle needs to update later
        $.each(self.handles, function(i, handle) {
          if (self.settings.tooltip) {
            handle.tooltip({
              content: function() {
                return '' + self.getModifiedTextValue(Math.floor(self.value()[i]));
              },
              placement: (isVertical ? 'right' : 'bottom'),
              trigger: 'focus',
              keepOpen: self.settings.persistTooltip
            });
            handle.removeAttr('aria-describedby');
          }
        });

        if (this.element.prop('disabled') === true) {
          this.disable();
        }

        return self;
      },

      bindEvents: function() {
        var self = this;

        $.each(self.handles, function (i, handle) {
          handle.on('mousedown.slider', function () {
            if (self.isDisabled()) {
              return;
            }
            $(this).focus();
          })
          .on('click.slider', function (e) {
            e.preventDefault(); //Prevent from jumping to top.
          })
          .on('keydown.slider', function(e) {
            self.activateHandle(handle);
            self.handleKeys(e, self);
          })
          .on('keyup.slider blur.slider', function() {
            self.deactivateHandle(handle);
          });

          self.enableHandleDrag(handle);
        });

        self.wrapper.on('click.slider touchend.slider touchcancel.slider', function(e) {
          self.handleRangeClick(e);
        });

        // Slider Control listens to 'updated' trigger on its base element to update values
        self.element.on('updated.slider', function() {
          self.updated();
        });

        return self;
      },

      // User is interacting with the Slider Range (not the handle or ticks)
      handleRangeClick: function(e) {
          e.preventDefault();
          if (this.isDisabled()) {
            return;
          }

          var self = this,
            isVertical = this.wrapper.hasClass('vertical'),
            pageX = e.originalEvent.type !== 'click' ? e.originalEvent.changedTouches[0].pageX : e.pageX,
            pageY = e.originalEvent.type !== 'click' ? e.originalEvent.changedTouches[0].pageY : e.pageY,
            mouseX = pageX - self.wrapper.offset().left - $(document).scrollLeft(),
            mouseY = pageY - self.wrapper.offset().top - $(document).scrollTop(),
            clickCoords = [mouseX,mouseY],
            fhX = (self.handles[0].offset().left + (self.handles[0].width()/2)) - self.wrapper.offset().left - $(document).scrollLeft(),
            fhY = (self.handles[0].offset().top + (self.handles[0].height()/2)) - self.wrapper.offset().top - $(document).scrollTop(),
            firstHandleCoords = [fhX,fhY],
            shX,
            shY,
            secondHandleCoords,
            oldVals = self.value(),
            dLower = getDistance(clickCoords,firstHandleCoords),
            dHigher,
            targetOldVal = oldVals[0],
            targetHandle = self.handles[0];

          targetHandle.addClass('hide-focus');

          function conversion() {
            if (isVertical) {
              var wh = self.wrapper.height();
              return ((wh - mouseY) / wh) * 100;
            }
            return (mouseX / self.wrapper.width()) * 100;
          }

          // Convert the coordinates of the mouse click to a value
          var val = conversion(),
            rangeVal = self.convertPercentageToValue(val);

          // If the slider is a range, we may use the second handle instead of the first
          if (self.handles[1]) {
            shX = (self.handles[1].offset().left + (self.handles[1].width()/2)) - self.wrapper.offset().left - $(document).scrollLeft();
            shY = (self.handles[1].offset().top + (self.handles[1].height()/2)) - self.wrapper.offset().top - $(document).scrollTop();
            secondHandleCoords = [shX, shY];
            dHigher = getDistance(clickCoords,secondHandleCoords);

            if (dLower > dHigher) {
              self.value([undefined, rangeVal]);
              targetHandle = self.handles[1];
              targetOldVal = oldVals[1];
            } else {
              self.value([rangeVal]);
            }
          } else {
            self.value([rangeVal]);
          }

          self.checkHandleDifference(targetHandle, targetOldVal, rangeVal);

          if (rangeVal < targetOldVal) {
            self.decreaseValue(e, targetHandle, rangeVal, 0);
          } else {
            self.increaseValue(e, targetHandle, rangeVal, 0);
          }

          // Tooltip repositioner will focus the handle after positioning occurs, but if we are clicking a tick
          // on a slider with no tooltip, we need to focus it manually.
          if (!self.settings.tooltip) {
            targetHandle.focus();
          }
      },

      activateHandle: function(handle) {
        handle.addClass('is-active');
      },

      deactivateHandle: function(handle) {
        handle.removeClass('is-active');
      },

      enableHandleDrag: function(handle) {
        if (this.isDisabled()) {
          return;
        }

        var self = this,
          draggableOptions = {
            containment: 'parent',
            axis: (this.isVertical() ? 'y' : 'x'),
            clone: false
          };

        function updateHandleFromDraggable(e, handle, args) {
          if (self.isDisabled()) {
            return;
          }

          function conversion() {
            if (self.isVertical()) {
              var wh = self.wrapper.height(),
              // Vertical Slider accounts for limits set on the height by SoHo Xi Drag.js
              adjustedHeight = wh - handle.outerHeight();

              return ((adjustedHeight - args.top) / adjustedHeight) * 100;
            }
            return args.left / (self.wrapper.width() - handle.outerWidth()) * 100;
          }

          var val = conversion(),
            rangeVal = self.convertPercentageToValue(val);

          // Ranged values need to check to make sure that the higher-value handle doesn't drawindowg past the
          // lower-value handle, and vice-versa.
          if (self.settings.range) {
            var originalVal = self.value();
            if (handle.hasClass('higher') && rangeVal <= originalVal[0]) {
              rangeVal = originalVal[0];
            }
            if (handle.hasClass('lower') && rangeVal >= originalVal[1]) {
              rangeVal = originalVal[1];
            }
          }

          // Round the value to the nearest step, if the step is defined
          if (self.settings.step) {
            rangeVal = Math.round(rangeVal / self.settings.step) * self.settings.step;
          }

          if (!e.defaultPrevented) {
            self.value(handle.hasClass('higher') ? [undefined, rangeVal] : [rangeVal]);
            self.updateRange();
            self.updateTooltip(handle);
            self.element.trigger('sliding', handle, rangeVal);
          }

          return;
        }

        // Add/Remove Classes for canceling animation of handles on the draggable's events.
        handle.drag(draggableOptions)
        .on('drag.slider', function (e, args) {
          updateHandleFromDraggable(e, $(e.currentTarget), args);
        })
        .on('dragstart', function() {
          $(this).addClass('is-dragging');
          self.range.addClass('is-dragging');
          self.element.trigger('slidestart', handle);
        })
        .on('dragend', function() {
          $(this).removeClass('is-dragging');
          self.range.removeClass('is-dragging');
          self.element.trigger('slidestop', handle);
        });
      },

      disableHandleDrag: function(handle) {
        handle.off('drag.slider dragstart dragend');

        this.range.removeClass('is-dragging');
        handle.removeClass('is-dragging');

        var dragAPI = handle.data('drag');
        if (dragAPI) {
          dragAPI.destroy();
        }
      },

      convertValueToPercentage: function(value) {
        return (((value - this.settings.min) / (this.settings.max - this.settings.min)) * 100);
      },

      convertPercentageToValue: function(percentage) {
        var val = (percentage / 100) * (this.settings.max - this.settings.min) + this.settings.min;
        return this.isRtlHorizontal ? (this.settings.max - val + this.settings.min) : val;
      },

      // Gets a 10% increment/decrement as a value within the range of minimum and maximum values.
      getIncrement: function() {
        var increment = 0.1 * (this.settings.max - this.settings.min);
        if (this.settings.step !== undefined && increment <= this.settings.step) {
          increment = this.settings.step;
        }
        return increment;
      },

      handleKeys: function(e, self) {
        if (self.isDisabled()) {
          return;
        }

        var key = e.which,
          handle = $(e.currentTarget);

        handle.removeClass('hide-focus');

        // If the keycode got this far, it's an arrow key, Page Up, Page Down, HOME, or END.
        switch(key) {
          case 33: // Page Up increases the value by 10%
            self.increaseValue(e, handle, undefined, this.getIncrement());
            break;
          case 34: // Page Down decreases the value by 10%
            self.decreaseValue(e, handle, undefined, this.getIncrement());
            break;
          case 35: // End key sets the handle to its maximum possible value
            self.increaseValue(e, handle, this.settings.max);
            break;
          case 36: // Home key sets the handle to its lowest (either minimum value or as low as the "lower" handle)
            self.decreaseValue(e, handle, this.settings.min);
            break;
          case 38: case 39: // Right and Up increase the spinbox value
            if (self.isRtlHorizontal && key === 39) {
              self.decreaseValue(e, handle);
            } else {
              self.increaseValue(e, handle);
            }
            break;
          case 37: case 40: // Left and Down decrease the spinbox value
            if (self.isRtlHorizontal && key === 37) {
              self.increaseValue(e, handle);
            } else {
              self.decreaseValue(e, handle);
            }
            break;
        }
      },

      increaseValue: function(e, handle, value, increment) {
        e.preventDefault();
        clearTimeout(handle.data('animationTimeout'));

        var val = this.value().slice(0),
          incrementBy = increment !== undefined ? increment : this.settings.step !== undefined ? this.settings.step : 1,
          testVal,
          updatedVal,
          finalVal;

        if (handle.hasClass('higher')) {
          testVal = value !== undefined ? value : val[1];
          incrementBy = isInt(testVal) ? incrementBy : isNaN(testVal % incrementBy) ? 0 : testVal % incrementBy;
          updatedVal = testVal + incrementBy < this.settings.max ? testVal + incrementBy : this.settings.max;
          finalVal = updatedVal % incrementBy ? updatedVal : roundToIncrement(updatedVal, incrementBy);
          this.value([undefined, finalVal]);
        } else {
          testVal = value !== undefined ? value : val[0];
          var maxValue = val[1] === undefined ? this.settings.max : val[1];
          incrementBy = isInt(testVal) ? incrementBy : isNaN(testVal % incrementBy) ? 0 : incrementBy - (testVal % incrementBy);
          updatedVal = testVal + incrementBy < maxValue ? testVal + incrementBy : maxValue;
          finalVal = updatedVal % incrementBy ? updatedVal : roundToIncrement(updatedVal, incrementBy);
          this.value([finalVal]);
        }
        this.checkHandleDifference(handle, testVal, finalVal);
        this.updateRange();
        this.updateTooltip(handle);
      },

      decreaseValue: function(e, handle, value, decrement) {
        e.preventDefault();
        clearTimeout(handle.data('animationTimeout'));

        var val = this.value(),
          decrementBy = decrement !== undefined ? decrement : this.settings.step !== undefined ? this.settings.step : 1,
          testVal,
          updatedVal,
          finalVal;

        if (handle.hasClass('higher')) {
          testVal = value !== undefined ? value : val[1];
          var minValue = val[0] === undefined ? this.settings.min : val[0];
          decrementBy = isInt(testVal) ? decrementBy : isNaN(testVal % decrementBy) ? 0 : decrementBy - (testVal % decrementBy);
          updatedVal = testVal - decrementBy > minValue ? testVal - decrementBy : minValue;
          finalVal = updatedVal % decrementBy ? updatedVal : roundToIncrement(updatedVal, decrementBy);
          this.value([undefined, finalVal]);
        } else {
          testVal = value !== undefined ? value : val[0];
          decrementBy = isInt(testVal) ? decrementBy : isNaN(testVal % decrementBy) ? 0 : testVal % decrementBy;
          updatedVal = testVal - decrementBy > this.settings.min ? testVal - decrementBy : this.settings.min;
          finalVal = updatedVal % decrementBy ? updatedVal : roundToIncrement(updatedVal, decrementBy);
          this.value([finalVal]);
        }
        this.checkHandleDifference(handle, testVal, finalVal);
        this.updateRange();
        this.updateTooltip(handle);
      },

      // Changes the position of the bar and handles based on their values.
      updateRange: function() {
        var self = this,
          newVal = this.value(),
          percentages = [],
          color = this.getColorClosestToValue(),
          isVertical = self.wrapper.hasClass('vertical');

        for (var i = 0; i < this.ticks.length; i++) {
          var condition = !this.settings.range ? this.ticks[i].value <= newVal[0] :
            newVal[0] < this.ticks[i].value && this.ticks[i].value <= newVal[1];

          if (condition) {
            this.ticks[i].element.addClass('complete');
            if (color) {
              this.ticks[i].element[0].style.backgroundColor = color;
              this.ticks[i].element.addClass('inherit');
            }
          } else {
            this.ticks[i].element.removeClass('complete');
            if (color) {
              this.ticks[i].element[0].style.backgroundColor = '';
              this.ticks[i].element.removeClass('inherit');
            }
          }
        }

        if (color) {
          this.range[0].style.backgroundColor = color;
          $.each(this.handles, function(i, handle) {
            handle[0].style.backgroundColor = color;
            handle[0].style.borderColor = color;
          });
        }

        // Remove any text colors that already existed.
        $.each(self.ticks, function(i) {
          self.ticks[i].label[0].style.color = '';
        });

        // Convert the stored values from ranged to percentage
        percentages[0] = this.convertValueToPercentage(newVal[0]);
        if (newVal[1] !== undefined) {
          percentages[1] = this.convertValueToPercentage(newVal[1]);
        }

        var posAttrs = (isVertical ? ['bottom', 'top'] :
          (self.isRtlHorizontal ? ['right', 'left'] : ['left', 'right'])),
          cssProps = {};

        // If no arguments are provided, update both handles with the latest stored values.
        if (!this.handles[1]) {
          cssProps[posAttrs[0]] = '0%';
          cssProps[posAttrs[1]] = (100 - percentages[0]) + '%';
        } else {
          cssProps[posAttrs[0]] = percentages[0] + '%';
          cssProps[posAttrs[1]] = (100 - percentages[1]) + '%';
        }
        this.range.css(cssProps);

        function positionHandle(handle, percentage) {
          var basePosition = isVertical ? posAttrs[1] : posAttrs[0],
            realPercentage = isVertical ? 100 - percentage : percentage;

          handle.css(basePosition, 'calc(' + realPercentage + '% - ' + handle.outerWidth()/2 + 'px)');
        }

        if (this.handles[0].hasClass('is-animated')) {
          this.handles[0].data('animationTimeout', setTimeout( function() {
            self.handles[0].removeClass('is-animated').trigger('slide-animation-end');
            self.range.removeClass('is-animated');
          }, 201));
        }
        positionHandle(this.handles[0], percentages[0]);

        if (this.handles[1]) {
          if (this.handles[1].hasClass('is-animated')) {
            this.handles[1].data('animationTimeout', setTimeout( function() {
              self.handles[1].removeClass('is-animated').trigger('slide-animation-end');
              self.range.removeClass('is-animated');
            }, 201));
          }
          positionHandle(this.handles[1], percentages[1]);

          // update the 'aria-valuemin' attribute on the Max handle, and the 'aria-valuemax' attribute on the Min handle
          // for better screen reading compatability
          this.handles[0].attr('aria-valuemax', newVal[1]);
          this.handles[1].attr('aria-valuemin', newVal[0]);
        }
      },

      // Allows a handle to animate to a new position if the difference in value is greater
      // than 3% of the size of the range.
      checkHandleDifference: function(handle, originalVal, updatedVal) {
        // IE9 doesn't support animation so return immediately.
        if ($('html').hasClass('ie9')) {
          return;
        }
        var origPercent = this.convertValueToPercentage(originalVal),
          updatedPercent = this.convertValueToPercentage(updatedVal);

        if (Math.abs(origPercent - updatedPercent) > 3) {
          handle.addClass('is-animated');
          this.range.addClass('is-animated');
        }
      },

      updateTooltip: function(handle) {
        if (!this.settings.tooltip) {
          return;
        }

        if (!handle) {
          var tooltipLow = this.handles[0].data('tooltip'),
            tooltipHigh;

          if (this.handles[1]) {
            tooltipHigh = this.handles[1].data('tooltip');
          }

          tooltipLow.hide();
          if (tooltipHigh) {
            tooltipHigh.hide();
          }

          return;
        }

        var tooltip = handle.data('tooltip');

        function update() {
          tooltip.position();
          handle.focus();
        }

        // NOTE: This is a bit hacky because it depends on the setTimeout() method for animation that is triggered
        // inside the self.updateRange() method to have not fired yet.  If you put a breakpoint anywhere in there you
        // may see strange results with animation.
        if (handle.hasClass('is-animated')) {
          tooltip.hide();
          handle.one('slide-animation-end', function() {
            update();
          });
        } else {
          update();
        }
      },

      getColorClosestToValue: function() {
        var currentTheme = Soho.theme,
          preColors = {
            'light': {
              'default'   : '#000000',
              'very-poor' : '#a13030',
              'poor'      : '#d66221',
              'adequate'  : '#f2bc41',
              'good'      : '#9cce7c',
              'very-good' : '#76b051',
              'superior'  : '#488421'
            },
            'dark': {
              'default'   : '#ffffff',
              'very-poor' : '#a13030',
              'poor'      : '#d66221',
              'adequate'  : '#f2bc41',
              'good'      : '#9cce7c',
              'very-good' : '#76b051',
              'superior'  : '#488421'
            },
            'high-contrast': {
              'default'   : '#000000',
              'very-poor' : '#a13030',
              'poor'      : '#d66221',
              'adequate'  : '#e4882b',
              'good'      : '#76b051',
              'very-good' : '#56932e',
              'superior'  : '#397514'
            }
          };

        var themeColors = preColors[currentTheme],
          val = this.value()[0],
          highestTickColor, c;

        for (var i = 0; i < this.ticks.length; i++) {
          c = this.ticks[i].color;
          if (c && val >= this.ticks[i].value) {
            highestTickColor = c;
            highestTickColor = (c.indexOf('#') > -1) ? c : (themeColors[c] || themeColors.default);
          }
        }

        return highestTickColor;
      },

      // External Facing Function to set the value
      // works as percent for now but need it on ticks
      // NOTE:  Does not visually update the range.  Use setValue() to do both in one swoop.
      value: function(minVal, maxVal) {
        var self = this;

        // if both options are absent, act as a getter and return the current value
        if (minVal === undefined && maxVal === undefined) {
          return self._value;
        }

        // if an array is passed as the first argument, break it apart
        if (minVal && $.isArray(minVal)) {
          if (minVal[1] !== undefined) {
            maxVal = minVal[1];
          }
          minVal = minVal[0];
        }

        // set the values back to the existing one if they aren't passed.
        if (minVal === undefined && $.isArray(self._value) && self._value[0] !== undefined) {
          minVal = self._value[0];
        }
        if (maxVal === undefined && $.isArray(self._value) && self._value[1] !== undefined) {
          maxVal = self._value[1];
        }

        //set the internal value and the element's retrievable value.
        self._value = [minVal, maxVal];
        self.element.val(maxVal !== undefined ? self._value : self._value[0]);
        $.each(self.handles, function(i, handle) {
          var value = self._value[i],
            valueText = self.getModifiedTextValue(value);

          $.each(self.ticks, function(a, tick) {
            if (tick.value === value) {
              valueText = tick.description;
            }
          });

          handle.attr({
            'aria-valuenow': self._value[i],
            'aria-valuetext': valueText
          });
        });

        self.element.trigger('change');
        return self._value;
      },

      // Returns a value with prefixed/suffixed text content.
      // Used by the tooltip and default ticks to get potential identifiers like $ and %.
      getModifiedTextValue: function(content) {
        if (!this.settings.tooltip) {
          return content;
        }
        return this.settings.tooltip[0] + content + this.settings.tooltip[1];
      },

      enable: function() {
        this.element.prop('disabled', false);
        this.wrapper.removeClass('is-disabled');

        var self = this;
        $.each(this.handles, function(i, handle) {
          self.enableHandleDrag(handle);
        });

        return this;
      },

      disable: function() {
        this.element.prop('disabled', true);
        this.wrapper.addClass('is-disabled');

        var self = this;
        $.each(this.handles, function(i, handle) {
          self.disableHandleDrag(handle);
        });

        return this;
      },

      isDisabled: function() {
        return this.element.prop('disabled');
      },

      isVertical: function() {
        return this.wrapper.hasClass('vertical');
      },

      // Externally-facing function that updates the current values and correctly animates the
      // range handles, if applicable.
      setValue: function(lowVal, highVal) {
        var newLowVal = lowVal || undefined,
          newHighVal = highVal || undefined,
          oldVals = this.value();

        this.checkHandleDifference(this.handles[0], oldVals[0], newLowVal);
        if (this.handles[1]) {
          this.checkHandleDifference(this.handles[1], oldVals[1], newHighVal);
        }

        var vals = this.value(newLowVal, newHighVal);
        this.updateRange();
        this.updateTooltip();

        return vals;
      },

      // NOTE: refresh() has been deprecated in Xi Controls v4.2 - has been replaced with setValue().
      // This method will be completely removed in v4.3 and v5.x.  Please update your code.
      refresh: function(lowVal, highVal) {
        return this.setValue(lowVal, highVal);
      },

      // Settings and markup are complicated in the slider so we just destroy and re-invoke it
      // with fresh settings.
      updated: function() {
        this.element.removeAttr('value');
        return this
          .teardown()
          .init();
      },

      teardown: function() {
        var self = this;
        $.each(self.handles, function (i, handle) {
          self.disableHandleDrag(handle);
          handle.off('mousedown.slider click.slider blur.slider keydown.slider keyup.slider');
        });
        this.wrapper.off('click.slider touchend.slider touchcancel.slider').remove();
        this.element.attr('type', this.originalElement.type);

        return this;
      },

      destroy: function() {
        this.teardown();
        $.removeData(this.element[0], pluginName);
      }
    };

    // Support Chaining and Init the Control or Set Settings
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (instance) {
        if (typeof instance[options] === 'function') {
          instance[options]();
        } else {
          instance.settings = $.extend({}, instance.settings, options);
        }
        instance.updated();
      } else {
        instance = $.data(this, pluginName, new Slider(this, options));
      }
    });
  };


  $.fn.arrange = function(options) {
    'use strict';

    // Settings and Options
    var pluginName = 'arrange',
        defaults = {
          handle: null, // The Class of the handle element
          itemsSelector: null,
          connectWith: false,
          placeholder: null,
          placeholderCssClass: 'arrange-placeholder'
        },
        settings = $.extend({}, defaults, options);


    /**
    * The Arrange Component allows touch and drag support to sort UI items.
    *
    * @class Arrange
    * @param {String} handle  &nbsp;-&nbsp; The class name of the handle element to connect
    * @param {String} itemsSelector  &nbsp;-&nbsp; The selector to match all the sortable elements.
    * @param {String} connectWith  &nbsp;-&nbsp; The optional element to connect with when using two lists
    * @param {String} placeholder  &nbsp;-&nbsp; The html for the element that appears while dragging
    * @param {String} placeholderCssClass  &nbsp;-&nbsp; The class to add to the ghost element that is being dragged.
    *
    */
    function Arrange(element) {
      this.element = $(element);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    // Arrange Methods
    Arrange.prototype = {

      // example from: https://github.com/farhadi/html5arrangeable/blob/master/jquery.arrangeable.js
      init: function() {
        this.isTouch = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        this.isIe11 = (Soho.env.browser.name === 'ie' && Soho.env.browser.version === '11');
        this.handleEvents();
      },

      // Get Element By Touch In List
      getElementByTouchInList: function(list, x, y) {
        var returns = false;
        $(list).each(function() {
          var item = $(this), offset = item.offset();
          if (!(x <= offset.left || x >= offset.left + item.outerWidth() ||
                y <= offset.top  || y >= offset.top + item.outerHeight())) {
            returns = item;
          }
        });
        return returns;
      },

      // Dragg touch element
      dragTouchElement: function(e, elm) {
        var orig = e.originalEvent.changedTouches[0];
        elm[0].style.top = (orig.pageY - this.offset.y) + 'px';
        elm[0].style.left = (orig.pageX - this.offset.x) + 'px';
      },

      unbind: function() {
        this.items
          .removeClass('draggable')
          .removeAttr('draggable')
          .off('selectstart.arrange '+ this.dragStart +' '+ this.dragEnd +' '+ this.dragWhileDragging);

        $(this.handle, this.items)
          .removeClass('draggable')
          .off('mousedown.arrange mouseup.arrange touchstart.arrange touchend.arrange');

        return this;
      },

      /**
      * Resync the UI and Settings.
      */
      updated: function() {
        return this
          .unbind()
          .init();
      },

      /**
      * Teardown and remove any added markup and events.
      */
      destroy: function() {
        this.unbind();
        $.removeData(this.element[0], pluginName);
      },


      /**
       *  This component fires the following events.
       *
       * @fires Arrange#events
       * @param {Object} beforearrange  &nbsp;-&nbsp; Fires before moving an element allowing you to access the ui to customize the draggable item
       * @param {Object} afterearrange  &nbsp;-&nbsp; Fires after moving an element allowing you do any follow up updating.
       *
       */
      handleEvents: function() {
        var self = this,
          index, isHandle,
          status = {},
          items = self.element.children().not('[data-arrange-exclude="true"]'),
          placeholder = $('<' + (/^(ul|ol)$/i.test(self.element[0].tagName) ? 'li' : 'div') +'>');

        if (settings.itemsSelector) {
          items = $(settings.itemsSelector, self.element).not('[data-arrange-exclude="true"]');
          placeholder = $('<'+ items.first()[0].tagName +' />');
        }

        if (settings.placeholder) {
          placeholder = $(settings.placeholder);
        }

        self.dragStart = 'dragstart.arrange touchstart.arrange gesturestart.arrange';
        self.dragEnd = 'dragend.arrange touchend.arrange touchcancel.arrange gestureend.arrange';
        self.dragWhileDragging = 'dragover.arrange dragenter.arrange drop.arrange touchmove.arrange gesturechange.arrange';

        self.handle = settings.handle || self.element.attr('data-arrange-handle');
        self.connectWith = self.element.attr('data-arrange-connectWith');
        self.placeholders = placeholder;

        if (!self.isTouch) {
          self.placeholders.addClass(settings.placeholderCssClass +' draggable');
        }

        // Use Handle if available
        $(self.handle, items).addClass('draggable')
          .on('mousedown.arrange touchstart.arrange', function() { isHandle = true; })
          .on('mouseup.arrange touchend.arrange', function() { isHandle = false; });

        // Add connect with
        if (self.connectWith) {
          items = items
            .add($(self.connectWith).children().not('[data-arrange-exclude="true"]'))
            .data('connectWith', self.connectWith);
        }

        self.items = items;

        // Draggable Items
        self.items
        .attr('draggable', true).addClass(self.handle ? '' : 'draggable')
        .add([this, placeholder])
        .not('a[href], img').on('selectstart.arrange', function() {
          if(this.dragDrop) {
            this.dragDrop();//ie9
          }
          return false;
        }).end()

        .each(function() {
          $(this)
          // Drag start --------------------------------------------------------------------------
          .on(self.dragStart, function(e) {
            if (self.handle && !isHandle) {
              if (self.isTouch) {
                return;
              } else {
                return false;
              }
            }
            isHandle = false;
            self.dragging = $(this);

            index = self.dragging.addClass('arrange-dragging').index();

            $.extend(status, {start: self.dragging, startIndex: index});
            self.element.triggerHandler('beforearrange', status);

            if (self.isTouch) {
              var rect = self.dragging[0].getBoundingClientRect(),
                touch = e.originalEvent.changedTouches[0];

              //Save offset
              self.offset = {
                x: touch.pageX - rect.left,
                y: touch.pageY - rect.top
              };
              self.placeholderTouch = self.dragging
                .clone().addClass('is-touch').attr('id', 'arrange-placeholder-touch')
                .insertBefore(self.dragging);

              self.dragTouchElement(e, self.placeholderTouch);
            } else {
              var dt = e.originalEvent.dataTransfer;
              dt.effectAllowed = 'move';
              dt.setData('Text', 'dummy');
            }

          })

          // Drag end ----------------------------------------------------------
          .on(self.dragEnd, function() {
            if (!self.dragging) {
              return;
            }

            if (self.isTouch) {
              self.dragging.css('opacity', 1);
              self.placeholderTouch.remove();
            }

            self.placeholders.filter(':visible').after(self.dragging);
            self.dragging.removeClass('arrange-dragging').show();
            self.placeholders.detach();

            if (index !== self.dragging.index()) {
              $.extend(status, {end: self.dragging, endIndex: self.dragging.index()});
              self.element.triggerHandler('arrangeupdate', status);
            }
            self.dragging = null;
            self.placeholderTouch = null;
          })

          // While dragging ----------------------------------------------------
          .on(self.dragWhileDragging, function(e) {
            if (!self.dragging) {
              return;
            }
            var overItem = this,
              overIndex;
            e.preventDefault();

            if (e.type==='drop') {
              e.stopPropagation();
              self.dragging.trigger('dragend.arrange');
              return false;
            }

            if (self.isTouch) {
              var touch = e.originalEvent.touches[0];
              overItem = self.getElementByTouchInList(items, touch.pageX, touch.pageY) || overItem;
            }
            overItem = $(overItem);

            if (!self.isTouch) {
              e.originalEvent.dataTransfer.dropEffect = 'move';
            }

            if (items.is(overItem) && placeholder.index() !== overItem.index()) {
              if (self.isTouch) {
                self.dragging.css('opacity', 0);
              } else {
                self.dragging.hide();
              }

              if (placeholder.index() < (overItem.index())) {
                placeholder.insertAfter(overItem);
                overIndex = overItem.index();
              }
              else {
                placeholder.insertBefore(overItem);
                overIndex = placeholder.index();
              }

              $.extend(status, {over: overItem, overIndex: overIndex});
              self.element.triggerHandler('draggingarrange', status);

              // Fix: IE-11 on windows-10 svg was disappering
              var svg = $('svg', overItem);
              if(self.isIe11 && svg.length) {
                overItem.html(overItem.html());
              }

              self.placeholders.not(placeholder).detach();
            }
            else if (!self.placeholders.is(this)) {
              self.placeholders.detach();
              self.element.append(placeholder);
            }

            if (self.isTouch) {
              self.dragTouchElement(e, self.placeholderTouch);
              return;
            } else {
              return false;
            }
          });//-----------------------------------------------------------------
        });//end each items
      }

    };

    // Initialize the plugin (Once)
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (instance) {
        instance.settings = $.extend({}, instance.settings, options);
        instance.updated();
      } else {
        instance = $.data(this, pluginName, new Arrange(this, settings));
      }
    });
  };


  $.fn.scrollaction = function(options) {

    var pluginName = 'scrollaction';
    var defaults = {
      scrollActionTarget: '.js-scroll-target', // The element to add a class to based on scrolling logic
      classToAdd: 'scrolled-down' // The class added to the target element
    };

    var functions = {
      trackScrolling: function() {
        var self = this;
        self.lastScrollTop = 0;

        this.element.scroll(function() {
          var st = $(this).scrollTop();

          if (st > self.lastScrollTop){
            $(self.settings.scrollActionTarget).addClass(self.settings.classToAdd);
          } else {
            $(self.settings.scrollActionTarget).removeClass(self.settings.classToAdd);
          }

          self.lastScrollTop = st;
        });
      }
    };

    /**
     * A component that applies a class based on scroll direction
     * @constructor
     * @param {Object} [element=this] - The element to attach to (only when manually calling the constructor)
     * @param {Object} [options]
     * @param {string} [options.scrollActionTarget='.js-scroll-target'] - The selector of the element to add the class to
     * @param {string} [options.classToAdd='scrolled-down'] - The class name
     */
    function ScrollAction(element, options) {
      this.settings = $.extend({}, defaults, options);
      this.element = $(element);
      functions.trackScrolling.call(this);
    }

    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (instance) {
        instance.settings = $.extend({}, instance.settings, options);
      } else {
        instance = $.data(this, pluginName, new ScrollAction(this, options));
      }
    });
  };



  $.fn.spinbox = function(options, args) {
    'use strict';

    // Settings and Options
    var pluginName = 'spinbox',
        defaults = {
          min: null,
          max: null,
          step: null
        },
        settings = $.extend({}, defaults, options);

    /**
     * @constructor
     * @param {Object} element
     */
    function Spinbox(element) {
      this.element = $(element);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    // Plugin Methods
    Spinbox.prototype = {

      init: function() {
        this.settings = $.extend({}, settings);
        this.inlineLabel = this.element.closest('label');
        this.inlineLabelText = this.inlineLabel.find('.label-text');
        this.isInlineLabel = this.element.parent().is('.inline');
        this.isWrapped = this.element.parent().is('.spinbox-wrapper');

        this
          .setInitialValue()
          .addMarkup()
          .bindEvents()
          .setWidth();
      },

      setWidth: function() {
        var style = this.element[0].style;

        if (style.width) {
          this.element.parent()[0].style.width = style.width;
          this.element[0].style.width = (parseInt(style.width) - (this.element.parent().find('.down').outerWidth() * 2)) + 'px';
        }

        return this;
      },

      // Sanitize the initial value of the input field.
      setInitialValue: function() {
        var self = this,
          val = self.checkForNumeric(self.element.val());

        this.element.val(val);
        // If using Dirty Tracking, reset the "original" value of the dirty tracker to the current value
        // of the input, since it may have changed after re-invoking the input field.
        if (this.element.attr('data-trackdirty')) {
          this.element.data('original', val);
        }

        //allow numeric input on iOS
        var iOS = /(iPad|iPhone|iPod)/g.test( navigator.userAgent );
        if (iOS) {
          this.element.attr('pattern','\\d*');
        }

        if (this.settings.max) {
          this.element.attr('max', this.settings.max);
        }
        if (this.settings.step) {
          this.element.attr('step', this.settings.step);
        }
        if (this.settings.min) {
          this.element.attr('min', this.settings.min);
        }


        return this;
      },

      addMarkup: function() {
        var self = this;
        if (this.isInlineLabel) {
          this.inlineLabel.addClass('spinbox-wrapper');
        }
        else if (!this.isWrapped) {
          this.element.wrap('<span class="spinbox-wrapper"></span>');
        }

        this.isTouch = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);

        if (this.isWrapped) {
          this.buttons = {
            'down' : this.element.parent().find('.down').button(),
            'up' : this.element.parent().find('.up').button()
          };

          if (this.isTouch) {
            this.buttons.down.attr('aria-hidden', 'true');
            this.buttons.up.attr('aria-hidden', 'true');
          }
        }

        if (!this.buttons) {
          this.buttons = {
            'down' : $('<span ' + (this.isTouch ? '' : 'aria-hidden="true"') + ' class="spinbox-control down">-</span>').insertBefore(this.element).button(),
            'up' : $('<span ' + (this.isTouch ? '' : 'aria-hidden="true"') + ' class="spinbox-control up">+</span>').insertAfter(this.element).button()
          };
        }

        // Figure out minimum/maximum and data-masking attributes.  The user can provide the spinbox
        // plugin either the min/max or the mask, and the plugin will automatically figure out how to
        // use them.
        var min = this.element.attr('min'),
          max = this.element.attr('max'),
          mask = this.element.attr('data-mask'),
          maskSize, maskValue = '',
          attributes = {
            role: 'spinbutton'
          },
          i = 0;

        // Define a default Max value if none of these attributes exist, to ensure the mask plugin will
        // work correctly.  Cannot define a Min value here because the plugin must be able to invoke itself
        // with a NULL value.
        if (!min && !max && !mask) {
          max = '9999999';
        }

        // If a mask doesn't exist, but min and max values do exist, create a mask that reflects those min/max values
        if ((min || max) && !mask) {
          var newMask = '',
            tempMin = min ? min : '',
            tempMax = max ? max : '',
            longerVal = tempMin.length > tempMax.length ? tempMin : tempMax;
          i = 0;

          while (i <= longerVal.length) {
            newMask += '#';
            i++;
          }

          // Add a negative symbol to the mask if it exists within the longer value.
          if (tempMin.indexOf('-') !== -1 || tempMax.indexOf('-') !== -1) {
            newMask = '-' + newMask.substring(0, (newMask.length - 1));
          }

          attributes['data-mask'] = newMask;
          mask = newMask;
        }

        // If a "data-mask" attribute is already defined, use it to determine missing values for min/max, if they
        // don't already exist.
        maskSize = mask.length;
        i = 0;
        while (i <= maskSize) {
          maskValue += '9';
          i++;
        }

        // If no negative symbol exists in the mask, the minimum value must be zero.
        if (mask.indexOf('-') === -1) {
          attributes.min = min ? min : 0;
          attributes.max = max ? max : maskValue;
        } else {
          attributes.min = min ? min : maskValue;
          attributes.max = max ? max : maskValue.substring(0, (maskValue.length - 1));
        }

        if (!this.element.attr('data-mask-mode') || this.element.attr('data-mask-mode') !== 'number') {
          attributes['data-mask-mode'] = 'number';
        }

        // Destroy the Mask Plugin if it's already been invoked.  We will reinvoke it later on during
        // initialization.  Check to make sure its the actual Mask plugin object, and not the "data-mask"
        // pattern string.
        if (this.element.data('mask') && typeof this.element.data('mask') === 'object') {
          this.element.data('mask').destroy();
        }

        // Add Aria Properties for valuemin/valuemax
        if (min) {
          attributes['aria-valuemin'] = min;
        }
        if (max) {
          attributes['aria-valuemax'] = max;
        }
        this.element.attr(attributes);

        // Set an initial "aria-valuenow" value.
        this.updateAria(self.element.val());

        // Invoke the mask plugin
        this.element.mask();

        // Disable in full if the settings have determined we need to disable on init.
        if (this.isDisabled()) {
          this.disable();
        }

        return this;
      },

      bindEvents: function() {
        var self = this,
          preventClick = false;

        // Main Spinbox Input
        this.element.on('focus.spinbox', function() {
          self.element.parent('.spinbox-wrapper').addClass('is-focused');
        }).on('blur.spinbox', function() {
          self.element.parent('.spinbox-wrapper').removeClass('is-focused');
          // Explicitly trigger the change event if the "original" value is different from its current value.
          // Prevents an issue where changing the value with arrow keys doesn't trigger the "change" event on blur.
          self.element.trigger('change');
        }).on('keydown.spinbox', function(e) {
          self.handleKeyDown(e, self);
        }).on('keypress.spinbox', function(e) {
          self.handleKeyPress(e, self);
        }).on('keyup.spinbox', function(e) {
          self.handleKeyup(e, self);
        }).on('afterPaste.mask', function() {
          self.handleAfterPaste(self);
        });

        // Up and Down Buttons
        var buttons = this.buttons.up.add(this.buttons.down[0]);
        buttons.on('touchstart.spinbox mousedown.spinbox', function(e) {
          if (e.which === 1) {

            if (!preventClick) {
              self.handleClick(e);
            }

            if (self.isTouch) {
              return;
            }

            preventClick = true;
            self.enableLongPress(e, self);

            $(document).one('mouseup', function() {
              self.disableLongPress(e, self);
              preventClick = false;
              self.element.focus();
            });

            //Stop MouseDown From Running
            if (this.isTouch) {
              e.preventDefault();
              e.stopPropagation();
            }
          }
        });

        return this;
      },

      enableLongPress: function(e, self) {
        self.addButtonStyle(e);
        self.longPressInterval = setInterval(function() {
          if ($(e.currentTarget).is(':hover')) {
            self.handleClick(e);
          }
        }, 140);
      },

      disableLongPress: function(e, self) {
        self.removeButtonStyle(e);
        clearInterval(self.longPressInterval);
        self.longPressInterval = null;
      },

      // Sets up the click/long press
      handleClick: function(e) {
        if (this.isDisabled() || e.which !== 1) {
          return;
        }
        var target = $(e.currentTarget);
        if (target.hasClass('up')) {
          this.increaseValue();
        } else {
          this.decreaseValue();
        }

        if (!this.isTouch) {
          this.element.focus();
        } else {
          target.focus();
        }
      },

      handleKeyDown: function(e, self) {
        var key = e.which,
          validKeycodes = [35, 36, 37, 38, 39, 40];

        if ($.inArray(key, validKeycodes) === -1) {
          return;
        }

        // If the keycode got this far, it's an arrow key, HOME, or END.
        switch(key) {
          case 35: // End key sets the spinbox to its minimum value
            if (self.element.attr('min')) { self.element.val(self.element.attr('min')); }
            break;
          case 36: // Home key sets the spinbox to its maximum value
            if (self.element.attr('max')) { self.element.val(self.element.attr('max')); }
            break;
          case 38: case 39: // Right and Up increase the spinbox value
            if (Locale.isRTL() && key === 39) {
              self.addButtonStyle(self.buttons.down);
              self.decreaseValue();
            } else {
              self.addButtonStyle(self.buttons.up);
              self.increaseValue();
            }
            break;
          case 37: case 40: // Left and Down decrease the spinbox value
            if (Locale.isRTL() && key === 37) {
              self.addButtonStyle(self.buttons.up);
              self.increaseValue();
            } else {
              self.addButtonStyle(self.buttons.down);
              self.decreaseValue();
            }
            break;
        }
      },

      handleKeyPress: function(e, self) {
        if (self.isDisabled()) {
          return;
        }
        var key = e.which;

        // NOTE:
        if (key < 48 || (key > 57 && key < 96) || key > 105) {
          return;
        }

        // If the key is a number, pre-calculate the value of the number to see if it would be
        // greater than the maximum, or less than the minimum.  If it's fine, let it through.
        // Doing this check here prevents visual jitter.
        var num = Number(this.checkForNumeric(this.element.val())), // if using Numlock, subtract 48 to get the correct value from String.fromCharCode()
          min = self.element.attr('min'),
          max = self.element.attr('max');

        if (num < min) {
          e.preventDefault();
          return self.updateVal(min);
        }
        if (num > max) {
          e.preventDefault();
          return self.updateVal(max);
        }
      },

      handleKeyup: function(e, self) {
        if (self.isDisabled()) {
          return;
        }
        var key = e.which;

        // Spinbox Control Button styles are added/removed on keyup.
        switch (key) {
          case 38: case 39:
            if (Locale.isRTL() && key === 39) {
              self.removeButtonStyle(self.buttons.down);
            } else {
              self.removeButtonStyle(self.buttons.up);
            }
            break;
          case 37: case 40:
            if (Locale.isRTL() && key === 39) {
              self.removeButtonStyle(self.buttons.up);
            } else {
              self.removeButtonStyle(self.buttons.down);
            }
            break;
        }

        self.updateAria(self.element.val());
      },

      // Change a newly pasted value to this element's min or max values, if the pasted value goes
      // beyond either of those limits.  Listens to an event emitted by the Mask plugin after pasted content
      // is handled.
      handleAfterPaste: function(self) {
        var min = Number(self.element.attr('min')),
          max = Number(self.element.attr('max')),
          val = Number(self.element.val());

        val = (val < min ? min : (val > max ? max : val));
        self.updateVal(val);
      },

      increaseValue: function() {
        var val = this.checkForNumeric(this.element.val()) + Number(this.element.attr('step') || 1);
        if (this.element.attr('max') && val > this.element.attr('max')) {
          return;
        }
        this.updateVal(val);
      },

      decreaseValue: function() {
        var val = this.checkForNumeric(this.element.val()) - Number(this.element.attr('step') || 1);
        if (this.element.attr('min') && val < this.element.attr('min')) {
          return;
        }
        this.updateVal(val);
      },

      updateVal: function(newVal) {
        this.element.val(newVal);
        this.updateAria(newVal);
        this.element.focus();
      },

      // Sanitizes the value of the input field to an integer if it isn't already established.
      checkForNumeric: function(val) {
        // Allow for NULL
        if (val === '') {
          return val;
        }
        if ($.isNumeric(val)) {
          return Number(val);
        }
        val = parseInt(val);
        if ($.isNumeric(val)) {
          return Number(val);
        }
        // Zero out the value if a number can't be made out of it.
        return 0;
      },

      // Updates the "aria-valuenow" property on the spinbox element if the value is currently set
      updateAria: function(val) {
        var min = this.element.attr('min'),
          max = this.element.attr('max');

        val = this.checkForNumeric(val);
        this.element.attr('aria-valuenow', (val !== '' ? val : ''));

        // Tougle min/max buttons
        this.setIsDisabled(this.buttons.up, (val !== '' && max && val >= max) ? 'disable' : 'enable');
        this.setIsDisabled(this.buttons.down, (val !== '' && min && val <= min) ? 'disable' : 'enable');
      },

      // adds a "pressed-in" styling for one of the spinner buttons
      addButtonStyle: function(e) {
        if (this.isDisabled()) {
          return;
        }
        var target = e;
        if (e.currentTarget) {
          target = $(e.currentTarget);
        }
        target.addClass('is-active');
      },

      // removes "pressed-in" styling for one of the spinner buttons
      removeButtonStyle: function(e) {
        if (this.isDisabled()) {
          return;
        }
        var target = e;
        if (e.currentTarget) {
          target = $(e.currentTarget);
        }
        target.removeClass('is-active');
      },

      enable: function() {
        this.element.prop('disabled', false);
        this.element.parent('.spinbox-wrapper').removeClass('is-disabled');
      },

      disable: function() {
        this.element.prop('disabled', true);
        this.element.parent('.spinbox-wrapper').addClass('is-disabled');
      },

      isDisabled: function() {
        return this.element.prop('disabled');
      },

      setIsDisabled: function(button, isDisabled) {
        isDisabled = isDisabled === undefined ? true :
          (!isDisabled || isDisabled === 'enable') ? false : true;

        button[isDisabled ? 'addClass' : 'removeClass']('is-disabled');
      },

      // Teardown
      destroy: function() {
        var mask = this.element.data('mask');
        if (mask && typeof mask.destroy === 'function') {
          mask.destroy();
        }

        for (var button in this.buttons) {
          var buttonAPI = $(button).data('button');

          if (buttonAPI) {
            buttonAPI.destroy();
          }
        }

        this.buttons.up.off('click.spinbox mousedown.spinbox');
        this.buttons.up.remove();
        this.buttons.down.off('click.spinbox mousedown.spinbox');
        this.buttons.down.remove();
        this.element.off('focus.spinbox blur.spinbox keydown.spinbox keyup.spinbox');
        this.element.unwrap();
        $.removeData(this.element[0], pluginName);
      }
    };

    // Keep the Chaining and Init the Controls or Settings
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (instance) {
        if (typeof instance[options] === 'function') {
          instance[options](args);
        }
        instance.settings = $.extend({}, defaults, options);
      } else {
        instance = $.data(this, pluginName, new Spinbox(this, settings));
      }
    });
  };


  //NOTE: Just this part will show up in SoHo Xi Builds.

  $.fn.splitter = function(options) {
    'use strict';

    // Settings and Options
    var pluginName = 'splitter',
        defaults = {
          axis: 'x',
          side: 'left', // or right
          resize: 'immediate',
          containment: null, //document or parent
          save: true
        },
        settings = $.extend({}, defaults, options);

    /**
     * @constructor
     * @param {Object} element
     */
    function Splitter(element) {
      this.settings = $.extend({}, settings);
      this.element = $(element);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    // Plugin Methods
    Splitter.prototype = {
      init: function() {
        //Do other init (change/normalize settings, load externals, etc)
        return this
          .build()
          .handleEvents();
      },

      // Build the Control and Events
      build: function() {
        var self = this,
          s = this.settings,
          splitter = this.element,
          parent = splitter.parent(),
          w = parent.width(),
          direction = s.axis === 'x' ? 'left' : 'top',
          thisSide = parent.is('.content') ? parent.parent() : parent,
          parentHeight,
          defaultOffset = 299;

        setTimeout(function() {
          parentHeight = parent.height();
        }, 0);

        this.docBody = $('body');
        this.isSplitterRightSide = splitter.is('.splitter-right') || (s.axis === 'x' && s.side === 'right');
        this.isSplitterHorizontal = splitter.is('.splitter-horizontal') || s.axis === 'y';
        s.uniqueId = this.uniqueId();

        if (this.isSplitterRightSide) {
          this.leftSide = thisSide;

          thisSide.addClass('is-right-side')
            .next().addClass('flex-grow-shrink is-right-side')
            .parent().addClass('splitter-container');

          splitter.addClass('splitter-right');

          if (s.collapseButton) {
            var savedOffset = 0;
            var $splitterButton = $('<button type="button" class="splitter-btn" id="splitter-collapse-btn" title="Collapse"><svg class="icon" focusable="false" aria-hidden="true" role="presentation"><use xlink:href="#icon-double-chevron"></use></svg></button>');
            $splitterButton.appendTo(splitter);
            if (splitter[0].offsetLeft > 10) {
              $('#splitter-collapse-btn').addClass('rotate');
            }
            $('#splitter-collapse-btn').click(function() {
              if (savedOffset <= 0) {
                if (splitter[0].offsetLeft <= 10){
                  self.splitTo(defaultOffset, parentHeight);
                  $(this).addClass('rotate');
                } else {
                  savedOffset = splitter[0].offsetLeft;
                  self.splitTo(0, parentHeight);
                  $(this).removeClass('rotate');
                }
              } else {
                if (splitter[0].offsetLeft > 10){
                  savedOffset = splitter[0].offsetLeft;
                  self.splitTo(0, parentHeight);
                  $(this).removeClass('rotate');
                } else {
                  self.splitTo(savedOffset, parentHeight);
                  $(this).addClass('rotate');
                  savedOffset = 0;
                }
              }
            });
          }
        }
        else if (this.isSplitterHorizontal) {
          this.topPanel = splitter.prev();
          w = this.topPanel.height();

          parent.addClass('splitter-container is-horizontal');
          splitter.next().addClass('flex-grow-shrink');
          splitter.addClass('splitter-horizontal');
        } else {
          this.rightSide = thisSide;
          this.leftSide = thisSide.prev().parent();

          thisSide.prev()
            .addClass('flex-grow-shrink')
            .parent().addClass('splitter-container');
        }

        //Restore from local storage
        if (localStorage && s.save &&
          !isNaN(parseInt(localStorage[s.uniqueId]))) {
          w = localStorage[s.uniqueId];
        }

        w = parseInt(w);

        if (this.isSplitterHorizontal) {
          splitter[0].style.top = w + 'px';
        } else {
          splitter[0].style.top = 0;
        }

        this.splitTo(w, parentHeight);

        //Add the Splitter Events
        this.documentWidth = 0;

        this.element.drag({
          axis: s.axis,
          containment: s.containment || s.axis === 'x' ? 'document' : 'parent',
          containmentOffset: {left: 20, top: 0}
        })
        .on('dragstart.splitter', function () {
          var iframes = $('iframe');
          self.documentWidth = $(document).width();

          if (iframes.length > 0) {
            for (var i = 0, l = iframes.length; i < l; i++) {
              var frame = $(iframes[i]),
                width = parseInt(getComputedStyle(frame.parent()[0]).width, 10) - 40 +'px';
              frame.before('<div class="overlay" style="opacity: 0; visibility: visible; height: 100%; width: '+ width +'"></div>');
            }
          }
        })
        .on('dragend.splitter', function (e, args) {
          $('.overlay').remove();

          if (s.collapseButton) {
            if (args[direction] <= 10) {
              $('#splitter-collapse-btn').removeClass('rotate');
            } else {
              $('#splitter-collapse-btn').addClass('rotate');
            }
          }

          if (s.resize === 'end') {
            self.splitTo(args[direction], parentHeight);
          }

        })
        .on('drag.splitter', function (e, args) {
          if (args.left <= 0) {
            return false;
          }
          if (s.resize === 'immediate') {
            self.splitTo(args[direction], parentHeight);
          }
        });

        //Horizontal Splitter
        if (s.axis === 'y') {
          this.element.addClass('splitter-horizontal');
        }

        //Aria
        this.element.attr({'aria-dropeffect': 'move', 'tabindex': '0', 'aria-grabbed': 'false'});

        return this;
      },

      // Sets up event handlers for this control and its sub-elements
      handleEvents: function() {
        var self = this;

        this.element
          .on('updated.' + pluginName, function() {
            self.updated();
          })
          .on('keydown.' + pluginName, function(e) {
            //Space will toggle selection
            if (e.which === 32) {
              self.toggleSelection();
              e.preventDefault();
            }

            if (e.which === 37) {
              self.splitTo(self.split - 15, self.parentHeight);
            }

            if (e.which === 39) {
              self.splitTo(self.split + 15, self.parentHeight);
            }
          });

        return this;
      },

      toggleSelection: function () {
        this.element.toggleClass('is-dragging');
      },

      //Resize the panel vertically
      resizeTop: function (splitter, top, parentHeight) {
        if (top > parentHeight || top < 0) {
          top = parseInt(parentHeight) / 2;
        }

        this.topPanel[0].style.height = top + 'px';
      },

      //Resize the panel to the Left
      resizeLeft: function (splitter, leftArg) {
        var left = this.leftSide.outerWidth() - leftArg;

        //Adjust Left and Right Side
        this.rightSide[0].style.width = left + 'px';

        //Reset the Width
        splitter[0].style.left = '';
      },

      //Resize the panel to the Right
      resizeRight: function (splitter, w) {
        //Adjust Left and Right Side
        this.leftSide[0].style.width = w + 'px';
        splitter[0].style.left = (w-1) +'px';
      },

      //Preferably use the id, but if none that make one based on the url and count
      uniqueId: function () {
        return this.element.attr('id') ||
          (window.location.pathname.split('/').pop()) + '-splitter-' + $('.splitter').length;
      },

      splitTo: function (split, parentHeight) {
        var self = this,
          splitter = this.element;

        if (this.isSplitterRightSide) {
          this.resizeRight(splitter, split);
        } else if (this.isSplitterHorizontal) {
          this.resizeTop(splitter, split, parentHeight);
        } else {
          this.resizeLeft(splitter, split);
        }

        this.element.trigger('split', [split]);
        this.docBody.triggerHandler('resize', [self]);

        //Save to local storage
        if (localStorage) {
          localStorage[this.settings.uniqueId] = split;
        }

        this.split = split;
        this.parentHeight = parentHeight;
      },

      //Handle Updating Settings
      updated: function() {
        return this
          .teardown()
          .init();
      },

      // Simple Teardown - remove events & rebuildable markup.
      teardown: function() {
        this.element.off('updated.' + pluginName);
        return this;
      },

      // Teardown - Remove added markup and events
      destroy: function() {
        this.teardown();
        $.removeData(this.element[0], pluginName);
      }
    };

    // Initialize the plugin (Once)
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (instance) {
        instance.settings = $.extend({}, instance.settings, options);
        instance.updated();
      } else {
        instance = $.data(this, pluginName, new Splitter(this, settings));
      }
    });
  };


  $.fn.stepprocess = function(options) {
    var pluginName = 'stepprocess',
      defaults = {
        linearProgression: false,
        folderIconOpen: 'caret-up',
        folderIconClosed: 'caret-down',
        stepList: '#step-list',
        stepLi: '.js-step',
        stepLink: '.js-step-link',
        stepFolder: '.js-step-folder',
        btnPrev: '.js-step-link-prev',
        btnNext: '.js-step-link-next',
        beforeSelectStep: null,
      },
      settings = $.extend({}, defaults, options);

    /**
     * A Stepprocess/wizard control
     *
     * @param {object} element
     * @param {object[]} [options]
     * @param {boolean} [options.linearProgression=false]                     - Whether to prevent clicking and allow only prev/next navigation of steps
     * @param {string} [options.folderIconOpen="caret-up"]                    - A specific folder open icon
     * @param {string} [options.folderIconClosed="caret-down"]                - A specific folder close icon
     * @param {object} [options.stepList="#step-list"]                        - The ID of the stepList
     * @param {object} [options.stepLi=".js-step"]                            - jQuery selector for the step elements
     * @param {object} [options.stepLink=".js-step-link"]                     - jQuery selector for the step link elements
     * @param {object} [options.stepFolder=".js-step-folder"]                 - jQuery selector for the step folder elements
     * @param {object} [options.btnPrev=".js-step-link-prev"]                 - jQuery selector for the previous step button
     * @param {object} [options.btnNext=".js-step-link-next"]                 - jQuery selector for the next step button
     * @param {function(event, args)|Promise} [options.beforeSelectStep=null] - A callback (function or promise) that gives
     *        args.stepLink (the step link element) and args.isStepping (whether we are prev/next'ing or not)
     */
    function Stepprocess(element) {
      this.element = $(element);
      this.init();
    }

    // Stepprocess Methods
    Stepprocess.prototype = {
      init: function() {
        this.settings = $.extend({}, settings);
        this.$stepList = $(this.settings.stepList);
        this.initStepprocess();
        this.handleKeys();
        this.setupEvents();
        this.focusFirst();
      },

      /** @private  */
      initStepprocess: function() {
        var self = this,
          steps = self.$stepList.find(this.settings.stepLi);

        steps.each(function() {
          self.decorateNode(this);
        });

        var startingStep = $(this.settings.stepLi + '.is-selected');
        var startingStepLink = startingStep.find(this.settings.stepLink);
        this.selectStep(startingStepLink);
      },

       /**
       * @private
       * Set initial attributes on each step its counterparts
       * @param  {object} step - The step element to decorate
       */

      decorateNode: function(step) {
        var self = this,
            $step = $(step),
            $stepLink = $step.children(this.settings.stepLink),
            $stepFolder = $step.children(this.settings.stepFolder),
            isDisabled = $stepLink.hasClass('is-disabled'),
            isOpen = $stepFolder.hasClass('is-open');

        if (isDisabled) {
          $stepLink.attr('aria-disabled','true');
        }

        if ($stepFolder.length) {

          $step.addClass('folder');
          $stepFolder.attr('role', 'group');

          if (isDisabled) {
            $stepFolder.addClass('disabled');

            if (isOpen) {
              $stepFolder.children().each(function() {
                $(this).find(self.settings.stepLink)
                  .addClass('is-disabled')
                  .attr('aria-disabled', 'true');
              });
            }
          }

          $stepLink.attr('aria-expanded', isOpen);
        }

        // parentCount 'aria-level' to the node's level depth
        var parentCount = $stepLink.parentsUntil(this.$stepList, 'ul').length - 1;

        // Set the current stepprocess item node position relative to its aria-setsize
        var posinset = $step.index();

        // Set the current stepprocess item aria-setsize
        var listCount = $step.siblings().addBack().length;

        $stepLink
          .attr({
            'role': 'stepitem',
            'tabindex': '-1',
            'aria-selected': 'false',
            'aria-level': parentCount + 1,
            'aria-posinset': posinset + 1,
            'aria-setsize': listCount,
            'aria-disabled': isDisabled
          })
          .addClass('hide-focus')
          .hideFocus();
      },

       /** @private  */

        /**
       * @private
       * @param  {object} step - The step element
       * @return {boolean}
       */

      /** @private  */
      focusFirst: function () {
        this.$stepList.find(this.settings.stepLi + ':first').attr('tabindex', '0');
      },

          /**
       * @private
       * @param  {[type]} step - The step element
       */

      /**
       * @private
       * @param  {object} step - The step element
       */
      folderClose: function(step) {
        var self = this,
            $step = $(step),
            $stepLink = $step.children(this.settings.stepLink),
            $stepFolder = $step.children(this.settings.stepFolder);

        var treeIcon = $stepLink
                        .closest('.folder')
                          .removeClass('is-open')
                          .end()
                        .find('svg.icon-tree');

        this.setIcon(treeIcon, this.settings.folderIconClosed);

        this.isAnimating = true;

        $stepFolder
          .one('animateclosedcomplete', function() {
            $stepFolder.removeClass('is-open');
            self.isAnimating = false;
          })
          .animateClosed();

        $stepLink.attr('aria-expanded', 'false');
      },

      /**
       * @private
       * @param  {object} step - The step element
       */
      folderOpen: function(step) {
        var self = this,
            $step = $(step);

        if (!this.isOpen($step)) {

          var $stepLink = $step.children(this.settings.stepLink),
              $stepFolder = $step.children(this.settings.stepFolder);

          $step.addClass('is-open');
          $stepLink.attr('aria-expanded', 'true');

          var svgElem = $stepLink.find('svg.icon-tree');
          self.setIcon(svgElem, self.settings.folderIconOpen);

          self.isAnimating = true;

          $stepFolder
            .one('animateopencomplete', function() {
              self.isAnimating = false;
            })
            .addClass('is-open')
            .css('height', 0)
            .animateOpen();
        }
      },

      /**
       * @private
       * @param  {[type]} stepLink- Description
       * @return {[type]}     - Description
       */
      folderToggle: function(stepLink) {
        var $step = stepLink.closest(this.settings.stepLi);

        if (this.isFolder($step)) {
          var $stepFolder = $step.children(this.settings.stepFolder);
          if (this.isOpen($stepFolder)) {
            this.folderClose($step);
          } else {
            this.folderOpen($step);
          }
        }
      },


       /**
       * @private
       * @return {object} - the "step" element
       */

      /**
       * @private
       * @return {object}
       */
      getSelectedStep: function () {
        return $(this.settings.stepLi + '.is-selected', this.$stepList);
      },

      /**
       * @private
       * @param  {object} stepLink - The step link element
       * @return {object}
       */
      getNextNode: function(stepLink) {
        var next = stepLink.parent().next().find(this.settings.stepLink + ':first');
        var $nextStep = next.closest(this.settings.stepLi);

        // Possibly Move Into Children
        if (stepLink.next().is(this.settings.stepFolder) && stepLink.next().hasClass('is-open')) {
          next = stepLink.next().find(this.settings.stepLink + ':first');
        }

        //skip disabled
        if(next.hasClass('is-disabled')) {
          next = $nextStep.next().find(this.settings.stepLink + ':first');
        }

        //bottom of a group..{l=2: max folders to be deep }
        if (next.length === 0) {
          for (var i=0, l=2, closest=stepLink; i < l; i++) {
            closest = closest.parent().closest('.folder');
            next = closest.next().find(this.settings.stepLink + ':first');
            if (next.length) {
              break;
            }
          }
        }
        return next;
      },
       /**
       * @private
       * Get the next step in the tree
       * (not to be confused with getNextNode, which includes folders)
       * @return {object}
       */

      /**
       * @private
       * @return {object}
       */
      getNextStep: function() {
        var $curStep = this.getSelectedStep(),
            $curStepLink = $curStep.children(this.settings.stepLink),
            $curStepFolder = $curStep.next(this.settings.stepFolder),
            $nextStepLink = this.getNextNode($curStepLink),
            $nextStepFolder = $nextStepLink.next(this.settings.stepFolder),
            stepLinkToSelect = null,
            theFolder = null;

        if ($curStepFolder.length) {
          // Select the first node of the current folder,
          // unless its empty, which means nextStep will be the folder's "title"
          theFolder = $curStepFolder;
          stepLinkToSelect = theFolder.children().length ? theFolder.find(this.settings.stepLink).first() : $nextStepLink;

        } else if ($nextStepFolder.length) {
          // Select the first node of the next node's folder,
          // unless its empty, which means nextStep will be the folder's "title"
          theFolder = $nextStepFolder;
          stepLinkToSelect = theFolder.children().length ? theFolder.find(this.settings.stepLink).first() : $nextStepLink;

        } else {
          // Neither folders options work so select the next node
          stepLinkToSelect = $nextStepLink;
        }

        return stepLinkToSelect;
      },

      /**
       * @private
       * @param  {object} stepLink - The step link element
       * @return {object}
       */
      getPreviousNode: function(stepLink) {
        var prev = stepLink.parent().prev().find(this.settings.stepLink + ':first');
        var $prevStep = prev.closest(this.settings.stepLi);

        //move into children at bottom
        if ($prevStep.is('.folder.is-open') &&
            $prevStep.find('ul.is-open a').length &&
            !$prevStep.find('ul.is-disabled').length) {
          prev = $prevStep.find('ul.is-open ' + this.settings.stepLink + ':last');
        }

        //skip disabled
        if(prev.hasClass('is-disabled')) {
          prev = $prevStep.prev().find(this.settings.stepLink + ':first');
        }

        //top of a group
        if (prev.length === 0) {
          prev = stepLink.closest(this.settings.stepFolder).prev(this.settings.stepLink);
        }
        return prev;
      },

      /**
       * @private
       * Get the previous step in the tree
       * (not to be confused with getPreviousNode, which includes folders)
       * @return {object}
       */
      getPreviousStep: function() {
        // Get the currently select node
        var $curStep = this.getSelectedStep(),
            $curStepLink = $curStep.children(this.settings.stepLink);

        // Get the previous step to switch to
        var $prevStepLink = this.getPreviousNode($curStepLink),
            $prevStep = $prevStepLink.closest(this.settings.stepLi),
            stepLinkToSelect = $prevStepLink;

        // If we are moving upwards and hit a folder title step
        if (this.isFolder($prevStep)) {

          if (this.isOpen($prevStep)) {
            // If the folder is open, and we got here, that means we
            // were currently at the first step in the folder and need to
            // go to the prev step above the folder step (aka the prev to the prev)
            stepLinkToSelect = this.getPreviousNode($prevStepLink);

          } else {
            var theFolder = $prevStep.children(this.settings.stepFolder);

            if (theFolder.children().length) {
              stepLinkToSelect = theFolder.find(this.settings.stepLink).last();
            }
          }
        }

        return stepLinkToSelect;
      },

      /**
       * Go to the next step element
       */
      goToNextStep: function() {
        var stepLink = this.getNextStep();
        if (stepLink.length) {
          this.selectStep(stepLink, 'next');
        }
      },

      /**
       * Go to the previous step element
       */
      goToPreviousStep: function() {
        var stepLink = this.getPreviousStep();
        if (stepLink.length) {
          this.selectStep(stepLink, 'prev');
        }
      },

      /**
       * @private
       * Key Behavior as per:
       * http://access.aol.com/dhtml-style-guide-working-group/#treeview
       */
      handleKeys: function () {
        var self = this;

        this.$stepList.on('focus.stepprocess', this.settings.stepLink, function() {
          var target = $(this);
          if ((parseInt(target.attr('aria-level')) === 0) &&
              (parseInt(target.attr('aria-posinset')) === 1)) {

            // First element if disabled
            if (target.hasClass('is-disabled')) {
              var e = $.Event('keydown.stepprocess');
              e.keyCode= 40; // move down
              target.trigger(e);
              return;
            }
          }
        });

        // Handle Up/Down Arrow Keys and Space
        this.$stepList.on('keydown.stepprocess', this.settings.stepLink, function (e) {

          var charCode = e.charCode || e.keyCode,
              target = $(this),
              next, prev;

          if (self.isAnimating) {
            return;
          }

          //down arrow
          if (charCode === 40) {
            var nextNode = self.getNextNode(target);
            self.setFocus(nextNode);
          }

          //up arrow,
          if (charCode === 38) {
            var prevNode = self.getPreviousNode(target);
            self.setFocus(prevNode);
          }

          //space
          if (e.keyCode === 32) {
            target.trigger('click.stepprocess');
          }

          // Left arrow
          if (charCode === 37) {
            if (Locale.isRTL()) {
              if (target.next().hasClass('is-open')) {
                prev = target.next().find(self.settings.stepLink + ':first');
                self.setFocus(prev);
              } else {
                self.folderToggle(target);
              }
            } else {
              if (target.next().hasClass('is-open')) {
                self.folderToggle(target);
              } else {
                prev = target.closest('.folder').find(self.settings.stepLink + ':first');
                self.setFocus(prev);
              }
            }
            e.stopPropagation();
            return false;
          }

          // Right arrow
          if (charCode === 39) {
            if (Locale.isRTL()) {
              if (target.next().hasClass('is-open')) {
                self.folderToggle(target);
              } else {
                next = target.closest('.folder').find(self.settings.stepLink + ':first');
                self.setFocus(next);
              }
            } else {
              if (target.next().hasClass('is-open')) {
                next = target.next().find(self.settings.stepLink + ':first');
                self.setFocus(next);
              } else {
                self.folderToggle(target);
                self.setFocus(target);
              }

            }
            e.stopPropagation();
            return false;
          }

          // Home  (fn-right on mac)
          if (charCode === 36) {
            next = self.$stepList.find(self.settings.stepLink + ':first:visible');
            self.setFocus(next);
          }

          // End (fn-right on mac)
          if (charCode === 35) {
            next = self.$stepList.find(self.settings.stepLink + ':last:visible');
            self.setFocus(next);
          }

        });

        // Handle Left/Right Arrow Keys
        this.$stepList.on('keypress.stepprocess', this.settings.stepLink, function (e) {
          var charCode = e.charCode || e.keyCode,
            target = $(this);

          if ((charCode >= 37 && charCode <= 40) || charCode === 32) {
            e.stopPropagation();
            return false;
          }

          //Printable Chars Jump to first high level node with it...
           if (e.which !== 0) {
            target.closest(self.settings.stepLi).nextAll().find('.js-step-link:visible').each(function () {
              var node = $(this),
                first = node.text().substr(0,1).toLowerCase(),
                term = String.fromCharCode(e.which).toLowerCase();

              if (first === term) {
                self.setFocus(node);
                return false;
              }
            });
          }
        });
      },

      /**
       * @private
       * @param  {[type]}  step - The step Li element
       * @return {Boolean}
       */
      isFolder: function(step) {
        return $(step).hasClass('folder');
      },

      /**
       * @private
       * @param  {object} step - The step element
       * @return {boolean}
       */
      isInFolder: function(step) {
        return $(step).closest(this.settings.stepFolder, this.$stepList).length;
      },

      /**
       * @private
       * @param  {object}  stepFolder - The step folder element
       * @return {boolean}
       */
      isOpen: function(stepFolder) {
        return $(stepFolder).hasClass('is-open');
      },

      /**
       * @private
       * @param {object} stepLink
       */
      setFocus: function (stepLink) {
        stepLink.focus();
      },

      /**
       * @private
       * Replace all "icon-", "hide-focus", "\s? - all spaces if any" with nothing
       * @param {string} svg
       * @param {string} icon
       */
      setIcon: function(svg, icon) {
        var iconStr = icon.replace(/icon-|hide-focus|\s?/gi, '');
        svg.changeIcon(iconStr);
      },

        /**
       * Select a step
       * @param  {object} stepLink - The jquery object for the step link element
       * @param  {string} [linearDirection=none|previous|next] - Which direction we are traveling
       */
      selectStep: function (stepLink, linearDirection) {
        var self = this;
        if (linearDirection === undefined) {
          linearDirection = 'none';
        }

        // Possibly Call the beforeSelectStep
        var result;
        if (typeof self.settings.beforeSelectStep === 'function') {

          var args = {
            stepLink: stepLink,
            isStepping: linearDirection
          };
          result = self.settings.beforeSelectStep(args);

          if (result.done && typeof result.done === 'function') { // A promise is returned
            result.done(function(continueSelectNode, stepLinkToSelect) {
              if (continueSelectNode) {
                if (stepLinkToSelect) {
                  stepLink = stepLinkToSelect;
                }
                self.selectStepFinish(stepLink, linearDirection);
              }
            });
          } else if (result) { // boolean is returned instead of a promise
            self.selectStepFinish(stepLink, linearDirection);
          }

        } else { // No Callback specified
          self.selectStepFinish(stepLink, linearDirection);
        }
      },

      /**
       * @private
       * Finishes selecting a step
       * @param  {object} stepLink - Description
       * @param  {string} [linearDirection=previous|next] - Description
       *
       */
      selectStepFinish: function(stepLink, linearDirection) {
        var self = this,
            $allStepLinks = $(this.settings.stepLink, this.$stepList),
            $step = stepLink.closest(this.settings.stepLi);

        $allStepLinks
          .attr({
            'tabindex': '-1',
            'aria-selected': 'false'
          })
          .parent().removeClass('is-selected');

        stepLink.attr({
          'tabindex': '0',
          'aria-selected': 'true'
        });

        $step.addClass('is-selected');

        if (this.isFolder($step)) {
          // It is a folder
          if (linearDirection === 'none') {
            this.folderToggle($step); // clicking toggles
          } else {
            this.folderOpen($step); // going prev/next always opens
          }
        } else {
          // Its not a folder
          var parentIsFolder = $step.closest(this.settings.stepFolder, this.$stepList);

          if (parentIsFolder.length) {
            // If the step is in a folder, make sure that folder opens
            this.folderOpen(parentIsFolder.closest(this.settings.stepLi));
          }

          // Show the step's panel
          this.showStepPanel(stepLink.attr('href'));
        }
        stepLink.focus();

        setTimeout(function() {
          self.element.triggerHandler('selected', stepLink);
        }, 0);
      },

      /**
       * @private
       * @param  {object} step - The step element to decorate
       */
      unSelectedNode: function (step) {
        var aTags = $(this.settings.stepLink, this.$stepList),
            $step = $(step),
            $stepLink = $step.children(this.settings.stepLink);

        aTags.attr('tabindex', '-1');
        $stepLink.attr('tabindex', '0');

        $step.removeClass('is-selected');
        $stepLink.attr('aria-selected', 'false');
      },

      /**
       * @private
       * @return {[type]}- Description
       */
      setupEvents: function () {
        var self = this;

        // Updated and Click events
        self.$stepList
          .on('updated.stepprocess', function () {
            self.initStepprocess();
          })
          .on('click.stepprocess', self.settings.stepLink + ':not(.is-clone)', function (e) {
            e.preventDefault();

            if (!self.settings.linearProgression) {
              var $target = $(this);

              if (!$target.is('.is-disabled, .is-loading')) {
                self.selectStep($target);
                e.stopPropagation();
              }
            }
          });

        // Next Button Click
        $(this.settings.btnPrev).on('click', function(e) {
          e.preventDefault();
          self.goToPreviousStep.call(self);
        });

        // Previous Button Click
        $(this.settings.btnNext).on('click', function(e) {
          e.preventDefault();
          self.goToNextStep.call(self);
        });

        // Setup main scrolling
        $(this.settings.contentScroll).scrollaction({
          scrollActionTarget: '.main'
        });

        // Setup sidebar scrolling
        $(this.settings.stepListScroll).scrollaction({
          scrollActionTarget: '.sidebar'
        });

        // Toggle sidebar
        // Button to toggle the tree in responsive view
        $('.js-toggle-sidebar').click(function(e) {
          e.preventDefault();
          self.element
            .toggleClass('tablet-hide-steps')
            .toggleClass('phone-hide-steps');
        });
      },

      /**
       * @private
       * Show the content panel for the step
       * @param  {string} contentId - The contentId to show
       */
      showStepPanel: function(contentId) {
        $('.step-panel-active').removeClass('step-panel-active');
        $(contentId).addClass('step-panel-active');
        this.element.addClass('phone-hide-steps');
      },

      /** @private */
      destroy: function() {
        this.$stepList.removeData(pluginName);
        this.$stepList.off('updated.stepprocess click.stepprocess focus.stepprocess keydown.stepprocess keypress.stepprocess').empty();
      }
    };

    // Keep the Chaining and Init the Controls or Settings
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (instance) {
        instance.settings = $.extend({}, defaults, options);
      } else {
        instance = $.data(this, pluginName, new Stepprocess(this, settings));
      }
    });

  };


  $.fn.swaplist = function(options) {
    'use strict';

    // Settings and Options
    var pluginName = 'swaplist',
        defaults = {
          // Datasets
          'available': null,
          'selected': null,
          'additional': null,

          // Main containers
          'availableClass': '.available',
          'selectedClass': '.selected',
          'additionalClass': '.full-access',

          // Action buttons
          'availableBtn': '.btn-moveto-selected',
          'selectedBtnLeft': '.btn-moveto-left',
          'selectedBtnRight': '.btn-moveto-right',
          'additionalBtn': '.btn-moveto-selected',

          // Template HTML
          'template': ''+
            '<ul data-swap-handle=".handle">'+
              '{{#dataset}}'+
                '{{#text}}'+
                  '<li'+
                    '{{#value}} data-value="{{value}}"{{/value}}'+
                    '{{#selected}} selected="selected"{{/selected}}'+
                    '{{#disabled}} class="is-disabled"{{/disabled}}'+
                  '>'+
                    '<span class="handle" focusable="false" aria-hidden="true" role="presentation">&#8286;</span>'+
                    '<div class="swaplist-item-content"><p>{{text}}</p></div>'+
                  '</li>'+
                '{{/text}}'+
              '{{/dataset}}'+
            '</ul>'
        },
        settings = $.extend({}, defaults, options);

    /**
     * @constructor
     * @param {Object} element
     */
    function SwapList(element) {
      this.settings = $.extend({}, settings);
      this.element = $(element);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    // SwapList Methods
    SwapList.prototype = {

      init: function() {
        var self = this,
          s = self.settings;
        self.isTouch = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        self.isAdditional = $(s.additionalClass +' .listview', self.element).length > 0;

        if (self.isTouch) {
          self.element.addClass('is-touch');
        }
        self.loadListview();
        self.initDataset();
        self.setElements();
        self.isMultiSelectClass();

        setTimeout(function() { // Wait for Listview availability
          self.makeDraggable();
          self.handleEvents();
          self.initSelected(s.availableClass);
          self.initSelected(s.additionalClass);
        }, 0);
      },

      // Handle Events
      handleEvents: function() {
        var self = this,
          settings = self.settings,
          selections = self.selections;

        // TOP BUTTONS =============================================================================
        self.actionButtons.off('click.swaplist').on('click.swaplist', function () {
          var actionButton = $(this),
            container = actionButton.closest('.card'); // Current list clicked from

          if (container.is(settings.availableClass)) { // Move from Available to Selected
            self.moveElements(settings.availableClass, settings.selectedClass);
          }

          else if (container.is(settings.additionalClass)) { // Move from Additional to Selected
            self.moveElements(settings.additionalClass, settings.selectedClass);
          }

          // Move from Selected
          else if (container.is(settings.selectedClass)) {
            if (actionButton.is(settings.selectedBtnLeft)) { // to Available
              self.moveElements(settings.selectedClass, settings.availableClass);
            }
            else if (actionButton.is(settings.selectedBtnRight)) { // to Additional
              self.moveElements(settings.selectedClass, settings.additionalClass);
            }
          }
        });


        // KEYSTROKE ===============================================================================
        // Keydown event to implement selections
        self.containers.on('keydown.swaplist', function(e) {
          var container = $(this);
          e = e || window.event;
          if (e.keyCode === 77 && self.hasModifier(e)) { // Modifier + M
            if (!container.is(settings.selectedClass) ||
              (container.is(settings.selectedClass) && self.selectedButtons.length === 1)) {
              container.find(self.actionButtons).trigger('click.swaplist');
            } else {
              self.selectedButtons.first().focus();
            }
            e.preventDefault();
          }
        });

        // Keydown event to handle selected container
        self.selectedButtons.on('keydown.swaplist', function(e) {
          var btn = $(this), index, move;
          e = e || window.event;
          if (e.keyCode === 13 || e.keyCode === 32) { // Enter or Space
            btn.trigger('click.swaplist');
            e.preventDefault();
          }
          // Left or Right arrow
          if ((e.keyCode === 37 || e.keyCode === 39) && self.selectedButtons.length > 1) {
            index = self.selectedButtons.index(this);
            move = e.keyCode === 37 ?
              (index > 0 ? index-1 : self.selectedButtons.length-1) :
              (index < self.selectedButtons.length-1 ? index+1 : 0);
            self.selectedButtons[move].focus();
          }
        });

        self.element.on('keydown.swaplist', self.tabButtonsStr, function(e) {
          var btn = $(this),
            keyCode = e.keyCode || e.which;

          if (keyCode === 9 && !e.shiftKey) { // Tab key
            $('li:first-child', btn.closest('.card')).focus();
            e.preventDefault();
          }
        });


        // DRAGGABLE ===============================================================================
        self.element
        .on('mousedown.swaplist', self.dragElements, function(e) {
          if (self.handle) {
            var target = $(e.target).closest('li');
            target.attr({ 'draggable': $(e.target).is('.draggable') });
          }
          e.stopPropagation();
        })
        .onTouchClick('swaplist', self.dragElements)

        // Dragstart - initiate dragging
        .on(self.dragStart, self.dragElements, function(e) {
          if (self.handle && !selections.isHandle) {
            e.stopPropagation();
            return;
          }
          var rect, touch, placeholderContainer,
            target = $(e.target).closest('li'),
            list = $('.listview', target.closest('.card')).data('listview');

          // Not in draging area
          if (!list) {
            return;
          }

          if (!self.isTouch) {
            self.draggedMakeSelected(list, target);
          }

          self.clearSelections(); // Clear selection before fill

          selections.owner = target.closest('.card');
          selections.dragged = target;
          selections.draggedIndex = target.index();
          selections.placeholder = target.clone(true);
          selections.placeholder.attr('id', 'sl-placeholder');

          self.setSelectionsItems(selections.owner);

          selections.items = list.selectedItems;
          self.element.triggerHandler('beforeswap', [selections.itemsData]);

          $('.'+ settings.numOfSelectionsClass, settings.itemContentTempl).html(selections.items.length);
          self.addDropeffects();

          if (!self.isTouch) {
            selections.dragged.addClass('is-dragging');
            e.originalEvent.dataTransfer.setData('text', '');

            if (selections.items.length > 1) {
              $('.'+ settings.itemContentClass, selections.dragged).html(settings.itemContentTempl.html());
            }
          }
          else {
            rect = target[0].getBoundingClientRect();
            touch = e.originalEvent.changedTouches[0];

            //Save offset
            self.offset = {
              x: touch.pageX - rect.left,
              y: touch.pageY - rect.top
            };

            for (var i = 0, l = self.containers.length; i < l; i++) {
              self.containers[i].style.zIndex = '1';
            }
            selections.placeholderTouch = selections.dragged.clone(true);

            if (selections.items.length > 1 && !$('#sl-placeholder-touch2').length) {
              selections.dragged.clone()
                .addClass('is-dragging-touch').attr('id', 'sl-placeholder-touch2')
                .insertBefore(selections.dragged)
                .hide();
            }
            selections.placeholderTouch.attr('id', 'sl-placeholder-touch').removeClass('is-selected').hide();

            // Mobile view with three container(available, selected, additional) prepend to parent
            placeholderContainer = (self.element.is('.one-third') && self.isMaxWidth(766)) ? self.element.parent() : self.element;
            placeholderContainer.prepend('<ul id="sl-placeholder-container"></ul>');

            $('#sl-placeholder-container').append(selections.placeholderTouch);
            $('#sl-placeholder-container')[0].style.width = selections.owner.width() +'px';
            $('#sl-placeholder-touch')[0].style.width = selections.owner.width() +'px';

            self.draggTouchElement(e, selections.placeholderTouch);
          }
          e.stopPropagation();
        })

        // Dragenter - set that related/droptarget
        .on(self.dragEnterWhileDragging, self.dragElements, function(e) {
          if (!selections.dragged) {
            return;
          }
          self.element.triggerHandler('draggingswap', [selections.itemsData]);
          selections.related = e.target;
          $('ul, li', self.element).removeClass('over');
          $(e.target).closest('ul, li').addClass('over');
          selections.droptarget = $(selections.related).closest('.card');
          $('[aria-grabbed="true"]', self.element).not(selections.dragged).slideUp();
          e.stopPropagation();
        })

        // Dragover - allow the drag by preventing default, for touch set related/droptarget
        .on(self.dragOverWhileDragging, self.dragElements, function(e) {
          if (!selections.dragged) {
            return;
          }
          var touch,
            overItem = $(this),
            list = $('.listview', selections.dragged.closest('.card')).data('listview');

          if (self.isTouch) {
            if (!!self.handle && !selections.isHandle) {
              return;
            }

            if (!selections.isInSelection) {
              self.draggedMakeSelected(list, selections.dragged);
              selections.items = list.selectedItems;
              $('.'+ settings.numOfSelectionsClass, settings.itemContentTempl).html(selections.items.length);
            }

            touch = e.originalEvent.touches[0];
            overItem = self.getElementByTouchInList($('ul, li', self.element), touch.pageX, touch.pageY) || overItem;

            selections.dragged.addClass('is-dragging');
            selections.placeholderTouch.addClass('is-dragging is-dragging-touch');
            selections.placeholderTouch.show();

            $('[aria-grabbed="true"]', self.element)
              .not(selections.dragged)
              .not(selections.placeholderTouch)
              .not('#sl-placeholder-touch2')
              .slideUp();

            if (selections.items.length > 1) {
              $('.'+ settings.itemContentClass, (selections.placeholderTouch.add('#sl-placeholder-touch2')))
                .html(settings.itemContentTempl.html());

              $('#sl-placeholder-touch2').show();
              selections.dragged.hide();
            }
            self.draggTouchElement(e, selections.placeholderTouch);

            self.element.triggerHandler('draggingswap', [selections.itemsData]);
            selections.related = overItem;
            $('ul, li', this.element).removeClass('over');
            overItem.closest('ul, li').addClass('over');
            selections.droptarget = selections.related.closest('.card');
          }
          e.preventDefault();
          e.stopPropagation();
        })

        // Dragend - implement items being validly dropped into targets
        .on(self.dragEnd, self.dragElements, function(e) {
          if (!selections.dragged) {
            return;
          }
          var related = $(selections.related).closest('li'),
          ul = $('ul', selections.droptarget),
          currentSize = $('li', ul).length,
          size = selections.items.length + currentSize;

          self.unselectElements($('.listview', selections.owner).data('listview'));

          $.each(selections.items, function(index, val) {
            val = $(val);
            if (currentSize && !$(selections.related).is('ul')) {
              var isLess = (related.index() < selections.draggedIndex),
                el = isLess ? val : $(selections.items[(selections.items.length-1) - index]),
                posinset = related.index()+(isLess ? index+1 : index+2);

              val.attr({ 'aria-posinset': posinset, 'aria-setsize': size });
              related[isLess ? 'before' : 'after'](el);

            } else {
              val.attr({ 'aria-posinset': currentSize+index+1, 'aria-setsize': size });
              ul.append(val);
            }
            val.focus();
          });

          if (selections.items.length > 1) {
            $('.'+ settings.itemContentClass, selections.dragged).html(
              $('.'+ settings.itemContentClass, selections.placeholder).html()
            );
            if (self.isTouch) {
              selections.dragged.show();
            }
          }

          if (self.isTouch) {
            for (var i = 0, l = self.containers.length; i < l; i++) {
              self.containers[i].style.zIndex = '';
            }
          }

          selections.isHandle = null;
          $('[aria-grabbed="true"]', self.element).show();
          self.afterUpdate($('.listview', selections.droptarget).data('listview'));
          e.preventDefault();
          e.stopPropagation();
        });
      }, // END: Handle Events ---------------------------------------------------------------------


      // Load listview
      loadListview: function() {
        var i, l, lv, c,
          self = this,
          s = self.settings,
          containers = [
            { dataset: s.available, class: s.availableClass },
            { dataset: s.selected, class: s.selectedClass },
            { dataset: s.additional, class: s.additionalClass }
          ];

        for (i=0,l=containers.length; i<l; i++) {
          c = containers[i];
          lv = $(c.class +' .listview', self.element);
          if (!c.dataset && lv.length && $('li', lv).length) {
            lv.listview({ selectable: 'multiple' });
          }
          else if (lv.length) {
            lv.listview({ dataset: (c.dataset || []), template: s.template, selectable: 'multiple' });
          }
        }
      },


      // Set elements
      setElements: function() {
        this.offset = null;

        this.containers = $(
          this.settings.availableClass +','+
          this.settings.selectedClass +','+
          this.settings.additionalClass, this.element);

        this.actionButtons = $(
          this.settings.availableBtn +','+
          this.settings.additionalBtn +','+
          this.settings.selectedBtnLeft +','+
          this.settings.selectedBtnRight, this.element);

        this.selectedButtons = $(
          this.settings.selectedBtnLeft +','+
          this.settings.selectedBtnRight, this.element);

        this.tabButtonsStr = ''+
          this.settings.availableBtn +' '+
          this.settings.additionalBtn +' '+
          (this.selectedButtons.length > 1 ?
            this.settings.selectedBtnRight : this.settings.selectedBtnLeft);

        this.dragElements = 'ul, li:not(.is-disabled)';
        this.dragStart = 'dragstart.swaplist touchstart.swaplist gesturestart.swaplist';
        this.dragEnterWhileDragging = 'dragenter.swaplist';
        this.dragOverWhileDragging = 'dragover.swaplist touchmove.swaplist gesturechange.swaplist';
        this.dragEnd = 'dragend.swaplist touchend.swaplist touchcancel.swaplist gestureend.swaplist';

        this.selections = {
          'items': [],
          'owner': null,
          'related': null,
          'droptarget': null,
          'isInSelection': null,
          'isHandle': null,
          'placeholder': null,
          'placeholderTouch': null,
          'dragged': null,
          'draggedIndex': null
        };

        // Dragging time placeholder
        this.settings.numOfSelectionsClass = 'num-of-selections';
        this.settings.itemContentClass = 'swaplist-item-content';
        this.settings.itemContentTempl = $(
          '<div><p><span class="'+ this.settings.numOfSelectionsClass +'">###</span> '+
            Locale.translate('ItemsSelected') +'</p><div/>'
        );
      },

      // When list is Empty force to add css class "is-muliselect"
      isMultiSelectClass: function() {
        var i, l, lv,
          s = this.settings,
          containers = [s.availableClass, s.selectedClass, s.additionalClass];

        for (i=0,l=containers.length; i<l; i++) {
          lv = $(containers[i] +' .listview', this.element);
          if (!$('li', lv).length) {
            lv.addClass('is-muliselect');
          }
        }
      },

      // Initialize pre selected items
      initSelected: function(container) {
        var list;
        container = this.isjQuery(container) ? container : $(container, this.element);
        if (container.length) {
          list = $('.listview', container).data('listview');
          $('li[selected]', container).each(function() {
            $(this).removeAttr('selected');
            list.select($(this));// Select this item
          });
          this.moveElements(container, this.settings.selectedClass);
          $(this.settings.selectedClass +' li:last-child', this.element).blur();
        }
      },

      // Move Elements
      moveElements: function(from, to) {
        var ul, size, currentSize,
          self = this, list;

        from = (typeof from !== 'string') ? from : $(from, self.element);
        to = (typeof to !== 'string') ? to : $(to, self.element);
        list = $('.listview', from).data('listview');

        self.clearSelections();
        self.selections.owner = from;
        self.selections.droptarget = to;

        if (self.isTouch) {
          $.each(list.selectedItems, function(index, val) {
            self.selections.items[index] = val.closest('li');
          });
        } else {
          self.selections.items = list.selectedItems;
        }

        self.setSelectionsItems(self.selections.owner);
        self.unselectElements(list);

        if (self.selections.items.length) {
          self.element.triggerHandler('beforeswap', [self.selections.itemsData]);

          ul = $('ul', to);
          currentSize = $('li', ul).length;
          size = self.selections.items.length + currentSize;

          $.each(self.selections.items, function(index, val) {
            val = $(val);
            val.attr({ 'aria-posinset': currentSize + index + 1, 'aria-setsize': size });
            ul.append(val);
            val.focus();
          });

          self.afterUpdate($('.listview', to).data('listview'));
        }
      },

      // Un-select Elements
      unselectElements: function(list) {
        $.each(list.selectedItems, function(index, val) {
          list.select(val);
        });
      },

      // Detect browser support for drag-n-drop
      isDragAndDropSupports: function() {
        var div = document.createElement('div');
        return ('draggable' in div) || ('ondragstart' in div && 'ondrop' in div);
      },

      // Detect browser support for match-media
      isMatchMediaSupports: function() {
        return (typeof window.matchMedia !== 'undefined' || typeof window.msMatchMedia !== 'undefined');
      },

      // Detect browser viewport
      viewport: function() {
        var e = window, a = 'inner';
        if (!('innerWidth' in window)) {
          a = 'client';
          e = document.documentElement || document.body;
        }
        return { width : e[a+'Width'] , height : e[a+'Height'] };
      },

      // Check given [max-width] is true/false
      isMaxWidth: function(w) {
        return ((this.isMatchMediaSupports() && window.matchMedia('(max-width: '+ w +'px)').matches) || this.viewport().width <= w);
      },

      // Make Draggable
      makeDraggable: function() {
        var self = this,
          ul = $('ul', self.element);

        if (self.isDragAndDropSupports) {
          // Use Handle if available
          self.handle = ul.first().attr('data-swap-handle');
          self.handle = $(self.handle, ul).length > 0 ? self.handle : null;
          // self.handle = (!self.isTouch && $(self.handle, ul).length > 0) ? self.handle : null;
          $(self.handle, ul).addClass('draggable')
            .off('mousedown.swaplist touchstart.swaplist')
            .on('mousedown.swaplist touchstart.swaplist', function() { self.selections.isHandle = true; })
            .off('mouseup.swaplist touchend.swaplist')
            .on('mouseup.swaplist touchend.swaplist', function() { self.selections.isHandle = false; });

          self.targets = ul.attr({'aria-dropeffect': 'none'});

          self.items = $('li:not(.is-disabled)', self.element)
            .not('a[href], img')
              .off('selectstart.swaplist')
              .on('selectstart.swaplist', function() {
              if (this.dragDrop) { this.dragDrop(); } //ie9
              return false;
            }).end()
            .attr({'draggable': true})
            .addClass(self.handle ? '' : 'draggable');
        }
      },

      // Get Element By Touch In List
      getElementByTouchInList: function(list, x, y) {
        var returns = false;
        $(list).each(function() {
          var item = $(this), offset = item.offset();
          if (!(x <= offset.left || x >= offset.left + item.outerWidth() ||
                y <= offset.top  || y >= offset.top + item.outerHeight())) {
            returns = item;
          }
        });
        return returns;
      },

      // Dragg touch element
      draggTouchElement: function(e, elm) {
        var orig = e.originalEvent.changedTouches[0];
        elm[0].style.top = (orig.pageY - this.offset.y) + 'px';
        elm[0].style.left = (orig.pageX - this.offset.x) + 'px';
      },

      // Shorctut for testing whether a modifier is pressed
      hasModifier: function(e) {
        return (e.ctrlKey || e.metaKey || e.shiftKey);
      },

      // Applying dropeffect to the target containers
      addDropeffects: function() {
        this.targets.each(function() {
          $(this).attr({'aria-dropeffect': 'move', 'tabindex': 0});
        });
        $.each(this.selections.items, function(index, val) {
          $(val).attr({'aria-grabbed': true, 'tabindex': 0});
        });
      },

      // Removing dropeffect from the target containers
      clearDropeffects: function() {
        this.targets.attr({'aria-dropeffect': 'none'}).removeAttr('tabindex');
        $.each(this.selections.items, function(index, val) {
          val = $(val);
          val.removeAttr('aria-grabbed' + (!val.is(':focus') ? ' tabindex' : ''));
        });
      },

      // Clear selections
      clearSelections: function() {
        this.selections.items = [];
        this.selections.itemsData = [];
        this.selections.owner = null;
        this.selections.related = null;
        this.selections.droptarget = null;
        this.selections.isInSelection = null;
        this.selections.dragged = null;
        this.selections.placeholder = null;
        this.selections.placeholderTouch = null;
        $('ul, li', this.element).removeClass('over');
        $('#sl-placeholder-container, #sl-placeholder-touch, #sl-placeholder-touch2, #sl-placeholder').remove();
      },

      // Set selections items
      setSelectionsItems: function(container) {
        container = this.isjQuery(container) ? container : $(container, this.element);
        var nodes = $('.listview li', container),
          dataList = this.getDataList(container);
        for (var i=0,l=nodes.length; i<l; i++) {
          var li = $(nodes[i]);
          if (li.is('.is-selected')) {
            this.selections.itemsData.push(dataList[i]);
          }
        }
      },

      // Init dataset
      initDataset: function() {
        var s = this.settings,
          containers = [
            {type: 'available', dataset: s.available, class: s.availableClass},
            {type: 'selected', dataset: s.selected, class: s.selectedClass},
            {type: 'additional', dataset: s.additional, class: s.additionalClass}
          ];

        this.dataset = {'available': [], 'selected': []};
        if (this.isAdditional) {
          this.dataset.additional = [];
        }

        for (var i=0,l=containers.length; i<l; i++) {
          var c = containers[i],
            nodes = $(c.class +' .listview li', this.element);
          for (var nodeIndex=0,l2=nodes.length; nodeIndex<l2; nodeIndex++) {
            var data, value,
              li = $(nodes[nodeIndex]);
            if (c.dataset) {
              // Make sure it's not reference pointer to data object, make copy of data
              data = JSON.parse(JSON.stringify(c.dataset[nodeIndex]));
              delete data.selected;
            }
            else {
              data = {text: $.trim($('.swaplist-item-content', li).text())};
              value = li.attr('data-value');
              if (value) {
                data.value = value;
              }
            }
            if (this.dataset[c.type]) {
              data.node = li;
              this.dataset[c.type].push(data);
            }
          }
        }
      },

      // Get data list
      getDataList: function(container) {
        var s = this.settings,
          d = this.dataset;
        container = this.isjQuery(container) ? container : $(container, this.element);
        return container.is(s.additionalClass) ? d.additional :
          (container.is(s.selectedClass) ? d.selected :
            (container.is(s.availableClass) ? d.available : []));
      },

      // Move an array element position
      arrayIndexMove: function(arr, from, to) {
        arr.splice(to, 0, arr.splice(from, 1)[0]);
      },

      // Sync dataset
      syncDataset: function(owner, droptarget) {
        var droptargetNodes = $('.listview li', droptarget),
          ownerDataList = this.getDataList(owner),
          dtDataList = this.getDataList(droptarget);

        for (var i=0,l=this.selections.items.length; i<l; i++) {
          var item = this.selections.items[i];
          for (var dtIndex=0,l2=droptargetNodes.length; dtIndex<l2; dtIndex++) {
            if ($(droptargetNodes[dtIndex]).is(item)) {
              for (var ownerIndex=0,l3=ownerDataList.length; ownerIndex<l3; ownerIndex++) {
                var ownerItem = ownerDataList[ownerIndex];
                if (ownerItem.node && ownerItem.node.is(item)) {
                  dtDataList.push(ownerItem);
                  ownerDataList.splice(ownerIndex, 1);
                  this.arrayIndexMove(dtDataList, dtDataList.length-1, dtIndex);
                  break;
                }
              }
            }
          }
        }
      },

      // Check if a object is jQuery object
      isjQuery: function (obj) {
        return (obj && (obj instanceof jQuery || obj.constructor.prototype.jquery));
      },

      // Update attributes
      updateAttributes: function(list) {
        var items = $('li', list),
          size = items.length;

        items.each(function(i) {
          $(this).attr({ 'aria-posinset': i+1, 'aria-setsize': size });
        });
      },

      // After update
      afterUpdate: function(list) {
        var self = this;

        setTimeout(function() {
          if (list) {
            if (self.selections.placeholder) {
              list.select(self.selections.placeholder);
              self.selections.placeholder.focus();
            }
            self.unselectElements(list);
            self.syncDataset(self.selections.owner, self.selections.droptarget);
            self.updateAttributes($('.listview', self.selections.owner));
            self.updateAttributes($('.listview', self.selections.droptarget));
            if (self.selections.items.length) {
              self.element.triggerHandler('swapupdate', [self.selections.itemsData]);
            }
          }
          self.clearDropeffects();
          self.clearSelections();
          self.items.removeClass('is-dragging is-dragging-touch');
        }, 100);
      },

      // Get items from provided container
      getItems: function(container) {
        container = this.isjQuery(container) ? container : $(container, this.element);
        return this.getDataList(container);
      },

      // Get available dataset
      getAvailable: function() {
        return this.getDataList(this.settings.availableClass);
      },

      // Get selected dataset
      getSelected: function() {
        return this.getDataList(this.settings.selectedClass);
      },

      // Get additional dataset
      getAdditional: function() {
        return this.getDataList(this.settings.additionalClass);
      },

      // Make selected if dragged element was not selected
      draggedMakeSelected: function(list, target) {
        var self = this, isInSelection = false;
        if (!self.selections.isInSelection) {
          // Check if dragged element was selected or not
          $.each(list.selectedItems, function(index, val) {
            if (target[0] === val[0]) {
              isInSelection = true;
              return false;
            }
          });
          if (!isInSelection) {
            list.select(target); // Make selected
            self.selections.isInSelection = true;
          }
        }
      },

      // Update dataset
      updateDataset: function(ds) {
        var i, l, lv, c, api,
          self = this,
          s = self.settings,
          containers = [
            { type: 'available', dataset: ds.available, class: s.availableClass },
            { type: 'selected', dataset: ds.selected, class: s.selectedClass },
            { type: 'additional', dataset: ds.additional, class: s.additionalClass }
          ];

        for (i = 0, l = containers.length; i < l; i++) {
          c = containers[i];
          lv = $(c.class +' .listview', self.element);
          api = lv.data('listview');

          if (api) {
            api.unselectRowsBetweenIndexes([0, $('li', lv).length - 1]);
            s[c.type] = c.dataset || [];
            api.loadData(s[c.type]);
          }
        }

        self.initDataset();
        self.makeDraggable();
        self.initSelected(s.availableClass);
        self.initSelected(s.additionalClass);
      },

      unbind: function() {
        this.actionButtons.off('click.swaplist');
        this.containers.off('keydown.swaplist');
        this.selectedButtons.off('keydown.swaplist');
        this.element.off(this.dragStart+' '+this.dragEnterWhileDragging +' '+this.dragOverWhileDragging +' '+this.dragEnd, this.dragElements);

        $('#sl-placeholder-container, #sl-placeholder-touch, #sl-placeholder-touch2, #sl-placeholder').remove();
        return this;
      },

      updated: function() {
        return this
          .unbind()
          .init();
      },

      // Teardown
      destroy: function() {
        this.unbind();
        $.removeData(this.element[0], pluginName);
      }
    };

    // Initialize the plugin (Once)
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (instance) {
        instance.settings = $.extend({}, instance.settings, options);
        instance.updated();
      } else {
        instance = $.data(this, pluginName, new SwapList(this, settings));
      }
    });
  };


  $.fn.toast = function(options) {
    'use strict';

    // Settings and Options
    var pluginName = 'toast',
        defaults = {
          title: '(Title)',
          message: '(Content)',
          position: 'top right',  //top left, bottom left, bottom right (center??)
          audibleOnly: false,
          progressBar: true,
          timeout: 6000
        },
        settings = $.extend({}, defaults, options);

    /**
     * @constructor
     * @param {Object} element
     */
    function Toast(element) {
      this.element = $(element);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    // Toast Methods
    Toast.prototype = {

      init: function() {
        this.settings = settings;
        this.show();
      },

      // Show a Single Toast Message
      show: function() {
        var self = this,
          settings = self.settings,
          maxHideTime = parseFloat(settings.timeout),
          isPausePlay = false,
          percentage = 100,
          timer,
          container = $('#toast-container'),
          toast = $('<div class="toast"><span class="toast-title">'+ settings.title+
            '</span><span class="toast-message">'+ settings.message + '</span></div>'),
          closeBtn = $('<button type="button" class="btn-icon btn-close" title="'+ Locale.translate('Close')+
            '" aria-hidden="true">' + $.createIcon('close') + '<span class="audible"> '+ Locale.translate('Close')+'</span></button>'),
          progress = $('<div class="toast-progress"></div>');

        if (!container.length) {
          container = $('<div id="toast-container" class="toast-container" aria-relevant="additions" aria-live="polite"></div>').appendTo('body');
        }

        container.removeClass('toast-top-left toast-top-right toast-bottom-right toast-bottom-left')
          .addClass('toast-' + settings.position.replace(' ', '-'));

        settings.timeout = settings.audibleOnly ? 100 : settings.timeout;

        // Start timer
        timer = new $.fn.timer(function() {
          self.remove(toast);
        }, settings.timeout);

        if (settings.progressBar) {
          toast.append(progress);
        }

        $(timer.event).on('update', function(e, data) {
          percentage = ((maxHideTime - data.counter) / maxHideTime) * 100;

          if (Locale.isRTL()) {
            percentage = 100 - percentage;
          }

          if (settings.progressBar) {
            progress[0].style.width = percentage + '%';
          }
        });

        container.append(toast);
        toast.addClass((settings.audibleOnly ? 'audible' : 'effect-scale'));
        toast.append(closeBtn);

        $(document).on('keydown keyup', function(e) {
          e = e || window.event;
          if(e.ctrlKey && e.altKey && e.keyCode === 80) { //[Control + Alt + P] - Pause/Play toggle
            isPausePlay = e.type === 'keydown' ? true : false;
            timer[isPausePlay ? 'pause' : 'resume']();
          }
        });

        toast.on('mousedown.toast touchstart.toast mouseup.toast touchend.toast', function (e) {
          isPausePlay = /mousedown|touchstart/i.test(e.type) ? true : false;
          timer[isPausePlay ? 'pause' : 'resume']();
        });

        closeBtn.on('click', function () {
          timer.cancel();
          self.remove(toast);
        });
      },

      // Remove the Message and Animate
      remove: function (toast) {
        if (this.settings.audibleOnly) {
          toast.remove();
          return;
        }

        toast.addClass('effect-scale-hide');
        setTimeout(function () {
          toast.remove();
        }, 500);
      },

      // Teardown
      destroy: function() {
        $('#toast-container').remove();
        $.removeData(this.element[0], pluginName);
      }
    };

    // Initialize the plugin (Once)
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (instance) {
        instance.settings = $.extend({}, defaults, options);
        instance.show();
      } else {
        instance = $.data(this, pluginName, new Toast(this, settings));
      }
    });
  };


  $.fn.tabs = function(options) {

    // Tab Settings and Options
    var pluginName = 'tabs',
        defaults = {
          addTabButton: false, // If set to true, creates a button at the end of the tab list that can be used to add an empty tab and panel
          addTabButtonCallback: null, // if defined as a function, will be used in-place of the default Tab Adding method
          ajaxOptions: null, // if defined, will be used by any internal Tabs AJAX calls as the desired request settings.
          containerElement: null, // Defines a separate element to be used for containing the tab panels.  Defaults to a `.tab-panel-container` element that is created if it doesn't already exist.
          changeTabOnHashChange: false, // If true, will change the selected tab on invocation based on the URL that exists after the hash
          hashChangeCallback: null, // If defined as a function, provides an external method for adjusting the current page hash used by these tabs
          lazyLoad: true, // if true, when using full URLs in tab HREFs, or when using Ajax calls, tabs will be loaded as needed instead of the markup all being established at once.
          moduleTabsTooltips: false, // if true, will display a tooltip on Module Tabs with cut-off text content.
          source: null, // If defined, will serve as a way of pulling in external content to fill tabs.
          sourceArguments: {}, // If a source method is defined, this flexible object can be passed into the source method, and augmented with parameters specific to the implementation.
          tabCounts: false, // If true, Displays a modifiable count above each tab.
          verticalResponsive: false // If Vertical Tabs & true, will automatically switch to Horizontal Tabs on smaller breakpoints.
        },
        tabContainerTypes = ['horizontal', 'vertical', 'module-tabs', 'header-tabs'],
        settings = $.extend({}, defaults, options);

    /**
     * @constructor
     * @param {Object} element
     */
    function Tabs(element) {
      this.settings = $.extend({}, settings);
      this.element = $(element);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    // Actual Plugin Code
    Tabs.prototype = {

      init: function(){
        return this
          .setup()
          .build()
          .setupEvents();
      },

      setup: function() {
        // Used by the $(body).resize event to correctly identify the tabs container element
        this.tabsIndex = $('.tab-container').index(this.element);
        return this;
      },

      build: function() {
        var self = this,
          tabPanelContainer,
          moveTabPanelContainer = false;

        // Check for a tab panel container immediately after the `.tab-container` element (default as of Soho Xi 4.3.0)
        tabPanelContainer = this.element.next('.tab-panel-container');

        // Auto-detect and move existing tab-panel containers in key areas, if applicable.
        // Check inside the container first
        if (!tabPanelContainer.length) {
          tabPanelContainer = this.element.children('.tab-panel-container');

          if (!this.isVerticalTabs()) {
            moveTabPanelContainer = true;
          }
        }

        // Special case for Header Tabs, find the page container and use that as the container
        var bodyPageContainer = $('body > .page-container, .application-menu + .page-container');
        if (this.element.closest('.header').length > 0 && bodyPageContainer.length) {
          tabPanelContainer = bodyPageContainer;
        }

        // Special case for Module Tabs, where it's possible for layout reasons for there to be
        // an application menu element adjacent between the Tab list and the Tab Panel container
        if (this.element.next('.application-menu').length) {
          tabPanelContainer = this.element.next().next('.page-container');
          moveTabPanelContainer = false;
        }

        // Defining `this.settings.containerElement` ultimately overrides any internal changes to the tab panel container.
        if (this.settings.containerElement && $(this.settings.containerElement).length) {
          tabPanelContainer = $(this.settings.containerElement);
          moveTabPanelContainer = false;
        }

        // If a `.tab-panel-container` still doesn't exist, create one.
        if (!tabPanelContainer || !tabPanelContainer.length) {
          tabPanelContainer = $('<div class="tab-panel-container"></div>');
          moveTabPanelContainer = true;
        }

        if (!tabPanelContainer[0].classList.contains('tab-panel-container')) {
          tabPanelContainer[0].classList.add('tab-panel-container');
        }
        if (moveTabPanelContainer) {
          tabPanelContainer.insertAfter(this.element);
        }

        this.container = tabPanelContainer;

        // Detect the existence of a "tab-list-container" element, if applicable.
        // Tab List containers are optional for all tab container types, but mandatory for
        // Composite Form tabs.
        var tablistContainer = this.element.children('.tab-list-container');
        if (!tablistContainer.length && this.isScrollableTabs()) {
          tablistContainer = $('<div class="tab-list-container"></div>').prependTo(this.element);
        }
        if (tablistContainer.length) {
          this.tablistContainer = tablistContainer;
        }

        // Add a default tabs class of "horizontal" if it doesn't already exist
        var noClass = true,
          closestHeader = this.element.closest('.header');
        tabContainerTypes.forEach(function tabTypeIterator(val, i) {
          if (self.element.hasClass(tabContainerTypes[i])) {
            noClass = false;
          }
        });
        if (noClass) {
          if (closestHeader.length) {
            self.element.addClass('header-tabs');
          } else {
            self.element.addClass('horizontal');
          }
        }

        // Build Tab Counts
        if (self.settings.tabCounts) {
          self.element.addClass('has-counts');
        }

        //Attach Tablist role and class to the tab headers container
        this.tablist = this.element.children('.tab-list');
        if (!this.tablist.length) {

          // If we have a `.tab-list-container` element, check that before creating markup
          if (this.tablistContainer) {
            this.tablist = this.tablistContainer.children('.tab-list');
          }

          // Create and append the `.tab-list` if it still doesn't exist.
          if (!this.tablist.length) {
            this.tablist = $('<ul class="tab-list"></ul>');
            if (this.tablistContainer) {
              this.tablist.appendTo(this.tablistContainer);
            } else {
              this.tablist.appendTo(this.element);
            }
          }
        }

        // Double-check that the `.tab-list-container` actually contains the `.tab-list`.
        // Move it if necessary.
        if (this.tablistContainer) {
          if (!this.tablist.parent().is(this.tablistContainer)) {
            this.tablistContainer.append(this.tablist);
          }

          this.tablistContainer.on('mousewheel.tabs', function(e) {
            if (e.deltaY) {
              this.scrollLeft += e.deltaY;
            }
          });
        }

        self.tablist
          .attr({
            'class': 'tab-list',
            'role': 'tablist',
            'aria-multiselectable': 'false'
          });

        // Conditionally Change layout classes if veritcal tabs is in responsive mode, and breakpoints match
        this.checkResponsive();

        // Handle Focus State, Animated Bar, More Button, Add Tabs Button, and App Menu Button.
        this.renderHelperMarkup();

        //for each item in the tabsList...
        self.anchors = self.tablist.children('li:not(.separator)').children('a');
        self.anchors.each(function prepareAnchor() {
          var a = $(this);
          a.attr({'role': 'tab', 'aria-expanded': 'false', 'aria-selected': 'false', 'tabindex': '-1'})
           .parent().attr('role', 'presentation').addClass('tab');

          if (a.parent().hasClass('dismissible') && !a.parent().children('.icon').length) {
            $.createIconElement({ icon: 'close', classes: 'icon close' }).insertAfter(a);
          }

          // Find and configure dropdown tabs
          var dd = a.nextAll('ul').first();
          if (dd.length > 0) {
            dd.addClass('dropdown-tab');
            var li = a.parent();

            li.addClass('has-popupmenu').popupmenu({
              menu: dd,
              trigger: 'click',
              attachToBody: true
            });

            a.removeAttr('role').removeAttr('aria-expanded').removeAttr('aria-selected');

            if (!a.parent().children('.icon.icon-more').length) {
              $.createIconElement({ classes: 'icon-more', icon: 'dropdown' }).insertAfter(a);
            }
          }

          if (self.settings.tabCounts && $(this).find('.count').length === 0) {
            $(this).prepend('<span class="count">0 </span>');
          }

          // Make it possible for Module Tabs to display a tooltip containing their contents
          // if the contents are cut off by ellipsis.
          if (self.settings.moduleTabsTooltips) {
            a.on('beforeshow.toolbar', function() {
              return a.data('cutoffTitle') === 'yes';
            }).tooltip({
              content: '' + a.text().trim()
            });
          }
        });

        // Build/manage tab panels
        function associateAnchorWithPanel() {
          var a = $(this),
            li = a.parent(),
            popup = li.data('popupmenu'),
            panel;

          // Associated the current one
          var href = a.attr('href');

          if (href.substr(0, 1) !== '#') {
            //is an outbound Link
            return;
          }

          if (href !== undefined && href !== '#') {
            panel = $(href);

            if (li.is(':not(.has-popupmenu)') && !panel.length) {
              return;
            }

            a.data('panel-link', panel);
            panel.data('tab-link', a);
            self.panels = self.panels.add(panel);
          }

          // If dropdown tab, add the contents of the dropdown
          // NOTE: dropdown tabs shouldn't have children, so they aren't accounted for here
          if (popup) {
            popup.menu.children('li').each(function() {
              var li = $(this),
                a = li.children('a'),
                href = a.attr('href'),
                panel = $(href);

              a.data('panel-link', panel);
              panel.data('tab-link', a);

              self.panels = self.panels.add(panel);
              self.anchors = self.anchors.add(a);

              if (!li.hasClass('dismissible')) {
                return;
              }

              var icon = li.children('.icon');
              if (!icon.length) {
                icon = $.createIconElement({icon: 'close', classes: 'icon close'});
              }
              icon.detach().appendTo(a);

            }).on('click.popupmenu', '.icon', function iconClickHandler(e) {
              var icon = $(this),
                li = icon.closest('li');

              if (li.is('.dismissible') && icon.is('.icon')) {
                e.preventDefault();
                e.stopPropagation();
                self.closeDismissibleTab(li.children('a').attr('href'));
              }
            });
          }
        }

        self.panels = $();
        self.anchors.each(associateAnchorWithPanel);
        self.panels
          .addClass('tab-panel')
          .attr({'role': 'tabpanel'})
          .find('h3:first').attr('tabindex', '0');

        self.panels.appendTo(self.container);

        var excludes = ':not(.separator):not(.is-disabled):not(.is-hidden)',
          tabs = this.tablist.children('li' + excludes),
          selected = this.tablist.children('li.is-selected' + excludes),
          selectedAnchor = selected.children('a');

        // Setup a hash for nested tab controls
        self.nestedTabControls = self.panels.find('.tab-container');

        if (tabs.length) {
          // If the hashChange setting is on, change the selected tab to the one referenced by the hash
          if (this.settings.changeTabOnHashChange) {
            var hash = window.location.hash;
            if (hash && hash.length) {
              var matchingTabs = tabs.find('a[href="'+ hash +'"]');
              if (matchingTabs.length) {
                selected = matchingTabs.first().parent();
                selectedAnchor = selected.children('a');
              }
            }
          }

          // If there is no selected tab, try to find the first available tab (if there are any present)
          if (!selected.length) {
            selected = tabs.not('.add-tab-button, .application-menu-trigger').first();
            selectedAnchor = selected.children('a');
          }

          // If there are tabs present, activate the first one
          if (selected.length) {
            this.activate(selectedAnchor.attr('href'));
          }
        }

        if (this.isModuleTabs() && this.element.children('.toolbar').length) {
          this.element.addClass('has-toolbar');
        }

        this.setOverflow();

        if (this.hasSquareFocusState()) {
          this.positionFocusState(selectedAnchor);
        }

        if (this.hasAnimatedBar()) {
          this.animatedBar.addClass('no-transition');
          this.focusBar(undefined, function transitionRemover() {
            setTimeout(function() {
              self.animatedBar.removeClass('no-transition');
            }, 0);
          });
        }

        // Setup Edge Fades
        if (this.tablistContainer) {
          this.tablistContainer.on('scroll.tabs', function() {
            self.renderEdgeFading();
          });
          this.renderEdgeFading();
        }

        return this;
      },

      /**
       * Adds/removes helper buttons and accessibility-centric markup, based on Tabs' configuration
       * Designed to be run at any point in the Tabs lifecycle.
       * @returns {this}
       */
      renderHelperMarkup: function() {
        var auxilaryButtonLocation = this.tablistContainer || this.tablist;
        if (this.isModuleTabs()) {
          auxilaryButtonLocation = this.tablist;
        }

        // Square Focus State
        if (this.hasSquareFocusState()) {
          this.focusState = this.element.find('.tab-focus-indicator');
          if (!this.focusState.length) {
            this.focusState = $('<div class="tab-focus-indicator" role="presentation"></div>').insertBefore(this.tablist);
          }
        } else {
          if (this.focusState && this.focusState.length) {
            this.focusState.off().remove();
            this.focusState = undefined;
          }
        }

        // Animated Bar
        if (this.hasAnimatedBar()) {
          this.animatedBar = this.element.find('.animated-bar');
          if (!this.animatedBar.length) {
            this.animatedBar = $('<div class="animated-bar" role="presentation"></div>');
          }
          this.animatedBar.insertBefore(this.tablist);
        } else {
          if (this.animatedBar && this.animatedBar.length) {
            this.animatedBar.off().remove();
            this.animatedBar = undefined;
          }
        }

        // Add the markup for the "More" button if it doesn't exist.
        if (!this.moreButton) {
          this.moreButton = $();
        }

        if (!this.isVerticalTabs()) {
          if (!this.moreButton.length) {
            this.moreButton = auxilaryButtonLocation.next('.tab-more');
          }
          // If we still don't have a More Button, create one
          if (!this.moreButton.length) {
            this.moreButton = $('<div>').attr({'class': 'tab-more'});
            this.moreButton.append( $('<span class="more-text">').text(Locale.translate('More')));
            this.moreButton.append($.createIconElement({ classes: 'icon-more', icon: 'dropdown' }));
          }

          // Append in the right place based on configuration
          auxilaryButtonLocation.after(this.moreButton);
        } else {
          if (this.moreButton.length) {
            this.moreButton.off().remove();
            this.moreButton = $();
          }
        }

        // Add the application menu Module Tab, if applicable
        var appMenuTrigger = this.tablist.find('.application-menu-trigger');
        if (this.isModuleTabs()) {
          if (!appMenuTrigger.length) {
            appMenuTrigger = $('<li class="tab application-menu-trigger"><a href="#">' +
              '<span class="icon app-header"><span class="one"></span><span class="two"></span><span class="three"></span></span>' +
              '<span>Menu</span>' +
              '</a></tab>');
            this.tablist.prepend(appMenuTrigger);
          }
        } else {
          if (this.isVerticalTabs() && appMenuTrigger.length) {
            appMenuTrigger.off().remove();
          }
        }

        // Add Tab Button
        if (this.settings.addTabButton) {
          if (!this.addTabButton || !this.addTabButton.length) {
            this.addTabButton = $('<div class="add-tab-button" tabindex="0" role="button">' +
              '<span aria-hidden="true" role="presentation">+</span>' +
              '<span class="audible">'+ Locale.translate('AddNewTab') +'</span>' +
              '</div>');
            this.addTabButton.insertAfter(this.moreButton);
            this.element.addClass('has-add-button');
          }
        } else {
          if (this.addTabButton && this.addTabButton.length) {
            this.addTabButton.remove();
            this.addTabButton = undefined;
            this.element.removeClass('has-add-button');
          }
        }

        return this;
      },

      setupEvents: function() {
        var self = this;

        // Set animation bar if tabs under modal
        var modal = self.element.closest('.modal');
        if (modal.length) {
          modal.on('afteropen', function () {
            if (self.hasAnimatedBar()) {
              self.focusBar();
            }
          });
        }

        // Clicking the 'a' triggers the click on the 'li'
        function routeAnchorClick(e) {
          var a = $(e.currentTarget);

          if (this.wasTapped === true) {
            this.wasTapped = false;
            return;
          }

          if (e.type === 'touchend') {
            this.wasTapped = true;
          }

          if (a.attr('href').substr(0, 1) !== '#') {
            //is an outbound Link
            return;
          }
          e.preventDefault();
        }

        // Some tabs have icons that can be clicked and manipulated
        function handleIconClick(e) {
          var elem = $(this);
          if (elem.is('[disabled]') || elem.parent().hasClass('is-disabled')) {
            return;
          }

          var li = $(elem).parent();

          if (li.hasClass('dismissible')) {
            e.preventDefault();
            e.stopPropagation();
            self.closeDismissibleTab(li.children('a').attr('href'));
          }
        }

        function handleTabBlur() {
          $(this).parent().removeClass('is-focused');
        }

        // Any events bound to individual tabs (li) and their anchors (a) are bound to the tablist
        // element so that tabs can be added/removed/hidden/shown without needing to change event bindings.
        this.tablist
          .on('mousedown.tabs', '> li', function(e) {
            self.handleAddFocusData(e, $(this));

            // let right click pass through
            if (e.which !== 3) {
              return self.handleTabClick(e, $(this));
            }
          })
          .on('click.tabs', 'a', routeAnchorClick)
          .on('click.tabs', '.icon', handleIconClick)
          .on('focus.tabs', 'a', function(e) {
            return self.handleTabFocus(e, $(this));
          })
          .on('blur.tabs', 'a', handleTabBlur)
          .on('keydown.tabs', 'a', function(e) {
            return self.handleTabKeyDown(e);
          });

        // Setup events on Dropdown Tabs
        function dropdownTabEvents(i, tab) {
          var li = $(tab),
            a = li.children('a'),
            menu = li.data('popupmenu').menu;

          // Alt+Del or Alt+Backspace closes a dropdown tab item
          function closeDropdownMenuItem(e) {
            if (!e.altKey || !li.is('.dismissible')) {
              return;
            }

            self.closeDismissibleTab(a.attr('href'));
            return;
          }

          menu.on('keydown.popupmenu', 'a', function(e) {
            switch(e.which) {
              case 27: // escape
                li.addClass('is-selected');
                a.focus();
                break;
              case 8: // backspace (delete on Mac)
                closeDropdownMenuItem(e);
                break;
              case 46: // The actual delete key
                closeDropdownMenuItem(e);
                break;
            }
          });

          li.on('selected.tabs', function(e, anchor) {
            var li = $(this),
              href = $(anchor).attr('href');
            self.activate(href);

            if (self.hasSquareFocusState()) {
              self.positionFocusState(a);
            }

            if (self.hasAnimatedBar()) {
              self.focusBar(li);
            }

            a.focus();
            self.scrollTabList(li);

            li.addClass('is-selected');
            return false;
          });
        }

        var ddTabs = self.tablist.find('li').filter('.has-popupmenu');
        ddTabs.each(dropdownTabEvents);

        function dismissibleTabEvents(i, tab) {
          var li = $(tab),
            a = li.children('a');

          a.on('keydown.tabs', function(e) {
            self.handleDismissibleTabKeydown(e);
          });
        }

        var dismissible = self.tablist.find('li').filter('.dismissible');
        dismissible.each(dismissibleTabEvents);

        // Events specific to markup that can be re-rendered mid-lifecycle
        // The responsive vertical tabs system will set this up automatically, so skip
        if (!this.isResponsiveVerticalTabs()) {
          this.setupHelperMarkupEvents();
        }

        this.panels.on('keydown.tabs', function(e) {
          self.handlePanelKeydown(e);
        });

        // Check whether or not all of the tabs + more button are de-focused.
        // If true, the focus-state and animated bar need to revert positions
        // back to the currently selected tab.
        this.element.on('focusout.tabs', function allTabsFocusOut() {
          var noFocusedTabs = !$.contains(self.element[0], document.activeElement),
            noPopupMenusOpen = self.tablist.children('.has-popupmenu.is-open').length === 0;

          if (noFocusedTabs && noPopupMenusOpen && !self.moreButton.is('.is-selected, .popup-is-open')) {
            self.hideFocusState();
          }
        }).on('updated.tabs', function() {
          self.updated();
        }).on('activated.tabs', function(e) {
          // Stop propagation of the activate event from going higher up into the DOM tree
          e.stopPropagation();
        }).on('add.tabs', function(e, newTabId, newTabOptions, newTabIndex) {
          self.add(newTabId, newTabOptions, newTabIndex);
        }).on('remove.tabs', function(e, tabId) {
          self.remove(tabId);
        });

        // Check to see if we need to add/remove the more button on resize
        $('body').on('resize.tabs' + this.tabsIndex, function() {
          self.handleResize();
        });
        self.handleResize(true);

        return this;
      },

      /**
       * Adds events associated with elements that are re-renderable during the Tabs lifecycle
       * @private
       * @returns {this}
       */
      setupHelperMarkupEvents: function () {
        var self = this;

        // Setup the "more" function
        this.moreButton
          .onTouchClick('tabs')
          .on('click.tabs', function(e) {
            self.handleMoreButtonClick(e);
          })
          .on('keydown.tabs', function(e) {
            self.handleMoreButtonKeydown(e);
          })
          .on('focus.tabs', function(e) {
            self.handleMoreButtonFocus(e);
          })
          .on('mousedown.tabs', function(e) {
            self.handleAddFocusData(e, $(this));
          });

        if (this.settings.addTabButton) {
          this.addTabButton
            .onTouchClick('tabs')
            .on('click.tabs', function() {
              self.handleAddButton();
            })
            .on('keydown.tabs', function(e) {
              self.handleAddButtonKeydown(e);
            })
            .on('focus.tabs', function(e) {
              self.handleAddButtonFocus(e);
            });
        }
      },

      /**
       * Removes events associated with elements that are re-renderable during the Tabs lifecycle
       * @private
       * @returns {this}
       */
      removeHelperMarkupEvents: function() {
        if (this.moreButton && this.moreButton.length) {
          this.moreButton.offTouchClick('tabs')
            .off('click.tabs keydown.tabs focus.tabs mousedown.tabs');
        }

        if (this.addTabButton && this.addTabButton.length) {
          this.addTabButton.offTouchClick('tabs')
            .off('click.tabs keydown.tabs focus.tabs');
        }

        return this;
      },

      /**
       * Setup a mousedown event on tabs to determine in the focus handler whether or a not a keystroked cause
       * a change in focus, or a click.  Keystroke focus changes cause different visual situations
       * @param {$.Event} e
       * @param {jQuery[]} elem
       * @returns {undefined}
       */
      handleAddFocusData: function(e, elem) {
        var tab = elem;
        if (tab.is('.is-disabled')) {
          e.preventDefault();
          return false;
        }

        if (!tab.is(this.moreButton)) {
          tab = tab.children('a');
        }

        this.hideFocusState();
        tab.data('focused-by-click', true);
      },

      handleTabClick: function(e, li) {
        if (this.element.is('.is-disabled') || (li && (li.is('.is-disabled') || li.is('.separator')))) {
          e.stopPropagation();
          e.preventDefault();
          return false;
        }

        var appMenuResult = this.handleAppMenuTabKeydown(e);
        if (!appMenuResult) {
          return;
        }

        var a = li.children('a');
        a.data('focused-by-click', true);

        if (this.popupmenu && this.popupmenu.element.hasClass('is-open')) {
          this.popupmenu.close();
        }

        // Don't activate a dropdown tab.  Clicking triggers the Popupmenu Control attached.
        if (li.is('.has-popupmenu')) {
          this.positionFocusState(a);
          return;
        }

        var href = a.attr('href');

        if (li.is('.add-tab-button')) {
          a = this.handleAddButton();
          li = a.parent();
          href = a.attr('href');
          this.element.trigger('tab-added', [a]);
        }

        // close tab on middle click
        if (e.which === 2) {
          if (li.is('.dismissible') && $(e.target).is('.close')) {
            this.closeDismissibleTab(href);
          }
          e.preventDefault();
          return;
        }

        this.activate(href);
        this.changeHash(href);

        if (this.hasSquareFocusState()) {
          this.focusState.removeClass('is-visible');
        }

        a.focus();

        if (this.isScrollableTabs()) {
          this.scrollTabList(li);
        }

        // Hide these states
        this.focusBar(li);
        this.positionFocusState(a);

        if (this.settings.lazyLoad === true && this.isURL(href)) {
          return false;
        }
      },

      handleMoreButtonClick: function(e) {
        if (this.element.is('.is-disabled') || this.moreButton.is('.is-disabled')) {
          e.preventDefault();
          e.stopPropagation();
          return false;
        }

        this.moreButton.data('focused-by-click', true);

        if (!(this.container.hasClass('has-more-button'))) {
          e.stopPropagation();
        }
        if (this.moreButton.hasClass('popup-is-open')) {
          this.popupmenu.close();
          this.moreButton.removeClass('popup-is-open');
        } else {
          this.buildPopupMenu();
        }

        this.hideFocusState();
      },

      handleTabFocus: function(e, a) {
        if (this.element.is('.is-disabled')) {
          e.preventDefault();
          return false;
        }

        var li = a.parent(),
          dataFocusedClick = a.data('focused-by-click'),
          focusedByKeyboard = dataFocusedClick === undefined || (dataFocusedClick && dataFocusedClick === false);

        $.removeData(a[0], 'focused-by-click');

        if (this.isTabOverflowed(li)) {
          this.buildPopupMenu(a.attr('href'));
          this.moreButton.addClass('is-focused');
          this.positionFocusState(this.moreButton);
        } else {
          li.addClass('is-focused');
          this.positionFocusState(a, focusedByKeyboard);
        }
      },

      handleMoreButtonFocus: function(e) {
        if (this.element.is('.is-disabled')) {
          e.preventDefault();
          return;
        }

        var dataFocusedClick = this.moreButton.data('focused-by-click'),
          focusedByKeyboard = (dataFocusedClick && dataFocusedClick === false);

        $.removeData(this.moreButton[0], 'focused-by-click');

        if (this.hasSquareFocusState()) {
          this.focusState.removeClass('is-visible');
          this.positionFocusState(this.moreButton, focusedByKeyboard);
        }
      },

      handleTabKeyDown: function(e) {
        if (this.element.is('.is-disabled')) {
          e.preventDefault();
          return false;
        }

        if (e.shiftKey || e.ctrlKey || e.metaKey || (e.altKey && e.which !== 8)) {
          return;
        }

        var self = this,
          passableKeys = [8, 13, 32];

        function isPassableKey() {
          return $.inArray(e.which, passableKeys) > -1;
        }

        if ((e.which < 32 && !isPassableKey()) || e.which > 46) {
          return;
        }

        if (isPassableKey()) {
          var appMenuResult = this.handleAppMenuTabKeydown(e);
          if (!appMenuResult) {
            return;
          }
        }

        function openMenu(oldHref) {
          e.preventDefault();
          // setTimeout is used to bypass triggering of the keyboard when self.buildPopupMenu() is invoked.
          setTimeout(function() {
            self.buildPopupMenu(oldHref);
          }, 0);
        }

        var allExcludes = ':not(.separator):not(.is-disabled):not(:hidden)',
          currentLi = $(e.currentTarget).parent(),
          currentA = currentLi.children('a'),
          targetLi,
          tabs = self.tablist.children('li' + allExcludes),
          isRTL = Locale.isRTL();

        function previousTab() {
          var i = tabs.index(currentLi) - 1;
          while (i > -1 && !targetLi) {
            if (tabs.eq(i).is(allExcludes)) {
              return tabs.eq(i);
            }
            i = i - 1;
          }

          if (self.settings.addTabButton) {
            return self.addTabButton;
          }

          var last = self.tablist.children('li' + allExcludes).last();

          if (self.hasMoreButton() && self.isScrollableTabs()) {
            openMenu(last.find('a').attr('href'));
          }

          return last;
        }

        function nextTab() {
          var i = tabs.index(currentLi) + 1;
          while(i < tabs.length && !targetLi) {
            if (tabs.eq(i).is(allExcludes)) {
              return tabs.eq(i);
            }
            i++;
          }

          var first = self.tablist.children('li' + allExcludes).first();

          if (self.hasMoreButton() && self.isScrollableTabs()) {
            openMenu(first.find('a').attr('href'));
            return first;
          }

          if (self.settings.addTabButton) {
            return self.addTabButton;
          }
          return first;
        }

        function checkAngularClick() {
          if (currentA.attr('ng-click') || currentA.attr('data-ng-click')) { // Needed to fire the "Click" event in Angular situations
            currentA.click();
          }
        }

        function activate() {
          if (currentLi.hasClass('has-popupmenu')) {
            currentLi.data('popupmenu').open();
            return;
          }

          var href = currentA.attr('href');

          if (currentLi.is('.add-tab-button')) {
            currentA = self.handleAddButton();
            currentLi = currentA.parent();
            href = currentA.attr('href');
            self.element.trigger('tab-added', [currentA]);
          }

          self.activate(href);
          self.changeHash(href);
          self.focusBar(currentLi);
          checkAngularClick();
          currentA[0].focus();
          self.hideFocusState();

          // In the event that the activated tab is a full link that should be followed,
          // the keystroke events need to manually activate the link change.  Clicks are handled
          // automatically by the browser.
          self.handleOutboundLink(href);
        }

        switch(e.which) {
          case 8:
            if (e.altKey && currentLi.is('.dismissible')) {
              e.preventDefault();
              self.closeDismissibleTab(currentA.attr('href'));
            }
            return;
          case 13: // Enter
            activate();
            return false;
          case 32: // Spacebar
            activate();
            return false;
          case 38:
            targetLi = previousTab();
            e.preventDefault(); // jshint ignore:line
            break;
          case 37:
            targetLi = isRTL ? nextTab() : previousTab();
            e.preventDefault();
            break;
          case 40:
            targetLi = nextTab();
            e.preventDefault(); // jshint ignore:line
            break;
          case 39:
            targetLi = isRTL ? previousTab() : nextTab();
            e.preventDefault();
            break;
        }

        var isAddTabButton = targetLi.is('.add-tab-button'),
          focusStateTarget = isAddTabButton ? targetLi : targetLi.children('a');

        // Use the matching option in the popup menu if the target is hidden by overflow.
        if (this.isTabOverflowed(targetLi)) {
          return openMenu(targetLi.children('a').attr('href'));
        }

        if (!isAddTabButton) {
          focusStateTarget.focus();
        } else {
          self.addTabButton.focus();
        }

        if (this.isScrollableTabs()) {
          this.scrollTabList(focusStateTarget);
        }

        if (self.hasSquareFocusState()) {
          self.positionFocusState(focusStateTarget, true);
        }
      },

      handleDismissibleTabKeydown: function(e) {
        var key = e.which,
          tab = $(e.target);

        if (tab.is('a')) {
          tab = tab.parent();
        }

        if (e.altKey && key === 46) { // Alt + Del
          if (tab.children('a').is('[disabled]') || tab.hasClass('is-disabled')) {
            return;
          }

          e.preventDefault();
          this.closeDismissibleTab(tab.children('a').attr('href'));
        }
      },

      handleAppMenuTabKeydown: function(e) {
        var target = $(e.target),
          li = target.parent();

        if (!(li.is('.application-menu-trigger') || target.is('.application-menu-trigger'))) {
          return true;
        }

        // If the tab is an application-menu trigger, open the app menu
        // Used by Module Tabs
        var menu = $('#application-menu');
        if (!menu.length) {
          return false;
        }

        e.preventDefault();

        this.hideFocusState();

        if (menu.hasClass('is-open')) {
          menu.trigger('close-applicationmenu');
          return false;
        }

        menu.trigger('open-applicationmenu');
        return false;
      },

      handleMoreButtonKeydown: function(e) {
        if (this.element.is('.is-disabled')) {
          e.preventDefault();
          return false;
        }

        var self = this,
          isRTL = Locale.isRTL();

        function openMenu() {
          e.preventDefault();
          self.buildPopupMenu(self.tablist.find('.is-selected').children('a').attr('href'));
          self.positionFocusState(self.moreButton, true);
        }

        function lastTab() {
          e.preventDefault();
          self.findLastVisibleTab();
        }

        switch(e.which) {
          case 37: // left
            if (isRTL) {
              openMenu();
              break;
            }
            lastTab();
            break;
          case 38: // up
            lastTab();
            break;
          case 13: // enter
          case 32: // spacebar
            e.preventDefault(); //jshint ignore:line
          case 39: // right
            if (isRTL) {
              lastTab();
              break;
            }
            openMenu();
            break;
          case 40: // down
            openMenu();
            break;
        }
      },

      handlePanelKeydown: function(e) {
        var key = e.which,
          panel = $(e.target),
          a = this.anchors.filter('#' + panel.attr('id')),
          tab = this.anchors.filter('#' + panel.attr('id')).parent();

        if (tab.is('.dismissible')) {
          // Close a Dismissible Tab
          if (e.altKey && key === 46) { // Alt + Delete
            e.preventDefault();
            return this.closeDismissibleTab(a.attr('href'));
          }
        }

        // Takes focus away from elements inside a Tab Panel and brings focus to its corresponding Tab
        if ((e.ctrlKey && key === 38) && $.contains(document.activeElement, panel[0])) { // Ctrl + Up Arrow
          e.preventDefault();
          return this.activate(a.attr('href'));
        }
      },

      handleAddButton: function() {
        var cb = this.settings.addTabButtonCallback;
        if (cb && typeof cb === 'function') {
          var newTabId = cb();
          return this.anchors.filter('[href="#'+ newTabId +'"]');
        }

        function makeId() {
          var stringName = 'new-tab',
            existing = $('[id^="'+ stringName +'"]');

          if (!existing.length) {
            return stringName + '-0';
          }
          return stringName + '-' + existing.length;
        }

        function makeName(id) {
          var nameParts = id.toString().split('-');
          nameParts.forEach(function(val, i) {
            nameParts[i] = val.charAt(0).toUpperCase() + val.slice(1);
          });

          return nameParts.join(' ');
        }

        var newIndex = this.tablist.children().index(this.addTabButton),
          newId = makeId(),
          newName = makeName(newId),
          settings = {
            name: newName,
            content: '&nbsp;',
            isDismissible: true
          };

        if (newIndex < 0) {
          newIndex = this.tablist.find('li:not(.separator)').length;
        }

        // Allow the opportunity to pass in external settings for the new tab control
        var externalSettings = this.element.triggerHandler('before-tab-added', [newId, settings, newIndex]);
        if (!externalSettings) {
          this.add(newId, settings, newIndex);
          return this.anchors.filter('[href="#'+ newId +'"]');
        }

        if (externalSettings.newId && externalSettings.newId.length && typeof externalSettings.newId === 'string') {
          newId = externalSettings.newId;
        }
        if (externalSettings.settings && typeof externalSettings.settings === 'object') {
          settings = externalSettings.settings;
        }
        if (!isNaN(externalSettings.newIndex)) {
          newIndex = externalSettings.newIndex;
        }

        this.add(newId, settings, newIndex);
        return this.anchors.filter('[href="#'+ newId +'"]');
      },

      handleAddButtonKeydown: function(e) {
        if (this.element.is('.is-disabled')) {
          e.preventDefault();
          return false;
        }

        var self = this,
          isRTL = Locale.isRTL(),
          targetLi,
          filter = 'li:not(.separator):not(.is-disabled):not(:hidden)';

        function openMenu() {
          e.preventDefault();
          targetLi = self.tablist.find(filter).last();

          if (self.isTabOverflowed(targetLi)) {
            // Open the spillover
            self.buildPopupMenu(targetLi.children('a').attr('href'));
            self.positionFocusState(self.moreButton, true);
            return;
          }
        }

        function firstTab() {
          targetLi = self.tablist.find(filter).first();
        }

        switch(e.which) {
          case 37: // left
            if (isRTL) {
              firstTab();
              break;
            }
            openMenu();
            break;
          case 38: // up
            openMenu();
            break;
          case 13: // enter
          case 32: // spacebar
            e.preventDefault(); //jshint ignore:line
            return this.handleAddButton();
          case 39: // right
            if (isRTL) {
              openMenu();
              break;
            }
            firstTab();
            break;
          case 40: // down
            firstTab();
            break;
          default:
            return;
        }

        targetLi.children('a').focus();
      },

      handleAddButtonFocus: function() {
        var tabs = this.tablist.find('li:not(.separator)');
        tabs.add(this.moreButton).removeClass('is-focused');

        this.addTabButton.addClass('is-focused');
        this.positionFocusState(this.addTabButton, true);
      },

      handleResize: function(ignoreResponsiveCheck) {
        if (!ignoreResponsiveCheck) {
          this.checkResponsive();
        }

        this.setOverflow();

        var selected = this.tablist.find('.is-selected');
        if (!selected.length || this.moreButton.is('.is-selected') || this.isTabOverflowed(selected)) {
          selected = this.moreButton;
        }

        if (!selected.length) {
          this.defocusBar();
          this.hideFocusState();
        } else {
          this.focusBar(selected);
          this.positionFocusState(selected);
        }

        this.handleVerticalTabResize();
        this.renderVisiblePanel();
        this.renderEdgeFading();
      },

      checkResponsive: function() {
        var self = this,
          classList = self.element[0].classList;

        function rebuild() {
          self.removeHelperMarkupEvents();
          self.renderHelperMarkup();
          self.setupHelperMarkupEvents();
        }

        function makeResponsive() {
          if (!classList.contains('is-in-responsive-mode')) {
            classList.add('is-in-responsive-mode');
            classList.add('header-tabs');
            classList.add('alternate');
            classList.remove('vertical');
            rebuild();
          }
        }

        function makeVertical() {
          if (classList.contains('is-in-responsive-mode')) {
            classList.add('vertical');
            classList.remove('is-in-responsive-mode');
            classList.remove('header-tabs');
            classList.remove('alternate');
            rebuild();
          }
        }

        // Check for responsive mode for Vertical tabs
        if (this.isResponsiveVerticalTabs()) {
          if (Soho.breakpoints.isBelow('phone-to-tablet')) {
            makeResponsive();
          } else {
            makeVertical();
          }
        } else {
          makeVertical();
        }
      },

      handleVerticalTabResize: function() {
        if (!this.isVerticalTabs()) {
          return;
        }

        // When tabs are full-size (part of a layout) CSS rules should handle this better
        // due to less strange sizing constraints.  JS resizing is necessary for nesting.
        if (!this.isNested() || this.isNestedInLayoutTabs() || this.isHidden()) {
          return;
        }

        var elemStyle = window.getComputedStyle(this.element[0]),
          elemOuterHeight = elemStyle.getPropertyValue('height') + elemStyle.getPropertyValue('margin-top') + elemStyle.getPropertyValue('margin-bottom');

        this.tablist[0].style.height = elemOuterHeight;
      },

      // Changes the location in the browser address bar to force outbound links.
      handleOutboundLink: function(href, useRelativePath) {
        if (href.charAt(0) === '#') {
          return false;
        }

        if (href.charAt(0) === '/' && (!useRelativePath || useRelativePath === false)) {
          href = window.location.origin + href;
        }

        window.location = href;
      },

      hasAnimatedBar: function() {
        return !this.isModuleTabs() && !this.isVerticalTabs();
      },

      hasSquareFocusState: function() {
        return true;
      },

      hasMoreButton: function() {
        return this.element[0].classList.contains('has-more-button');
      },

      isInResponsiveMode: function() {
        return this.element[0].classList.contains('is-in-responsive-mode');
      },

      isModuleTabs: function() {
        return this.element.hasClass('module-tabs');
      },

      isVerticalTabs: function() {
        return this.element.hasClass('vertical');
      },

      isResponsiveVerticalTabs: function() {
        return this.settings.verticalResponsive === true;
      },

      isHeaderTabs: function() {
        return this.element.hasClass('header-tabs');
      },

      isScrollableTabs: function() {
        return !this.isModuleTabs() && !this.isVerticalTabs();
      },

      isHidden: function() {
        return this.element.is(':hidden');
      },

      isNested: function() {
        return this.element.closest('.tab-panel').length;
      },

      isActive: function(href) {
        if (!href || !href.length || (href.length === 1 && href.indexOf('#') < 1)) {
          return false;
        }

        var panel = this.getPanel(href);
        return panel[0].classList.contains('can-show');
      },

      isNestedInLayoutTabs: function() {
        var nestedInModuleTabs = this.element.closest('.module-tabs').length,
          nestedInHeaderTabs = this.element.closest('.header-tabs').length,
          hasTabContainerClass = this.element.closest('.tab-panel-container').length;

        return (nestedInModuleTabs > 0 || nestedInHeaderTabs > 0 || hasTabContainerClass > 0);
      },

      isTab: function(obj) {
        return obj instanceof jQuery && obj.length && obj.is('li.tab');
      },

      isAnchor: function(obj) {
        return obj instanceof jQuery && obj.length && obj.is('a');
      },

      getAnchor: function(href) {
        if (this.isAnchor(href)) {
          return href;
        }

        if (href.indexOf('#') === -1 && href.charAt(0) !== '/') {
          href = '#' + href;
        }
        return this.anchors.filter('[href="' + href + '"]');
      },

      getPanel: function(href) {
        if (this.isTab(href)) {
          href = href.children('a');
        }

        if (this.isAnchor(href)) {
          href = href.attr('href');
        }

        if (!href || href === '' || href === '#') {
          return $();
        }

        return this.panels.filter('[id="' + href.replace(/#/g, '') + '"]');
      },

      getMenuItem: function(href) {
        if (this.isAnchor(href)) {
          href = href.attr('href');
        }

        if (href.indexOf('#') === -1) {
          href = '#' + href;
        }
        return this.moreMenu.children().children().filter('[data-href="'+ href +'"]').parent();
      },

      // Takes a tab ID and returns a jquery object containing the previous available tab
      getPreviousTab: function(tabId) {
        var tab = this.getTab(null, tabId),
          filter = 'li:not(.separator):not(:hidden):not(.is-disabled)',
          tabs = this.tablist.find(filter),
          target = tabs.eq(tabs.index(tab) - 1);

        while(target.length && !target.is(filter)) {
          target = tabs.eq(tabs.index(target) - 1);
        }

        // Top-level Dropdown Tabs don't have an actual panel associated with them.
        // Get a Dropdown Tab's first child as the target.
        if (target.is('.has-popupmenu')) {
          var menuAPI = target.data('popupmenu');
          if (menuAPI) {
            target = menuAPI.menu.children('li').first();
          }
        }

        return target;
      },

      // Takes a tab ID and returns a jquery object containing the previous available tab
      // If an optional target Tab (li) is provided, use this to perform activation events
      activatePreviousTab: function(tabId, target) {
        var tab = this.getTab(null, tabId);

        if (!target || !(target instanceof jQuery)) {
          target = this.getPreviousTab(tabId);
        }

        if (!target.length) {
          this.hideFocusState();
          this.defocusBar();
          return target;
        }

        var a = target.children('a');
        if (tab.is('.is-selected')) {
          this.activate(a.attr('href'));
          a.focus();
        }
        this.positionFocusState(a);
        this.focusBar(target);

        return target;
      },

      isURL: function(href) {
        if (!href || href.indexOf('#') === 0) {
          return false;
        }

        return true;
      },

      activate: function(href) {
        var self = this,
          a, targetTab, targetPanel, targetPanelElem, oldTab, oldPanel,
          selectedStateTarget,
          activeStateTarget;

        if (self.isURL(href)) {
          return this.callSource(href, true);
        }

        a = self.getAnchor(href);
        targetTab = a.parent();
        targetPanel = self.getPanel(href);
        targetPanelElem = targetPanel[0];
        oldTab = self.anchors.parents().filter('.is-selected');

        // Avoid filter(:visible)
        for (var i = 0; i < self.panels.length; i++) {
          if (self.panels[i].classList.contains('is-visible')) {
            oldPanel = $(self.panels[i]);
          }
        }

        if (!oldPanel) {
          oldPanel = self.panels;
        }

        var isCancelled = self.element.trigger('beforeactivate', [a]);
        if (!isCancelled) {
          return;
        }

        if (targetPanel.length < 1) {
          if (this.settings.source) {
            return this.callSource(href);
          }
        } else {
          oldPanel[0].classList.remove('can-show');
          oldPanel[0].classList.remove('is-visible');
          oldPanel.closeChildren();
          self.element.trigger('activated', [a]);

          targetPanelElem.classList.add('can-show');
          self.renderVisiblePanel();
          // trigger reflow as display property is none for animation
          targetPanelElem.offsetHeight; // jshint ignore:line

          targetPanel.one($.fn.transitionEndName() + '.tabs', function() {
            self.element.trigger('afteractivated', [a]);
          });

          // Triggers the CSS Animation
          targetPanelElem.classList.add('is-visible');
        }

        // Update the currently-selected tab
        self.updateAria(a);
        oldTab.add(this.moreButton).removeClass('is-selected');

        if (targetTab[0].classList.contains('tab')) {
          selectedStateTarget = targetTab;
          activeStateTarget = targetTab;
        }

        var ddMenu = targetTab.parents('.popupmenu'),
          ddTab;

        if (ddMenu.length) {
          ddTab = ddMenu.data('trigger');
          if (ddTab.length) {
            selectedStateTarget = ddTab;
            activeStateTarget = ddTab;
          }
        }

        if (this.isTabOverflowed(activeStateTarget)) {
          activeStateTarget = this.moreButton;
          selectedStateTarget = this.moreButton;
        }
        this.focusBar(activeStateTarget);

        selectedStateTarget.addClass('is-selected');

        // Fires a resize on any invoked child toolbars inside the tab panel.
        // Needed to fix issues with Toolbar alignment, since we can't properly detect
        // size on hidden elements.
        var childToolbars = targetPanel.find('.toolbar');
        if (childToolbars.length) {
          childToolbars.each(function() {
            var api = $(this).data('toolbar');
            if (api && typeof api.handleResize === 'function') {
              api.handleResize();
            }
          });
        }
      },

      /**
       * Shows/Hides some tabsets' faded edges based on scrolling position, if applicable.
       * @returns {undefined}
       */
      renderEdgeFading: function() {
        if (!this.isScrollableTabs() || !this.tablistContainer) {
          return;
        }

        var isRTL = Locale.isRTL(),
          tablistContainerElem = this.tablistContainer[0],
          scrollLeft = tablistContainerElem.scrollLeft,
          scrollWidth = tablistContainerElem.scrollWidth,
          containerWidth = parseInt(window.getComputedStyle(tablistContainerElem).getPropertyValue('width'));

        if (isRTL) {
          this.element[0].classList[ scrollLeft > 0 ? 'add' : 'remove' ]('scrolled-left');
          this.element[0].classList[ (scrollWidth - scrollLeft) <= containerWidth ? 'remove' : 'add' ]('scrolled-right');
        } else {
          this.element[0].classList[ scrollLeft > 0 ? 'add' : 'remove' ]('scrolled-right');
          this.element[0].classList[ (scrollWidth - scrollLeft) <= containerWidth ? 'remove' : 'add' ]('scrolled-left');
        }
      },

      /**
       * Calls an options-provided source method to fetch content that will be displayed inside a tab.
       * @param {string} href - string representing the target tab to load content under.
       * @param {function} callback - method that fires after a successful source call.
       * @returns {boolean|$.Deferred} true if source call was successful, false for failure/ignore, or a promise object that will fire callbacks in either "success" or "failure" scenarios.
       */
      callSource: function(href, isURL) {
        if ((isURL === undefined || isURL === null || isURL === false) && !this.settings.source) {
          return false;
        }
        if (this.settings.lazyLoad !== true) {
          return false;
        }

        var self = this,
          sourceType = typeof this.settings.source,
          response = function(htmlContent) {
            if (htmlContent === undefined || htmlContent === null) {
              return;
            }

            htmlContent = $.sanitizeHTML(htmlContent);

            // Get a new random tab ID for this tab if one can't be derived from the URL string
            if (isURL) {
              var anchor = self.tablist.find('[href="'+ href +'"]'),
                containerId = self.element[0].id || '',
                id = anchor.uniqueId('tab', containerId);

              href = '#' + id;
              // Replace the original URL on this anchor now that we've loaded content.
              anchor.attr('href', href);
            }

            self.createTabPanel(href, htmlContent, true);
            self.activate(href);

            self.element.triggerHandler('complete'); // For Busy Indicator
            self.element.trigger('requestend', [href, htmlContent]);
          };

        this.container.triggerHandler('start'); // For Busy Indicator
        this.container.trigger('requeststart');

        function handleStringSource(url, options) {
          var opts = $.extend({ dataType: 'html' }, options, {
            url: url
          });

          var request = $.ajax(opts);
          request.done(response);
          return request;
        }

        if (isURL) {
          return handleStringSource(href, this.ajaxOptions);
        }

        // return _true_ from this source function on if we're just loading straight content
        // return a promise if you'd like to setup async handling.
        if (sourceType === 'function') {
          return this.settings.source(response, href, this.settings.sourceArguments);
        }

        if (sourceType === 'string') {
          // Attempt to resolve source as a URL string.  Make an $.ajax() call with the URL
          var safeHref = href.replace(/#/g, ''),
            sourceURL = this.settings.source.toString(),
            hasHref = sourceURL.indexOf(safeHref) > -1;

          if (!hasHref) {
            var param = 'tab=' + safeHref,
              paramIndex = sourceURL.indexOf('?'),
              hashIndex = sourceURL.indexOf('#'),
              insertIndex = sourceURL.length;

            if (paramIndex < 0) {
              param = '?' + param;
              if (hashIndex > -1) {
                insertIndex = hashIndex + 1;
              }
            } else {
              param = param + '&';
              insertIndex = paramIndex + 1;
            }

            sourceURL = Soho.string.splice(sourceURL, insertIndex, 0, param);
          }

          return handleStringSource(sourceURL, this.ajaxOptions);
        }

        return false;
      },

      renderVisiblePanel: function() {
        // Recalculate all components inside of the visible tab to adjust widths/heights/display if necessary
        this.resizeNestedTabs();
        //TJM: Prioritizing performance fix.
        //this.panels.filter(':visible').handleResize();
      },

      changeHash: function(href) {
        if (!this.settings.changeTabOnHashChange) {
          return;
        }

        if (!href) {
          href = '';
        }

        href.replace(/#/g, '');

        var cb = this.settings.hashChangeCallback;
        if (cb && typeof cb === 'function') {
          cb(href);
        } else {
          window.location.hash = href;
        }

        this.element.triggerHandler('hash-change', [href]);
      },

      updateAria: function(a) {
        if (!a) {
          return;
        }
        //hide old tabs
        this.anchors.attr({
          'aria-selected': 'false',
          'aria-expanded': 'false',
          'tabindex': '-1'
        });
        this.moreButton.attr({
          'tabindex': '-1'
        });

        //show current tab
        if (a.length && this.element.is(':not(.is-disabled)')) {
          a.parent().removeClass('is-selected');
          if (!this.isTabOverflowed(a.parent())) {
            a.attr({
              'aria-selected': 'true',
              'aria-expanded': 'true',
              'tabindex': '0'
            }).parent().addClass('is-selected');
          } else {
            this.moreButton.attr({
              'tabindex': '0'
            });
          }
        }
      },

      resizeNestedTabs: function() {
        this.nestedTabControls.each(function(i, container) {
          var c = $(container),
            api = c.data('tabs');

          if (api && api.handleResize && typeof api.handleResize === 'function') {
            api.handleResize(true);
          }
        });
      },

      // Adds a new tab into the list and properly binds events
      add: function(tabId, options, atIndex) {
        if (!tabId) {
          return this;
        }

        if (!options) {
          options = {};
        }

        var startFromZero = this.tablist.find('li').not('.application-menu-trigger, .add-tab-button').length === 0;

        // Sanitize
        tabId = '' + tabId.replace(/#/g, '');
        options.name = options.name ? options.name.toString() : '&nbsp;';
        options.isDismissible = options.isDismissible ? options.isDismissible === true : false;
        options.isDropdown = options.isDropdown ? options.isDropdown === true : false;

        function getObjectFromSelector(sourceString) {
          var contentType = typeof sourceString;
          switch(contentType) {
            case 'string':
              var hasId = sourceString.match(/#/g);
              // Text Content or a Selector.
              if (hasId !== null) {
                var obj = $(sourceString);
                sourceString = obj.length ? $(sourceString).clone() : sourceString;
              }
              // do nothing if it's just a string of text.
              break;
            case 'object':
              // jQuery object or HTML Element
              sourceString = $(sourceString).clone();
              break;
          }
          return sourceString;
        }

        if (options.content) {
          options.content = getObjectFromSelector(options.content);
        }
        if (options.dropdown) {
          options.dropdown = getObjectFromSelector(options.dropdown);
        }

        // Build
        var tabHeaderMarkup = $('<li role="presentation" class="tab"></li>'),
          anchorMarkup = $('<a href="#'+ tabId +'" role="tab" aria-expanded="false" aria-selected="false" tabindex="-1">'+ options.name +'</a>'),
          tabContentMarkup = this.createTabPanel(tabId, options.content);

        tabHeaderMarkup.html(anchorMarkup);

        if (options.isDismissible) {
          tabHeaderMarkup.addClass('dismissible');
          tabHeaderMarkup.append($.createIconElement({ icon: 'close', classes: 'close icon' }));
        }

        if (this.settings.tabCounts) {
          anchorMarkup.prepend('<span class="count">0 </span>');
        }

        if (options.dropdown) {
          // TODO: Need to implement the passing of Dropdown Tab menus into this method.
        }

        function insertIntoTabset(self, targetIndex) {
          var method,
            tabs = self.tablist.children('li'),
            nonSpecialTabs = tabs.not('.application-menu-trigger, .add-tab-button'),
            finalIndex = tabs.length - 1;

          if (!tabs.length) {
            tabHeaderMarkup.appendTo(self.tablist);
            tabContentMarkup.appendTo(self.container);
            return;
          }

          var addTabButton = tabs.filter('.add-tab-button'),
            appMenuTrigger = tabs.filter('.application-menu-trigger');

          // NOTE: Cannot simply do !targetIndex here because zero is a valid index
          if (targetIndex === undefined || targetIndex === null || isNaN(targetIndex)) {
            targetIndex = tabs.length;
          }

          function pastEndOfTabset(index) {
            return index > tabs.length - 1;
          }

          function atBeginningOfTabset(index) {
            return index <= 0;
          }

          if (tabs.length > nonSpecialTabs.length) {
            if (pastEndOfTabset(targetIndex) && addTabButton && addTabButton.length) {
              targetIndex = targetIndex - 1;
            }

            if (atBeginningOfTabset(targetIndex) && appMenuTrigger && appMenuTrigger.length) {
              targetIndex = targetIndex + 1;
            }
          }

          var conditionInsertTabBefore = tabs.eq(targetIndex).length > 0;

          finalIndex = conditionInsertTabBefore ? targetIndex : finalIndex;

          method = 'insertAfter';
          if (conditionInsertTabBefore) {
            method = 'insertBefore';
          }

          tabHeaderMarkup[method](tabs.eq(finalIndex));
          tabContentMarkup.appendTo(self.container);
          return;
        }

        insertIntoTabset(this, atIndex);

        // Add each new part to their respective collections.
        this.panels = this.panels.add(tabContentMarkup);
        this.anchors = this.anchors.add(anchorMarkup);

        // Link the two items via data()
        anchorMarkup.data('panel-link', tabContentMarkup);
        tabContentMarkup.data('tab-link', anchorMarkup);
        // TODO: When Dropdown Tabs can be added/removed, add that here

        // Make it possible for Module Tabs to display a tooltip containing their contents
        // if the contents are cut off by ellipsis.
        if (this.settings.moduleTabsTooltips) {
          anchorMarkup.on('beforeshow.toolbar', function() {
            return anchorMarkup.data('cutoffTitle') === 'yes';
          }).tooltip({
            content: '' + anchorMarkup.text().trim()
          });
        }

        // Adjust tablist height
        this.setOverflow();

        // If started from zero, position the focus state/bar and activate the tab
        if (startFromZero) {
          this.positionFocusState(anchorMarkup);
          this.focusBar(tabHeaderMarkup);
          this.activate(anchorMarkup.attr('href'));
          anchorMarkup.focus();
        }

        return this;
      },

      // Removes a tab from the list and cleans up properly
      // NOTE: Does not take advantage of _activatePreviousTab()_ due to specific needs of selecting certain
      // Tabs/Anchors at certain times.
      remove: function(tabId) {
        var self = this,
          targetLi = this.doGetTab(null, tabId);

        if (!targetLi || !targetLi.length) {
          return;
        }

        var targetAnchor = targetLi.children('a'),
          targetPanel = this.getPanel(tabId),
          hasTargetPanel = (targetPanel && targetPanel.length),
          targetLiIndex = this.tablist.children('li').index(targetLi),
          notATab = '.application-menu-trigger, .separator, .is-disabled, :hidden',
          prevLi = targetLi.prev();

        var canClose = this.element.triggerHandler('beforeclose', [targetLi]);
        if (canClose === false) {
          return false;
        }

        var wasSelected = false;
        if (targetLi.hasClass('is-selected')) {
          wasSelected = true;
        } else {
          prevLi = this.tablist.children('li').not(notATab).filter('.is-selected');
        }

        // Remove these from the collections
        if (hasTargetPanel) {
          this.panels = this.panels.not(targetPanel);
        }
        this.anchors = this.anchors.not(targetAnchor);

        // Destroy Anchor tooltips, if applicable
        if (this.settings.moduleTabsTooltips) {
          targetAnchor.off('beforeshow.toolbar').data('tooltip').destroy();
        }

        // Close Dropdown Tabs in a clean fashion
        var popupAPI = targetLi.data('popupmenu');
        if (targetLi.hasClass('has-popupmenu')) {
          if (popupAPI) {
            popupAPI.menu.children('li').each(function() {
              self.remove($(this).children('a').attr('href'));
            });
            popupAPI.destroy();
          }
        }

        // If this tab is inside of a Dropdown Tab's menu, detect if it was the last one
        // remaining, and if so, close the entire Dropdown Tab.
        // The actual check on these elements needs to be done AFTER the targetLi is removed
        // from a Dropdown Tab, to accurately check the number of list items remaining.
        // See: _isLastDropdownTabItem()_
        var parentMenu = targetLi.closest('.dropdown-tab'),
          trigger = parentMenu.data('trigger');

        // Kill associated events
        targetLi.off('click.tabs');
        targetAnchor.off('click.tabs focus.tabs keydown.tabs');

        // Remove Markup
        targetLi.remove();
        if (hasTargetPanel) {
          targetPanel.remove();
        }

        var menuItem = targetAnchor.data('moremenu-link');
        if (menuItem) {
          menuItem.parent().off().remove();
          $.removeData(targetAnchor[0], 'moremenu-link');
        }

        function isLastDropdownTabItem(menu) {
          return menu.length && menu.children('li:not(.separator)').length === 0;
        }
        if (isLastDropdownTabItem(parentMenu)) {
          prevLi = this.getPreviousTab(trigger);

          setTimeout(function() {
            self.remove(trigger);
          }, 1);
        }

        // Close dropdown tab's menu
        if (trigger && trigger.length) {
          trigger.data('popupmenu').close();
        }

        // Adjust tablist height
        this.setOverflow();

        this.element.trigger('close', [targetLi]);

        // If any tabs are left in the list, set the previous tab as the currently selected one.
        var count = targetLiIndex - 1;
        while (count > -1) {
          count = -1;
          if (prevLi.is(notATab)) {
            prevLi = prevLi.prev();
            count = count - 1;
          }
        }

        // If we find nothing, search for ANY available tab
        if (!prevLi.length) {
          prevLi = this.tablist.children('li').not(notATab).first();
        }

        // If there's really nothing, kick on out and defocus everything.
        if (!prevLi.length) {
          this.hideFocusState();
          this.defocusBar();

          this.element.trigger('afterclose', [targetLi]);
          return this;
        }

        var a = prevLi.children('a'),
          activateTargetA = a;

        this.positionFocusState(a);

        if (wasSelected) {
          if (prevLi.is('.has-popupmenu') && prevLi.data('popupmenu')) {
            activateTargetA = prevLi.data('popupmenu').menu.children().first().children('a');
          }
          this.activate(activateTargetA.attr('href'));
        }

        this.focusBar(prevLi);
        a.focus();

        this.element.trigger('afterclose', [targetLi]);

        return this;
      },


      createTabPanel: function(tabId, content, doInsert) {
        tabId = tabId.replace(/#/g, '');

        // If a jQuery-wrapped element is provided, actually append the element.
        // If content is text/string, simply inline it.
        var markup = $('<div id="'+ tabId +'" class="tab-panel" role="tabpanel"></div>');
        if (content instanceof $) {
          markup.append(content);
        } else {
          markup[0].innerHTML = content || '';
        }

        if (doInsert === true) {
          this.container.append(markup);
        }

        this.panels = this.panels.add(markup);

        return markup;
      },

      checkPopupMenuItems: function(tab) {
        function getRemainingMenuItems(popupAPI) {
          if (!popupAPI || !popupAPI.menu) {
            return $();
          }
          var menu = popupAPI.menu,
            items = menu.children('li');

          if (!items.length) {
            popupAPI.destroy();
            return $();
          }
          return items;
        }

        if (tab.is('.has-popupmenu')) {
          return getRemainingMenuItems(tab.data('popupmenu'));
        }

        var ddTab = tab.closest('.dropdown-tab');
        if (!ddTab.length) {
          return $();
        }
        return getRemainingMenuItems(ddTab.data('popupmenu'));
      },

      getTab: function(e, tabId) {
        var self = this,
          tab = $();

        function getTabFromEvent(ev) {
          var t = $(ev.currentTarget);
          if (t.is('.tab')) {
            return t;
          }
          if (t.closest('.tab').length) {
            return t.closest('.tab').first();
          }
          return null;
        }

        function getTabFromId(id) {
          if (!id || id === '' || id === '#') {
            return null;
          }

          if (id.indexOf('#') === -1) {
            id = '#' + id;
          }

          var anchor = self.anchors.filter('[href="' + id + '"]');
          if (!anchor.length) {
            return null;
          }

          return anchor.parent();
        }

        // TabId can also be a jQuery object containing a tab.
        if (tabId instanceof $ && tabId.length > 0) {
          if (tabId.is('a')) {
            return tabId.parent();
          }
          return tabId;
        }

        return e ? getTabFromEvent(e) : tabId ? getTabFromId(tabId) : tab;
      },

      doGetTab: function(e, tabId) {
        if (!e && !tabId) { return $(); }
        if (e && !(e instanceof $.Event) && typeof e !== 'string') {
          return $();
        }

        if (e) {
          if (typeof e !== 'string') { // jQuery Event
            return this.getTab(e);
          }
          return this.getTab(null, e); // String containing a selector
        }

        // Straight to the TabID
        return this.getTab(null, tabId);
      },

      // Hides a tab
      hide: function(e, tabId) {
        var tab = this.doGetTab(e, tabId);

        if (tab.is('.is-selected')) {
          this.activatePreviousTab(tabId);
        }
        tab.addClass('hidden');
        this.focusBar();
        this.positionFocusState();
        return this;
      },

      // Shows a tab
      show: function(e, tabId) {
        var tab = this.doGetTab(e, tabId);

        tab.removeClass('hidden');
        this.focusBar();
        this.positionFocusState();
        return this;
      },

      // Disables an individual tab
      disableTab: function(e, tabId) {
        var tab = this.doGetTab(e, tabId);

        if (tab.is('.is-selected')) {
          this.activatePreviousTab(tabId);
        }
        tab.addClass('is-disabled');
        this.focusBar();
        this.positionFocusState();
        return this;
      },

      // Enables an individual tab
      enableTab: function(e, tabId) {
        var tab = this.doGetTab(e, tabId);

        tab.removeClass('is-disabled');
        this.focusBar();
        this.positionFocusState();
        return this;
      },

      // Renames a tab and resets the focusable bar/animation.
      rename: function(e, tabId, name) {
        // Backwards compatibility with 4.2.0
        if (e && typeof e === 'string') {
          name = tabId;
          tabId = e;
        }

        if (!name) {
          return;
        }

        var tab = this.doGetTab(e, tabId),
          hasCounts = this.settings.tabCounts,
          anchor = tab.children('a'),
          count;

        if (hasCounts) {
          count = anchor.find('.count').clone();
        }

        anchor.text(name.toString());

        if (hasCounts) {
          anchor.prepend(count);
        }

        var doesTabExist = this.tablist.children('li').length < 2 ? tab : undefined;

        this.positionFocusState(doesTabExist);
        this.focusBar(doesTabExist);
      },

      // For tabs with counts, updates the count and resets the focusable bar/animation
      updateCount: function(e, tabId, count) {
        // Backwards compatibility with 4.2.0
        if (e && typeof e === 'string') {
          count = tabId;
          tabId = e;
        }

        if (!this.settings.tabCounts || !count) {
          return;
        }

        var tab = this.doGetTab(e, tabId);

        tab.children('a').find('.count').text(count.toString() + ' ');

        var doesTabExist = this.tablist.children('li').length < 2 ? tab : undefined;

        this.positionFocusState(doesTabExist);
        this.focusBar(doesTabExist);
      },

      // returns the currently active tab
      getActiveTab: function() {
        var visible = this.panels.filter(':visible');
        return this.anchors.filter('[href="#'+ visible.first().attr('id') +'"]');
      },

      getVisibleTabs: function() {
        var self = this,
          tabHash = $();

        this.tablist.find('li:not(.separator):not(.hidden):not(.is-disabled):not(.application-menu-trigger)')
          .each(function tabOverflowIterator() {
            var tab = $(this);

            if (!self.isTabOverflowed(tab)) {
              tabHash = tabHash.add(tab);
            }
          });

        return tabHash;
      },

      getOverflowTabs: function() {
        var self = this,
          tabHash = $();

        this.tablist.find('li:not(.separator):not(.hidden):not(.is-disabled):not(.application-menu-trigger)')
          .each(function tabOverflowIterator() {
            var tab = $(this);

            if (self.isTabOverflowed(tab)) {
              tabHash = tabHash.add(tab);
            }
          });

        return tabHash;
      },

      setOverflow: function () {
        var elem = this.element[0],
          tablist = this.tablist[0],
          HAS_MORE = 'has-more-button',
          hasMoreIndex = this.hasMoreButton(),
          isScrollableTabs = this.isScrollableTabs();

        // Recalc tab width before detection of overflow
        if (this.isModuleTabs()) {
          this.adjustModuleTabs();
        }

        var tablistStyle, tablistHeight,
          tablistContainerScrollWidth, tablistContainerWidth,
          overflowCondition;

        if (isScrollableTabs) {
          tablistContainerScrollWidth = this.tablistContainer[0].scrollWidth;
          tablistContainerWidth = this.tablistContainer[0].offsetWidth;
          overflowCondition = tablistContainerScrollWidth > tablistContainerWidth;
        } else {
          tablistStyle = window.getComputedStyle(tablist, null);
          tablistHeight = parseInt(tablistStyle.getPropertyValue('height')) + 1; // +1 to fix an IE bug
          overflowCondition = tablist.scrollHeight > tablistHeight; // Normal tabs check the height
        }

        // Add "has-more-button" class if we need it, remove it if we don't
        // Always display the more button on Scrollable Tabs
        if (overflowCondition) {
          if (!hasMoreIndex) {
            elem.classList.add(HAS_MORE);
          }
        } else if (hasMoreIndex) {
          elem.classList.remove(HAS_MORE);
        }

        this.adjustSpilloverNumber();
      },

      adjustModuleTabs: function() {
        var self = this,
          sizeableTabs = this.tablist.find('li:not(.separator):not(.application-menu-trigger):not(:hidden)'),
          appTrigger = this.tablist.find('.application-menu-trigger'),
          hasAppTrigger = appTrigger.length > 0,
          tabContainerW = this.tablist.outerWidth(),
          defaultTabSize = 120,
          visibleTabSize = 120,
          appTriggerSize = (hasAppTrigger ? appTrigger.outerWidth() : 0),
          anchorStyle,
          anchorPadding;

        // Remove overflowed tabs
        sizeableTabs.children('a').removeAttr('style');
        sizeableTabs.removeAttr('style').each(function() {
          var t = $(this);
          if (self.isTabOverflowed(t)) {
            sizeableTabs = sizeableTabs.not(t);
          }
        });

        // Resize the more button to fit the entire space if no tabs can show
        // Math: +101 is the padding of the <ul class="tab-list"> element
        if (!sizeableTabs.length) {
          visibleTabSize = (tabContainerW - appTriggerSize + 101);
          this.moreButton[0].style.width = visibleTabSize + 'px';
          return;
        } else {
          anchorStyle = window.getComputedStyle(sizeableTabs.eq(0).children()[0]);
          anchorPadding = parseInt(anchorStyle.paddingLeft) + parseInt(anchorStyle.paddingRight);

          if (this.moreButton[0].hasAttribute('style')) {
            this.moreButton[0].removeAttribute('style');
          }
        }

        // Math explanation:
        // Width of tab container - possible applcation menu trigger
        // Divided by number of visible tabs (doesn't include app menu trigger which shouldn't change size)
        // Minus one (for the left-side border of each tab)
        visibleTabSize = ((tabContainerW - appTriggerSize) / sizeableTabs.length - 1);

        if (visibleTabSize < defaultTabSize) {
          visibleTabSize = defaultTabSize;
        }

        var a,
          prevWidth,
          cutoff = 'no';

        for (var i = 0; i < sizeableTabs.length; i++) {
          a = sizeableTabs.eq(i).children('a');
          a[0].style.width = '';

          if (this.settings.moduleTabsTooltips === true) {
            cutoff = 'no';

            prevWidth = parseInt(window.getComputedStyle(sizeableTabs[i]).width);

            if (prevWidth > (visibleTabSize - anchorPadding)) {
              cutoff = 'yes';
            }
            a.data('cutoffTitle', cutoff);
          }

          sizeableTabs[i].style.width = visibleTabSize + 'px';
          a[0].style.width = visibleTabSize + 'px';
        }

        this.adjustSpilloverNumber();
      },

      adjustSpilloverNumber: function() {
         var moreDiv = this.moreButton.find('.more-text'),
          tabs = this.tablist.find('li:not(.separator):not(.hidden):not(.is-disabled):not(.application-menu-trigger)'),
          overflowedTabs = this.getOverflowTabs();

        if (tabs.length <= overflowedTabs.length) {
          moreDiv.text('' + Locale.translate('Tabs'));
        } else {
          moreDiv.text('' + Locale.translate('More'));
        }

        var countDiv = this.moreButton.find('.count');
        if (!countDiv.length) {
          countDiv = $('<span class="count"></span>');
          this.moreButton.children('span').first().prepend(countDiv);
        }

        countDiv.text('' + overflowedTabs.length + ' ');

        return;
      },

      //Selects a Tab
      select: function (href) {
        var modHref = href.replace(/#/g, ''),
          anchor = this.getAnchor(modHref);

        this.positionFocusState(undefined, false);
        this.focusBar(anchor.parent());
        this.activate(anchor.attr('href'));
        this.changeHash(modHref);

        anchor.focus();
      },

      buildPopupMenu: function(startingHref) {
        var self = this;
        if (self.popupmenu) {
          self.popupmenu.destroy();
          $('#tab-container-popupmenu').off('focus.popupmenu').remove();
          $(document).off('keydown.popupmenu');
        }

        // Build the new markup for the popupmenu if it doesn't exist.
        // Reset it if it does exist.
        var menuHtml = $('#tab-container-popupmenu'),
          shouldBeSelectable = '';
        if (this.isScrollableTabs()) {
          shouldBeSelectable = ' is-selectable';
        }

        if (menuHtml.length === 0) {
          menuHtml = $('<ul id="tab-container-popupmenu" class="tab-list-spillover'+ shouldBeSelectable +'">').appendTo('body');
        } else {
          menuHtml.html('');
        }

        // Build menu options from overflowed tabs
        var tabs = self.tablist.children('li'),
          isRTL = Locale.isRTL();

        function buildMenuItem(item) {
          var $item = $(item),
            $itemA = $item.children('a');

          if ($item.is(':hidden')) {
            return;
          }

          if (!self.isScrollableTabs() && !self.isTabOverflowed($item)) {
            return;
          }

          if ($item.is('.separator')) {
            $item.clone().appendTo(menuHtml);
            return;
          }

          var popupLi = $item.clone(),
            popupA = popupLi.children('a');

          popupLi[0].classList.remove('tab');
          if (popupLi[0].classList.contains('is-selected')) {
            popupLi[0].classList.remove('is-selected');
            if (self.isScrollableTabs()) {
              popupLi[0].classList.add('is-checked');
            }
          }

          popupLi[0].removeAttribute('style');

          popupLi.children('.icon').off().appendTo(popupA);
          popupLi.appendTo(menuHtml);

          // Link tab to its corresponding "More Tabs" menu option
          $item.data('moremenu-link', popupA);
          popupA.find('.icon-more').remove();

          // Link "More Tabs" menu option to its corresponding Tab.
          // Remove onclick methods from the popup <li> because they are called
          // on the "select" event in context of the original button
          popupA.data('original-tab', $itemA);
          popupA.onclick = undefined;

          if (!$item.is('.has-popupmenu')) {
            return;
          }

          // If this is a Dropdown Tab, clone its menu and add it to the "More Tabs" menu
          // As a submenu of the "popupLi".
          var submenu = $('#' + item.getAttribute('aria-controls')),
            clone = submenu.clone(),
            cloneLis = clone.children('li');

          clone[0].classList.remove('has-popupmenu');

          cloneLis.each(function(i) {
            var li = $(this),
              a = li.children('a'),
              originalLi = submenu.children('li').eq(i),
              originalA = originalLi.children('a');

            a.data('original-tab', originalA);
            originalA.data('moremenu-link', a);
          });

          clone.insertAfter(popupA);
        }

        // Build spillover menu options
        for (var i = 0; i < tabs.length; i++) {
          buildMenuItem(tabs[i]);
        }

        self.tablist.children('li:not(.separator)').removeClass('is-focused');
        var xOffset = 1;
        if (!this.isScrollableTabs()) {
          xOffset = 3;
        }

        // Invoke the popup menu on the button.
        self.moreButton.popupmenu({
          autoFocus: false,
          attachToBody: true,
          menu: 'tab-container-popupmenu',
          trigger: 'immediate',
          offset: { x: xOffset }
        });
        self.moreButton.addClass('popup-is-open');
        self.popupmenu = self.moreButton.data('popupmenu');

        if (self.hasSquareFocusState()) {
          self.positionFocusState(self.moreButton);
        }

        function closeMenu() {
          $(this).off('close.tabs selected.tabs');
          self.moreButton.removeClass('popup-is-open');
          self.positionFocusState(undefined);
          self.focusBar();
        }

        function selectMenuOption(e, anchor) {
          var href = anchor.attr('href'),
            id = href.substr(1, href.length),
            tab = self.doGetTab(id) || $(),
            a = tab ? tab.children('a') : $(),
            originalTab = anchor.data('original-tab').parent();

          if (originalTab.is('.add-tab-button')) {
            a = self.handleAddButton();
            originalTab = a.parent();
            href = a.attr('href');
            self.element.trigger('tab-added', [a]);
          }

          self.activate(href);

          // Fire an onclick event associated with the original tab from the spillover menu
          if (tab.length && a.length && typeof a[0].onclick === 'function') {
            a[0].onclick.apply(a[0]);
          }

          // Focus the More Button
          // NOTE: If we switch the focusing-operations back to how they used to be (blue bar moving around with the focus state)
          // remove the line below.
          self.moreButton.focus();

          self.scrollTabList(tab);
        }

        self.moreButton
          .on('close.tabs', closeMenu)
          .on('selected.tabs', selectMenuOption);

        var menu = self.popupmenu.menu;

        function handleDestroy() {
          menu.off();
          self.hideFocusState();
          $('#tab-container-popupmenu').remove();
        }

        function handleDismissibleIconClick(e) {
          var icon = $(this),
            li = icon.closest('li');

          if (!li.is('.dismissible') || !icon.is('.close')) {
            return;
          }

          e.preventDefault();
          e.stopPropagation();
          self.closeDismissibleTab(li.children('a').attr('href'));
          self.popupmenu.close();
        }

        menu
          .on('destroy.popupmenu', handleDestroy)
          .on('touchend.popupmenu touchcancel.popupmenu', '.icon', handleDismissibleIconClick)
          .on('click.popupmenu', '.icon', handleDismissibleIconClick);

        // If the optional startingIndex is provided, focus the popupmenu on the matching item.
        // Otherwise, focus the first item in the list.
        if (startingHref) {
          self.popupmenu.highlight(menu.find('a[href="' + startingHref + '"]'));
        } else if (self.tablist.children('.is-selected').length > 0) {
          self.popupmenu.highlight(menu.find('a[href="' + self.tablist.children('.is-selected').children('a').attr('href') + '"]'));
        } else {
          self.popupmenu.highlight(menu.find('li:first-child > a'));
        }

        // Overrides a similar method in the popupmenu code that controls escaping of this menu when
        // pressing certain keys.  We override this here so that the controls act in a manner as if all tabs
        // are still visible (for accessiblity reasons), meaning you can use left and right to navigate the
        // popup menu options as if they were tabs.
        $(document).bindFirst('keydown.popupmenu', function handlePopupMenuKeydown(e) {
          var key = e.which,
            currentMenuItem = $(e.target);

          function isFocusedElement() {
            return this === document.activeElement;
          }

          function prevMenuItem() {
            // If the first item in the popup menu is already focused, close the menu and focus
            // on the last visible item in the tabs list.
            var first = menu.find('li:first-child > a');
            if (first.filter(isFocusedElement).length > 0) {
              e.preventDefault();
              $(document).off(e);
              self.popupmenu.close();
              self.findLastVisibleTab();
            }
          }

          function nextMenuItem() {
            // If the last item in the popup menu is already focused, close the menu and focus
            // on the first visible item in the tabs list.
            var last = menu.find('li:last-child > a');
            if (last.filter(isFocusedElement).length > 0 && last.parent().is(':not(.submenu)')) {
              e.preventDefault();
              $(document).off(e);
              self.popupmenu.close();

              if (self.settings.addTabButton) {
                self.addTabButton.focus();
                return;
              }
              self.findFirstVisibleTab();
            }
          }

          // Alt+Del or Alt+Backspace closes a dropdown tab item
          function closeDropdownMenuItem(e) {
            if (!e.altKey || !currentMenuItem.parent().is('.dismissible')) {
              return;
            }
            //self.popupmenu.close();
            self.closeDismissibleTab(currentMenuItem.attr('href'));
            return;
          }

          var pseudoKeycode;

          switch(key) {
            case 8:
            case 46:
              closeDropdownMenuItem(e);
              break;
            case 37: // left
              pseudoKeycode = isRTL ? 40 : 38;
              if (currentMenuItem.is('a')) {
                if (currentMenuItem.parent().is(':not(:first-child)')) {
                  e.preventDefault(); // Prevent popupmenu from closing on left key
                }
                $(document).trigger({type: 'keydown.popupmenu', which: pseudoKeycode});
              }
              break;
            case 38: // up
              prevMenuItem();
              break;
            case 39: // right
              pseudoKeycode = isRTL ? 38 : 40;
              if (currentMenuItem.is('a') && !currentMenuItem.parent('.submenu').length) {
                $(document).trigger({type: 'keydown.popupmenu', which: pseudoKeycode});
              }
              break;
            case 40: // down
              nextMenuItem();
              break;
          }
        });
      },

      // Used for checking if a particular tab (in the form of a jquery-wrapped list item) is spilled into
      // the overflow area of the tablist container <UL>.
      isTabOverflowed: function(li) {
        if (this.isVerticalTabs() || this.isScrollableTabs()) {
          return false;
        }

        if (this.tablist.scrollTop() > 0) {
          this.tablist.scrollTop(0);
        }

        var liTop = Math.round(li[0].getBoundingClientRect().top),
          tablistTop = Math.round(this.tablist[0].getBoundingClientRect().top + 1);

        // +1 to compensate for top border on Module Tabs
        if (this.isModuleTabs()) {
          tablistTop = tablistTop + 1;
        }

        return liTop > tablistTop;
      },

      findLastVisibleTab: function() {
        var tabs = this.tablist.children('li:not(.separator):not(.hidden):not(.is-disabled)'),
          targetFocus = tabs.first();

        // if Scrollable Tabs, simply get the last tab and focus.
        if (this.isScrollableTabs()) {
          return tabs.last().find('a').focus();
        }

        while(!(this.isTabOverflowed(targetFocus))) {
          targetFocus = tabs.eq(tabs.index(targetFocus) + 1);
        }
        tabs.eq(tabs.index(targetFocus) - 1).find('a').focus();
      },

      findFirstVisibleTab: function() {
        var tabs = this.tablist.children('li:not(.separator):not(.hidden):not(.is-disabled)');
        tabs.eq(0).find('a').focus();
      },

      focusBar: function(li, callback) {
        if (!this.hasAnimatedBar()) {
          return;
        }

        if (!(li instanceof $) || !li.length) {
          return;
        }

        var self = this,
          target = li,
          scrollingTablist = this.tablistContainer,
          isRTL = Locale.isRTL(),
          paddingLeft, paddingRight, width,
          tabMoreWidth,
          tablistScrollWidth,
          tablistScrollLeft,
          anchorStyle, targetStyle;

        this.animatedBar.removeClass('no-transition');

        if (!target || target === undefined || !target.length || !self.anchors.length) {
          this.animatedBar.removeClass('visible');
          return;
        }

        targetStyle = window.getComputedStyle(target[0], null);
        paddingLeft = parseInt(targetStyle.getPropertyValue('padding-left'), 10) || 0;
        paddingRight = parseInt(targetStyle.getPropertyValue('padding-right'), 10) || 0;
        width = parseInt(targetStyle.getPropertyValue('width')) || 0;

        if (target.is('.tab')) {
          anchorStyle = window.getComputedStyle(target.children('a')[0]);
          paddingLeft += parseInt(anchorStyle.getPropertyValue('padding-left'), 10) || 0;
          paddingRight += parseInt(anchorStyle.getPropertyValue('padding-right'), 10) || 0;
        }

        var left = isRTL ?
          (paddingRight + target.position().left + target.outerWidth(true)) : (target.position().left);

        clearTimeout(self.animationTimeout);
        this.animatedBar.addClass('visible');

        function animationTimeout(cb) {
          var style = self.animatedBar[0].style;
          tablistScrollLeft = scrollingTablist[0].scrollLeft;
          tablistScrollWidth = scrollingTablist[0].scrollWidth;
          tabMoreWidth = this.moreButton.outerWidth(true);

          if (isRTL) {
            style.right = tablistScrollWidth + paddingRight - (left + tablistScrollLeft) + 'px';
          } else {
            style.left = left + tablistScrollLeft + 'px';
          }
          style.width = width + 'px';

          if (cb && typeof cb === 'function') {
            cb();
          }
        }
        this.animationTimeout = setTimeout(animationTimeout.apply(this, [callback]), 0);
      },

      defocusBar: function() {
        if (!this.hasAnimatedBar()) {
          return;
        }

        var self = this,
          left = Locale.isRTL() ? 0 : (self.animatedBar.position().left+(self.animatedBar.outerWidth()/2));

        clearTimeout(self.animationTimeout);

        this.animatedBar[0].style.left = left + 'px';
        this.animatedBar[0].style.width = 0;

        this.animationTimeout = setTimeout(function() {
          if (self.animatedBar && self.animatedBar.length) {
            self.animatedBar.removeClass('visible').removeAttr('style');
          }
        }, 350);
      },

      /**
       * Wrapper for the Soho behavior _smoothScrollTo()_ that will determine scroll distance.
       * @param {jQuery[]} target - the target <li> or <a> tag
       * @param {Number} duration - the time it will take to scroll
       * @returns {undefined}
       */
      scrollTabList: function(target) {
        if (!this.tablistContainer || !target || !(target instanceof $) || !target.length) {
          return;
        }

        var tabCoords = Soho.DOM.getDimensions(target[0]),
          tabContainerDims = Soho.DOM.getDimensions(this.tablistContainer[0]),
          d;

        var FADED_AREA = 40, // the faded edges on the sides of the tabset
          adjustedLeft = tabCoords.left,
          adjustedRight = tabCoords.right;

        if (adjustedLeft < tabContainerDims.left + FADED_AREA) {
          d = (Math.round(Math.abs(tabContainerDims.left - adjustedLeft)) * -1) - FADED_AREA;
        }
        if (adjustedRight > tabContainerDims.right - FADED_AREA) {
          d = Math.round(Math.abs(adjustedRight - tabContainerDims.right)) + FADED_AREA;
        }

        if (d === 0) {
          d = undefined;
        }

        // Scroll the tablist container
        this.tablistContainer.smoothScroll(d, 250);
      },

      hideFocusState: function() {
        if (this.hasSquareFocusState()) {
          this.focusState.removeClass('is-visible');
        }
      },

      positionFocusState: function(target, unhide) {
        if (!this.hasSquareFocusState()) {
          return;
        }

        var self = this;
        target = target !== undefined ? $(target) :
            self.moreButton.hasClass('is-selected') ? self.moreButton :
            self.tablist.children('.is-selected').length > 0 ? self.tablist.children('.is-selected').children('a') : undefined;

        if (!target || target === undefined || !target.length || (target.is(this.moreButton) && this.isScrollableTabs())) {
          this.focusState.removeClass('is-visible');
          return;
        }

        // Use the parent <li> for anchors to get their dimensions.
        if (target.is('a')) {
          target = target.parent();
        }

        // Move the focus state from inside the tab list container, if applicable.
        // Put it back into the tab list container, if not.
        if (target.is('.add-tab-button, .tab-more')) {
          if (!this.focusState.parent().is(this.element)) {
            this.focusState.prependTo(this.element);
          }
        } else {
          if (!this.focusState.parent().is(this.tablistContainer)) {
            this.focusState.prependTo(this.tablistContainer);
          }
        }

        var focusStateElem = this.focusState[0],
          targetPos = Soho.DOM.getDimensions(target[0]),
          targetClassList = target[0].classList,
          isNotHeaderTabs = (!this.isHeaderTabs() || this.isHeaderTabs() && this.element[0].classList.contains('alternate')),
          isVerticalTabs = this.isVerticalTabs(),
          isRTL = Locale.isRTL(),
          tabMoreWidth = !isVerticalTabs ? this.moreButton.outerWidth(true) : 0,
          parentContainer = this.element,
          scrollingTablist = this.tablistContainer,
          accountForPadding = scrollingTablist && this.focusState.parent().is(scrollingTablist);

        function adjustForParentContainer(targetRectObj, parentElement, tablistContainer) {
          var parentRect = parentElement[0].getBoundingClientRect(),
            parentPadding,
            tabLeftMargin,
            tablistScrollWidth,
            tablistScrollLeft;

          // Adjust from the top
          targetRectObj.top = targetRectObj.top - parentRect.top;
          if (isVerticalTabs) {
            targetRectObj.top = targetRectObj.top + parentElement[0].scrollTop;
          }

          if (isRTL) {
            targetRectObj.right = parentRect.right - targetRectObj.right;
          } else {
            targetRectObj.left = targetRectObj.left - parentRect.left;
          }

          // If inside a scrollable tablist, account for the scroll position
          if (tablistContainer) {
            tablistScrollLeft = tablistContainer ? tablistContainer[0].scrollLeft : 0;
            tablistScrollWidth = tablistContainer ? tablistContainer[0].scrollWidth : 0;

            if (isRTL && !isVerticalTabs) {
              // TODO: Improve this calculation because there's something off
              var tmpLeft = targetRectObj.left;
              if (isNotHeaderTabs) {
                tabLeftMargin = parseInt(window.getComputedStyle(target[0]).marginLeft);
                targetRectObj.left = tablistScrollWidth - tabLeftMargin - targetRectObj.right + tablistScrollLeft;
                targetRectObj.right = tablistScrollWidth - tabLeftMargin - tmpLeft + tablistScrollLeft;
              } else {
                targetRectObj.left = tablistScrollWidth - (targetRectObj.right + tablistScrollLeft + (tabMoreWidth) + 32);
                targetRectObj.right = tablistScrollWidth - (tmpLeft + tablistScrollLeft + (tabMoreWidth) + 32);
              }
            } else {
              targetRectObj.left = targetRectObj.left + tablistScrollLeft;
              targetRectObj.right = targetRectObj.right + tablistScrollLeft;
            }

            if (accountForPadding) {
              parentPadding = parseInt(window.getComputedStyle(parentElement[0])[ 'padding' + (isRTL ? 'Right' : 'Left') ]);
              targetRectObj.left = targetRectObj.left + (isRTL ? parentPadding : (parentPadding * -1));
              targetRectObj.right = targetRectObj.right + (isRTL ? parentPadding : (parentPadding * -1));
            }
          }

          // Alternate Header Tabs have 1px removed from bottom to prevent overlap onto the bottom border
          if (isNotHeaderTabs && !isVerticalTabs) {
            targetRectObj.height = targetRectObj.height - 1;
          }

          return targetRectObj;
        }

        // Adjust the values one more time if we have tabs contained inside of a page-container, or some other scrollable container.
        targetPos = adjustForParentContainer(targetPos, parentContainer, scrollingTablist);

        // build CSS string containing each prop and set it:
        var targetPosString = '';
        for (var property in targetPos) {
          if (targetPos.hasOwnProperty(property)) {
            if (targetPosString.length) {
              targetPosString += ' ';
            }
            targetPosString += '' + property + ': ' + targetPos[property] + 'px;';
          }
        }
        focusStateElem.setAttribute('style', targetPosString);

        var selected = targetClassList.contains('is-selected') ? 'add' : 'remove';
        focusStateElem.classList[selected]('is-selected');

        var doHide = unhide === true ? 'add' : 'remove';
        focusStateElem.classList[doHide]('is-visible');
      },

      checkFocusedElements: function() {
        var self = this,
          focusableItems = self.tablist;

        if (this.hasSquareFocusState() && focusableItems.find('.is-focused').length === 0 && !self.moreButton.hasClass('is-focused') && !self.moreButton.hasClass('popup-is-open')) {
          self.focusState.removeClass('is-visible');
        }

        if (this.hasAnimatedBar() && focusableItems.find('.is-selected').length === 0 && !self.moreButton.hasClass('is-selected')) {
          self.defocusBar();
        }
      },

      updated: function() {
        return this
          .teardown()
          .init();
      },

      // Disables all tabs in the
      disableOtherTabs: function() {
        return this.disable(true);
      },

      disable: function(isPartial) {
        if (!isPartial) {
          this.element.prop('disabled', true).addClass('is-disabled');
        }

        if (!this.disabledElems) {
          this.disabledElems = [];
        }

        var self = this,
          tabs = this.tablist.children('li:not(.separator)');
          if (isPartial) {
            tabs = tabs.filter(':not(.application-menu-trigger)');
          }


        tabs.each(function() {
          var li = $(this);
          var a = li.children('a');

          if (isPartial && self.isActive(a.attr('href'))) {
            return;
          }

          if (li.is('.is-disabled') || a.prop('disabled') === true) {
            self.disabledElems.push({
              elem: li,
              originalTabindex: li.attr('tabindex'),
              originalDisabled: a.prop('disabled')
            });
          }

          li.addClass('is-disabled');
          a.prop('disabled', true);

          if (li.is('.application-menu-trigger') || li.is('.add-tab-button')) {
            return;
          }

          var panel = $(a.attr('href'));
          panel.addClass('is-disabled');
          panel.find('*').each(function() {
            var t = $(this);

            // These are shadow inputs.  They are already handled by virtue of running .disable() on the original select tag.
            if (t.is('input.dropdown, input.multiselect')) {
              return;
            }

            if (t.attr('tabindex') === '-1' || t.attr('disabled')) {
              self.disabledElems.push({
                elem: t,
                originalTabindex: t.attr('tabindex'),
                originalDisabled: t.prop('disabled')
              });
            }

            t.disable();
          });
        });

        this.moreButton.addClass('is-disabled');

        if (this.isModuleTabs() && !isPartial) {
          this.element.children('.toolbar').disable();
        }

        this.updateAria($());
      },

      enable: function() {
        this.element.prop('disabled', false).removeClass('is-disabled');

        var self = this,
          tabs = this.tablist.children('li:not(.separator)');

        tabs.each(function() {
          var li = $(this);
          var a = li.children('a');

          li.removeClass('is-disabled');
          a.prop('disabled', false);

          if (li.is('.application-menu-trigger') || li.is('.add-tab-button')) {
            return;
          }

          var panel = $(a.attr('href'));
          panel.removeClass('is-disabled');
          panel.find('*').each(function() {
            var t = $(this);
            if (t.enable && typeof t.enable === 'function') {
              t.enable();
            }
          });

          $.each(self.disabledElems, function(i, obj) {
            var attrTarget = obj.elem.is('.tab') ? obj.elem.children('a') : obj.elem;
            if (obj.elem.disable && typeof obj.elem.disable === 'function') {
              obj.elem.disable();
            }

            if (obj.elem.is('li')) {
              obj.elem.addClass('is-disabled');
              return;
            }

            // These are shadow inputs.  They are already handled by virtue of running .disable() on the original select tag.
            if (obj.elem.is('input.dropdown, input.multiselect')) {
              return;
            }

            obj.elem.attr('tabindex', obj.originalTabindex);
            attrTarget.prop('disabled', obj.originalDisabled);
          });
        });

        this.moreButton.removeClass('is-disabled');

        if (this.isModuleTabs()) {
          this.element.children('.toolbar').enable();
        }

        this.disabledElems = [];

        this.updateAria(this.tablist.find('.is-selected > a'));
      },

      closeDismissibleTab: function(tabId) {
        return this.remove(tabId);
      },

      teardown: function() {
        this.panels.removeAttr('style');

        this.tablist
          .off()
          .removeAttr('role')
          .removeAttr('aria-multiselectable');

        var tabs = this.tablist.children('li');
        tabs
          .off()
          .removeAttr('role')
          .removeClass('is-selected');

        var dds = tabs.filter('.has-popupmenu');
        dds.each(function() {
          var popup = $(this).data('popupmenu');
          if (popup) {
            popup.menu.children('li:not(.separator)').each(function() {
              var li = $(this),
                a = li.children('a'),
                panel = a.data('panel-link');

              $.removeData(a[0], 'panel-link');
              if (panel && panel.length) {
                $.removeData(panel[0], 'tab-link');
              }
            });
            popup.destroy();
          }
        });

        this.panels
          .off();

        this.anchors
          .off()
          .removeAttr('role')
          .removeAttr('aria-expanded')
          .removeAttr('aria-selected')
          .removeAttr('tabindex');

        if (this.settings.moduleTabsTooltips) {
          this.anchors.each(function() {
            var api = $(this).data('tooltip');
            if (api && typeof api.destroy === 'function') {
              api.destroy();
            }
          });
        }

        this.element.off('focusout.tabs updated.tabs activated.tabs');
        $('body').off('resize.tabs' + this.tabsIndex);
        this.tabsIndex = undefined;

        if (this.moreButton.data('popupmenu')) {
          var popup = this.moreButton.data('popupmenu');
          popup.menu.find('li:not(.separator)').each(function() {
            var li = $(this),
              a = li.children('a');

            if (a.data('original-tab')) {
              $.removeData(a[0], 'original-tab');
            }
          });
          popup.destroy();
        }

        this.removeHelperMarkupEvents();

        if (this.tablistContainer) {
          this.tablistContainer.off('mousewheel.tabs');
        }

        if (this.hasSquareFocusState()) {
          this.focusState.remove();
          this.focusState = undefined;
        }

        if (this.hasAnimatedBar()) {
          this.animatedBar.remove();
          this.animatedBar = undefined;
        }

        return this;
      },

      destroy: function(){
        this.teardown();
        $.removeData(this.element[0], pluginName);
      }
    };

    // Keep the Chaining and Init the Controls or Settings
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (instance) {
        instance.settings = $.extend({}, instance.settings, options);
        instance.updated();
      } else {
        instance = $.data(this, pluginName, new Tabs(this, settings));
      }
    });
  };

  // Deprecated the old Vertical Tabs code in favor of using the Tabs class.
  $.fn.verticaltabs = $.fn.tabs;


  $.fn.tag = function(options) {
    'use strict';

    // Settings and Options
    var pluginName = 'tag',
        defaults = {
        },
        settings = $.extend({}, defaults, options);

    /**
     * @constructor
     * @param {Object} element
     */
    function Tag(element) {
      this.settings = $.extend({}, settings);
      this.element = $(element);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    // Tag Methods
    Tag.prototype = {

      init: function() {
        this.element.hideFocus();
        this.handleEvents();
      },

      // Handle Events
      handleEvents: function() {
        var self = this,
          btnDismissable = $(
            '<span class="dismissible-btn">' +
              $.createIcon('close') +
              '<span class="audible"> '+ Locale.translate('Close') +'</span>' +
            '</span>'),
          dismissibleClass = '.is-dismissable, .is-dismissible';

        // EPC: Deprecating "dismissable" in favor of "dismissible" as of 4.3.0
        if (self.element.is(dismissibleClass)) {
          self.element.append(btnDismissable);

          // Handle Click
          btnDismissable.on('click.tag', function(event) {
            self.remove(event, self.element);
          });

          // Handle Keyboard
          self.element.on('keydown.tag', function(event) {
            var e = event || window.event;
            if (e.keyCode === 8) { // Backspace
              self.remove(event, this);
            }
          });

        }

      }, // END: Handle Events ---------------------------------------------------------------------

      // Remove from DOM
      remove: function(event, el) {
        el = el instanceof jQuery ? el : $(el);
        var parent = el.parent();
        this.element.triggerHandler('beforetagremove', {event: event, element: el});
        el.remove();
        parent.triggerHandler('aftertagremove', {event: event});
      },

      // Teardown
      destroy: function() {
        this.element.off('keydown.tag');
        $('.dismissable-btn, .dismissible-btn', this.element).off('click.tag').remove();

        $.removeData(this.element[0], pluginName);
      }
    };

    // Initialize the plugin (Once)
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (instance) {
        instance.settings = $.extend({}, instance.settings, options);
        instance.updated();
      } else {
        instance = $.data(this, pluginName, new Tag(this, settings));
      }
    });
  };


  $.fn.textarea = function(options) {

    // Settings and Options
    var pluginName = 'textarea',
        defaults = {
          characterCounter: true, //But needs a maxlength
          printable: true,  //If the text area can be printed
          charRemainingText: null,
          charMaxText: null
        },
        settings = $.extend({}, defaults, options);

    /**
     * @constructor
     * @param {Object} element
     */
    function Textarea(element) {
      this.element = $(element);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    // Plugin Methods
    Textarea.prototype = {

      init: function() {
        this.isChrome = /Chrome/.test(navigator.userAgent) && /Google Inc/.test(navigator.vendor);
        this.isSafari = (
          navigator.userAgent.indexOf('Safari')  !== -1 &&
          navigator.userAgent.indexOf('Chrome') === -1 &&
          navigator.userAgent.indexOf('Android') === -1
        );

        this.element.addClass(this.element.is('.textarea-xs') ? 'input-xs' :
            this.element.is('.textarea-sm') ? 'input-sm' :
            this.element.is('.textarea-lg') ? 'input-lg' : '');

        if (settings.characterCounter && this.element.attr('maxlength')) {
          this.counter = $('<span class="textarea-wordcount">Chars Left..</span>').insertAfter(this.element);
        }
        if (settings.printable) {
          this.printarea = $('<span class="textarea-print"></span>').insertBefore(this.element);
        }
        this.handleEvents();
        this.update(this);
      },

      // Attach Events
      handleEvents: function() {
        var self = this;
        this.element.on('keyup.textarea', function () {
          self.update(self);
        }).on('focus.textarea', function () {
          if (self.counter) {
            self.counter.addClass('focus');
          }
        }).on('keypress.textarea', function (e) {
          var length = self.element.val().length,
          max = self.element.attr('maxlength');

          if ([97, 99, 118, 120].indexOf(e.which) > -1 && (e.metaKey || e.ctrlKey)) {
            self.update(self);
            return;
          }

          if (!self.isPrintable(e.which)) {
            return;
          }

          if (length >= max && !self.isSelected(this)) {
            e.preventDefault();
          }

        })
        .on('blur.textarea', function () {
          self.update(self);
          if (self.counter) {
            self.counter.removeClass('focus');
          }
        });
      },

      isSelected: function (input) {
        if (typeof input.selectionStart === 'number') {
          return input.selectionStart === 0 && input.selectionEnd === input.value.length;
        } else if (typeof document.selection !== 'undefined') {
          input.focus();
          return document.selection.createRange().text === input.value;
        }
      },

      isPrintable: function(keycode) {
        var valid =
          (keycode > 47 && keycode < 58)   || // number keys
          (keycode > 64 && keycode < 91)   || // letter keys
          (keycode > 95 && keycode < 112)  || // numpad keys
          (keycode > 185 && keycode < 193) || // ;=,-./` (in order)
          (keycode > 218 && keycode < 223);   // [\]' (in order)
        return valid;
      },

      // Counts characters
      countLinebreaks: function(s) {
        return (s.match(/\n/g) || []).length;
      },

      update: function (self) {
        var value = self.element.val(),
          isExtraLinebreaks = this.isChrome || this.isSafari,
          length = value.length + (isExtraLinebreaks ? this.countLinebreaks(value) : 0),
          max = self.element.attr('maxlength'),
          remaining = (parseInt(max)-length),
          text = (settings.charRemainingText ? settings.charRemainingText : (Locale.translate('CharactersLeft') === 'CharactersLeft' ? 'Characters Left' : Locale.translate('CharactersLeft'))).replace('{0}', remaining.toString());

        if (self.counter) {
          if (length === 0) {
            text = (settings.charMaxText ? settings.charMaxText : Locale.translate('CharactersMax')) + max;
            self.counter.text(text);
            self.counter.removeClass('almost-empty');
          } else {
            self.counter.text(text);
            if (remaining < 10) {
              self.counter.addClass('almost-empty');
            } else {
              self.counter.removeClass('almost-empty');
            }
          }
        }

        if (self.printarea) {
          self.printarea.text(self.element.val());
        }
      },

      enable: function () {
        this.element.prop('disable', false).prop('readonly', false);
      },

      disable: function () {
        this.element.prop('disable', true);
      },

      readonly: function () {
        this.element.prop('readonly', true);
      },

      // Teardown
      destroy: function() {
        $.removeData(this.element[0], pluginName);
        if (this.printarea && this.printarea.length) {
          this.printarea.remove();
        }
        if (this.counter && this.counter.length) {
          this.counter.remove();
        }
        this.element.off('keyup.textarea');
      }
    };

    // Initialize the plugin (Once)
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (instance) {
        instance.settings = $.extend({}, defaults, options);
      } else {
        instance = $.data(this, pluginName, new Textarea(this, settings));
      }
    });
  };


  $.fn.timepicker = function(options) {
    'use strict';

    // Settings and Options
    var pluginName = 'timepicker',
        defaults = {
          timeFormat: Locale.calendar().timeFormat || 'h:mm a', // The time format
          minuteInterval: 5, // Integer from 1 to 60.  Multiples of this value are displayed as options in the minutes dropdown.
          secondInterval: 5, // Integer from 1 to 60.
          mode: 'standard', // options: 'standard', 'range',
          roundToInterval: false,
          parentElement: null
        },
        settings = $.extend({}, defaults, options);

    /**
     * @constructor
     * @param {Object} element
     */
    function TimePicker(element) {
      this.settings = $.extend({}, settings);
      this.element = $(element);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    // Plugin Methods
    TimePicker.prototype = {

      init: function() {
        this
          .setup()
          .build()
          .handleEvents()
          .roundMinutes();
      },

      // Configure any settings for the Timepicker
      setup: function() {

        function sanitizeIntervals(value, type) {
          if (!type || ['minute', 'second'].indexOf(type) < 0) {
            type = 'minute';
          }

          var defaultInterval = defaults[(type + 'Interval')];
          if (value === undefined || isNaN(value)) {
            return defaultInterval;
          }
          var intValue = parseInt(value, 10);
          return intValue > 0 && intValue < 60 ? intValue : defaultInterval;
        }

        function sanitizeTimeFormat(value) {
          if (!value || (!value.match('h') && !value.match('HH')) || !value.match('mm')) {
            return defaults.timeFormat;
          }

          return value;
        }

        function sanitizeRoundToInterval(value) {
          return value === true;
        }

        function sanitizeMode(value) {
          var modes = ['standard', 'range'];
          return $.inArray(value, modes) > -1 ? value : defaults.mode;
        }

        if (this.element.is('[data-round-to-interval]')) {
          this.settings.roundToInterval = sanitizeRoundToInterval(this.element.attr('data-round-to-interval'));
        }
        if (this.element.is('[data-minute-interval]')) {
          this.settings.minuteInterval = sanitizeIntervals(this.element.attr('data-minute-interval'), 'minute');
        }

        this.settings.timeFormat = sanitizeTimeFormat(parseInt(this.element.attr('data-force-hour-mode')) === 24 ? 'HH:mm' : this.settings.timeFormat);
        this.settings.minuteInterval = sanitizeIntervals(this.settings.minuteInterval, 'minute');
        this.settings.secondInterval = sanitizeIntervals(this.settings.secondInterval, 'second');
        this.settings.mode = sanitizeMode(this.settings.mode);
        this.settings.roundToInterval = sanitizeRoundToInterval(this.settings.roundToInterval);

        this.dayPeriods = Locale.calendar().dayPeriods;

        return this;
      },

      //Add any markup
      build: function() {
        //With this option forgoe the input and append the dropdowns/popup to the parent element
        if (this.settings.parentElement) {
          this.trigger = $();
          this.buildStandardPopup();
          this.setupStandardEvents();
          return this;
        }

        //Append a Button
        this.trigger = this.element.next('svg.icon');
        if (this.trigger.length === 0) {
          this.trigger = $.createIconElement('clock').insertAfter(this.element);
        }

        this.addAria();

        // Add Mask and Validation plugins for time
        this.mask();

        return this;
      },

      addAria: function () {
        this.element.attr({
          'aria-expanded': 'false',
          'role': 'combobox'
        });

        //TODO: Confirm this with Accessibility Team
        this.label = $('label[for="'+ this.element.attr('id') + '"]');
        this.label.append('<span class="audible">' + Locale.translate('UseArrow') + '</span>');
      },

      //Attach Events used by the Control
      handleEvents: function () {
        var self = this;
        this.trigger.onTouchClick('timepicker').on('click.timepicker', function () {
          self.toggleTimePopup();
        });

        this.handleKeys();
        this.handleBlur();

        return this;
      },

      handleKeys: function() {
        var self = this;

        this.element.on('keydown.timepicker', function (e) {
          var handled = false;

          // Esc closes an open popup with no action
          if (e.which === 27 && self.isOpen()) {
            handled = true;
            self.closeTimePopup();
          }

          //Arrow Down or Alt first opens the dialog
          if (e.which === 40 && !self.isOpen()) {
            handled = true;
            self.openTimePopup();
          }

          if (handled) {
            e.stopPropagation();
            e.preventDefault();
            return false;
          }
        });
      },

      handleBlur: function() {
        var self = this;

        this.element.on('blur.timepicker', function() {
          self.roundMinutes();

          // The action of closing the popup menu is set on a timer because technically there are no fields focused
          // on frame 0 of the popup menu's existence, which would cause it to close immediately on open.
          setTimeout(function() {
            if (self.isOpen() && self.popup.find(':focus').length === 0) {
              self.closeTimePopup();
            }
          }, 20);
        });
      },

      is24HourFormat: function(value) {
        if (!value) { value = this.settings.timeFormat; }
        return (value.match('HH') || []).length > 0;
      },

      hasSeconds: function(value) {
        if (!value) { value = this.settings.timeFormat; }
        return (value.match('ss') || []).length > 0;
      },

      getTimeSeparator: function() {
        return Locale.calendar().dateFormat.timeSeparator;
      },

      roundMinutes: function() {
        if (!this.getBoolean(this.settings.roundToInterval)) {
          return;
        }

        // separate out the minutes value from the rest of the value.
        var val = this.element.val(),
          timeSeparator = this.getTimeSeparator(),
          parts = val ? val.split(timeSeparator) : [],
          interval = this.settings.minuteInterval;

        if (!parts[1]) {
          return;
        }

        if (!this.is24HourFormat(this.settings.timeFormat)) {
          var periodParts = parts[1].split(' ');
          parts[1] = periodParts[0];
          if (periodParts[1]) {
            parts.push(periodParts[1]);
          }
        }

        parts[1] = parseInt(parts[1], 10);
        if (parts[1] % interval === 0) {
          return;
        }

        parts[1] = Math.round(parts[1] / interval) * interval;

        parts[1] = parts[1].toString();
        parts[1] = (parts[1].length < 2 ? '0' : '') + parts[1];

        if (parts[1] === '60') {
          parts[1] = '00';
          parts[0] = (parseInt(parts[0]) + 1).toString();
        }

        var newVal = parts[0] + timeSeparator + parts[1] + ' ' + (parts[2] ? parts[2] : '');
        this.element.val(newVal);
      },

      // Add masking with the mask function
            mask: function () {
        if (this.element.data('mask') && typeof this.element.data('mask') === 'object') {
          this.element.data('mask').destroy();
        }
        this.element.data('mask', undefined);

        var timeSeparator = this.getTimeSeparator(),
          mask = '##' + timeSeparator + '##' + (this.hasSeconds() ? timeSeparator + '##' : '') + (!this.is24HourFormat() ? ' am' : ''),
          maskMode = 'group',
          validation = 'time',
          events = {'time': 'blur'},
          customValidation = this.element.attr('data-validate'),
          customEvents = this.element.attr('data-validation-events');

        if (customValidation === 'required' && !customEvents) {
            validation = customValidation + ' ' + validation;
            $.extend(events, {
                'required': 'change blur'
            });
        } else if (!!customValidation && !!customEvents) {
            // Remove default validation, if found "no-default-validation" string in "data-validate" attribute
            if (customValidation.indexOf('no-default-validation') > -1) {
                validation = customValidation.replace(/no-default-validation/g, '');
                events = $.fn.parseOptions(this.element, 'data-validation-events');
            }
                // Keep default validation along custom validation
            else {
                validation = customValidation + ' ' + validation;
                $.extend(events, $.fn.parseOptions(this.element, 'data-validation-events'));
            }
        }

        this.element
          .attr('data-validate', validation)
          .attr('data-validation-events', JSON.stringify(events))
          .mask({
            pattern: mask,
            mode: maskMode
          })
          .validate()
          .triggerHandler('updated');
      },

      buildStandardPopup: function() {
        var self = this,
          popupContent = $('<div class="timepicker-popup-content"></div>'),
          timeSeparator = this.getTimeSeparator(),
          textValue = '',
          secondSelect,
          selected;

        this.initValues = self.getTimeFromField();
        var timeParts = $('<div class="time-parts"></div>').appendTo(popupContent);

        // Build the inner-picker HTML
        var is24HourFormat = this.is24HourFormat(),
          hasSeconds = this.hasSeconds(),
          hourCounter = is24HourFormat ? 0 : 1,
          maxHourCount = is24HourFormat ? 24 : 13;

        this.hourSelect = $('<select id="timepicker-hours" class="hours dropdown"></select>');

        while(hourCounter < maxHourCount) {
          selected = '';
          if (parseInt(self.initValues.hours, 10)  === hourCounter) {
            selected = ' selected';
          }
          self.hourSelect.append($('<option' + selected + '>' + hourCounter + '</option>'));
          hourCounter++;
        }
        timeParts.append($('<label for="timepicker-hours" class="audible">' + Locale.translate('Hours') + '</label>'));
        timeParts.append(this.hourSelect);
        timeParts.append($('<span class="label colons">'+ timeSeparator +'</span>'));

        // Minutes Picker
        var minuteCounter = 0;
        this.minuteSelect = $('<select id="timepicker-minutes" class="minutes dropdown"></select>');

        while(minuteCounter <= 59) {
          textValue = minuteCounter < 10 ? '0' + minuteCounter : minuteCounter;

          selected = '';
          if (parseInt(self.initValues.minutes, 10) === minuteCounter) {
            selected = ' selected';
          }
          self.minuteSelect.append($('<option' + selected + '>' + textValue + '</option>'));
          minuteCounter = minuteCounter + self.settings.minuteInterval;
        }

        // If the value inside the picker doesn't match an interval, add the value as the currently selected option, right at the top
        if (!this.minuteSelect.find('option[selected]').length) {
          this.minuteSelect.prepend($('<option selected>' + self.initValues.minutes + '</option>'));
        }

        timeParts.append($('<label for="timepicker-minutes" class="audible">' + Locale.translate('Minutes') + '</label>'));
        timeParts.append(this.minuteSelect);

        // Seconds Picker
        if (hasSeconds) {
          var secondCounter = 0;
          secondSelect = $('<select id="timepicker-seconds" class="seconds dropdown"></select>');

          while(secondCounter <= 59) {
            textValue = secondCounter < 10 ? '0' + secondCounter : secondCounter;

            selected = '';
            if (parseInt(self.initValues.seconds, 10) === secondCounter || (!self.initValues.seconds && textValue === '00')) {
              selected = ' selected';
            }
            secondSelect.append($('<option' + selected + '>' + textValue + '</option>'));
            secondCounter = secondCounter + self.settings.secondInterval;
          }

          // If the value inside the picker doesn't match an interval, add the value as the currently selected option, right at the top
          if (!secondSelect.find('option[selected]').length) {
            secondSelect.prepend($('<option selected>' + self.initValues.seconds + '</option>'));
          }

          timeParts.append($('<span class="label colons">'+ timeSeparator +'</span>'));
          timeParts.append($('<label for="timepicker-seconds" class="audible">' + Locale.translate('Seconds') + '</label>'));
          timeParts.append(secondSelect);
        }

        this.periodSelect = $('<select id="timepicker-period" class="period dropdown"></select>');
        if (!is24HourFormat) {
          timeParts.append($('<span class="label colons"></span>'));
          var localeDays = Locale.calendar().dayPeriods,
            localeCount = 0,
            regexDay = new RegExp(self.initValues.period, 'i'),
            realDayValue = 'AM'; // AM

          while(localeCount < 2) {
            realDayValue = localeCount === 0 ? 'AM' : 'PM';  // ? AM : PM
            selected = '';
            if (regexDay.test(localeDays[localeCount])) {
              selected = ' selected';
            }
            this.periodSelect.append($('<option value="' + realDayValue + '"'+ selected +'>' + localeDays[localeCount] + '</option>'));

            localeCount++;
          }
          timeParts.append($('<label for="timepicker-period" class="audible">' + Locale.translate('TimePeriod') + '</label>'));
          timeParts.append(this.periodSelect);
        }

        if (this.settings.parentElement) {
          this.settings.parentElement.append(popupContent);
          //self.afterShow(this.settings.parentElement);
          self.popup = this.settings.parentElement.find('.timepicker-popup-content').addClass('timepicker-popup').attr('id', 'timepicker-popup');
        } else {

          popupContent.append('<div class="modal-buttonset"><button type="button" class="btn-modal-primary set-time">' + Locale.translate('SetTime') + '</button></div>');

          var placementParent = this.element,
            placementParentXAlignment = (Locale.isRTL() ? 'right' : 'left'),
            parent = this.element.parent();

          if (parent.is('.datagrid-cell-wrapper')) {
            placementParentXAlignment = 'center';
            placementParent = this.element.next('.icon');
          }

          this.trigger.popover({
            content: popupContent,
            trigger: 'immediate',
            placement: 'bottom',
            placementOpts: {
              parent: placementParent,
              parentXAlignment: placementParentXAlignment,
              strategies: ['flip', 'nudge', 'shrink']
            },
            tooltipElement: '#timepicker-popup'})
          .on('show.timepicker', function(e, ui) {
            self.afterShow(ui);
          }).on('hide.timepicker', function() {
            self.element.focus();
          });
        }

        // Make adjustments to the popup HTML specific to the timepicker
        if (this.trigger.data('tooltip')) {
          var tooltip = self.popup = this.trigger.data('tooltip').tooltip;
          tooltip.addClass('timepicker-popup');
        }
      },

      afterShow: function (ui) {
        var self = this;

        ui.find('button').button();

        // Set default values based on what's retrieved from the Timepicker's input field.
        this.hourSelect.val(this.initValues.hours);
        this.hourSelect.data('dropdown').pseudoElem.find('span').text(this.initValues.hours);
        this.minuteSelect.val(this.initValues.minutes);
        this.minuteSelect.data('dropdown').pseudoElem.find('span').text(this.initValues.minutes);

        if (!self.is24HourFormat()) {
          this.periodSelect.val(this.initValues.period);
          this.periodSelect.data('dropdown').pseudoElem.find('span').text(this.initValues.period);
        }

        ui.find('div.dropdown').first().focus();
        ui.find('.set-time').off('click.timepicker').onTouchClick('timepicker').on('click.timepicker', function(e) {
          e.preventDefault();
          self.setTimeOnField();
          self.closeTimePopup();
        });
      },

      setupStandardEvents: function() {
        var self = this;

        self.popup.on('touchend.timepicker touchcancel.timepicker', '.set-time', function(e) {
          e.preventDefault();
          e.target.click();
        }).on('keydown.timepicker', 'input.dropdown', function(e) {
          var handled = false;

          // Pressing Esc when focused on a closed dropdown menu causes the entire popup to close.
          if (e.which === 27) {
            handled = true;
            self.closeTimePopup();
            self.element.focus();
          }

          // Pressing Spacebar while the popup is open submits with the new time value.
          if (e.which === 32) {
            handled = true;
            self.popup.find('.set-time').click();
          }

          // Left & Right Arrows will switch between the available dropdowns
          if (e.which === 37 || e.which === 39) {
            handled = true;
            var inputs = self.popup.find('input[id$="-shdo"]');

            if (e.which === 37) {
              var prev = inputs.eq(inputs.index(this) - 1);
              if (!prev || prev.length === 0) {
                prev = inputs.eq(inputs.length);
              }
              prev.focus();
            }

            if (e.which === 39) {
              var next = inputs.eq(inputs.index(this) + 1);
              if (!next || next.length === 0) {
                next = inputs.eq(0);
              }
              next.focus();
            }
          }

          if (handled) {
            e.preventDefault();
            e.stopPropagation();
            return false;
          }
        });

        // Listen to the popover/tooltip's "hide" event to properly close out the popover's inner controls.
        self.trigger.on('hide.timepicker', function() {
          self.onPopupHide();
        });
      },

      buildRangePopup: function() {
        // TODO: Build this
      },

      setupRangeEvents: function() {
        // TODO: Build this
      },

      getTimeFromField: function(value) {
        var self = this,
          val = value || this.element.val(),
          sep = this.getTimeSeparator(),
          parts = val.split(sep),
          endParts,
          timeparts = {};

        // Check the last element in the array for a time period, and add it as an array
        // member if necessary
        if (!this.is24HourFormat()) {
          endParts = parts[parts.length - 1].split(' ');
          parts.pop();
          parts = parts.concat(endParts);
        }

        function isDayPeriod(value) {
          return self.dayPeriods.indexOf(value) > -1;
        }

        function removeLeadingWhitespace(value) {
          return value.replace(/^\s+|\s+$/g, '');
        }

        function addLeadingZero(value) {
          if (!value || isNaN(value)) {
            return '00';
          }
          value = parseInt(value);
          value = value < 10 ? '0' + value : value;
          return value;
        }

        // Handle Hours
        if (!parts[0] || !parts[0].length || isNaN(parts[0])) {
          parts[0] = '1';
        }

        parts[0] = parseInt(parts[0], 10);
        if (isNaN(parts[0])) {

        } else {
          parts[0] = '' + parseInt(parts[0], 10);
        }
        timeparts.hours = parts[0];

        // Handle Minutes
        if (parts[1]) {
          // remove leading whitespace
          parts[1] = removeLeadingWhitespace(parts[1]);
          parts[1] = addLeadingZero(parts[1]);
          timeparts.minutes = parts[1];
        } else {
          timeparts.minutes = '00';
        }

        // Handle Seconds/Period (slot 3)
        function handleSlot2(value) {
          // Should not kick off at all if we don't pass it a value, OR if this field is 24-hour display with no seconds
          if (!value) {
            if (!self.is24HourFormat()) {
              if (self.hasSeconds()) {
                value = '00';
                timeparts.seconds = value;
              } else {
                value = Locale.translateDayPeriod('AM');
                timeparts.period = value;
              }
            }

            return value;
          }

          value = removeLeadingWhitespace(value);

          // Has seconds
          if (self.hasSeconds()) {
            value = addLeadingZero(value);
            timeparts.seconds = value;
            return value;
          }
          // No seconds, but has a day period
          if (!isDayPeriod(value)) {
            value = Locale.translateDayPeriod('AM');
          }
          timeparts.period = value;
          return;
        }
        handleSlot2(parts[2]);

        // Handle Period after seconds (slot 4)
        if (parts[3]) {
          parts[3] = removeLeadingWhitespace(parts[3]);
          timeparts.period = parts[3];
        } else {
          if (!this.is24HourFormat() && this.hasSeconds()) {
            timeparts.period = Locale.translateDayPeriod('AM');
          }
        }

        return timeparts;
      },

      setTimeOnField: function() {
        var hours = $('#timepicker-hours').val() || '',
          minutes = $('#timepicker-minutes').val() || '',
          seconds = $('#timepicker-seconds').val() || '',
          period = ($('#timepicker-period').val() || '').toUpperCase(),
          sep = this.getTimeSeparator(),
          timeString = '' + hours + sep + minutes + (this.hasSeconds() ? sep + seconds : '');

        period = (!this.is24HourFormat() && period === '') ? $('#timepicker-period-shdo').val() : period;
        timeString += period ? ' ' + Locale.translateDayPeriod(period) : '';

        this.element.val(timeString)
          .trigger('change');

        this.element
          .focus();
      },

      // Return whether or not the calendar div is open.
      isOpen: function () {
        return (this.popup && !this.popup.hasClass('is-hidden'));
      },

      openTimePopup: function() {
        var self = this;

        // Get all current settings.
        self.setup();

        if (this.element.is(':disabled') || this.element.attr('readonly')) {
          return;
        }

        if (this.popup && !this.popup.hasClass('is-hidden')) {
          self.closeTimePopup();
        }

        this.element.addClass('is-active');

        // Build a different Time Popup based on settings
        if (self.settings.mode === 'range') {
          self.buildRangePopup();
          self.setupRangeEvents();
        } else {
          self.buildStandardPopup();
          self.setupStandardEvents();
        }

        this.element.attr({'aria-expanded': 'true'});
        this.popup.find('div.dropdown').first().focus();
      },

      // Triggers the "hide" method on the tooltip plugin.  The Timepicker officially "closes" after the popover's
      // hide event fully completes because certain events need to be turned off and certain markup needs to be
      // removed only AFTER the popover is hidden.
      closeTimePopup: function() {

        if (this.trigger.data('tooltip')) {
          this.trigger.data('tooltip').hide();
        }

      },

      // This gets fired on the popover's "hide" event
      onPopupHide: function() {
        if (this.settings.mode === 'standard') {
          $('#timepicker-hours').data('dropdown').destroy();
          $('#timepicker-minutes').data('dropdown').destroy();
          if (this.hasSeconds()) {
            $('#timepicker-seconds').data('dropdown').destroy();
          }
          if (!this.is24HourFormat()) {
            $('#timepicker-period').data('dropdown').destroy();
          }
          this.popup.off('click.timepicker touchend.timepicker touchcancel.timepicker keydown.timepicker');
        }
        this.element.attr({'aria-expanded': 'false'});
        this.trigger.off('hide.timepicker show.timepicker');
        this.trigger.data('tooltip').destroy();
        this.trigger.data('tooltip', undefined);
        $('#timepicker-popup').remove();
        this.element.removeClass('is-active');
      },

      toggleTimePopup: function() {
        if (this.isOpen()) {
          this.closeTimePopup();
        } else {
          this.openTimePopup();
        }
      },

      // Getter for retrieving the value of the timefield
      // Optional parameter 'removePunctuation' that gets rid of all the value's punctatuion on return.
      value: function(removePunctuation) {
        var val = this.element.val();
        if (!removePunctuation || removePunctuation === false) {
          return val;
        }

        var timeSeparator = Locale.calendar().dateFormat.timeSeparator,
          sepRegex = new RegExp(timeSeparator, 'g');

        // Remove punctuation
        val = val.replace(sepRegex, '');

        // Add leading zero for times without a double digit hour
        var parts = val.split(' ');
        if (parts[0].length < 4) {
          val = '0' + parts[0] + (parts[1] ? parts[1] : '');
        }

        return val;
      },

      enable: function() {
        this.element.prop('disabled', false);
      },

      disable: function() {
        this.element.prop('disabled', true);
      },

      isDisabled: function() {
        return this.element.prop('disabled');
      },

      // Convert a string to boolean
      getBoolean: function(val) {
        var num = +val;
        return !isNaN(num) ? !!num : !!String(val).toLowerCase().replace(!!0, '');
      },

      updated: function() {
        return this
          .teardown()
          .init();
      },

      teardown: function() {
        this.trigger.off('keydown.timepicker');
        this.element.off('focus.timepicker blur.timepicker keydown.timepicker');
        if (this.popup) {
          this.closeTimePopup();
        }

        this.trigger.remove();

        var mask = this.element.data('mask');
        if (mask && typeof mask.destroy === 'function') {
          mask.destroy();
        }

        this.label.find('.audible').remove();

        return this;
      },

      // Teardown
      destroy: function() {
        this.teardown();
        $.removeData(this.element[0], 'validate');
        $.removeData(this.element[0], pluginName);
      }
    };

    // Initialize the plugin (Once)
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (instance) {
        instance.settings = $.extend({}, instance.settings, options);
        instance.updated();
      } else {
        instance = $.data(this, pluginName, new TimePicker(this, settings));
      }
    });
  };

/**
 *  Copyright 2011 Twitter, Inc.
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 *  @private
 */


  var Tmpl = window.Tmpl = {};

  Tmpl.Template = function (codeObj, text, compiler, options) {
    codeObj = codeObj || {};
    this.r = codeObj.code || this.r;
    this.c = compiler;
    this.options = options || {};
    this.text = text || '';
    this.partials = codeObj.partials || {};
    this.subs = codeObj.subs || {};
    this.buf = '';
  };

  // Setup regex  assignments
  // remove whitespace according to Mustache spec
  var rIsWhitespace = /\S/,
      rNewline =  /\n/g,
      rCr = /\r/g,
      rSlash = /\\/g,
      rLineSep = /\u2028/,
      rParagraphSep = /\u2029/;

  var rAmp = /&/g,
      rLt = /</g,
      rGt = />/g,
      rApos = /\'/g,
      rQuot = /\"/g,
      hChars = /[&<>\"\']/;

  //Find a key in an object
  function findInScope(key, scope, doModelGet) {
    var val;

    if (scope && typeof scope === 'object') {

      if (scope[key] !== undefined) {
        val = scope[key];

      // try lookup with get for backbone or similar model data
      } else if (doModelGet && scope.get && typeof scope.get === 'function') {
        val = scope.get(key);
      }
    }

    return val;
  }

  function write(s) {
    return 't.b(' + s + ');';
  }

  function isOpener(token, tags) {
    for (var i = 0, l = tags.length; i < l; i++) {
      if (tags[i].o === token.n) {
        token.tag = '#';
        return true;
      }
    }
  }

  function isCloser(close, open, tags) {
    for (var i = 0, l = tags.length; i < l; i++) {
      if (tags[i].c === close && tags[i].o === open) {
        return true;
      }
    }
  }

  function esc(s) {
    return s.replace(rSlash, '\\\\')
            .replace(rQuot, '\\\'')
            .replace(rNewline, '\\n')
            .replace(rCr, '\\r')
            .replace(rLineSep, '\\u2028')
            .replace(rParagraphSep, '\\u2029');
  }

  function createSpecializedPartial(instance, subs, partials, stackSubs, stackPartials, stackText) {
    function PartialTemplate() {}
    PartialTemplate.prototype = instance;
    function Substitutions() {}
    Substitutions.prototype = instance.subs;
    var key;
    var partial = new PartialTemplate();
    partial.subs = new Substitutions();
    partial.subsText = {};  //hehe. substext.
    partial.buf = '';

    stackSubs = stackSubs || {};
    partial.stackSubs = stackSubs;
    partial.subsText = stackText;
    for (key in subs) {
      if (!stackSubs[key]) {
        stackSubs[key] = subs[key];
      }
    }
    for (key in stackSubs) {
      partial.subs[key] = stackSubs[key];
    }

    stackPartials = stackPartials || {};
    partial.stackPartials = stackPartials;
    for (key in partials) {
      if (!stackPartials[key]) {
       stackPartials[key] = partials[key];
      }
    }
    for (key in stackPartials) {
      partial.partials[key] = stackPartials[key];
    }

    return partial;
  }

  function coerceToString(val) {
    return String((val === null || val === undefined) ? '' : val);
  }

  function cleanTripleStache(token) {
    if (token.n.substr(token.n.length - 1) === '}') {
      token.n = token.n.substring(0, token.n.length - 1);
    }
  }

  function trim(s) {
    if (s.trim) {
      return s.trim();
    }

    return s.replace(/^\s*|\s*$/g, '');
  }

  function tagChange(tag, text, index) {
    if (text.charAt(index) !== tag.charAt(0)) {
      return false;
    }

    for (var i = 1, l = tag.length; i < l; i++) {
      if (text.charAt(index + i) !== tag.charAt(i)) {
        return false;
      }
    }
    return true;
  }

  function TmplEscape(str) {
    str = coerceToString(str);
    return hChars.test(str) ?
      str
        .replace(rAmp, '&amp;')
        .replace(rLt, '&lt;')
        .replace(rGt, '&gt;')
        .replace(rApos, '&#39;')
        .replace(rQuot, '&quot;') :
      str;
  }

  Tmpl.Template.prototype = {
    // render: replaced by generated code.
    r: function (context, partials, indent) { return ''; }, // jshint ignore:line

    // variable escaping
    v: TmplEscape,

    // triple stache
    t: coerceToString,

    render: function render(context, partials, indent) {
      return this.ri([context], partials || {}, indent);
    },

    // render internal -- a hook for overrides that catches partials too
    ri: function (context, partials, indent) {
      return this.r(context, partials, indent);
    },

    // ensurePartial
    ep: function(symbol, partials) {
      var partial = this.partials[symbol];

      // check to see that if we've instantiated this partial before
      var template = partials[partial.name];
      if (partial.instance && partial.base === template) {
        return partial.instance;
      }

      if (typeof template === 'string') {
        if (!this.c) {
          throw new Error('No compiler available.');
        }
        template = this.c.compile(template, this.options);
      }

      if (!template) {
        return null;
      }

      // We use this to check whether the partials dictionary has changed
      this.partials[symbol].base = template;

      if (partial.subs) {
        // Make sure we consider parent template now
        if (!partials.stackText) {
          partials.stackText = {};
        }
        for (var key in partial.subs) {
          if (!partials.stackText[key]) {
            partials.stackText[key] = (this.activeSub !== undefined && partials.stackText[this.activeSub]) ? partials.stackText[this.activeSub] : this.text;
          }
        }
        template = createSpecializedPartial(template, partial.subs, partial.partials,
          this.stackSubs, this.stackPartials, partials.stackText);
      }
      this.partials[symbol].instance = template;

      return template;
    },

    // tries to find a partial in the current scope and render it
    rp: function(symbol, context, partials, indent) {
      var partial = this.ep(symbol, partials);
      if (!partial) {
        return '';
      }

      return partial.ri(context, partials, indent);
    },

    // render a section
    rs: function(context, partials, section) {
      var tail = context[context.length - 1];

      if (!$.isArray(tail)) {
        section(context, partials, this);
        return;
      }

      for (var i = 0; i < tail.length; i++) {
        context.push(tail[i]);
        section(context, partials, this);
        context.pop();
      }
    },

    // maybe start a section
    s: function(val, ctx, partials, inverted, start, end, tags) {
      var pass;

      if ($.isArray(val) && val.length === 0) {
        return false;
      }

      if (typeof val === 'function') {
        val = this.ms(val, ctx, partials, inverted, start, end, tags);
      }

      pass = !!val;

      if (!inverted && pass && ctx) {
        ctx.push((typeof val === 'object') ? val : ctx[ctx.length - 1]);
      }

      return pass;
    },

    // find values with dotted names
    d: function(key, ctx, partials, returnFound) {
      var found,
          names = key.split('.'),
          val = this.f(names[0], ctx, partials, returnFound),
          doModelGet = this.options.modelGet,
          cx = null;

      if (key === '.' && $.isArray(ctx[ctx.length - 2])) {
        val = ctx[ctx.length - 1];
      } else {
        for (var i = 1; i < names.length; i++) {
          found = findInScope(names[i], val, doModelGet);
          if (found !== undefined) {
            cx = val;
            val = found;
          } else {
            val = '';
          }
        }
      }

      if (returnFound && !val) {
        return false;
      }

      if (!returnFound && typeof val === 'function') {
        ctx.push(cx);
        val = this.mv(val, ctx, partials);
        ctx.pop();
      }

      return val;
    },

    // find values with normal names
    f: function(key, ctx, partials, returnFound) {
      var val = false,
          v = null,
          found = false,
          doModelGet = this.options.modelGet;

      for (var i = ctx.length - 1; i >= 0; i--) {
        v = ctx[i];
        val = findInScope(key, v, doModelGet);
        if (val !== undefined) {
          found = true;
          break;
        }
      }

      if (!found) {
        return (returnFound) ? false : '';
      }

      if (!returnFound && typeof val === 'function') {
        val = this.mv(val, ctx, partials);
      }

      return val;
    },

    // higher order templates
    ls: function(func, cx, partials, text, tags) {
      var oldTags = this.options.delimiters;

      this.options.delimiters = tags;
      this.b(this.ct(coerceToString(func.call(cx, text)), cx, partials));
      this.options.delimiters = oldTags;

      return false;
    },

    // compile text
    ct: function(text, cx, partials) {
      if (this.options.disableLambda) {
        throw new Error('Lambda features disabled.');
      }
      return this.c.compile(text, this.options).render(cx, partials);
    },

    // template result buffering
    b: function(s) { this.buf += s; },

    fl: function() { var r = this.buf; this.buf = ''; return r; },

    // method replace section
    ms: function(func, ctx, partials, inverted, start, end, tags) {
      var textSource,
          cx = ctx[ctx.length - 1],
          result = func.call(cx);

      if (typeof result === 'function') {
        if (inverted) {
          return true;
        } else {
          textSource = (this.activeSub && this.subsText && this.subsText[this.activeSub]) ? this.subsText[this.activeSub] : this.text;
          return this.ls(result, cx, partials, textSource.substring(start, end), tags);
        }
      }

      return result;
    },

    // method replace variable
    mv: function(func, ctx, partials) {
      var cx = ctx[ctx.length - 1];
      var result = func.call(cx);

      if (typeof result === 'function') {
        return this.ct(coerceToString(result.call(cx)), cx, partials);
      }

      return result;
    },

    sub: function(name, context, partials, indent) {
      var f = this.subs[name];
      if (f) {
        this.activeSub = name;
        f(context, partials, this, indent);
        this.activeSub = false;
      }
    }
  };

  Tmpl.tags = {
    '#': 1, '^': 2, '<': 3, '$': 4,
    '/': 5, '!': 6, '>': 7, '=': 8, '_v': 9,
    '{': 10, '&': 11, '_t': 12
  };

  Tmpl.scan = function scan(text, delimiters) {
    var len = text.length,
        IN_TEXT = 0,
        IN_TAG_TYPE = 1,
        IN_TAG = 2,
        state = IN_TEXT,
        tagType = null,
        tag = null,
        buf = '',
        tokens = [],
        seenTag = false,
        i = 0,
        lineStart = 0,
        otag = '{{',
        ctag = '}}';

    function addBuf() {
      if (buf.length > 0) {
        tokens.push({tag: '_t', text: new String(buf)}); // jshint ignore:line
        buf = '';
      }
    }

    function lineIsWhitespace() {
      var isAllWhitespace = true;
      for (var j = lineStart; j < tokens.length; j++) {
        isAllWhitespace =
          (Tmpl.tags[tokens[j].tag] < Tmpl.tags._v) ||
          (tokens[j].tag == '_t' && tokens[j].text.match(rIsWhitespace) === null); // jshint ignore:line
        if (!isAllWhitespace) {
          return false;
        }
      }

      return isAllWhitespace;
    }

    function filterLine(haveSeenTag, noNewLine) {
      addBuf();

      if (haveSeenTag && lineIsWhitespace()) {
        for (var j = lineStart, next; j < tokens.length; j++) {
          if (tokens[j].text) {
            if ((next = tokens[j+1]) && next.tag === '>') {
              // set indent to token value
              next.indent = tokens[j].text.toString();
            }
            tokens.splice(j, 1);
          }
        }
      } else if (!noNewLine) {
        tokens.push({tag:'\n'});
      }

      seenTag = false;
      lineStart = tokens.length;
    }

    function changeDelimiters(text, index) {
      var close = '=' + ctag,
          closeIndex = text.indexOf(close, index),
          delimiters = trim(
            text.substring(text.indexOf('=', index) + 1, closeIndex)
          ).split(' ');

      otag = delimiters[0];
      ctag = delimiters[delimiters.length - 1];

      return closeIndex + close.length - 1;
    }

    if (delimiters) {
      delimiters = delimiters.split(' ');
      otag = delimiters[0];
      ctag = delimiters[1];
    }

    for (i = 0; i < len; i++) {
      if (state === IN_TEXT) {
        if (tagChange(otag, text, i)) {
          --i;
          addBuf();
          state = IN_TAG_TYPE;
        } else {
          if (text.charAt(i) === '\n') {
            filterLine(seenTag);
          } else {
            buf += text.charAt(i);
          }
        }
      } else if (state === IN_TAG_TYPE) {
        i += otag.length - 1;
        tag = Tmpl.tags[text.charAt(i + 1)];
        tagType = tag ? text.charAt(i + 1) : '_v';
        if (tagType === '=') {
          i = changeDelimiters(text, i);
          state = IN_TEXT;
        } else {
          if (tag) {
            i++;
          }
          state = IN_TAG;
        }
        seenTag = i;
      } else {
        if (tagChange(ctag, text, i)) {
          tokens.push({tag: tagType, n: trim(buf), otag: otag, ctag: ctag,
                       i: (tagType === '/') ? seenTag - otag.length : i + ctag.length});
          buf = '';
          i += ctag.length - 1;
          state = IN_TEXT;
          if (tagType === '{') {
            if (ctag === '}}') {
              i++;
            } else {
              cleanTripleStache(tokens[tokens.length - 1]);
            }
          }
        } else {
          buf += text.charAt(i);
        }
      }
    }

    filterLine(seenTag, true);
    return tokens;
  };

  // the tags allowed inside super templates
  var allowedInSuper = {'_t': true, '\n': true, '$': true, '/': true};

  function buildTree(tokens, kind, stack, customTags) {
    var instructions = [],
        opener = null,
        tail = null,
        token = null;

    tail = stack[stack.length - 1];

    while (tokens.length > 0) {
      token = tokens.shift();

      if (tail && tail.tag === '<' && !(token.tag in allowedInSuper)) {
        throw new Error('Illegal content in < super tag.');
      }

      if (Tmpl.tags[token.tag] <= Tmpl.tags.$ || isOpener(token, customTags)) {
        stack.push(token);
        token.nodes = buildTree(tokens, token.tag, stack, customTags);
      } else if (token.tag === '/') {
        if (stack.length === 0) {
          throw new Error('Closing tag without opener: /' + token.n);
        }
        opener = stack.pop();
        if (token.n !== opener.n && !isCloser(token.n, opener.n, customTags)) {
          throw new Error('Nesting error: ' + opener.n + ' vs. ' + token.n);
        }
        opener.end = token.i;
        return instructions;
      } else if (token.tag === '\n') {
        token.last = (tokens.length === 0) || (tokens[0].tag === '\n');
      }

      instructions.push(token);
    }

    if (stack.length > 0) {
      throw new Error('missing closing tag: ' + stack.pop().n);
    }

    return instructions;
  }

  function stringifySubstitutions(obj) {
    var items = [];
    for (var key in obj) {
      items.push('"' + esc(key) + '": function(c,p,t,i) {' + obj[key] + '}');
    }
    return '{ ' + items.join(',') + ' }';
  }

  function stringifyPartials(codeObj) {
    var partials = [];
    for (var key in codeObj.partials) {
      partials.push('"' + esc(key) + '":{name:"' + esc(codeObj.partials[key].name) + '", ' + stringifyPartials(codeObj.partials[key]) + '}');
    }
    return 'partials: {' + partials.join(',') + '}, subs: ' + stringifySubstitutions(codeObj.subs);
  }

  Tmpl.stringify = function(codeObj, text, options) { // jshint ignore:line
    return '{code: function (c,p,i) { ' + Tmpl.wrapMain(codeObj.code) + ' },' + stringifyPartials(codeObj) +  '}';
  };

  var serialNo = 0;
  Tmpl.generate = function(tree, text, options) {
    serialNo = 0;
    var context = { code: '', subs: {}, partials: {} };
    Tmpl.walk(tree, context);

    if (options.asString) {
      return this.stringify(context, text, options);
    }

    return this.makeTemplate(context, text, options);
  };

  Tmpl.wrapMain = function(code) {
    return 'var t=this;t.b(i=i||"");' + code + 'return t.fl();';
  };

  Tmpl.template = Tmpl.Template;

  Tmpl.makeTemplate = function(codeObj, text, options) {
    var template = this.makePartials(codeObj);
    template.code = new Function('c', 'p', 'i', this.wrapMain(codeObj.code)); // jshint ignore:line
    return new this.template(template, text, this, options);
  };

  Tmpl.makePartials = function(codeObj) {
    var key, template = {subs: {}, partials: codeObj.partials, name: codeObj.name};
    for (key in template.partials) {
      template.partials[key] = this.makePartials(template.partials[key]);
    }
    for (key in codeObj.subs) {
      template.subs[key] = new Function('c', 'p', 't', 'i', codeObj.subs[key]); // jshint ignore:line
    }
    return template;
  };

  function chooseMethod(s) {
    return (~s.indexOf('.')) ? 'd' : 'f';
  }

  function createPartial(node, context) {
    var prefix = '<' + (context.prefix || '');
    var sym = prefix + node.n + serialNo++;
    context.partials[sym] = {name: node.n, partials: {}};
    context.code += 't.b(t.rp("' +  esc(sym) + '",c,p,"' + (node.indent || '') + '"));';
    return sym;
  }

  function tripleStache(node, context) {
    context.code += 't.b(t.t(t.' + chooseMethod(node.n) + '("' + esc(node.n) + '",c,p,0)));';
  }

  Tmpl.codegen = {
    '#': function(node, context) {
      context.code += 'if(t.s(t.' + chooseMethod(node.n) + '("' + esc(node.n) + '",c,p,1),' +
                      'c,p,0,' + node.i + ',' + node.end + ',"' + node.otag + ' ' + node.ctag + '")){' +
                      't.rs(c,p,' + 'function(c,p,t){';
      Tmpl.walk(node.nodes, context);
      context.code += '});c.pop();}';
    },

    '^': function(node, context) {
      context.code += 'if(!t.s(t.' + chooseMethod(node.n) + '("' + esc(node.n) + '",c,p,1),c,p,1,0,0,"")){';
      Tmpl.walk(node.nodes, context);
      context.code += '};';
    },

    '>': createPartial,
    '<': function(node, context) {
      var ctx = {partials: {}, code: '', subs: {}, inPartial: true};
      Tmpl.walk(node.nodes, ctx);
      var template = context.partials[createPartial(node, context)];
      template.subs = ctx.subs;
      template.partials = ctx.partials;
    },

    '$': function(node, context) {
      var ctx = {subs: {}, code: '', partials: context.partials, prefix: node.n};
      Tmpl.walk(node.nodes, ctx);
      context.subs[node.n] = ctx.code;
      if (!context.inPartial) {
        context.code += 't.sub("' + esc(node.n) + '",c,p,i);';
      }
    },

    '\n': function(node, context) {
      context.code += write('"\\n"' + (node.last ? '' : ' + i'));
    },

    '_v': function(node, context) {
      context.code += 't.b(t.v(t.' + chooseMethod(node.n) + '("' + esc(node.n) + '",c,p,0)));';
    },

    '_t': function(node, context) {
      context.code += write('"' + esc(node.text) + '"');
    },

    '{': tripleStache,

    '&': tripleStache
  };

  Tmpl.walk = function(nodelist, context) {
    var func;
    for (var i = 0, l = nodelist.length; i < l; i++) {
      func = Tmpl.codegen[nodelist[i].tag];
      if (func) {
        func(nodelist[i], context);
      }
    }
    return context;
  };

  Tmpl.parse = function(tokens, text, options) {
    options = options || {};
    return buildTree(tokens, '', [], options.sectionTags || []);
  };

  Tmpl.cache = {};

  Tmpl.cacheKey = function(text, options) {
    return [text, !!options.asString, !!options.disableLambda, options.delimiters, !!options.modelGet].join('||');
  };

  Tmpl.compile = function(text, options) {
    options = options || {};
    var key = Tmpl.cacheKey(text, options);
    var template = this.cache[key];

    if (template) {
      var partials = template.partials;
      for (var name in partials) {
        delete partials[name].instance;
      }
      return template;
    }

    template = this.generate(this.parse(this.scan(text, options.delimiters), text, options), text, options);
    this.cache[key] = template;
    return template;
  };



  $.fn.toolbar = function(options) {
    'use strict';

    /**
     * The Toolbar Component manages various levels of application navigation.  It contains a group of buttons that functionally
     * related content. Each panel consists of two levels: the top level identifies the
     * category or section header, and the second level provides the associated options.
     *
     * @class Toolbar
     *
     * @param {HTMLElement|SVGElement|jQuery[]} element   &nbsp;-&nbsp; The element that will serve as the base for this Toolbar component.
     * @param {boolean} rightAligned   &nbsp;-&nbsp; Will always attempt to right-align the contents of the toolbar.
     * @param {Number} maxVisibleButtons   &nbsp;-&nbsp; Total amount of buttons that can be present, not including the More button.
     * @param {boolean} resizeContainers   &nbsp;-&nbsp; If true, uses Javascript to size the Title and Buttonset elements in a way that shows as much of the Title area as possible.
     * @param {boolean} favorButtonset   &nbsp;-&nbsp; If "resizeContainers" is true, setting this to true will try to display as many buttons as possible while resizing the toolbar.  Setting to false attempts to show the entire title instead.
     */
    var pluginName = 'toolbar',
        defaults = {
          rightAligned: false,
          maxVisibleButtons: 3,
          resizeContainers: true,
          favorButtonset: true
        },
        settings = $.extend({}, defaults, options);

    function Toolbar(element) {
      this.settings = $.extend({}, settings);
      this.element = $(element);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    // Plugin Methods
    Toolbar.prototype = {

      /**
       * Initializes the Toolbar Component
       * @private
       * @chainable
       * @returns {this}
       */
      init: function() {
        return this
          .setup()
          .build()
          .handleEvents();
      },

      /**
       * Detects discrepencies in settings.  In general, configures the component based on user settings.
       * @private
       * @chainable
       * @returns {this}
       */
      setup: function() {
        // Can't have zero buttons
        if (this.settings.maxVisibleButtons <= 0) {
          this.settings.maxVisibleButtons = defaults.maxVisibleButtons;
        }

        return this;
      },

      /**
       * Adds additional markup, wraps some internal elements, and helps construct a complete Toolbar representation in the HTML Markup.  This method also builds the "More Actions" menu and ties its elements to the toolbar items.
       * @private
       * @chainable
       * @returns {this}
       */
      build: function() {
        var self = this;

        this.element.attr('role', 'toolbar');
        if (this.settings.resizeContainers && this.element.is(':not(:hidden)')) {
          this.element[0].classList.add('do-resize');
        }

        this.buildAriaLabel();

        // keep track of how many popupmenus there are with an ID.
        // Used for managing events that are bound to $(document)
        if (!this.id) {
          this.id = (parseInt($('.toolbar, .formatter-toolbar').index(this.element), 10));
        }

        // Check for a "title" element.  This element is optional.
        // If a title element exists, a tooltip will be created for when it's not
        // possible to show the entire title text on screen.
        this.title = this.element.children('.title');
        if (this.title.length) {
          this.element[0].classList.add('has-title');

          this.cutoffTitle = false;
          this.title.on('beforeshow.toolbar', function() {
            return self.cutoffTitle;
          }).tooltip({
            content: '' + this.title.text().trim()
          });
        } else {
          this.element[0].classList.remove('has-title');
        }

        // Container for main group of buttons and input fields.  Only these spill into the More menu.
        this.buttonset = this.element.children('.buttonset');
        if (!this.buttonset.length) {
          this.buttonset = $('<div class="buttonset"></div>');
          if (this.title.length) {
            this.buttonset.insertAfter(this.title);
          } else {
            this.buttonset.prependTo(this.element);
          }
        }

        this.buttonset[this.settings.rightAligned ? 'addClass' : 'removeClass']('right-aligned');

        // Add and invoke More Button, if it doesn't exist
        this.more = this.element.find('.btn-actions');
        if (this.more.length === 0 && !this.element.hasClass('no-actions-button')) {
          var moreContainer = this.element.find('.more');

          if (!moreContainer.length) {
            moreContainer = $('<div class="more"></div>').appendTo(this.element);
          }

          this.more = $('<button class="btn-actions" type="button"></button>')
            .html($.createIcon({icon: 'more'}) +
              '<span class="audible">'+Locale.translate('MoreActions')+'</span>')
            .appendTo(moreContainer);
        }

        // Reference all interactive items in the toolbar
        this.buttonsetItems = this.buttonset.children('button')
          .add(this.buttonset.find('input')); // Searchfield Wrappers

        // Items contains all actionable items in the toolbar, including the ones in the title, and the more button
        this.items = this.buttonsetItems
          .add(this.title.children('button'))
          .add(this.more);

        // Invoke buttons
        var buttons = this.items.filter('button, input[type="button"], [class^="btn"]');
        buttons.each(function() {
          var buttonControl = $(this).data('button');
          if (!buttonControl) {
            $(this).button();
          }
        });

        // Invoke searchfields
        var searchfields = this.items.filter('.searchfield, .toolbar-searchfield-wrapper, .searchfield-wrapper');
        searchfields.each(function(i, item) {
          var sf = $(item);
          if (sf.is('.toolbar-searchfield-wrapper, .searchfield-wrapper')) {
            sf = sf.children('.searchfield');
          }

          if (!sf.data('searchfield')) {
            var searchfieldOpts = $.extend({}, $.fn.parseOptions(sf[0]));
            sf.toolbarsearchfield(searchfieldOpts);
          }
        });

        // Setup the More Actions Menu.  Add Menu Items for existing buttons/elements in the toolbar, but
        // hide them initially.  They are revealed when overflow checking happens as the menu is opened.
        var popupMenuInstance = this.more.data('popupmenu'),
          moreAriaAttr = this.more.attr('aria-controls');

        if (!popupMenuInstance) {
          this.moreMenu = $('#' + moreAriaAttr);
          if (!this.moreMenu.length) {
            this.moreMenu = this.more.next('.popupmenu');
          }
          if (!this.moreMenu.length) {
            this.moreMenu = $('<ul id="popupmenu-toolbar-'+ this.id +'" class="popupmenu"></ul>').insertAfter(this.more);
          }
        } else {
          this.moreMenu = popupMenuInstance.menu;
        }

        this.defaultMenuItems = this.moreMenu.children('li:not(.separator)').length > 0;

        function menuItemFilter() {
          //jshint validthis:true
          return $(this).parent('.buttonset, .inline').length;
        }

        var menuItems = [];
        function buildMenuItem() {
          /*jshint validthis:true */
          var item = $(this),
            isSplitButton = false;

          // If this item should be skipped, just return out
          if (item.data('skipit') === true) {
            item.data('skipit', undefined);
            return;
          }

          var popupLi = $('<li></li>'),
            a = $('<a href="#"></a>').appendTo(popupLi);

          if (item.is(':hidden')) {
            popupLi.addClass('hidden');
          }
          if (item.is(':disabled')) {
            popupLi.addClass('is-disabled');
          } else {
            popupLi.removeClass('is-disabled');
          }

          a.text(self.getItemText(item));

          // Pass along any icons except for the dropdown (which is added as part of the submenu design)
          var submenuDesignIcon = $.getBaseURL('#icon-dropdown');
          var icon = item.children('.icon').filter(function() {
            var iconName = $(this).getIconName();
            return iconName && iconName !== submenuDesignIcon && iconName.indexOf('dropdown') === -1;
          });

          if (icon && icon.length) {
            a.html('<span>' + a.text() + '</span>');
            icon.clone().detach().prependTo(a);
          }

          var linkspan = popupLi.find('b');
          if (linkspan.length) {
            self.moreMenu.addClass('has-icons');
            linkspan.detach().prependTo(popupLi);
          }

          function addItemLinksRecursively(menu, diffMenu, parentItem) {
            var children = menu.children('li'),
              id = diffMenu.attr('id');

            diffMenu.children('li').each(function(i, diffMenuItem) {
              var dmi = $(diffMenuItem), // "Diffed" Menu Item
                omi = children.eq(i), // Corresponding "Original" menu item
                dmiA = dmi.children('a'), // Anchor inside of "Diffed" menu item
                omiA = omi.children('a'), // Anchor inside of "Original" menu item
                dmiID = dmi.attr('id'),
                dmiAID = dmiA.attr('id');

              // replace menu item ids with spillover-menu specific ids.
              if (dmiID) {
                dmi.removeAttr('id').attr('data-original-menu-item', dmiID);
              }
              if (dmiAID) {
                dmiA.removeAttr('id').attr('data-original-menu-anchor', dmiAID);
              }

              omiA.data('action-button-link', dmiA);
              dmiA.data('original-button', omiA);

              var omiSubMenu = omi.children('.wrapper').children('.popupmenu'),
                dmiSubMenu = dmi.children('.wrapper').children('.popupmenu');

              if (omiSubMenu.length && dmiSubMenu.length) {
                addItemLinksRecursively(omiSubMenu, dmiSubMenu, dmi);
              }

              if (isSplitButton) {
                dmi.removeClass('is-checked');
              }
            });

            diffMenu.removeAttr('id').attr('data-original-menu', id);
            parentItem.addClass('submenu');

            if (parentItem.is(popupLi)) {
              diffMenu.wrap($('<div class="wrapper"></div>'));
              parentItem.append(diffMenu);
            }
          }

          if (item.is('.btn-menu')) {
            if (!item.data('popupmenu')) {
              item.popupmenu();
            }

            var menu = item.data('popupmenu').menu,
              diffMenu = menu.clone();

            addItemLinksRecursively(menu, diffMenu, popupLi);
          }

          if (item.is('[data-popdown]')) {
            item.popdown();
          }

          // Setup data links between the buttons and their corresponding list items
          item.data('action-button-link', a);
          popupLi.children('a').data('original-button', item);
          menuItems.push(popupLi);
        }

        this.items.not(this.more).filter(menuItemFilter).each(buildMenuItem);
        menuItems.reverse();
        $.each(menuItems, function(i, item) {
          if (item.text() !== '') {
            item.prependTo(self.moreMenu);
          }
        });

        //Refresh Text and Disabled
        function refreshTextAndDisabled(menu) {
          $('li > a', menu).each(function () {
            var a = $(this),
                li = a.parent(),
                item = a.data('originalButton'),
                itemParent,
                text = self.getItemText(item),
                submenu;

            if (item) {
              if (a.find('span').length) {
                a.find('span').text(text.trim());
              } else {
                a.text(text.trim());
              }

              if (item.is('.hidden') || item.parent().is('.hidden')) {
                li.addClass('hidden');
              } else {
                li.removeClass('hidden');
              }

              if (item.parent().is('.is-disabled') || item.is(':disabled')) { // if it's disabled menu item, OR a disabled menu-button
                li.addClass('is-disabled');
                a.attr('tabindex', '-1');
              } else {
                li.removeClass('is-disabled');
                a.removeAttr('disabled');
              }

              if (item.is('a')) {
                itemParent = item.parent('li');

                if (itemParent.is('.is-checked')) {
                  li.addClass('is-checked');
                } else {
                  li.removeClass('is-checked');
                }
              }

              if (item.is('.btn-menu')) {
                submenu = a.parent().find('.popupmenu').first();
                refreshTextAndDisabled(submenu);
              }
            }
          });
        }

        if (popupMenuInstance) {
          this.more
            .on('beforeopen.toolbar', function() {
              refreshTextAndDisabled(self.moreMenu);
            })
            .triggerHandler('updated');
        } else {
          var actionButtonOpts = $.fn.parseOptions(this.more[0]);

          this.more.popupmenu($.extend({}, actionButtonOpts, {
            trigger: 'click',
            menu: this.moreMenu
          })).on('beforeopen.toolbar', function() {
            refreshTextAndDisabled(self.moreMenu);
          });
        }


        // Setup the tabindexes of all items in the toolbar and set the starting active button.
        function setActiveToolbarItem() {
          self.items.attr('tabindex', '-1');

          var active = self.items.filter('.is-selected');
          if (active.length) {
            self.activeButton = active.first().attr('tabindex', '0');
            self.items.not(self.activeButton).removeClass('is-selected');
            return;
          }

          // Set active to the first item in the toolbar.
          active = self.items.filter(':visible:not(:disabled)').first().attr('tabindex', '0');
          self.activeButton = active;

          // If the whole toolbar is hidden (contextual toolbars, etc),
          // automatically set the first non-disabled item as visible
          if (self.element.is(':hidden, .is-hidden')) {
            self.activeButton = self.items.filter(':not(:disabled)').first().attr('tabindex', '0');
            return;
          }

          if (self.isItemOverflowed(active)) {
            active.attr('tabindex', '-1');
            self.activeButton = self.more.addClass('is-selected').attr('tabindex', '0');
          }
          return;
        }

        setActiveToolbarItem();

        // Toggles the More Menu based on overflow of toolbar items
        this.adjustMenuItemVisibility();
        this.handleResize();

        this.element.triggerHandler('rendered');
        return this;
      },

      /**
       * Gets the complete text contnts of a Toolbar Item, in order to create its corresponding "more actions" menu item.
       *
       * Order of operations for populating the List Item text:
       * 1. span contents (.audible), then
       * 2. button title attribute, then
       * 3. tooltip text (if applicable)
       * @param {jQuery[]} item - the item being evaluated.
       * @returns {string} - the complete text representation.
       */
      getItemText: function (item) {
        if (!item) {
          return;
        }
        var span = item.find('.audible'),
          title = item.attr('title'),
          tooltip = item.data('tooltip'),
          tooltipText = tooltip ? tooltip.content : undefined;

        var popupLiText = span.length ? span.text() :
          title !== '' && title !== undefined ? item.attr('title') :
          tooltipText ? tooltipText : item.text();

        return popupLiText;
      },

      /**
       * Sets up all necessary event handling on a Toolbar component
       * @private
       * @chainable
       * @returns {this}
       */
      handleEvents: function() {
        var self = this;

        this.items
          .off('keydown.toolbar').on('keydown.toolbar', function(e) {
            self.handleKeys(e);
          }).off('click.toolbar').on('click.toolbar', function(e) {
            self.handleClick(e);
          });

        this.items.filter('.btn-menu, .btn-actions')
          .off('close.toolbar').on('close.toolbar', function onClosePopup() {
            var el = $(this),
              last;

            if (el.is('.is-overflowed')) {
              last = self.getLastVisibleButton();
              if (last && last.length) {
                last[0].focus();
              }
              return;
            }

            el.focus();
            self.buttonset.scrollTop(0);
          });

        this.items.not(this.more).off('selected.toolbar').on('selected.toolbar', function(e, anchor) {
          e.stopPropagation();
          self.handleSelected(e, anchor);
        });

        this.more.on('keydown.toolbar', function(e) {
          self.handleKeys(e);
        }).on('beforeopen.toolbar', function() {
          self.adjustMenuItemVisibility();
        }).on('selected.toolbar', function(e, anchor) {
          e.stopPropagation();
          self.handleSelected(e, anchor);
        });

        this.element.off('updated.toolbar').on('updated.toolbar', function(e) {
          e.stopPropagation();
          self.updated();
        }).off('recalculate-buttons.toolbar').on('recalculate-buttons.toolbar', function(e, containerDims) {
          self.handleResize(containerDims);
        }).off('scrollup.toolbar').on('scrollup.toolbar', function() {
          var moduleTabsParent = self.element.parents('.tab-container.module-tabs');
          if (moduleTabsParent.length) {
            moduleTabsParent.scrollTop(0);
          }
        });

        $('body').off('resize.toolbar-' + this.id).on('resize.toolbar-' + this.id, function() {
          self.handleResize();
        });

        return this;
      },

      /**
       * Event handler for the Soho `selected` event on toolbar items
       * @private
       * @listens {jQuery.Event} e
       * @param {jQuery.Event} e
       * @returns {undefined}
       */
      handleSelected: function(e, anchor) {
        var itemLink = anchor.data('original-button'),
          li = anchor.parent(),
          itemEvts,
          toolbarEvts,
          popup, popupTrigger;

        // Don't continue if hidden/readonly/disabled
        if (li.is('.hidden, .is-disabled') || anchor.is('[readonly], [disabled]')) {
          e.preventDefault();
          return;
        }

        if (itemLink && itemLink.length > 0) {
          itemEvts = itemLink.listEvents();
          toolbarEvts = this.element.listEvents();

          // Make sure the active button is set properly
          this.setActiveButton(itemLink);

          // Fire Angular Events
          if (itemLink.attr('ng-click') || itemLink.attr('data-ng-click')) {
            itemLink.trigger('click');
            return;
          }

          // Check the Toolbar Button for the existence of certain event types.
          // Checks the button, and checks the toolbar container element for delegated events.
          var evtTypes = ['click', 'touchend', 'touchcancel'];
          for (var i = 0; i < evtTypes.length; i++) {
            var type = evtTypes[i];

            // Check toolbar element for delegated-down events first
            if (toolbarEvts && toolbarEvts[type] && toolbarEvts[type].delegateCount > 0) {
              var el = this.element,
                evt = $.Event(type);

              evt.target = el.find(itemLink)[0];
              el.trigger(evt);
              return;
            }

            // Check for events directly on the element
            if ((itemEvts && itemEvts[type]) || itemLink[0]['on' + type]) {
              itemLink.trigger(type);
              return;
            }
          }

          // If the linked element is a child of a menu button, trigger its 'selected' event.
          popup = itemLink.parents('.popupmenu');
          popupTrigger = popup.data('trigger');
          if (popup.length && popupTrigger instanceof $ && popupTrigger.length) {
            popupTrigger.triggerHandler('selected', [itemLink]);
            return;
          }

          // Manually Trigger Select on the linked item, since it won't be done by another event
          this.triggerSelect(itemLink);
          return;
        }

        // If no item link exists, it's a pre-defined menu item.
        // Trigger 'selected' manually on the toolbar element.
        // Normally this would happen by virtue of triggering the "click" handlers on a linked button above.
        this.triggerSelect(anchor);
      },

      /**
       * Event handler for clicks on toolbar items
       * @private
       * @listens {jQuery.Event} e
       * @param {jQuery.Event} e
       * @returns {false}
       */
      handleClick: function(e) {
        this.setActiveButton($(e.currentTarget));
        this.triggerSelect($(e.currentTarget));
        return false;
      },

      /**
       * Event handler for key presses on toolbar items
       * @private
       * @listens {jQuery.Event} e
       * @param {jQuery.Event} e
       * @returns {undefined}
       */
      handleKeys: function(e) {
        var self = this,
          key = e.which,
          target = $(e.target),
          isActionButton = target.is('.btn-actions'),
          isRTL = Locale.isRTL();

        if ((key === 37 && target.is(':not(input)')) ||
          (key === 37 && target.is('input') && e.shiftKey) || // Shift + Left Arrow should be able to navigate away from Searchfields
          (key === 38 && target.is(':not(input.is-open)'))) { // Don't navigate away if Up Arrow in autocomplete field that is open
          e.preventDefault();

          if (isActionButton) {
            self.setActiveButton( isRTL ? self.getFirstVisibleButton() : self.getLastVisibleButton() );
          } else {
            self.navigate( isRTL ? 1 : -1 );
          }
        }

        if ((key === 39 && target.is(':not(input)')) ||
          (key === 39 && target.is('input') && e.shiftKey) || // Shift + Right Arrow should be able to navigate away from Searchfields
          (key === 40 && target.is(':not(input.is-open)'))) { // Don't navigate away if Down Arrow in autocomplete field that is open
          e.preventDefault();

          if (isActionButton) {
            self.setActiveButton( isRTL ? self.getLastVisibleButton() : self.getFirstVisibleButton() );
          } else {
            self.navigate( isRTL ? -1 : 1 );
          }
        }

        return;
      },

      /**
       * Re-renders the toolbar element and adjusts all internal parts to account for the new size.
       * @param {Object} [containerDims] - an object containing dimensions that can be set on the Toolbar's title and buttonset elements.
       * @param {number} [containerDims.title] - represents the width that will be applied to the title element
       * @param {number} [containerDims.buttonset] - represents the width that will be applied to the buttonset element
       * @returns {undefined}
       */
      handleResize: function(containerDims) {
        if (this.settings.resizeContainers) {
          var title = containerDims ? containerDims.title : undefined,
            buttonset = containerDims ? containerDims.buttonset : undefined;

          this.sizeContainers(title, buttonset);
        }

        var buttons = this._getButtonsetButtons();
        for (var i = 0; i < buttons.length; i++) {
          buttons[i].removeClass('is-overflowed');
        }

        if (this.element.is(':not(:hidden)')) {
          this.adjustMenuItemVisibility();
          this.toggleMoreMenu(); // Added 9/16/2015 due to issue HFC-2876
        }
      },

      /**
       * Resizes the Toolbar's internal container areas (title, buttonset) to make efficient use of their space.
       * @private
       * @chainable
       * @param {number} titleSize - desired size of the title element.
       * @param {number} buttonsetSize - desired size of the buttonset element.
       * @returns {this}
       */
      sizeContainers: function(titleSize, buttonsetSize) {
        var containerElem = this.element[0],
          titleElem = this.title[0],
          buttonsetElem = this.buttonset[0],
          moreElem = this.more[0];

        // Don't do this at all unless we have a title element (which is optional)
        if (!this.title || !this.title.length) {
          return;
        }

        // If the element's hidden and has defined sizes, remove them so we can use the defaults.
        if (this.element.is(':hidden')) {
          buttonsetElem.style.width = '';
          titleElem.style.width = '';
          containerElem.classList.remove('do-resize');
          return;
        }

        var WHITE_SPACE = 30,
          MIN_TITLE_SIZE = 44 + WHITE_SPACE,
          MIN_BUTTONSET_SIZE = 0;

        buttonsetElem.style.width = '';
        titleElem.style.width = '';

        if (!containerElem.classList.contains('do-resize')) {
          containerElem.classList.add('do-resize');
        }

        var toolbarDims = $(containerElem).getHiddenSize(),
          buttonsetDims = $(buttonsetElem).getHiddenSize(),
          titleDims = $(titleElem).getHiddenSize(),
          moreDims = $(moreElem).getHiddenSize(),
          toolbarPadding = parseInt(toolbarDims.padding.left) + parseInt(toolbarDims.padding.right);

        if (isNaN(moreDims.width)) {
          moreDims.width = 50;
        }

        if (isNaN(buttonsetDims.width) || buttonsetDims.width < MIN_BUTTONSET_SIZE) {
          buttonsetDims.width = MIN_BUTTONSET_SIZE;
        }

        function addPx(val) {
          return val + 'px';
        }

        // Get the target size of the title element
        var targetTitleWidth, targetButtonsetWidth, d;
        this.cutoffTitle = false;

        // Setter functionality
        if (titleSize && buttonsetSize && !isNaN(titleSize) && !isNaN(buttonsetSize)) {
          targetTitleWidth = parseInt(titleSize);
          targetButtonsetWidth = parseInt(buttonsetSize);
        } else {
          if ((buttonsetDims.scrollWidth + titleDims.scrollWidth + moreDims.width + toolbarPadding) > toolbarDims.width) {
            if (this.settings.favorButtonset) {
              targetButtonsetWidth = buttonsetDims.width;
              targetTitleWidth = toolbarDims.width - (toolbarPadding + buttonsetDims.width + moreDims.width);
            } else {
              targetTitleWidth = titleDims.scrollWidth;
              targetButtonsetWidth = toolbarDims.width - (toolbarPadding + titleDims.scrollWidth + moreDims.width);
            }
          }
        }

        if (this.settings.favorButtonset) {
          // Cut off the buttonset anyway if title is completely hidden.  Something's gotta give!
          if (targetTitleWidth < MIN_TITLE_SIZE) {
            this.cutoffTitle = true;
            d = Math.abs(targetTitleWidth - MIN_TITLE_SIZE);
            targetTitleWidth = MIN_TITLE_SIZE;
            targetButtonsetWidth = targetButtonsetWidth - d;
          }

          buttonsetElem.style.width = addPx(targetButtonsetWidth + 2);
          titleElem.style.width = addPx(targetTitleWidth - 2);

          return this;
        }
        //==========================
        // Favor the title element
        // Cut off the title anyway if buttonset is completely hidden.  Something's gotta give!
        if (targetButtonsetWidth < MIN_BUTTONSET_SIZE) {
          this.cutoffTitle = true;
          d = Math.abs(targetButtonsetWidth - MIN_BUTTONSET_SIZE);
          targetButtonsetWidth = MIN_BUTTONSET_SIZE;
          targetTitleWidth = targetTitleWidth - d;
        }

        // Always favor the title by one extra px for Chrome
        titleElem.style.width = addPx(targetTitleWidth + 2);
        buttonsetElem.style.width = addPx(targetButtonsetWidth - 2);
        return this;
      },

      /**
       * Changes the "active" button on the toolbar.
       * @param {number} direction - can be `-1` (previous), `1` (next), or `0` (remain on current).
       * @returns {jQuery[]}
       */
      navigate: function (direction) {
        var items = this.items.filter(':visible:not(:disabled)'),
          current = items.index(this.activeButton),
          next = current + direction,
          target;

        if (next >= 0 && next < items.length) {
          target = items.eq(next);
        }

        if (next >= items.length) {
          target = items.first();
        }

        if (next === -1) {
          target = items.last();
        }

        if (this.isItemOverflowed(target)) {
          target = this.more;
        }

        this.setActiveButton(target);
        return false;
      },

      /**
       * Gets a reference to the last visible (not overflowed) button inside of the buttonset.
       * @returns {jQuery[]}
       */
      getLastVisibleButton: function() {
        var items = $(this.items.get().reverse()).not(this.more),
          target;

        var i = 0,
          elem;

        while(!target && i < items.length) {
          elem = $(items[i]);
          if (!this.isItemOverflowed(elem)) {
            target = elem;
            break;
          }
          i++;
        }

        if (!target || target.length === 0) {
          target = items.first();
        }

        while(target.length && target.is('.separator, *:disabled, *:hidden')) {
          target = target.prev();
        }

        return target;
      },

      /**
       * Gets a reference to the first visible (not overflowed) button inside of the buttonset.
       * @returns {jQuery[]}
       */
      getFirstVisibleButton: function() {
        var i = 0,
          items = this.items,
          target = items.eq(i);

        while(target.is('.separator, *:disabled, *:hidden')) {
          i++;
          target = items.eq(i);
        }

        return target;
      },

      /**
       * Sets the currently "active" (focused) Toolbar item
       * @param {jQuery[]} activeButton - the preferred target element to make active.
       * @param {boolean} [noFocus] - if defined, prevents this method from giving focus to the new active button.
       */
      setActiveButton: function(activeButton, noFocus) {
        // Return out of this if we're clicking the currently-active item
        if (activeButton[0] === this.activeButton[0]) {
          return;
        }

        var self = this;

        function getActiveButton() {
          // Menu items simply set the "More Actions" button as active
          if (activeButton.is('a')) {
            return self.more;
          }

          // If it's the more button, hide the tooltip and set it as active
          var tooltip = self.more.data('tooltip');
          if (activeButton[0] === self.more[0]) {
            if (tooltip && tooltip.tooltip.is(':not(.hidden)')) {
              tooltip.hide();
            }
            return self.more;
          }

          // Overflowed items also set
          if (self.isItemOverflowed(activeButton)) {
            if (!activeButton.is('.searchfield')) {
              return self.more;
            }
          }

          return activeButton;
        }

        this.items.add(this.more).attr('tabindex', '-1').removeClass('is-selected');

        this.activeButton = getActiveButton();
        this.activeButton.addClass('is-selected').attr('tabindex', '0');

        if (!noFocus) {
          this.activeButton[0].focus();
        }
      },

      /**
       * Triggers a "selected" event on the base Toolbar element using a common element as an argument.
       * @param {HTMLElement|SVGElement|jQuery[]} element - a jQuery Object containing an anchor tag, button, or input field.
       */
      triggerSelect: function(element) {
        var elem = $(element);
        if (elem.is(this.more) || (elem.is('.btn-menu, li.submenu'))) {
          return;
        }

        this.element.triggerHandler('selected', [elem]);
      },

      /**
       * Assembles and returns a list of all buttons inside the Buttonset element.
       * @returns {Array}
       */
      _getButtonsetButtons: function() {
        var buttons = [],
          items = this.buttonsetItems,
          item;

        for (var i = 0; i < items.length; i++) {
          item = items.eq(i);
          if (item.data('action-button-link') !== undefined && item.is(':not(.searchfield)')) {
            buttons.push(item);
          }
        }

        return buttons;
      },

      /**
       * Gets and Iterates through a list of toolbar items and determines which are currently overflowed, and which are visible.
       * @param {Array} buttons - an Array of jQuery-wrapped elements that represents toolbar items.
       * @returns {VisibilitySortedToolbarItems}
       * @returns {VisibilitySortedToolbarItems.Array} visible - An array containing all visible items.
       * @returns {VisibilitySortedToolbarItems.Array} hidden - An array containing all hidden (overflowed) items.
      */
      getVisibleButtons: function(buttons) {
        var self = this,
          hiddenButtons = [],
          visibleButtons = [],
          i;

        if (!buttons || !Array.isArray(buttons)) {
          buttons = this._getButtonsetButtons();
        }

        for (i = 0; i < buttons.length; i++) {
          buttons[i][0].classList.remove('is-overflowed');
        }

        function getButtonVisibility(i, button) {
          if (!self.isItemOverflowed(button)) {
            visibleButtons.push(button);
          } else {
            hiddenButtons.push(button);
          }
        }

        for (i = 0; i < buttons.length; i++) {
          getButtonVisibility(i, buttons[i]);
        }

        return {
          visible: visibleButtons,
          hidden: hiddenButtons
        };
      },

      /**
       * Gets and Iterates through the full list of Toolbar Items and determines which ones should currently be present in the More Actions menu.
       * @param {Object} items - an object (normally generated by `_.getVisibleButtons()`) containing arrays of currently visible and hidden buttons, along with some meta-data.
       * @returns {undefined}
       */
      adjustMenuItemVisibility: function(items) {
        var iconDisplay = 'removeClass';

        if (!items) {
          items = this.getVisibleButtons();
        }

        function toggleClass($elem, doHide) {
          var elem = $elem[0],
            li = $elem.data('action-button-link').parent()[0],
            elemIsHidden = elem.classList.contains('hidden');

          if (doHide) {
            li.classList.add('hidden');
            elem.classList.remove('is-overflowed');

            /*
            if (elem.classList.contains('btn-split-menu') && elem.classList.contains('btn-menu')) {
              $elem.last().last().removeClass('is-overflowed');
            }
            */
            return;
          }

          if (!elemIsHidden) {
            li.classList.remove('hidden');
          }
          elem.classList.add('is-overflowed');

          /*
          if (elem.classList.contains('btn-split-menu') && elem.classList.contains('btn-menu')) {
            $elem.last().last().addClass('is-overflowed');
          }
          */

          if ($elem.find('.icon').length) {
            iconDisplay = 'addClass';
          }
        }

        var i = 0;
        for (i; i < items.visible.length; i++) {
          toggleClass(items.visible[i], true);
        }
        for (i = 0; i < items.hidden.length; i++) {
          toggleClass(items.hidden[i], false);
        }

        if (this.moreMenu.find('.icon').length) {
          iconDisplay = 'addClass';
        }

        this.moreMenu[iconDisplay]('has-icons');
      },

      /**
       * Detects whether or not a toolbar item is currently overflowed.  In general, toolbar items are considered overflow if their right-most edge sits past the right-most edge of the buttonset border.  There are some edge-cases.
       * @param {jQuery[]} item - the Toolbar item being tested.
       * @returns {boolean}
       */
      isItemOverflowed: function(item) {
        if (this.hasNoMoreButton()) {
          return false;
        }

        if (!item || item.length === 0) {
          return true;
        }

        // In cases where a Title is present and buttons are right-aligned, only show up to the maximum allowed.
        if (this.title.length && this.buttonsetItems.filter(':not(.hidden)').index(item) >= this.settings.maxVisibleButtons) { // Subtract one to account for the More Button
          // ONLY cause this to happen if there are at least two items that can be placed in the overflow menu.
          // This prevents ONE item from being present in the menu by itself
          //if (!this.buttonsetItems.last().is(item)) {
            //return true;
          //}
          return true;
        }

        if (this.buttonset.scrollTop() > 0) {
          this.buttonset.scrollTop(0);
        }

        // unwrap from jQuery
        if (item instanceof $ && item.length) {
          item = item[0];
        }

        var classList = item.classList,
          style = window.getComputedStyle(item);

        if (classList.contains('btn-actions')) {
          return true;
        }
        if (classList.contains('searchfield')) {
          return false;
        }
        if (style.display === 'none') {
          return true;
        }

        var isRTL = Locale.isRTL(),
          itemRect = item.getBoundingClientRect(),
          buttonsetRect = this.buttonset[0].getBoundingClientRect(),
          itemOutsideXEdge = isRTL ? (itemRect.left <= buttonsetRect.left) : (itemRect.right >= buttonsetRect.right),
          itemBelowYEdge = itemRect.bottom >= buttonsetRect.bottom;

        return (itemBelowYEdge === true || itemOutsideXEdge === true);
      },

      /**
       * Detection for this toolbar to have a More Button
       * @returns {boolean}
       */
      hasNoMoreButton: function() {
        return this.element[0].classList.contains('no-more-button');
      },

      /**
       * Determines whether or not the "more actions" button should be displayed.
       * @private
       * @returns {undefined}
       */
      toggleMoreMenu: function() {
        if (this.element.hasClass('no-actions-button')) {
          return;
        }

        var overflowItems = this.moreMenu.children('li:not(.separator)'),
          hiddenOverflowItems = overflowItems.not('.hidden');

        var method = 'removeClass';
        if (this.defaultMenuItems || hiddenOverflowItems.length > 0) {
          method = 'addClass';
        }

        this.element[method]('has-more-button');

        var popupAPI = this.more.data('popupmenu');
        if (method === 'removeClass') {
          if (!popupAPI) {
            return;
          }

          popupAPI.close();

          var menuItems = popupAPI.menu.find('li:not(.separator)').children('a'),
            shouldFocus = false;

          menuItems.add(this.more).each(function() {
            if (document.activeElement === this) {
              shouldFocus = true;
            }
          });

          if (shouldFocus) {
            this.getLastVisibleButton()[0].focus();
          }
        }
      },

      /**
       * Creates an `aria-label` attribute on the toolbar, for bettery accessibility
       * @private
       * @returns {undefined}
       */
      buildAriaLabel: function() {
        // Set up an aria-label as per AOL guidelines
        // http://access.aol.com/dhtml-style-guide-working-group/#toolbar
        if (!this.element.attr('aria-label')) {
          var isHeader = (this.element.closest('.header').length ===1),
            id = this.element.attr('id') || '',
            title = this.element.children('.title'),
            prevLabel = this.element.prev('label'),
            prevSpan = this.element.prev('.label'),
            labelText = isHeader ? $('header.header').find('h1').text() :
            title.length ? title.filter('div').text() :
            prevLabel.length ? prevLabel.text() :
            prevSpan.length ? prevSpan.text() : id + ' ' + Locale.translate('Toolbar');

          this.element.attr('aria-label', labelText.replace(/\s+/g,' ').trim());
        }
      },

      updated: function() {
        this
          .unbind()
          .teardown()
          .init();
      },

      /**
       * Enables the entire Toolbar component
       * @returns {undefined}
       */
      enable: function() {
        this.element.prop('disabled', false);
        this.items.prop('disabled', false);
        this.more.prop('disabled', false);
      },

      /**
       * Disables the entire Toolbar component
       * @returns {undefined}
       */
      disable: function() {
        this.element.prop('disabled', true);
        this.items.prop('disabled', true);
        this.more.prop('disabled', true).data('popupmenu').close();
      },

      /**
       * Removes currently associated event listeners from the Toolbar.
       * @private
       * @chainable
       * @returns {this}
       */
      unbind: function() {
        this.items
          .offTouchClick('toolbar')
          .off('keydown.toolbar click.toolbar focus.toolbar blur.toolbar');

        this.more.off('keydown.toolbar beforeopen.toolbar selected.toolbar');
        $('body').off('resize.toolbar-' + this.id);
        return this;
      },

      /**
       * Returns the Toolbar's internal markup to its original state.
       * @chainable
       * @returns {this}
       */
      teardown: function() {
        function deconstructMenuItem(i, item) {
          var li = $(item),
            a = li.children('a'),
            itemLink = a.data('original-button');

          a.off('updated.toolbar mousedown.toolbar click.toolbar touchend.toolbar touchcancel.toolbar recalculate-buttons.toolbar');

          var icons = li.find('.icon');
          if (icons.length) {
            icons.remove();
          }

          var submenuContainer;
          if (li.is('.submenu')) {
            submenuContainer = li.children('.wrapper').children('.popupmenu');
            submenuContainer.children('li').each(deconstructMenuItem);
          }

          if (itemLink && itemLink.length) {
            $.removeData(a[0], 'original-button');
            $.removeData(itemLink[0], 'action-button-link');
            a.remove();

            if (submenuContainer) {
              submenuContainer
                .off()
              .parent('.wrapper')
                .off()
                .remove();
            }

            li.remove();
          }

        }

        if (this.title && this.title.length) {
          var dataTooltip = this.title.off('beforeshow.toolbar').data('tooltip');
          if (dataTooltip) {
            dataTooltip.destroy();
          }
        }

        this.moreMenu.children('li').each(deconstructMenuItem);
        return this;
      },

      /**
       * Destroys this Toolbar Component instance and completely disassociates it from its corresponding DOM Element.
       * @returns {undefined}
       */
      destroy: function() {
        this
          .unbind()
          .teardown();

        if (this.buttonset.children('.searchfield-wrapper').length) {
          var searchFields = this.buttonset.children('.searchfield-wrapper').children('.searchfield');
          if (searchFields.data('toolbarsearchfield')) {
            searchFields.data('toolbarsearchfield').destroy();
          }
        }

        /*
        // Remove split button wrappers
        if (this.splitButtonWrappers.length) {
          $.each(this.splitButtonWrappers, function(wrapper) {
            var els = wrapper.children().detach();
            els.insertAfter(wrapper);
            wrapper.remove();
          });
        }
        */

        if (this.more.length && this.more.data('popupmenu') !== undefined) {
          this.more.data('popupmenu').destroy();
        }

        this.element[0].classList.remove('do-resize');
        this.buttonset[0].style.width = '';
        if (this.title && this.title.length) {
          this.title[0].style.width = '';
        }

        this.element.removeAttr('role').removeAttr('aria-label');
        $.removeData(this.element[0], pluginName);
      }
    };

    // Initialize the plugin (Once)
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (instance) {
        instance.settings = $.extend({}, instance.settings, options);
        instance.updated();
      } else {
        instance = $.data(this, pluginName, new Toolbar(this, settings));
      }
    });
  };


  //NOTE: Just this part will show up in SoHo Xi Builds.
  var TOOLBARSEARCHFIELD_EXPAND_SIZE = 230,
    MAX_TOOLBARSEARCHFIELD_EXPAND_SIZE = 450;

  $.fn.toolbarsearchfield = function(options) {
    'use strict';

    // Settings and Options
    var pluginName = 'toolbarsearchfield',
        defaults = {
          clearable: true,  // If "true", provides an "x" button on the right edge that clears the field
          collapsible: true, // If "true", allows the field to expand/collapse on larger breakpoints when focused/blurred respectively
          collapsibleOnMobile: true // If true, overrides `collapsible` only on mobile settings.
        },
        settings = $.extend({}, defaults, options);

    /**
     * Depends on both a Toolbar control and Searchfield control to be present
     * @constructor
     * @param {Object} element
     */
    function ToolbarSearchfield(element) {
      this.settings = $.extend({}, settings);
      this.element = $(element);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    // Plugin Methods
    ToolbarSearchfield.prototype = {

      init: function() {
        return this
          .build()
          .handleEvents();
      },

      // Creates and manages any markup the control needs to function.
      build: function() {
        // Used for managing events that are bound to $(document)
        if (!this.id) {
          this.id = this.element.uniqueId('toolbar-searchfield');
        }

        // Build the searchfield element
        this.input = this.element;

        // If inside a toolbar, make sure to append it to the root toolbar element.
        this.toolbarParent = this.element.parents('.toolbar');
        this.containmentParent = this.toolbarParent;
        var moduleTabs = this.containmentParent.closest('.module-tabs');
        if (moduleTabs.length) {
          this.containmentParent = moduleTabs;
        }

        this.getToolbarElements();

        // Setup ARIA
        var label = this.element.attr('placeholder') || this.element.prev('label, .label').text().trim();
        if (!label || label === '') {
          label = Locale.translate('Keyword');
        }
        this.input.attr({
          'aria-label': label,
        });

        // Invoke Searchfield, pass settings on
        var sfSettings = $.extend({}, this.settings, $.fn.parseOptions(this.input[0]));
        this.input.searchfield(sfSettings);
        this.inputWrapper = this.input.parent();
        this.inputWrapper.addClass('toolbar-searchfield-wrapper');

        if (sfSettings.categories) {
          this.button = this.inputWrapper.find('.searchfield-category-button');
        }

        // Add/remove the collapsible setting
        var collapsibleMethod = this.settings.collapsible ? 'removeClass' : 'addClass';
        this.inputWrapper[collapsibleMethod]('non-collapsible');

        this.xButton = this.inputWrapper.children('.icon.close');

        // Open the searchfield once on intialize if it's a "non-collapsible" searchfield
        if (this.settings.collapsible === false ) {
          this.inputWrapper.addClass('no-transition').one('expanded.' + this.id, function() {
            $(this).removeClass('no-transition');
          });

          if (!this.shouldBeFullWidth()) {
            this.expand(true);
          }
        } else {
          if (this.button instanceof $ && this.button.length) {
            this.setClosedWidth();
          }
        }

        return this;
      },

      // Main entry point for setting up event handlers.
      handleEvents: function() {
        var self = this;

        this.inputWrapper.on('mousedown.toolbarsearchfield', function() {
          self.fastExpand = true;
        }).on('focusin.toolbarsearchfield', function(e) {
          self.handleFocus(e);
        }).on('collapse.toolbarsearchfield', function() {
          self.collapse();
        });

        if (this.button && this.button.length) {
          this.button.on('beforeopen.toolbarsearchfield', function(e, menu) {
            return self.handlePopupBeforeOpen(e, menu);
          });
        }

        // Used to determine if the "Tab" key was involved in switching focus to the searchfield.
        $(document).on('keydown.' + this.id, function(e) {
          self.handleOutsideKeydown(e);
        });

        $('body').on('resize.' + this.id, function() {
          self.adjustOnBreakpoint();
        });

        return this;
      },

      handleDeactivationEvents: function() {
        var self = this;

        $(document).onTouchClick(this.id).on('click.' + this.id, function(e) {
          self.handleOutsideClick(e);
        });
      },

      handleFocus: function() {
        var self = this;
        clearTimeout(this.focusTimer);

        this.inputWrapper.addClass('has-focus');

        function searchfieldActivationTimer() {
          self.expand();
        }

        if (this.fastExpand) {
          searchfieldActivationTimer();
          return;
        }

        this.focusTimer = setTimeout(searchfieldActivationTimer, 0);
      },

      handleFakeBlur: function() {
        var self = this;
        clearTimeout(this.focusTimer);

        function searchfieldCollapseTimer() {
          if (!$.contains(self.inputWrapper[0], document.activeElement) && self.inputWrapper.hasClass('active')) {
            self.focusElem = document.activeElement;
            self.collapse();
          }
        }

        this.focusTimer = setTimeout(searchfieldCollapseTimer, 100);
      },

      handleOutsideClick: function(e) {
        var target = $(e.target);

        // Don't close if we're focused on an element inside the wrapper
        if ($.contains(this.inputWrapper[0], e.target) || target.is(this.element) || target.is(this.inputWrapper)) {
          return;
        }

        // Don't close if a category is being selected from a category menu
        if (this.button && this.button.length) {
          var menu = this.button.data('popupmenu').menu;
          if (menu.has(target).length) {
            return;
          }
        }

        $(document).offTouchClick(this.id).off('click.' + this.id);
        this.collapse();
      },

      handleOutsideKeydown: function(e) {
        var key = e.which;

        this.fastExpand = false;
        if (key === 9) { // Tab
          this.fastExpand = true;
          return this.handleFakeBlur();
        }

        var wasInputTheTarget = ($(e.target).is(this.input) || $(e.target).is(this.inputWrapper));
        if (wasInputTheTarget && (key === 37 || key === 38 || key === 39 || key === 40)) {
          return this.handleFakeBlur();
        }
      },

      handlePopupBeforeOpen: function(e, menu) {
        if (!menu) {
          return false;
        }

        if (!this.inputWrapper.is('.is-open')) {
          this.input.focus();
          return false;
        }

        return true;
      },

      // Retrieves the distance between a left and right boundary.
      // Used on controls like Lookup, Contextual Panel, etc. to fill the space remaining in a toolbar.
      getFillSize: function(leftBoundary, rightBoundary) {
        var leftBoundaryNum = 0,
          rightBoundaryNum = 0;

        function sanitize(boundary) {
          if (!boundary) {
            return 0;
          }

          // Return out if the boundary is just a number
          if (!isNaN(parseInt(boundary))) {
            return parseInt(boundary);
          }

          if (boundary instanceof jQuery) {
            if (!boundary.length) {
              return;
            }

            if (boundary.is('.title')) {
              boundary = boundary.next('.buttonset');
            }

            boundary = boundary[0];
          }

          return boundary;
        }

        function getEdgeFromBoundary(boundary, edge) {
          if (!isNaN(boundary)) {
            return (boundary === null || boundary === undefined) ? 0 : boundary;
          }

          if (!edge || typeof edge !== 'string') {
            edge = 'left';
          }

          var edges = ['left', 'right'];
          if ($.inArray(edge, edges) === -1) {
            edge = edges[0];
          }

          var rect;

          if (boundary instanceof HTMLElement || boundary instanceof SVGElement) {
            rect = boundary.getBoundingClientRect();
          }

          return rect[edge];
        }

        leftBoundary = sanitize(leftBoundary);
        rightBoundary = sanitize(rightBoundary);

        function whichEdge() {
          var e = 'left';
          if (leftBoundary === rightBoundary || ($(rightBoundary).length && $(rightBoundary).is('.buttonset'))) {
            e = 'right';
          }

          return e;
        }

        leftBoundaryNum = getEdgeFromBoundary(leftBoundary);
        rightBoundaryNum = getEdgeFromBoundary(rightBoundary, whichEdge());

        if (!leftBoundaryNum && !rightBoundaryNum) {
          return TOOLBARSEARCHFIELD_EXPAND_SIZE;
        }

        var distance = rightBoundaryNum - leftBoundaryNum;
        if (distance <= TOOLBARSEARCHFIELD_EXPAND_SIZE) {
          return TOOLBARSEARCHFIELD_EXPAND_SIZE;
        }

        if (distance >= MAX_TOOLBARSEARCHFIELD_EXPAND_SIZE) {
          return MAX_TOOLBARSEARCHFIELD_EXPAND_SIZE;
        }

        return distance;
      },

      setClosedWidth: function() {
        // If the searchfield category button exists, change the width of the
        // input field on the inside to provide space for the (variable) size of the currently-selected
        // category (or categories)
        if ((this.button instanceof $) && this.button.length) {
          var buttonStyle = window.getComputedStyle(this.button[0]),
            buttonWidth = parseInt(buttonStyle.width),
            buttonPadding = parseInt(buttonStyle.paddingLeft) + parseInt(buttonStyle.paddingRight);

          if (this.inputWrapper[0]) {
            this.inputWrapper[0].style.width = (buttonWidth + buttonPadding) + 'px';
          }
        }
      },

      setOpenWidth: function() {
        if (this.inputWrapper[0]) {
          this.inputWrapper[0].style.width = this.openWidth;
        }

        // If the searchfield category button exists, change the width of the
        // input field on the inside to provide space for the (variable) size of the currently-selected
        // category (or categories)
        if ((this.button instanceof $) && this.button.length) {
          var buttonStyle = window.getComputedStyle(this.button[0]),
            buttonWidth = parseInt(buttonStyle.width),
            buttonPadding = parseInt(buttonStyle.paddingLeft) + parseInt(buttonStyle.paddingRight),
            buttonBorder = (parseInt(buttonStyle.borderWidth) * 2),
            inputWidth = 'calc(100% - ' + (buttonWidth + buttonPadding + buttonBorder - 2) + 'px)';

          this.input[0].style.width = inputWidth;
        }
      },

      calculateOpenWidth: function() {
        var buttonset = this.element.parents('.toolbar').children('.buttonset'),
          nextElem = this.inputWrapper.next(),
          width;

        // If small form factor, use the right edge
        if (nextElem.is('.title')) {
          nextElem = buttonset;
        }

        if (this.shouldBeFullWidth()) {
          width = '100%';

          if (this.toolbarParent.closest('.header').length) {
            width = 'calc(100% - 40px)';
          }
          if (this.toolbarParent.closest('.tab-container.module-tabs').length) {
            width = 'calc(100% - 1px)';
          }

          this.openWidth = width;
          return;
        }

        if (!buttonset.length) {
          return;
        }

        // Figure out boundaries
        // +10 on the left boundary reduces the likelyhood that the toolbar pushes other elements
        // into the spillover menu whenever the searchfield opens.
        var leftBoundary = buttonset.offset().left + 10;
        var rightBoundary = this.inputWrapper.next();

        // If the search input sits alone, just use the other side of the buttonset to measure
        if (!rightBoundary.length) {
          rightBoundary = buttonset.offset().left + buttonset.outerWidth(true);
        }

        width = this.getFillSize(leftBoundary, rightBoundary);
        this.openWidth = width + 'px';
      },

      isActive: function() {
        return this.inputWrapper.hasClass('is-active');
      },

      adjustOnBreakpoint: function() {
        var isFullWidth = this.shouldBeFullWidth(),
          hasStyleAttr = this.inputWrapper.attr('style');

        if (this.isActive()) {
          this.collapse();
        }

        if (!isFullWidth && !hasStyleAttr) {
          this.calculateOpenWidth();

          if (this.settings.collapsible === false) {
            this.expand(true);
          }
        }
      },

      // Angular may not be able to get these elements on demand so we need to be
      // able to call this during the expand method.
      getToolbarElements: function() {
        this.buttonsetElem = this.toolbarParent.children('.buttonset')[0];
        if (this.toolbarParent.children('.title').length) {
          this.titleElem = this.toolbarParent.children('.title')[0];
        }
      },

      expand: function(noFocus) {
        var self = this,
          notFullWidth = !this.shouldBeFullWidth();

        if (this.inputWrapper.hasClass('active')) {
          return;
        }

        var dontRecalculateButtons = false,
          toolbarAPI = this.toolbarParent.data('toolbar'),
          toolbarSettings,
          containerSizeSetters;

        if (toolbarAPI) {
           toolbarSettings = this.toolbarParent.data('toolbar').settings;
        }

        if (this.animationTimer) {
          clearTimeout(this.animationTimer);
        }

        if (this.buttonsetElem === undefined) {
          this.getToolbarElements();
        }

        function expandCallback() {
          self.inputWrapper.addClass('is-open');
          self.calculateOpenWidth();
          self.setOpenWidth();

          var iOS = /(iPad|iPhone|iPod)/g.test( navigator.userAgent );
          if (!noFocus || iOS) {
            self.input.focus();
          }

          var eventArgs = [];
          if (containerSizeSetters) {
            eventArgs.push(containerSizeSetters);
          }

          self.toolbarParent.triggerHandler('recalculate-buttons', eventArgs);
          self.inputWrapper.triggerHandler('expanded');
        }

        // Places the input wrapper into the toolbar on smaller breakpoints
        if (!notFullWidth) {
          this.elemBeforeWrapper = this.inputWrapper.prev();
          this.inputWrapper.detach().prependTo(this.containmentParent);
          Soho.utils.fixSVGIcons(this.inputWrapper);
        } else {

          // Re-adjust the size of the buttonset element if the expanded searchfield would be
          // too large to fit.
          var buttonsetWidth = parseInt(window.getComputedStyle(this.buttonsetElem).width),
            d = TOOLBARSEARCHFIELD_EXPAND_SIZE;

          if (buttonsetWidth < TOOLBARSEARCHFIELD_EXPAND_SIZE) {
            d = TOOLBARSEARCHFIELD_EXPAND_SIZE - buttonsetWidth;
          }

          var buttonsetElemWidth = buttonsetWidth + TOOLBARSEARCHFIELD_EXPAND_SIZE;
          containerSizeSetters = {
            buttonset: buttonsetElemWidth
          };

          if (toolbarSettings && toolbarSettings.favorButtonset === true && this.titleElem) {
            var toolbarStyle = window.getComputedStyle(this.toolbarParent[0]),
              titleStyle = window.getComputedStyle(this.titleElem),
              toolbarElemWidth = parseInt(toolbarStyle.width),
              toolbarPadding = parseInt(toolbarStyle.paddingLeft) + parseInt(toolbarStyle.paddingRight),
              titleElemWidth = parseInt(titleStyle.width),
              moreElem = this.toolbarParent.children('more'),
              moreStyle, moreElemWidth = 0;

            if (moreElem.length) {
              moreStyle = window.getComputedStyle(moreElem[0]);
              moreElemWidth = moreStyle.width;
            }

            if (toolbarElemWidth < (toolbarPadding + titleElemWidth + buttonsetElemWidth + moreElemWidth)) {
              containerSizeSetters.title = (titleElemWidth - d);
            }
          }

          dontRecalculateButtons = true;
        }

        this.inputWrapper.addClass('active');
        this.handleDeactivationEvents();

        /*
        // Return out without collapsing or handling callbacks for the `collapse` event if:
        // Searchfield is not collapsible in general -OR-
        // Searchfield is only collapsible on mobile, and we aren't below the mobile breakpoint
        if ((self.settings.collapsible === false && self.settings.collapsibleOnMobile === false) ||
           (self.settings.collapsible === false && self.settings.collapsibleOnMobile === true && !self.shouldBeFullWidth())) {
          return;
        }
        */

        if (this.shouldExpandOnMobile()) {
          expandCallback();
          return;
        }

        this.animationTimer = setTimeout(expandCallback, 0);
      },

      collapse: function() {
        var self = this,
          textMethod = 'removeClass';

        function closeWidth() {
          if (self.button instanceof $ && self.button.length) {
            self.setClosedWidth();
          } else {
            self.inputWrapper.removeAttr('style');
          }
        }

        function collapseCallback() {
          self.inputWrapper.removeClass('is-open');
          self.fastExpand = false;

          closeWidth();

          if (self.button && self.button.length) {
            self.button.data('popupmenu').close(false, true);
          }

          self.inputWrapper.triggerHandler('collapsed');

          // TODO: Make this process more solid, without FOUC/jumpiness and better focus handling (EPC)
          // See http://jira/browse/SOHO-6347
          self.inputWrapper.one($.fn.transitionEndName(), function() {
            self.toolbarParent.triggerHandler('recalculate-buttons');
          });
        }

        // Puts the input wrapper back where it should be if it's been moved due to small form factors.
        if (this.inputWrapper.parent().is(this.containmentParent)) {
          if (!(this.elemBeforeWrapper instanceof $) || !this.elemBeforeWrapper.length) {
            this.inputWrapper.prependTo(this.toolbarParent.children('.buttonset'));
          } else {
            this.inputWrapper.detach().insertAfter(this.elemBeforeWrapper);
          }
          self.toolbarParent.triggerHandler('scrollup');
          Soho.utils.fixSVGIcons(this.inputWrapper);

          this.elemBeforeWrapper = null;
        }

        if (this.input.val().trim() !== '') {
          textMethod = 'addClass';
        }
        this.inputWrapper[textMethod]('has-text');

        if (this.animationTimer) {
          clearTimeout(this.animationTimer);
        }

        self.inputWrapper.removeClass('active has-focus');

        // Return out without collapsing or handling callbacks for the `collapse` event if:
        // Searchfield is not collapsible in general -OR-
        // Searchfield is only collapsible on mobile, and we aren't below the mobile breakpoint
        if ((self.settings.collapsible === false && self.settings.collapsibleOnMobile === false) ||
           (self.settings.collapsible === false && self.settings.collapsibleOnMobile === true && !self.shouldBeFullWidth())) {
          return;
        }

        if (this.fastExpand || !this.shouldExpandOnMobile()) {
          collapseCallback();
          return;
        }

        this.animationTimer = setTimeout(collapseCallback, 310);
      },

      /**
       * Determines whether or not the full-size Searchfield should open over top of its sibling Toolbar elements.
       * @private
       * @returns {boolean}
       */
      shouldBeFullWidth: function() {
        var header = this.inputWrapper.closest('.header'),
          headerCondition = false;

        if (header.length) {
          headerCondition = header.width() < 320;
        }

        return headerCondition || Soho.breakpoints.isBelow('phone-to-tablet');
      },

      /**
       * Determines whether or not the Searchfield should expand on the Mobile breakpoint.
       * @private
       * @returns {boolean}
       */
      shouldExpandOnMobile: function() {
        if (this.settings.collapsible === true) {
          return false;
        }
        if (this.settings.collapsibleOnMobile === true) {
          return true;
        }
        return this.shouldBeFullWidth();
      },

      // Used when the control has its settings or structural markup changed.  Rebuilds key parts of the control that
      // otherwise wouldn't automatically update.
      updated: function() {
        return this
          .teardown()
          .init();
      },

      enable: function() {
        this.inputWrapper.addClass('is-disabled');
        this.input.prop('disabled', true);
      },

      disable: function() {
        this.inputWrapper.removeClass('is-disabled');
        this.input.prop('disabled', false);
      },

      // Tears down events, properties, etc. and resets the control to "factory" state
      teardown: function() {
        this.inputWrapper.off('mousedown.toolbarsearchfield focusin.toolbarsearchfield collapse.toolbarsearchfield');
        this.inputWrapper.find('.icon').remove();

        if (this.xButton && this.xButton.length) {
          this.xButton.remove();
        }

        // Used to determine if the "Tab" key was involved in switching focus to the searchfield.
        $(document).off('keydown.' + this.id);
        $('body').off('resize.' + this.id);

        return this;
      },

      // Removes the entire control from the DOM and from this element's internal data
      destroy: function() {
        this.teardown();
        $.removeData(this.element[0], pluginName);
      }
    };

    // Initialize the plugin (Once)
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (instance) {
        instance.settings = $.extend({}, instance.settings, options);
        instance.updated();
      } else {
        instance = $.data(this, pluginName, new ToolbarSearchfield(this, settings));
      }
    });
  };


  $.fn.tooltip = function(options, args) {
    'use strict';

    // Settings and Options
    var pluginName = 'tooltip',
      defaults = {
        content: null,
        offset: {top: 10, left: 10},
        placement: 'top',
        trigger: 'hover',
        title: null,
        beforeShow: null,
        popover: null ,
        closebutton: null,
        isError: false,
        isErrorColor: false,
        tooltipElement: null,
        parentElement: null,
        keepOpen: false,
        extraClass: null,
        placementOpts: undefined,
        maxWidth: null
      };

    /**
     * Tooltip and Popover Control
     * @constructor
     * @param {Object} element
     * @param {Object|Function} options
     * @param {(string|Function)} [options.content] - Takes title attribute or feed content. Can be a string or jQuery markup
     * @param {Object} [options.offset={top: 10, left: 10}] - How much room to leave
     * @param {string} [options.placement=top|bottom|right|offset]
     * @param {string} [options.trigger=hover] - supports click and immediate and hover (and maybe in future focus)
     * @param {string} [options.title] - Title for Infor Tips
     * @param {string} [options.beforeShow] - Call back for ajax tooltip
     * @param {string} [options.popover] - force it to be a popover (no content)
     * @param {string} [options.closebutton] - Show X close button next to title in popover
     * @param {Boolean} [options.isError=false] - Add error classes
     * @param {Boolean} [options.isErrorColor=false] - Add error color only not description
     * @param {string} [options.tooltipElement] - ID selector for an alternate element to use to contain the tooltip classes
     * @param {Object} [options.parentElement=this.element] - jQuery-wrapped element that gets passed to the 'place' behavior as the element to place the tooltip against.
     * @param {Boolean} [options.keepOpen=false] - Forces the tooltip to stay open in situations where it would normally close.
     * @param {string} [options.extraClass] - Extra css class
     * @param {string} [options.maxWidth] - Toolip max width
     */
    function Tooltip(element, options) {
      this.settings = $.extend({}, defaults, options);
      this.element = $(element);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    Tooltip.prototype = {
      init: function() {
        this.setup();
        this.appendTooltip();

        // Initial Content Setting.
        // Don't do this if we're using an "immediate" trigger because _setContent()_ is handled at
        // display time in that case.
        var shouldRender = this.settings.trigger !== 'immediate';
        if (shouldRender) {
          this.setContent(this.settings.content, true);
        }

        this.handleEvents();
      },


      setup: function() {
        // "this.activeElement" is the target element that the Tooltip will display itself against
        this.activeElement = this.settings.parentElement instanceof $ && this.settings.parentElement.length ? this.settings.parentElement : this.element;

        this.descriptionId = $('.tooltip-description').length + 1;
        this.description = this.element.parent().find('.tooltip-description');
        if (!this.description.length && this.settings.isError) {
          this.description = $('<span id="tooltip-description-'+ this.descriptionId +'" class="tooltip-description audible"></span>').insertAfter(this.element);
        }

        if (this.element.is('.dropdown, .multiselect')) {
          this.activeElement = this.element.nextAll('.dropdown-wrapper:first').find('>.dropdown');
        }

        var titleAttr = this.element.attr('title');
        if (titleAttr && titleAttr.length) {
          this.settings.content = titleAttr;
          this.element.removeAttr('title');
        }

        this.isPopover = (this.settings.content !== null && typeof this.settings.content === 'object') || this.settings.popover === true;

        this.settings.closebutton = (this.settings.closebutton || this.element.data('closebutton')) ? true : false;

        if (this.element.data('extraClass') && this.element.data('extraClass').length) {
          this.settings.extraClass = this.element.data('extraClass');
        }

        this.isRTL = Locale.isRTL();
      },

      addAria: function() {
        if (!this.content) {
          return;
        }

        this.description.text(this.content);
        this.content = this.addClassToLinks(this.content, 'links-clickable');

        if (!this.isPopover) {
          this.element.removeAttr('title').attr('aria-describedby', this.description.attr('id'));
        }

        if (this.isPopover && this.settings.trigger === 'click') {
          this.element.attr('aria-haspopup', true);
        }
      },

      addClassToLinks: function(content, thisClass) {
        var isjQuery = (content instanceof $ && content.length > 0);
        if (isjQuery) {
          return content;
        }

        var d = $('<div/>').html(content);
        $('a', d).addClass(thisClass);
        return d.html();
      },

      appendTooltip: function() {
        this.tooltip = this.settings.tooltipElement ? $(this.settings.tooltipElement) : $('#tooltip');
        if (!this.tooltip.length) {
          var name = (this.settings.tooltipElement ? this.settings.tooltipElement.substring(1, this.settings.tooltipElement.length) : 'tooltip');
          this.tooltip = $('<div class="' + (this.isPopover ? 'popover' : 'tooltip') + ' bottom is-hidden" role="tooltip" id="' + name + '"><div class="arrow"></div><div class="tooltip-content"></div></div>');
        }

        this.tooltip.place({
          container: this.scrollparent,
          parent: this.activeElement,
          placement: this.settings.placement,
          strategy: 'flip'
        });

        this.setTargetContainer();
      },

      handleEvents: function() {
        var self = this, timer, delay = 400;

        if (this.settings.trigger === 'hover' && !this.settings.isError) {
          ((this.element.is('.dropdown, .multiselect')) ? this.activeElement : this.element)
            .on('mouseenter.tooltip', function() {
              timer = setTimeout(function() {
                self.show();
              }, delay);
            })
            .on('mouseleave.tooltip mousedown.tooltip click.tooltip mouseup.tooltip', function() {
                clearTimeout(timer);
                setTimeout(function() {
                  self.hide();
                }, delay);
            })
            .on('updated.tooltip', function() {
              self.updated();
            });
        }

        function toggleTooltipDisplay() {
          if (!self.tooltip.hasClass('is-hidden')) {
            self.hide();
          }
          self.show();
        }

        if (this.settings.trigger === 'click') {
          this.element.on('click.tooltip', function() {
            toggleTooltipDisplay();
          });
        }

        if (this.settings.trigger === 'immediate') {
          timer = setTimeout(function() {
            toggleTooltipDisplay();
          }, 1);
        }

        // Uncomment the line below to get focus support on some elements all the time, regardless of trigger setting.
        //var isFocusable = (this.element.filter('button, a').length && this.settings.trigger !== 'click') || this.settings.trigger === 'focus';
        var isFocusable = this.settings.trigger === 'focus';
        if (isFocusable) {
          this.element.on('focus.tooltip', function() {
            self.show();
          })
          .on('blur.tooltip', function() {
            if (!self.settings.keepOpen) {
              self.hide();
            }
          });
        }

        // Media Query Listener to detect a menu closing on mobile devices that change orientation.
        this.matchMedia = window.matchMedia('(orientation: landscape)');
        this.mediaQueryListener = function() {
          // Match every time.
          if (self.tooltip.hasClass('is-hidden')) {
            return;
          }
          self.close();
        };
        this.matchMedia.addListener(this.mediaQueryListener);
      },

      setContent: function(content, dontRender) {
        var self = this,
          specified,
          settingsContent = this.settings.content,
          noIncomingContent = (content === undefined || content === null),
          noSettingsContent = (settingsContent === undefined || settingsContent === null);

        function doRender() {
          if (dontRender === true) {
            return;
          }
          self.addAria();
          self.render();
        }

        // If all sources of content are undefined, just return false and don't show anything.
        if (noIncomingContent && noSettingsContent) {
          return false;
        }

        // If the settingsContent type is a function, we need to re-run that function to update the content.
        // NOTE: If you need to use a function to generate content, understand that the tooltip/popover will not
        // cache your content for future reuse.  It will ALWAYS override incoming content.
        if (typeof settingsContent === 'function') {
          content = settingsContent;
        }

        // Use the pre-set content if we have no incoming content
        if (noIncomingContent) {
          content = settingsContent;
        }

        // If the incoming/preset content is exactly the same as the stored content, don't continue with this step.
        // Deep object comparison for jQuery objects is done further down the chain.
        if (content === this.content) {
          doRender();
          return true;
        }

        // jQuery-wrapped elements don't get manipulated.
        // Simply store the reference, render, and return.
        if (content instanceof $ && content.length) {
          this.content = content.addClass('hidden');
          doRender();
          return true;
        }

        // Handle setting of content based on its Object type.
        // If type isn't handled, the tooltip will not display.
        if (typeof content === 'string') {
          if (!content.length) {
            return false;
          }

          // Could be a translation definition
          content = Locale.translate(content) || content;

          // Could be an ID attribute
          // If it matches an element already on the page, grab that element's content and store the reference only.
          if (content.indexOf('#') === 0) {
            var contentCheck = $('' + content);
            if (contentCheck.length) {
              this.content = contentCheck;
              doRender();
              return true;
            }
            return false;
          }

        // functions
        } else if (typeof content === 'function') {
          var callbackResult = content.call(this.element);
          if (!callbackResult || typeof callbackResult !== 'string' || !callbackResult.length) {
            return false;
          }
          content = callbackResult;

        // if type isn't handled, return false
        } else {
          return false;
        }

        // Store an internal copy of the processed content
        this.content = $.sanitizeHTML(content);

        // Wrap tooltip content in <p> tags if there isn't already one present.
        // Only happens for non-jQuery markup.
        if (!specified) {
          this.content = '<p>' + this.content + '</p>';
        }

        doRender();
        return true;
      },

      render: function() {
        if (this.isPopover) {
          return this.renderPopover();
        }
        return this.renderTooltip();
      },

      renderTooltip: function() {
        var titleArea = this.tooltip[0].querySelectorAll('.tooltip-title')[0],
          contentArea = this.tooltip[0].querySelectorAll('.tooltip-content')[0],
          extraClass = this.settings.extraClass,
          content = this.content,
          tooltip = this.tooltip[0],
          classes = 'tooltip is-hidden';

        if (extraClass) {
          classes += ' ' + extraClass;
        }
        tooltip.setAttribute('class', classes);

        if (titleArea) {
          titleArea.style.display = 'none';
        }

        if (!contentArea.previousElementSibling.classList.contains('arrow')) {
          contentArea.insertAdjacentHTML('beforebegin', '<div class="arrow"></div>');
        }

        if (typeof this.content === 'string') {
          contentArea.innerHTML = content;
        } else {
          contentArea.innerHTML = content[0].innerHTML;
        }
      },

      renderPopover: function() {
        var self = this,
          extraClass = this.settings.extraClass,
          content = this.content,
          contentArea = this.tooltip.find('.tooltip-content'),
          title = this.tooltip[0].querySelector('.tooltip-title'),
          classes = 'popover is-hidden';

        if (extraClass) {
          classes += ' ' + extraClass;
        }
        content[0].classList.remove('hidden');
        this.tooltip[0].setAttribute('class', classes);

        if (typeof content === 'string') {
          content = $(content);
        } else {
          contentArea.html(content);
        }

        contentArea[0].firstElementChild.classList.remove('hidden');

        if (this.settings.title !== null) {
          if (!title) {
            var titleFrag = document.createDocumentFragment();
            title = document.createElement('div');
            title.innerHTML = this.settings.title;
            title.classList.add('tooltip-title');
            titleFrag.appendChild(title);
            this.tooltip[0].insertBefore(titleFrag, this.tooltip[0].firstChild);
          } else {
            title.childNodes[0].nodeValue = this.settings.title;
          }
        }

        if (this.settings.closebutton && title && !title.firstElementChild) {
          var closeBtnX = $(
            '<button type="button" class="btn-icon l-pull-right" style="margin-top: -9px">' +
              $.createIcon({ classes: ['icon-close'], icon: 'close' }) +
              '<span>Close</span>' +
            '</button>'
          ).on('click', function() {
            self.hide();
          });

          title.appendChild(closeBtnX[0]);
        }

        content.initialize();
      },

      // Alias for _show()_.
      open: function() {
        return this.show();
      },

      show: function(newSettings, ajaxReturn) {
        var self = this;
        this.isInPopup = false;

        if (newSettings) {
          this.settings = $.extend({}, this.settings, newSettings);
        }

        if (this.settings.beforeShow && !ajaxReturn) {
          var response = function (content) {
            self.show({content: content}, true);
          };

          if (typeof this.settings.beforeShow === 'string') {
            window[this.settings.beforeShow](response);
            return;
          }

          this.settings.beforeShow(response);
          return;
        }

        var okToShow = true;

        okToShow = this.setContent(this.content);
        if (okToShow === false) {
          return;
        }

        okToShow = this.element.triggerHandler('beforeshow', [this.tooltip]);
        if (okToShow === false) {
          return;
        }

        this.tooltip[0].setAttribute('style', '');
        this.tooltip[0].classList.add(this.settings.placement);


        if (this.settings.isError || this.settings.isErrorColor) {
          this.tooltip[0].classList.add('is-error');
        }

        this.position();
        this.element.trigger('show', [this.tooltip]);

        setTimeout(function () {
          $(document).on('mouseup.tooltip', function (e) {
            var target = $(e.target);

            if (self.settings.isError || self.settings.trigger === 'focus') {
             return;
            }

            if (target.is(self.element) && target.is('svg.icon')) {
              return;
            }

            if ($('#editor-popup').length && $('#colorpicker-menu').length) {
              return;
            }

            if (target.closest('.popover').length === 0 &&
                target.closest('.dropdown-list').length === 0) {
              self.hide(e);
            }
          })
          .on('keydown.tooltip', function (e) {
            if (e.which === 27 || self.settings.isError) {
              self.hide();
            }
          });

          if (self.settings.isError && !self.element.is(':visible') && !self.element.is('.dropdown')) {
            self.hide();
          }

          if (window.orientation === undefined) {
            $('body').on('resize.tooltip', function() {
              self.hide();
            });
          }

          // Click to close
          if (self.settings.isError) {
            self.tooltip.on('click.tooltip', function () {
              self.hide();
            });
          }

          self.element.trigger('aftershow', [self.tooltip]);
        }, 400);

      },

      // Places the tooltip element itself in the correct DOM element.
      // If the current element is inside a scrollable container, the tooltip element goes as high as possible in the DOM structure.
      setTargetContainer: function() {
        var targetContainer = $('body');

        // adjust the tooltip if the element is being scrolled inside a scrollable DIV
        this.scrollparent = this.element.closest('.page-container.scrollable');
        if (this.scrollparent.length) {
          targetContainer = this.scrollparent;
        }

        if (this.settings.parentElement) {
          targetContainer = this.settings.parentElement;
        }

        //this.tooltip.detach().appendTo(targetContainer);
        targetContainer[0].appendChild(this.tooltip[0]);
      },

      // Placement behavior's "afterplace" handler.
      // DO NOT USE FOR ADDITIONAL POSITIONING.
      handleAfterPlace: function(e, placementObj) {
        this.tooltip.data('place').setArrowPosition(e, placementObj, this.tooltip);
        this.tooltip.triggerHandler('tooltipafterplace', [placementObj]);
      },

      position: function () {
        this.setTargetContainer();
        this.tooltip[0].classList.remove('is-hidden');

        var self = this,
          distance = this.isPopover ? 20 : 10,
          tooltipPlacementOpts = this.settings.placementOpts || {},
          opts = $.extend({}, {
            x: 0,
            y: distance,
            container: this.scrollparent,
            containerOffsetX: tooltipPlacementOpts.containerOffsetX || this.settings.offset.left,
            containerOffsetY: tooltipPlacementOpts.containerOffsetY || this.settings.offset.top,
            parent: tooltipPlacementOpts.parent || this.activeElement,
            placement: tooltipPlacementOpts.placement || this.settings.placement,
            strategies: ['flip', 'nudge']
          }, tooltipPlacementOpts);

        if (opts.placement === 'left' || opts.placement === 'right') {
          opts.x = distance;
          opts.y = 0;
        }

        this.tooltip.one('afterplace.tooltip', function(e, placementObj) {
          self.handleAfterPlace(e, placementObj);
        });

        this.tooltip.data('place').place(opts);
        return this;
      },

      // Alias for _hide()_ that works with the global _closeChildren()_ method.
      close: function() {
        return this.hide();
      },

      hide: function() {
        if (this.settings.keepOpen) {
          return;
        }

        if (this.isInPopup) {
          this.settings.content.addClass('hidden');
          return;
        }

        this.tooltip[0].classList.add('is-hidden');
        this.tooltip[0].style.left = '';
        this.tooltip[0].style.top = '';
        this.tooltip.find('.arrow').removeAttr('style');

        this.tooltip.off('click.tooltip');

        if ($('.popover').not('.is-hidden').length === 0) {
          $(document).off('mouseup.tooltip keydown.tooltip');
          $('body').off('resize.tooltip');
        }

        this.element.trigger('hide', [this.tooltip]);
      },

      updated: function() {
        var self = this;

        if (self.settings.trigger === 'immediate') {
          setTimeout(function() {
            self.show();
          }, 100);
        } else {
          self.setContent();
        }

        return this;
      },

      teardown: function() {
        this.description.remove();
        this.descriptionId = undefined;
        this.element.removeAttr('aria-describedby').removeAttr('aria-haspopup');
        if (!this.tooltip.hasClass('is-hidden')) {
          this.hide();
        }

        this.element.off('mouseenter.tooltip mouseleave.tooltip mousedown.tooltip click.tooltip mouseup.tooltip updated.tooltip focus.tooltip blur.tooltip');
        $(document).off('mouseup.tooltip');
        $('body').off('resize.tooltip');

        if (this.matchMedia) {
          this.matchMedia.removeListener(this.mediaQueryListener);
        }

        return this;
      },

      destroy: function() {
        this.teardown();
        $.removeData(this.element[0], pluginName);
      }
    };

    // Initializing the Control Once or Call Methods.
    return this.each(function() {

      var instance = $.data(this, pluginName);

      //Allow one tooltip and one popover
      if (instance /*&& (instance.settings.popover == null || instance.settings.popover !== settings.popover)*/) {
        if (typeof instance[options] === 'function') {
          instance[options](args);
        }

        instance.settings = $.extend({}, instance.settings, options);
        instance.updated();

        return;
      }

      instance = $.data(this, pluginName, new Tooltip(this, options));
    });
  };

  // Popover & Tooltip are the same control
  $.fn.popover = $.fn.tooltip;


  //TODO: - Context Menus
  //      - Search
  $.fn.tree = function(options) {
    var pluginName = 'tree',
      defaults = {
        selectable: 'single', // ['single'|'multiple']
        hideCheckboxes: false, // [true|false] -apply only with [selectable: 'multiple']
        menuId: null, //Context Menu to add to nodes
        useStepUI: false, // When using the UI as a stepped tree
        folderIconOpen: 'open-folder',
        folderIconClosed: 'closed-folder',
        sortable: false, // Allow nodes to be sortable
        onBeforeSelect: null
      },
      settings = $.extend({}, defaults, options);

    /**
     * @constructor
     * @param {Object} element
     */
    function Tree(element) {
      this.element = $(element);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    // Tree Methods
    Tree.prototype = {
      init: function() {
        this.settings = $.extend({}, settings);
        this.isIe11 = (Soho.env.browser.name === 'ie' && Soho.env.browser.version === '11');
        this.initTree();
        this.handleKeys();
        this.setupEvents();
        this.loadData(this.settings.dataset);
        this.syncDataset(this.element);
        this.initSelected();
        this.focusFirst();
        this.attachMenu(this.settings.menuId);
        this.createSortable();
      },

      //Init Tree from ul, li, a markup structure in DOM
      initTree: function() {
        var self = this,
          s = this.settings,
          links = this.element.find('a'),
          selectableAttr = this.element.attr('data-selectable');

        // Set attribute "data-selectable"
        s.selectable = ((typeof selectableAttr !== 'undefined') &&
         (selectableAttr.toLowerCase() === 'single' ||
           selectableAttr.toLowerCase() === 'multiple')) ?
            selectableAttr : s.selectable;

        // Set isMultiselect and checkboxes show/hide
        this.isMultiselect = s.selectable === 'multiple';
        s.hideCheckboxes = s.hideCheckboxes || !this.isMultiselect;

        this.element.addClass(this.isMultiselect ? ' is-muliselect' : '');

        links.each(function() {
          var a = $(this);
          self.decorateNode(a);
        });
      },

      //Init selected notes
      initSelected: function () {
        var self = this;
        this.element.find('li').each(function() {
          self.setNodeStatus($('a:first', this));
        });
      },

      //Focus first tree node
      focusFirst: function () {
        this.element.find('a:first').attr('tabindex', '0');
      },

      //Set focus
      setFocus: function (node) {
        node.focus();
      },

      //From the LI, Read props and add stuff
      decorateNode: function(a) {
        var subNode,
        parentCount = 0,
        badgeData = a.attr('data-badge'),
        alertIcon = a.attr('data-alert-icon'),
        badge = {elem: $('<span class="tree-badge badge"></span>')},
        isParentsDisabled = a.parentsUntil(this.element, 'ul[role=group].is-disabled').length > 0,
        isDisabled = a.hasClass('is-disabled') || isParentsDisabled;

        if (typeof badgeData !== 'undefined') {
          badgeData = $.fn.parseOptions(a, 'data-badge');
        }

        //set initial 'role', 'tabindex', and 'aria selected' on each link (except the first)
        a.attr({'role': 'treeitem', 'tabindex': '-1', 'aria-selected': 'false'});

        // Add Aria disabled
        if (isDisabled) {
          a.addClass('is-disabled').attr('aria-disabled','true');
          var childSection = a.next();

          if (childSection.is('ul.is-open')) {
            $('a', childSection).addClass('is-disabled').attr('aria-disabled','true');
            $('ul', a.parent()).addClass('is-disabled');
          }
        }

        //parentCount 'aria-level' to the node's level depth
        parentCount = a.parentsUntil(this.element, 'ul').length - 1;
        a.attr('aria-level', parentCount + 1);

        //Set the current tree item node position relative to its aria-setsize
        var posinset = a.parent().index();
        a.attr('aria-posinset', posinset + 1);

        //Set the current tree item aria-setsize
        var listCount = a.closest('li').siblings().addBack().length;
        a.attr('aria-setsize', listCount);

        //Set the current tree item node expansion state
        if (a.next('ul').children().length > 0) {
          a.attr('aria-expanded', a.next().hasClass('is-open') ? 'true' : 'false');
        }

        //adds role=group' to all subnodes
        subNode = a.next();

        //Inject Icons
        var text = a.contents().filter(function() {
          return !$(this).is('.tree-badge');// Do not include badge text
        }).text();

        a.text('');
        if (a.children('svg.icon-tree').length === 0) {
          a.prepend($.createIcon({ icon: 'tree-node', classes: ['icon-tree'] }));

          if (this.settings.useStepUI) {
            a.prepend($.createIcon({ icon: alertIcon, classes: ['step-alert', 'icon-' + alertIcon] }));
          }
        }

        //Inject checkbox
        if (this.isMultiselect && !this.settings.hideCheckboxes) {
          a.append('<span class="tree-checkbox"></span>');
        }

        //Inject badge
        if (badgeData && !badgeData.remove) {
          badge.text = '';

          if (typeof badgeData.text !== 'undefined') {
            badge.text = badgeData.text.toString();
            badge.elem.html(badge.text);
            if (badge.text.length === 1) {
              badge.elem.addClass('round');
            }
          }
          if (/info|good|error|alert|pending/i.test(badgeData.type)) {
            badge.elem.addClass(badgeData.type);
          } else if (badgeData.type && badgeData.type.charAt(0) === '#' && badgeData.type.length === 7) {
              badge.elem.css('background-color', badgeData.type);
          }

          if (badge.elem.text() !== '') {
            a.append(badge.elem);
          }
          if (badgeData.type && badgeData.type.indexOf('pending') !== -1) {
            badge.elem.text('');
          }
        }

        a.append('<span class="tree-text">' + text + '</span>');

        if (a.is('[class^="icon"]')) {
          //createIconPath
          this.setTreeIcon(a.find('svg.icon-tree'), a.attr('class'));
        }

        if (subNode.is('ul')) {
          subNode.attr('role', 'group').parent().addClass('folder');
          this.setTreeIcon(a.find('svg.icon-tree'), subNode.hasClass('is-open') ? this.settings.folderIconOpen : this.settings.folderIconClosed);

          if (a.attr('class') && a.attr('class').indexOf('open') === -1 && a.attr('class').indexOf('closed') === -1) {
            a.attr('class', isDisabled ? 'is-disabled' : '');
            this.setTreeIcon(a.find('svg.icon-tree'), subNode.hasClass('is-open') ? this.settings.folderIconOpen : this.settings.folderIconClosed);
          }

          if (a.is('[class^="icon"]')) {
            this.setTreeIcon(a.find('svg.icon-tree'), subNode.hasClass('is-open') ?  a.attr('class') : a.attr('class').replace('open', 'closed') );
          }
        }

        a.addClass('hide-focus');
        a.hideFocus();
      },

      setTreeIcon: function(svg, icon) {
        // Replace all "icon-", "hide-focus", "\s? - all spaces if any" with nothing
        var iconStr = icon.replace(/#?icon-|hide-focus|\s?/gi, '');
        svg.changeIcon(iconStr);
      },

      //Expand all Parents
      expandAll: function(nodes) {
        var self = this;

        nodes = nodes || this.element.find('ul[role=group]');
        nodes.each(function () {
          var node = $(this);
          node.addClass('is-open');
          self.setTreeIcon(node.prev('a').find('svg.icon-tree'), self.settings.folderIconOpen);

          if (node.prev('a').is('[class^="icon"]')) {
            self.setTreeIcon(node.prev('svg.icon-tree'), node.prev('a').attr('class'));
          }

        });
      },

      //Collapse all Parents
      collapseAll: function () {
        var nodes = this.element.find('ul[role=group]'), self = this;

        nodes.each(function () {
          var node = $(this);
          node.removeClass('is-open');
          self.setTreeIcon(node.prev('a').find('svg.icon-tree'), self.settings.folderIconClosed);

          if (node.prev('a').is('[class^="icon"]')) {
            self.setTreeIcon(node.prev('a').find('svg.icon-tree'), node.prev('a').attr('class').replace('open', 'closed').replace(' hide-focus', '').replace(' is-selected', '') );
          }

          if (node.prev('a').is('[class^="icon"]')) {
            self.setTreeIcon(node.prev('svg.icon-tree'), node.prev('a').attr('class').replace('open', 'closed'));
          }

        });
      },

      // Check if a jQuery object
      isjQuery: function (obj) {
        return (obj && (obj instanceof jQuery || obj.constructor.prototype.jquery));
      },

      // Select node by id
      selectNodeById: function (id) {
        this.selectNodeByJquerySelector('#'+ id);
      },

      // Select node by [jquery selector] -or- [jquery object]
      selectNodeByJquerySelector: function (selector) {
        var target = this.isjQuery(selector) ? selector : $(selector);
        if (target.length && !target.is('.is-disabled')) {
          var nodes = target.parentsUntil(this.element, 'ul[role=group]');
          this.expandAll(nodes);
          this.selectNode(target, true);
        }
      },

      //Set a node as unselected
      unSelectedNode: function (node, focus) {
        if (node.length === 0) {
          return;
        }

        var self = this,
          aTags = $('a', this.element);

        aTags.attr('tabindex', '-1');
        node.attr('tabindex', '0');

        $('a:not(.is-disabled)', node.parent()).attr('aria-selected', 'false').parent().removeClass('is-selected');

        this.syncNode(node);
        this.setNodeStatus(node);

        if (focus) {
          node.focus();
        }

        // Set active css class
        $('li', self.element).removeClass('is-active');
        node.parent().addClass('is-active');

        setTimeout(function() {
          var jsonData = node.data('jsonData') || {};
          self.element.triggerHandler('unselected', {node: node, data: jsonData});
        }, 0);
      },

      //Set a node as the selected one
      selectNode: function (node, focus) {
        var self = this;

        if (node.length === 0) {
          return;
        }

        // Possibly Call the onBeforeSelect
        var result;
        if (typeof self.settings.onBeforeSelect === 'function') {

          result = self.settings.onBeforeSelect(node);

          if (result.done && typeof result.done === 'function') { // A promise is returned
            result.done(function(continueSelectNode) {
              if (continueSelectNode) {
                self.selectNodeFinish(node, focus);
              }
            });
          } else if (result) { // Boolean is returned instead of a promise
            self.selectNodeFinish(node, focus);
          }

        } else { // No Callback specified
          self.selectNodeFinish(node, focus);
        }
      },

      selectNodeFinish: function(node, focus) {
        var self = this;
        var aTags = $('a', this.element);
        aTags.attr('tabindex', '-1');
        node.attr('tabindex', '0');

        if (this.isMultiselect) {
          $('a:not(.is-disabled)', node.parent())
            .attr('aria-selected', 'true').parent().addClass('is-selected');
        }
        else {
          aTags.attr('aria-selected', 'false').parent().removeClass('is-selected');
          aTags.attr('aria-selected', 'false').removeClass('is-selected');
          node.attr('aria-selected', 'true').parent().addClass('is-selected');
        }

        this.syncNode(node);
        if (!this.loading) {
          this.setNodeStatus(node);
        }

        if (focus) {
          node.focus();
        }

        // Set active css class
        $('li', self.element).removeClass('is-active');
        node.parent().addClass('is-active');

        setTimeout(function() {
          var jsonData = node.data('jsonData') || {};
          self.element.triggerHandler('selected', {node: node, data: jsonData});
        }, 0);
      },

      setNodeStatus: function(node) {
        var self = this,
          data = node.data('jsonData'),
          nodes;

        // Not multiselect
        if (!this.isMultiselect) {
          node.removeClass('is-selected is-partial');
          if (data && data.selected) {
            node.addClass('is-selected');
          }
          return;
        }

        var setStatus = function (nodes, isFirstSkipped) {
          nodes.each(function() {
            var node = $('a:first', this),
              parent = node.parent(),
              status = self.getSelectedStatus(node, isFirstSkipped);

            if (status === 'mixed') {
              parent.removeClass('is-selected is-partial').addClass('is-partial');
            }
            else if (status) {
              parent.removeClass('is-selected is-partial').addClass('is-selected');
            }
            else {
              parent.removeClass('is-selected is-partial');
            }
            self.syncNode(node);
          });
        };

        // Multiselect
        var isFirstSkipped = false;
        nodes = node.parent().find('li.folder');
        setStatus(nodes, isFirstSkipped);

        isFirstSkipped = (!nodes.length && data && !data.selected) ? false : true;
        nodes = node.parentsUntil(this.element, 'li.folder');
        setStatus(nodes, isFirstSkipped);
      },

      getSelectedStatus: function(node, isFirstSkipped) {
        var status,
          total = 0,
          selected = 0,
          unselected = 0,
          data;

        node.parent().find('a').each(function(i) {
          if (isFirstSkipped && i === 0) {
            return;
          }
          total++;
          data = $(this).data('jsonData');
          if (data && data.selected) {
            selected++;
          } else {
            unselected++;
          }
        });

        status = ((total === selected) ? true : ((total === unselected) ? false : 'mixed'));
        return status;
      },

      //Animate open/closed the node
      toggleNode: function(node) {
        var next = node.next(),
          self = this;

        if (next.is('ul[role="group"]')) {
          if (next.hasClass('is-open')) {

            self.setTreeIcon(node.closest('.folder').removeClass('is-open').end().find('svg.icon-tree'), self.settings.folderIconClosed);

            if (node.closest('.folder a').is('[class^="icon"]')) {
              self.setTreeIcon(node.closest('.folder a').find('svg.icon-tree'),
                node.closest('.folder a').attr('class').replace('open', 'closed').replace(' hide-focus', '').replace(' is-selected', ''));
            }

            self.isAnimating = true;

            if (!self.isMultiselect) {
              self.unSelectedNode(node.parent().find('li.is-selected'), false);
              node.removeClass('is-selected');
            }

            next.one('animateclosedcomplete', function() {
              next.removeClass('is-open');
              self.isAnimating = false;
            }).animateClosed();

            node.attr('aria-expanded', node.attr('aria-expanded')!=='true');



          } else {
            var nodeData = node.data('jsonData');

            if (self.settings.source && nodeData.children && nodeData.children.length === 0) {
              var response = function (nodes) {
                var id = nodeData.id,
                elem = self.findById(id);

                //Add DB and UI nodes
                elem.children = nodes;
                self.addChildNodes(elem, node.parent());
                node.removeClass('is-loading');
                self.loading = false;

                //open
                self.openNode(next, node);

                //sync data on node
                nodeData.children = nodes;
                node.data('jsonData', nodeData);
                self.selectNode(node, true);
                self.initSelected();
              };

              var args = {node: node, data: node.data('jsonData')};
              self.settings.source(args, response);
              node.addClass('is-loading');
              self.loading = true;

              return;
            }
            self.openNode(next, node);
          }
        }
      },

      //Open the node
      openNode: function(next, node) {
        var self = this;

        self.setTreeIcon(node.closest('.folder').addClass('is-open').end().find('svg.icon-tree'), self.settings.folderIconOpen);

        if (node.is('[class^="icon"]')) {
          self.setTreeIcon(node.find('svg.icon-tree'), node.attr('class').replace(' hide-focus', '').replace(' is-selected', ''));
        }

        self.isAnimating = true;

        next.one('animateopencomplete', function() {
          self.isAnimating = false;
        }).addClass('is-open').css('height', 0).animateOpen();
        node.attr('aria-expanded', node.attr('aria-expanded')!=='true');
      },

      //Setup event handlers
      setupEvents: function () {
        var self = this;
        self.element.on('updated.tree', function () {
          self.initTree();
        });
      },

      //Handle Keyboard Navigation
      handleKeys: function () {

        //Key Behavior as per: http://access.aol.com/dhtml-style-guide-working-group/#treeview
        var self = this;
        //on click give clicked element 0 tabindex and 'aria-selected=true', resets all other links
        this.element.on('click.tree', 'a:not(.is-clone)', function (e) {
          var target = $(this),
            parent = target.parent();
          if (!target.is('.is-disabled, .is-loading')) {
            if (self.isMultiselect) {
              if ($(e.target).is('.icon') && parent.is('.folder')) {
                self.toggleNode(target);
              }
              else if (parent.is('.is-selected, .is-partial')) {
                self.unSelectedNode(target, true);
              }
              else {
                self.selectNode(target, true);
              }
            }
            else {
              self.selectNode(target, true);
              self.toggleNode(target);
            }
            e.stopPropagation();
          }
          return false; //Prevent Click from Going to Top
        });

        this.element
        //Focus on "a" elements
        .on('focus.tree', 'a', function() {
          var target = $(this);
          if ((parseInt(target.attr('aria-level')) === 0) &&
              (parseInt(target.attr('aria-posinset')) === 1)) {

            // First element if disabled
            if (target.hasClass('is-disabled')) {
              var e = $.Event('keydown.tree');
              e.keyCode = 40; // move down
              target.trigger(e);
              return;
            }
          }
        });

        //Handle Up/Down Arrow Keys and Space
        this.element.on('keydown.tree', 'a', function (e) {

          var charCode = e.charCode || e.keyCode,
              target = $(this),
              next, prev;

          if (self.isAnimating) {
            return;
          }

          //down arrow
          if (charCode === 40) {
            var nextNode = self.getNextNode(target);
            self.setFocus(nextNode);
          }

          //up arrow,
          if (charCode === 38) {
            var prevNode = self.getPreviousNode(target);
            self.setFocus(prevNode);
          }

          //space
          if (e.keyCode === 32) {
            target.trigger('click.tree');
          }

          // Left arrow
          if (charCode === 37) {
            if (Locale.isRTL()) {
              if (target.next().hasClass('is-open')) {
                prev = target.next().find('a:first');
                self.setFocus(prev);
              } else {
                self.toggleNode(target);
              }
            } else {
              if (target.next().hasClass('is-open')) {
                self.toggleNode(target);
              } else {
                prev = target.closest('.folder').find('a:first');
                self.setFocus(prev);
              }
            }
            e.stopPropagation();
            return false;
          }

          // Right arrow
          if (charCode === 39) {
            if (Locale.isRTL()) {
              if (target.next().hasClass('is-open')) {
                self.toggleNode(target);
              } else {
                next = target.closest('.folder').find('a:first');
                self.setFocus(next);
              }
            } else {
              if (target.next().hasClass('is-open')) {
                next = target.next().find('a:first');
                self.setFocus(next);
              } else {
                self.toggleNode(target);
                self.setFocus(target);
              }

            }
            e.stopPropagation();
            return false;
          }

          //Home  (fn-right on mac)
          if (charCode === 36) {
            next = self.element.find('a:first:visible');
            self.setFocus(next);
          }

          //End (fn-right on mac)
          if (charCode === 35) {
            next = self.element.find('a:last:visible');
            self.setFocus(next);
          }

        });

        //Handle Left/Right Arrow Keys
        this.element.on('keypress.tree', 'a', function (e) {
          var charCode = e.charCode || e.keyCode,
            target = $(this);

          if ((charCode >= 37 && charCode <= 40) || charCode === 32) {
            e.stopPropagation();
            return false;
          }

          //Printable Chars Jump to first high level node with it...
           if (e.which !== 0) {
            target.closest('li').nextAll().find('a:visible').each(function () {
              var node = $(this),
                first = node.text().substr(0,1).toLowerCase(),
                term = String.fromCharCode(e.which).toLowerCase();

              if (first === term) {
                self.setFocus(node);
                return false;
              }
            });
          }

        });
      },

      //handle Loading JSON
      loadData: function (dataset) {
        var self = this;
        if (!dataset) {
          return;
        }

        self.element.empty();

        self.loading = true;
        for (var i = 0; i < dataset.length; i++) {
          self.addNode(dataset[i], 'bottom');
        }

        self.loading = false;
        self.syncDataset(self.element);
      },

      //Functions to Handle Internal Data Store
      addToDataset: function (node, location) {
        var elem;

        if (node.parent) {
          elem = this.findById(node.parent);
        }

        if (location === 'bottom' && !node.parent && !elem) {
          this.settings.dataset.push(node);
        }

        if (location === 'top' && !node.parent && !elem) {
          this.settings.dataset.unshift(node);
        }

        if (node.parent && elem) {

          if (!elem.children) {
            elem.children = [];
          }

          if (location === 'bottom') {
            elem.children.push(node);
          } else {
            elem.children.unshift(node);
          }
        }

        return ((node.parent && !elem) ? false : true);
      },

      //Find the Node (Dataset) By Id
      findById: function (id, source) {
        var key,
          self = this;

        if (!source) {
          source = this.settings.dataset;
        }

        for (key in source) {
            var item = source[key];
            if (item.id === id) {
              return item;
            }

            if (item.children) {
              var subresult = self.findById(id, item.children);

              if (subresult) {
                return subresult;
              }
            }
        }
        return null;
      },

      // Get node by ID if selected
      getNodeByIdIfSelected: function (id, source) {
        var node = this.findById(id, source);
        return (node && node.selected) ? node : null;
      },

      // Get selected nodes
      getSelectedNodes: function () {
        var node, data,
          selected = [];

        $('li.is-selected', this.element).each(function() {
          node = $('a:first', this);
          data = node.data('jsonData');
          selected.push({'node': node, 'data': data});
        });
        return selected;
      },

      getNextNode: function(target) {
        var next = target.parent().next().find('a:first'),
          subTarget = target.next();

        //Move Into Children
        if (subTarget.is('ul.is-open')) {
          next = subTarget.find('a:first');
        }

        //skip disabled
        if (next.hasClass('is-disabled')) {
          next = next.parent().next().find('a:first');
        }

        //bottom of a group..{l=1000: max folders to be deep }
        if (next.length === 0) {
          for (var i = 0, l = 1000, closest = target; i < l; i++) {
            closest = closest.parent().closest('.folder');
            next = closest.next().find('a:first');
            if (next.length) {
              break;
            }
          }
        }

        //another check for disabled
        if (next.hasClass('is-disabled')) {
          next = this.getNextNode(next);
        }

        return next;
      },

      getPreviousNode: function(target) {
        var prev = target.parent().prev().find('a:first'),
          subTarget = prev.parent();

        //move into children at bottom
        if (subTarget.is('.folder.is-open') &&
            subTarget.find('ul.is-open a').length &&
            !subTarget.find('ul.is-disabled').length) {
          prev = subTarget.find('ul.is-open a:last');
        }

        //skip disabled
        if (prev.hasClass('is-disabled')) {
          prev = prev.parent().prev().find('a:first');

          //another check if get to prev open folder
          subTarget = prev.parent();
          if (subTarget.is('.folder.is-open') &&
              subTarget.find('ul.is-open a').length &&
              !subTarget.find('ul.is-disabled').length) {
            prev = subTarget.find('ul.is-open a:last');
          }
        }

        //top of a group
        if (prev.length === 0) {
          prev = target.closest('ul').prev('a');
        }

        //another check for disabled
        if (prev.hasClass('is-disabled')) {
          prev = this.getPreviousNode(prev);
        }

        return prev;
      },


      //Sync the tree with the underlying dataset
      syncDataset: function (node) {

        var json = [],
          self = this;

        node.children('li').each(function () {
          var elem = $(this),
            tag = elem.find('a:first');

          var entry = self.syncNode(tag);
          json.push(entry);

        });

        this.settings.dataset = json;
      },

      //Sync a node with its dataset 'record'
      syncNode: function (node) {
        var entry = {},
          self = this,
          jsonData = node.data('jsonData');

        entry.node = node;
        entry.id = node.attr('id');
        entry.text = node.find('.tree-text').text();

        if (node.hasClass('is-open')) {
          entry.open = true;
        }

        if (node.attr('href')) {
          entry.href = node.attr('href');
        }

        if (node.parent().is('.is-selected')) {
          entry.selected = true;
        }

        //icon
        var clazz = node.attr('class');
        if (clazz && clazz.indexOf('icon') > -1) {
          entry.icon = node.attr('class');
        }

        if (node.next().is('ul')) {
          var ul = node.next();
          entry.children = [];

          ul.children('li').each(function () {
            var elem = $(this),
              tag = elem.find('a:first');

            entry.children.push(self.syncNode(tag));
          });
        }

        if (jsonData) {
          delete jsonData.selected;
          entry = $.extend({}, jsonData, entry);
        }

        node.data('jsonData', entry);
        return entry;
      },

      // Add a node and all its related markup
      addNode: function (nodeData, location) {
        var li = $('<li></li>'),
          a = $('<a href="#"></a>').appendTo(li),
          badgeAttr = typeof nodeData.badge === 'object' ? JSON.stringify(nodeData.badge) : nodeData.badge;

        location = (!location ? 'bottom' : location); //supports button or top or jquery node

        a.attr({
          'id': nodeData.id,
          'href': nodeData.href,
          'data-badge': badgeAttr,
          'data-alert-icon': nodeData.alertIcon
        }).text(nodeData.text);

        if (nodeData.open) {
          a.parent().addClass('is-open');
        }

        if (nodeData.disabled) {
          a.addClass('is-disabled');
        }

        if (nodeData.icon) {
          a.addClass(nodeData.icon);
        }

        //Handle Location
        var found = this.loading ? true : this.addToDataset(nodeData, location);

        if (nodeData.parent instanceof jQuery) {
          found = true;
        }

        if (location instanceof jQuery && (!nodeData.parent || !found) && !(nodeData.parent instanceof jQuery)) {
          location.append(li);
          found = true;
        }

        if (location === 'bottom' && (!nodeData.parent || !found)) {
          this.element.append(li);
        }

        if (location === 'top' && (!nodeData.parent || !found)) {
          this.element.prepend(li);
        }

        // Support ParentId in JSON Like jsTree
        if (nodeData.parent) {

          if (found && typeof nodeData.parent === 'string') {
            li = this.element.find('#'+nodeData.parent).parent();

            if (!nodeData.disabled && li.is('.is-selected') && typeof nodeData.selected === 'undefined') {
              nodeData.selected = true;
            }
            this.addAsChild(nodeData, li);
          }

          if (nodeData.parent && nodeData.parent instanceof jQuery) {
            li = nodeData.parent;
            if (nodeData.parent.is('a')) {
              li = nodeData.parent.parent();
            }
            this.addAsChild(nodeData, li);
          }
          nodeData.node = li.find('ul li a#'+ nodeData.id);

        } else {
          this.addChildNodes(nodeData, li);
          nodeData.node = li.children('a').first();
        }

        this.decorateNode(a);

        if (nodeData.selected) {
          this.selectNode(a, nodeData.focus);
        }

        a.data('jsonData', nodeData);
        return li;
      },

      //Add a node to an exiting node, making it a folder if need be
      addAsChild: function (nodeData, li) {
        var ul = li.find('ul').first();
        if (ul.length === 0) {
          ul = $('<ul></ul>').appendTo(li);
          ul.addClass('folder');
        }

        ul.addClass(nodeData.open ? 'is-open' : '');
        this.decorateNode(li.find('a').first());

        nodeData.parent = '';
        this.addNode(nodeData, ul);
      },

      //Add the children for the specified node element
      addChildNodes: function (nodeData, li) {
        var self = this,
          ul = li.find('ul');

        if (!nodeData.children) {
          ul.remove();
          return;
        }

        if (ul.length === 0) {
          ul = $('<ul></ul>').appendTo(li);
          ul.addClass(nodeData.open ? 'is-open' : '');
          ul.addClass('folder');
        }

        ul.empty();

        if (nodeData.children) {
          for (var i = 0; i < nodeData.children.length; i++) {
            var elem = nodeData.children[i];
            self.addNode(elem, ul);
          }
        }
      },

      //Update fx rename a node
      updateNode: function (nodeData) {
        //Find the node in the dataset and ui and sync it
        var elem = this.findById(nodeData.id);

        //Passed in the node element
        if (nodeData.node) {
          elem = {};
          elem.node = nodeData.node;
        }

        if (!elem) {
          return;
        }

        // Update badge
        if (nodeData.badge) {
          var badge = elem.node.find('.tree-badge:first');
          // Add badge if not exists
          if (!badge.length && !nodeData.badge.remove) {
            if (!nodeData.badge.remove && typeof nodeData.badge.text !== 'undefined' && $.trim(nodeData.badge.text) !== '') {
              $('<span class="tree-badge badge"></span>').insertBefore(elem.node.find('.tree-text:first'));
              badge = elem.node.find('.tree-badge:first');
            }
          }
          // Make update changes
          if (badge.length) {
            if (typeof nodeData.badge.text !== 'undefined') {
              nodeData.badge.text = nodeData.badge.text.toString();
              badge.text(nodeData.badge.text).removeClass('round');
              if (nodeData.badge.text.length === 1) {
                badge.addClass('round');
              }
            }
            if (typeof nodeData.badge.type !== 'undefined') {
              badge.removeClass('info good error alert pending');
              if (/info|good|error|alert|pending/i.test(nodeData.badge.type)) {
                badge.addClass(nodeData.badge.type);
              } else if (nodeData.type && nodeData.badge.type.charAt(0) === '#' && nodeData.badge.type.length === 7) {
                badge.elem.css('background-color', nodeData.badge.type);
              }

              if (nodeData.badge.type.indexOf('pending') !== -1) {
                badge.text('');
              }
            }
            elem.badge = nodeData.badge;

            //Remove badge
            if (this.parseBool(nodeData.badge.remove)) {
              badge.remove();
              if (typeof elem.badge !== 'undefined') {
                delete elem.badge;
              }
            }
          }
        }

        if (nodeData.text) {
          elem.node.find('.tree-text').first().text(nodeData.text);
          elem.text = nodeData.text;
        }

        if (nodeData.icon) {
          this.setTreeIcon(elem.node.find('svg.icon-tree').first(), nodeData.icon);
          elem.icon = nodeData.icon;
        }

        if (nodeData.disabled) {
          elem.node.addClass('is-disabled');
          elem.node.attr('aria-disabled','true');

          var parent = elem.node.parent();
          if (parent.is('.folder.is-open')) {
            $('a', parent).addClass('is-disabled').attr('aria-disabled','true');
          }
        }

        if (nodeData.node) {
          this.syncDataset(this.element);
        }

        if (nodeData.children) {
          if (nodeData.children.length) {
            this.addChildNodes(nodeData, elem.node.parent());
          }
          else {
            this.removeChildren(nodeData, elem.node.parent());
          }
        }

      },

      // Performs the usual Boolean coercion with the exception of
      // the strings "false" (case insensitive) and "0"
      parseBool: function(b) {
        return !(/^(false|0)$/i).test(b) && !!b;
      },

      // Delete children nodes
      removeChildren: function (nodeData, li) {
        var ul = li.find('ul');

        this.setTreeIcon(li.find('svg.icon-tree').first(), (nodeData.icon || 'icon-tree-node'));
        li.removeClass('folder is-open');
        ul.remove();
      },

      //Delete a node from the dataset or tree
      removeNode: function (nodeData) {
        var elem = this.findById(nodeData.id);

        if (nodeData instanceof jQuery) {
          elem = nodeData;
          elem.parent().remove();
        } else if (elem) {
          elem.node.parent().remove();
        }

        if (!elem) {
          return;
        }
        this.syncDataset(this.element);
      },

      //Attach Context Menus
      attachMenu: function (menuId) {
        var self = this;

        if (!menuId) {
          return;
        }

        this.element.off('contextmenu.tree').on('contextmenu.tree', 'a', function (e) {
          var node = $(this);
          e.preventDefault();

          $(e.currentTarget).popupmenu({menuId: menuId, eventObj: e, trigger: 'immediate', attachToBody: true}).off('selected').on('selected', function (e, args) {
            self.element.triggerHandler('menuselect', {node: node, item: args});
          });

          self.element.triggerHandler('menuopen', {menu: $('#' +menuId), node: node});
          return false;
        });

      },

      // Create sortable
      createSortable: function() {
        if (!this.settings.sortable) {
          return;
        }

        var self = this,
          clone, interval, doDrag;

        self.targetArrow = self.element.prev('.tree-drag-target-arrow');
        self.linkSelector = 'a:not(.is-dragging-clone, .is-disabled)';

        if (!self.targetArrow.length) {
          $('<div class="tree-drag-target-arrow"></div>').insertBefore(self.element);
          self.targetArrow = self.element.prev('.tree-drag-target-arrow');
        }

        function isReady() {
          // Make sure all dynamic nodes sync
          if (!self.loading) {
            clearInterval(interval);

            $(self.linkSelector, self.element).each(function() {
              var a = $(this);

              // Don't drag with folder icon, save for toggle nodes
              a.on('mousedown.tree', function(e) {
                e.preventDefault();
                doDrag = (e.which === 3) ? false : // 3 - Right mouse button clicked
                  ($(e.target).is('.icon') ? !a.parent().is('.folder') : true);
              })

              // Invoke drag
              .drag({
                clone: true,
                cloneAppendTo: a.closest('li'),
                clonePosIsFixed: true
              })

              // Drag start =======================================
              .on('dragstart.tree', function (e, pos, thisClone) {
                if (!thisClone || !doDrag) {
                  a.removeClass('is-dragging');
                  if (thisClone) {
                    thisClone.remove();
                  }
                  return;
                }
                clone = thisClone;
                clone.removeAttr('id').addClass('is-dragging-clone');
                clone.find('.tree-checkbox, .tree-badge').remove();

                self.sortable = {
                  // Do not use index from each loop, get updated index on drag start
                  startIndex: $(self.linkSelector, self.element).index(a),
                  startNode: a,
                  startIcon: $('svg.icon-tree', a).getIconName(),
                  startUl: a.closest('ul'),
                  startFolderNode: a.closest('ul').prev('a'),
                  startWidth: a.outerWidth()
                };

                e.preventDefault();
                e.stopImmediatePropagation();
              })

              // While dragging ===================================
              .on('drag.tree', function (e, pos) {
                if (!clone) {
                  return;
                }
                clone[0].style.left = pos.left + 'px';
                clone[0].style.top = pos.top + 'px';
                clone[0].style.opacity = '1';
                self.setDragOver(clone, pos);
              })

              // Drag end =========================================
              .on('dragend.tree', function (e, pos) {
                self.targetArrow.hide();
                $(self.linkSelector, self.element).removeClass('is-over');

                if (!clone || !self.sortable.overDirection) {
                  return;
                }
                clone[0].style.left = pos.left + 'px';
                clone[0].style.top = pos.top + 'px';

                var start = self.sortable.startNode.parent(),
                  end = self.sortable.overNode.parent();

                // Over
                if (self.sortable.overDirection === 'over') {
                  if (!end.is('.folder')) {
                    self.convertFileToFolder(self.sortable.overNode);
                  }
                  $('ul:first', end).append(start);
                  if (!end.is('.is-open')) {
                    self.toggleNode(self.sortable.overNode);
                  }
                }

                // Up
                else if (self.sortable.overDirection === 'up') {
                  start.insertBefore(end);
                }
                // Down
                else if (self.sortable.overDirection === 'down') {
                  if (end.is('.is-open')) {
                    $('ul:first', end).prepend(start);
                  }
                  else {
                    start.insertAfter(end);
                  }
                }

                // Restore file type
                if ($('li', self.sortable.startUl).length === 0 &&
                  !!self.sortable.startFolderNode.data('oldData') &&
                    self.sortable.startFolderNode.data('oldData').type === 'file') {
                  self.convertFolderToFile(self.sortable.startFolderNode);
                }

                // Fix: On windows 10 with IE-11 icons disappears
                if (self.isIe11) {
                  start.find('.icon-tree').each(function() {
                    var svg = $(this);
                    self.setTreeIcon(svg, svg.find('use').attr('xlink:href'));
                  });
                }

                // Sync dataset and ui
                self.syncDataset(self.element);
                if (self.isMultiselect) {
                  self.initSelected();
                }

              });
            });

          }
        }
        // Wait for make sure all dynamic nodes sync
        interval = setInterval(isReady, 10);
      },

      // Set actions while drag over
      setDragOver: function(clone, pos) {
        var self = this,
          treeRec = self.element[0].getBoundingClientRect(),
          extra = 20,
          exMargin, isParentsStartNode, isBeforeStart, isAfterSttart,
          li, a, ul, links, rec, i, l, left, top, direction, doAction,

          // Set as out of range
          outOfRange = function() {
            self.sortable.overNode = null;
            self.sortable.overIndex = null;
            self.sortable.overDirection = null;

            self.targetArrow.hide();
            self.setTreeIcon($('svg.icon-tree', clone), 'icon-cancel');
          };

        // Moving inside tree
        if (pos.top > (treeRec.top - extra) &&
            pos.top < (treeRec.bottom + extra) &&
            pos.left > (treeRec.left - extra - self.sortable.startWidth) &&
            pos.left < (treeRec.left + treeRec.height + extra)) {

          links = $(self.linkSelector, self.element);
          extra = 2;

          for (i = 0, l = links.length; i < l; i++) {
            direction = null;
            rec = links[i].getBoundingClientRect();

            // Moving on/around node range
            if (pos.top > rec.top - extra && pos.top < rec.bottom + extra) {
              a = $(links[i]);

              // Moving on/around node has parents as same node need to rearrange
              // Cannot rearrange parents to child
              isParentsStartNode = !!a.parentsUntil(self.element, '.folder')
                .filter(function() {
                  return $('a:first', this).is(self.sortable.startNode);
                }).length;
              if (isParentsStartNode) {
                outOfRange();
                continue;
              }

              li = a.parent();
              left = rec.left;
              ul = a.closest('ul');
              exMargin = parseInt(li[0].style.marginTop, 10) > 0 ? 2 : 0;
              isBeforeStart = ((i-1) === self.sortable.startIndex && ul.is(self.sortable.startUl));
              isAfterSttart = ((i+1) === self.sortable.startIndex && ul.is(self.sortable.startUl));
              links.removeClass('is-over');

              // Apply actions
              doAction = function() {
                if (!direction) {
                  outOfRange();
                  return;
                }

                // Reset icon
                self.setTreeIcon($('svg.icon-tree', clone), self.sortable.startIcon);

                // Over
                if (direction === 'over') {
                  self.targetArrow.hide();
                  if (!a.is('.is-disabled')) {
                    a.addClass('is-over');
                  }
                }
                // Up -or- Down
                else {
                  links.removeClass('is-over');
                  top = (direction === 'up') ?
                    (rec.top - 1.5 - (li.is('.is-active') ? 3 : 0)) :
                    (rec.bottom + (li.next().is('.is-active') ? -1 : 1.5) + exMargin);
                  self.targetArrow[0].style.left = left + 'px';
                  self.targetArrow[0].style.top = top + 'px';
                  self.targetArrow.show();
                }

                // Set changes
                self.sortable.overNode = a;
                self.sortable.overIndex = i;
                self.sortable.overDirection = direction;
              };

              // Set moveing directions
              if (i !== self.sortable.startIndex) {
                // If hover on link
                if (pos.left > rec.left - extra - self.sortable.startWidth &&
                  pos.left < rec.right + extra) {
                  if (!isBeforeStart && pos.top < rec.top) {
                    direction = 'up';
                  }
                  else if (!isAfterSttart && pos.top > rec.top + (extra * 2)) {
                    direction = 'down';
                  }
                  else {
                    direction = 'over';
                  }
                }
                // Not hover on link
                else {
                  if (!isBeforeStart && pos.top < rec.top) {
                    direction = 'up';
                  }
                  else if (!isAfterSttart) {
                    direction = 'down';
                  }
                }
              }
              doAction(direction);
            }
          }

        }
        else {
          // Out side from tree area
          outOfRange();
        }
      },

      // Convert file node to folder type
      convertFileToFolder: function(node) {
        var newFolder = $('<ul role="group"></ul>'),
          oldData = {
            icon: $('svg.icon-tree', node).getIconName(),
            type: 'file'
          };
        if (node.is('[class^="icon"]')) {
          var iconClass = node.attr('class').replace(' hide-focus', '').replace(' is-selected', '');
          oldData.iconClass = iconClass;
          node.removeClass(iconClass);
        }
        node.data('oldData', oldData);
        node.parent('li').addClass('folder').append(newFolder);
        this.setTreeIcon($('svg.icon-tree', node), this.settings.folderIconClosed);
      },

      // Convert folder node to file type
      convertFolderToFile: function(node) {
        var parent = node.parent('.folder');
        parent.removeClass('folder is-open');
        $('ul:first', parent).remove();
        if (parent.length) {
          this.setTreeIcon(
            $('svg.icon-tree', node),
            node.data('oldData') ? node.data('oldData').icon : 'tree-node'
          );
          if (node.data('oldData') && node.data('oldData').iconClass) {
            node.addClass(node.data('oldData').iconClass);
          }
          node.data('oldData', null);
        }
      },

      // Tree Related Functions
      destroy: function() {
        if (this.settings.sortable) {
          this.element.find('a').each(function() {
            var a = $(this), dragApi = a.data('drag');
            a.off('mousedown.tree');
            if (!!dragApi && !!dragApi.destroy) {
              dragApi.destroy();
            }
          });
          this.element.prev('.tree-drag-target-arrow').remove();
        }
        this.element.removeData(pluginName);
        this.element.off('contextmenu.tree updated.tree click.tree focus.tree keydown.tree keypress.tree').empty();
      }
    };

    // Keep the Chaining and Init the Controls or Settings
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (instance) {
        instance.settings = $.extend({}, defaults, options);
      } else {
        instance = $.data(this, pluginName, new Tree(this, settings));
      }
    });

  };


  /**
   * @constructor
   * @param {Object} element
   */
  function Validator(element) {
    this.element = $(element);
    Soho.logTimeStart('Validator');
    this.init();
    Soho.logTimeEnd('Validator');
  }

  // Plugin Object
  Validator.prototype = {

    init: function() {

      this.fields = 'input, textarea, select, div[data-validate], div[data-validation]';
      this.isPlaceholderSupport = !!('placeholder' in document.createElement('input'));//placeholder native support is-exists

      //If we initialize with a form find all inputs
      this.inputs = this.element.find(this.fields);

      //Or Just use the current input
      if (this.element.is(this.fields)) {
        this.inputs = $().add(this.element);
      }

      this.timeout = null;
    },

    extractEvents: function (events) {

      if (events.indexOf('{') > -1) {
        events = JSON.parse(events.replace(/'/g, '"'));
      }

      if (typeof events === 'object') {
        var e = '';
        for (var k in events) {
          if (e.indexOf(events[k]) === -1) {
            e += events[k] +' ';
          }
        }
        e = e.split(' ').join('.validate ');
        events = e;
      }
      return events;
    },

    filterValidations: function (events, type) {
      var validations = [];

      if (!events) {
        return [];
      }

      if (events.indexOf('{') > -1) {
        events = JSON.parse(events.replace(/'/g, '"'));
      }

      if(typeof events === 'object') {
        for (var k in events) {
          if (type && events[k].indexOf(type) > -1) {
            validations.push(k);
          }
        }
      }

      return validations;
    },

    attachEvents: function () {
      var self = this,
        attribs = '[data-validate],[data-validation]';

      //Attach required
      this.inputs.each(function () {
        var field = $(this),
        attr = field.attr('data-validate') || field.attr('data-validation');

        if (attr && attr.indexOf('required') > -1) {
          field.addClass('required');
        }
      });

      //Link on to the current object and perform validation.
      this.inputs.filter('input, textarea, div').filter(attribs).not('input[type=checkbox], [readonly]').each(function () {
        var field = $(this),
        attribs = field.attr('data-validation-events'),
        events = (attribs ? attribs : 'blur.validate change.validate keyup.validate');

        events = self.extractEvents(events);

        field.on(events, function (e) {

          //Skip on Tab
          if (e.type === 'keyup' && e.keyCode === 9) {
            return;
          }

          var field = $(this);
          setTimeout(function () {
            if (field.attr('data-disable-validation') === 'true' || field.hasClass('disable-validation') || field[0].style.visibility === 'is-hidden' || !field.is(':visible')) {
              return;
            }

            if (field.closest('.modal-engaged').length && !field.closest('.modal-body').length) {
              return;
            }

            self.validate(field, true, e);
          }, 300);
        });
      });

      this.inputs.filter('input[type=checkbox]').filter(attribs).on('click.validate', function (e) {
        self.validate($(this), true, e);
      });

      this.inputs.filter(':radio').on('click.validate', function (e) {
        self.validate($(this), true, e);
      });

      var selects = this.inputs.filter('select').filter(attribs);

      if (selects.length) {
        selects.on('change.validate', function (e) {
          self.validate($(this), true, e);
        }).on('listopened.validate', function() {
          var field = $(this),
            tooltip = field.data('tooltip');

          field.next('.dropdown-wrapper').next('.error-message').hide();
          if (tooltip && document.activeElement === field.data('dropdown').searchInput[0]) {
            tooltip.hide();
          }
        }).on('listclosed.validate', function() {
          var field = $(this),
            tooltip = field.data('tooltip');

          field.next('.dropdown-wrapper').next('.error-message').show();
          if (tooltip && document.activeElement !== field.data('dropdown').searchInput[0]) {
            tooltip.show();
          }
        });

        selects.filter(function() {
          return $(this).data('dropdown') !== undefined;
        }).data('dropdown').pseudoElem.on('blur.validate', function(e) {
          var select = $(this).closest('.field, .field-short').find('select');
          self.validate(select, true, e);
        });
      }

      //Attach to Form Submit and Validate
      if (this.element.is('form')) {

        var submitHandler = function (e) {
          e.stopPropagation();
          e.preventDefault();
          self.validateForm(function (isValid) {
            self.element.off('submit.validate');
            self.element.trigger('validated', isValid);
            self.element.data('isValid', isValid);
            self.element.on('submit.validate', submitHandler);
          });
        };

        this.element.on('submit.validate', submitHandler);
      }

    },

    validateForm: function (callback) {
      var self = this,
        deferreds = [];

      self.inputs = this.element.find(self.fields);
      self.inputs.each(function (e) {
        var field = $(this);
        if (field.attr('data-validate')) {

          if (field.attr('data-disable-validation') === 'true' || field.hasClass('disable-validation')) {
            return true;
          }

          var dfds = self.validate(field, false, e);
          for (var i = 0; i < dfds.length; i++) {
            deferreds.push(dfds[i]);
          }
        }

      });

      $.when.apply($, deferreds).then(function () {
        callback(true);
      }, function () {
        callback(false);
      });
    },

    // Set disable/enable primary button in modal
    setModalPrimaryBtn: function(field, modalBtn, isValid) {
      var modal = field.closest('.modal'),
        modalFields = modal.find('[data-validate]:visible'),
        allValid = true;

      if (modalFields.length > 0) {
        modalFields.each(function () {
          var modalField = $(this);
          modalField.data('isValid', isValid);
          if (modalField.closest('.datagrid-filter-wrapper').length > 0) {
            return;
          }
          var isVisible = modalField[0].offsetParent !== null;
          if (modalField.is('.required')) {
            if (isVisible && !modalField.val()) {
              allValid = false;
            }
          } else {
            if (isVisible && !modalField.isValid()) {
              allValid = false;
            }
          }
        });
      }

      if (allValid) {
        modalBtn.removeAttr('disabled');
      } else {
        modalBtn.attr('disabled', 'disabled');
      }
    },

    value: function(field) {
      if (field.is('input[type=checkbox]')) {
        return field.prop('checked');
      }
      if (field.is('div')) { // contentEditable div (Rich Text)
        return field[0].innerHTML;
      }
      return field.val();
    },

    getTypes: function(field, e) {

      var filters = this.filterValidations(field.attr('data-validation-events'), e.type),
        validations;

      if (field.is('input.dropdown') && field.prev().prev('select').attr('data-validate')) {
        validations = field.prev().prev('select').attr('data-validate').split(' ');
      } else if (field.is('input.dropdown') && field.prev().prev('select').attr('data-validation')) {
        validations = field.prev().prev('select').attr('data-validation').split(' ');
      } else if (field.attr('data-validation')) {
        validations = field.attr('data-validation').split(' ');
      } else if (field.attr('data-validate')) {
        validations = field.attr('data-validate').split(' ');
      } else {
        validations = [];
      }

      //Filter out not needed events
      if (filters.length > 0) {
        validations = validations.filter(function(n) {
          return filters.indexOf(n) !== -1;
        });
      }

      //Filter out specific events that should not use keyup
      if (e.type === 'keyup') {
        validations = validations.filter(function(n) {
          return n !== 'date' && n !== 'time';
        });
      }
      return validations;
    },

    // Set Error icon on parent tabs/expandable
    setErrorOnParent: function (field) {
      var errorIcon = $.createIcon({ classes: ['icon-error'], icon: 'error' }),
        parent = field.closest('.tab-panel, .expandable-pane'),
        parentContainer = field.closest('.tab-container, .expandable-area'),
        iconTarget = parent.attr('id'),
        iconContainer,
        dropdown,
        dropdownParent,
        menuitem;

      //Tabs
      if (parentContainer.is('.tab-container')) {
        //Default Tabs
        iconContainer = $('.tab-list a[href="#'+ iconTarget +'"]', parentContainer).closest('.tab');

        //Tabs with Counts
        if (iconContainer.length) {
          if ($('.count', iconContainer).length) {
            iconContainer = $('.count', iconContainer);
          }
        }
        //Dropdown Tabs(with popupmenu)
        else {
          iconTarget = $('a[href="#'+ iconTarget +'"]', '.popupmenu').closest('.popupmenu').attr('id');
          iconContainer = $('.tab-list .tab[aria-controls="'+ iconTarget +'"]', parentContainer);
          dropdown = iconTarget;
        }
      }

      //Expandable
      else if (parentContainer.is('.expandable-area')) {
        iconContainer = $('.expandable-header[aria-controls="'+ iconTarget +'"] .title', parentContainer);
      }

      //No action
      else {
        return;
      }

      //if Dropdown Tabs set each menu item to check
      if (dropdown && dropdown.length) {
        dropdownParent = parent.add($($(dropdown).attr('href')));
        $('a[role="menuitem"]', '#'+ dropdown).each (function () {
          dropdownParent = dropdownParent.add($($(this).attr('href')));
        });
      }
      menuitem = $('a[href="#'+ parent.attr('id') +'"]', '#'+ iconTarget);

      //Add Error icon
      if ((!!parent && $('.error', parent).length) ||
          (!!dropdownParent && $('.error', dropdownParent).length)) {

        //if Dropdown Tabs and current menu item has no error remove icon
        if (!$('.error', parent).length) {
          menuitem.removeClass('is-error');
          $('.icon-error', menuitem).remove();
        }

        //if Dropdown Tabs and current menu item has error add icon
        if ($('.error', parent).length &&
            $('.error', dropdownParent).length &&
            !$('.icon-error', menuitem).length) {
            menuitem.addClass('is-error').append(errorIcon);
        }

        //Add icon to main tab area
        if (!($('.icon-error', iconContainer).length)) {
          iconContainer.addClass('is-error').append(errorIcon);
        }
      }

      //Remove Error icon
      else {
        iconContainer = iconContainer.add(menuitem);
        iconContainer.removeClass('is-error');
        $('.icon-error', iconContainer).remove();
      }
    },

    validate: function (field, showTooltip, e) {
      //call the validation function inline on the element
      var self = this,
        types = self.getTypes(field, e) || [],
        rule, dfd,
        dfds = [],
        errors = [],
        i, l,
        value = self.value(field),
        placeholder = field.attr('placeholder'),

        manageResult = function (result, showTooltip) {
          // Only remove if "false", not any other value ie.. undefined
          if (rule.positive === false) {
            self.removePositive(field);
          }

          if (!result) {
            if (!self.isPlaceholderSupport && (value === placeholder) &&
               (rule.message !== Locale.translate('Required'))) {
              return;
            }

            self.addError(field, rule.message, field.attr('data-error-type') === 'tooltip' ? false: true, showTooltip);
            errors.push(rule.msg);
            dfd.reject();
          }
          else if (errors.length === 0) {
            self.removeError(field);
            dfd.resolve();

            if (rule.positive) {
              // FIX: In Contextual Action Panel control not sure why but need to add error,
              // otherwise "icon-confirm" get misaligned,
              // so for this fix adding and then removing error here
              self.addError(field, rule.message, rule.inline, showTooltip);
              self.removeError(field);
              dfd.resolve();

              self.addPositive(field);
            }
          }
          self.setErrorOnParent(field);
        };

      self.removeError(field);
      field.removeData('data-errormessage');

      for (i = 0, l = types.length; i < l; i++) {
        rule = $.fn.validation.rules[types[i]];
        dfd = $.Deferred();

        if (!rule) {
          continue;
        }

        if ($('#calendar-popup').is(':visible')) {
          continue; //dont show validation message while selecting
        }

        if (rule.async) {
          rule.check(value, field, manageResult);
        } else {
          manageResult(rule.check(value, field), showTooltip);
        }
        dfds.push(dfd);
      }

      return dfds;
    },

    getField: function(field) {
      if (field.is('select') && field.data('dropdown') !== undefined) {
        field = field.data('dropdown').pseudoElem;
      }
      return field;
    },

    hasError: function(field) {
      return this.getField(field).hasClass('error');
    },

    addError: function(field, message, inline, showTooltip) {
      var loc = this.getField(field).addClass('error'),
         dataMsg = loc.data('data-errormessage'),
         appendedMsg = message;

      if (dataMsg) {
        appendedMsg = (/^\u2022/.test(dataMsg)) ? '' : '\u2022 ';
        appendedMsg += dataMsg + '<br>\u2022 ' + message;
      }

      loc.data('data-errormessage', appendedMsg);

      //Add Aria Alert
      if ($.fn.toast !== undefined) {
        $('body').toast({title: Locale.translate('Error'), audibleOnly: true, message: appendedMsg});
      }

      if (!inline) {
        this.showTooltipError(field, appendedMsg, showTooltip);
        return;
      }

      // Disable primary button in modal
      var modalBtn = field.closest('.modal').find('.btn-modal-primary').not('.no-validation');
      if (modalBtn.length) {
        this.setModalPrimaryBtn(field, modalBtn, false);
      }

      this.showInlineError(loc, message);
    },

    showErrorIcon: function(field) {

      var loc = this.getField(field).addClass('error'),
        svg = $.createIconElement({ classes: ['icon-error'], icon: 'error' });

      if (loc.parent('.field, .field-short').find('svg.icon-error').length === 0) {

        if (field.parent().is('.editor-container')) {
          field.parent().addClass('is-error');
        }

        if (field.parent(':not(.editor-container)').find('.btn-actions').length ===1) {
          field.parent().find('.btn-actions').before(svg);
        } else if (field.parent().find('.data-description').length ===1) {
          field.parent().find('.data-description').before(svg);
        } else if (field.parent().find('.field-info').length ===1) {
          field.parent().find('.field-info').before(svg);
        } else if (field.is('textarea')) {
          field.after(svg);
        } else if (field.is('.dropdown, .multiselect')) {
          field.parent().find('.dropdown-wrapper').append(svg);
        } else if (field.is('.spinbox')) {
          field.parent().append(svg);
        } else if (field.is('.lookup')) {
          field.parent().append(svg);
        } else {
          field.parent().append(svg);
        }

        $('.icon-confirm', loc.parent('.field, .field-short')).remove();
      }
	  else {
		svg = loc.parent('.field, .field-short').find('svg.icon-error');
	  }

      return svg;
    },

    showTooltipError: function(field, message, showTooltip) {
      if (field.is(':radio')) {
        return;
      }

      var icon = this.showErrorIcon(field);
      var representationField = field;

      //Add error classes to pseudo-markup for certain controls
      if (field.is('.dropdown, .multiselect') && field.data('dropdown') !== undefined) {
        var input = field.data('dropdown').pseudoElem;
        representationField = input;
        input.addClass('error');
      }

      var tooltipAPI = icon.data('tooltip');

      // Error tooltips should be positioned on the 'x' so that they sit directly underneath the fields
      // that they are indicating.
      function tooltipPositionCallback(placementObj) {
        var fieldRect = representationField[0].getBoundingClientRect(),
          elRect = tooltipAPI.tooltip[0].getBoundingClientRect(),
          rtl = $('html').is('[dir="rtl"]'),
          currX = placementObj.x,
          xAdjustment = 0;

        if (rtl) {
          if (elRect.left < fieldRect.left) {
            xAdjustment += (fieldRect.left - elRect.left);
          }
        } else {
          if (elRect.right > fieldRect.right) {
            xAdjustment += (elRect.right - fieldRect.right) * -1;
          }
        }

        placementObj.setCoordinate('x', currX + xAdjustment);
        if (!placementObj.nudges) {
          placementObj.nudges = {};
        }
        placementObj.nudges.x = xAdjustment;

        return placementObj;
      }

      // Build Tooltip
      if (!tooltipAPI) {
        icon.tooltip({
          content: message,
          placement: 'bottom',
          placementOpts: {
            callback: tooltipPositionCallback
          },
          trigger: 'focus',
          isError: true,
          tooltipElement: '#validation-tooltip'
        });
        tooltipAPI = icon.data('tooltip');
      } else {
        tooltipAPI.content = message;
      }

      field.on('focus.validate', function() {
        if (!tooltipAPI) { return; }
        tooltipAPI.show();
      }).on('blur.validate', function() {
        if (!tooltipAPI) { return; }
        tooltipAPI.hide();
      });

      if (showTooltip && tooltipAPI) {
        tooltipAPI.show();
      }
    },

    // Toggle radio group error
    toggleRadioError:  function (field, message, markup, isShow) {
      var all, loc,
        name = field.attr('name');

      if (name && name.length) {
        all = $(':radio[name="'+ name +'"], :radio[name="'+ name +'"] + label');
        loc = field.parent().is('.inline') ?
          $(':radio[name="'+ name +'"]:last').parent() :
          $(':radio[name="'+ name +'"]:last + label');

        if (isShow) {
          all.addClass('error');
          $(markup).addClass('radio-group-error').insertAfter(loc);
        }
        else {
          all.removeClass('error');
          loc.next('.radio-group-error').remove();
        }
      }
    },

    showInlineError: function (field, message) {
      var loc = this.getField(field).addClass('error'),
        markup = '<div class="error-message">' +
          $.createIcon({ classes: ['icon-error'], icon: 'error' }) +
          '<pre class="audible">'+ Locale.translate('Error') +'</pre>' +
          '<p class="message-text">' + message +'</p>' +
          '</div>';


      if (field.is(':radio')) { // Radio button handler
        this.toggleRadioError(field, message, markup, true);
      } else { // All other components
        loc.closest('.field, .field-short').find('.formatter-toolbar').addClass('error');
        loc.closest('.field, .field-short').append(markup);
      }

      //Remove positive errors
      field.parent().find('.icon-confirm').remove();

    },

    addPositive: function(field) {
      var svg = $.createIcon({ icon: 'confirm', classes: 'icon-confirm'});

      if (!$('.icon-confirm', field.parent('.field, .field-short')).length) {
        field.parent('.field, .field-short').append(svg);
      }
    },

    removeError: function(field) {
      var loc = this.getField(field),
        isRadio = field.is(':radio'),
        hasTooltip = field.attr('data-error-type');

      this.inputs.filter('input, textarea').off('focus.validate');
      field.removeClass('error');
      field.removeData('data-errormessage');

      if (hasTooltip) {
        var tooltipAPI = field.find('.icon.error').data('tooltip');

        if (tooltipAPI) {
          tooltipAPI.destroy();
        }
        if (field.attr('aria-describedby') === 'validation-tooltip') {
          field.removeAttr('aria-describedby');
          $('#validation-tooltip').remove();
        }
      }

      if (isRadio) {
        this.toggleRadioError(field);
      }
      else {
        field.next('.icon-error').off('click.validate').remove();
      }

      if (field.hasClass('dropdown') || field.hasClass('multiselect')) {
        field.next().next().removeClass('error'); // #shdo
        field.parent().find('.dropdown-wrapper > .icon-error').off('click.validate').remove(); // SVG Error Icon
      }

      if (!isRadio) {
        field.next().next('.icon-error').remove();
        field.next('.inforCheckboxLabel').next('.icon-error').remove();
        field.parent('.field, .field-short').find('span.error').remove();
        field.parent().find('.icon-error').remove();
        field.off('focus.validate focus.tooltip');
      }

      if (loc.attr('data-placeholder')) {
        loc.attr('placeholder',loc.attr('data-placeholder'));
        loc.removeAttr('data-placeholder');
      }

      //Remove error classes from pseudo-markup for certain controls
      if (field.is('.dropdown, .multiselect')) {
        field.data('dropdown').pseudoElem.removeClass('error').removeAttr('placeholder');
      }

      if (field.parent().is('.editor-container')) {
        field.parent().removeClass('is-error');
      }

      // Enable primary button in modal
      var modalBtn = field.closest('.modal').find('.btn-modal-primary').not('.no-validation');
      if (modalBtn.length) {
        this.setModalPrimaryBtn(field, modalBtn, true);
      }

      //Stuff for the inline error
      field.closest('.field, .field-short').find('.error-message').remove();
      field.parent('.field, .field-short').find('.formatter-toolbar').removeClass('error');

    },

    removePositive: function(field) {
      $('.icon-confirm', field.parent('.field, .field-short')).remove();
    }
  };

  //Add a Message to a Field
  $.fn.addError = function(options) {
    var defaults = {message: '', showTooltip: false, inline: true},
      settings = $.extend({}, defaults, options);

    return this.each(function() {
      var instance = new Validator(this, settings);
      instance.addError($(this), settings.message, settings.inline, settings.showTooltip);
    });
  };

  //Remove a Message from a Field
  $.fn.removeError = function(options) {
    var defaults = {message: ''},
      settings = $.extend({}, defaults, options);

    return this.each(function() {
      var instance = new Validator(this, settings);
      instance.removeError($(this));
    });
  };

  $.fn.validate = function(options, args) {
    // Settings and Options
    var pluginName = 'validate',
      defaults = {
        inline: true
      },
      settings = $.extend({}, defaults, options);

    // Initializing the Control Once or Call Methods.
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (instance) {
        if (typeof instance[options] === 'function') {
          instance[options](args);
        }
        instance.settings = $.extend({}, defaults, options);
      } else {
        instance = $.data(this, pluginName, new Validator(this, settings));
        instance.attachEvents();
      }
    });
  };

  //The validation rules object
  var Validation = function () {
    var self = this;
    this.rules = {
      required: {
        isNotEmpty: function(value, field) {
          var supportsPlaceholder = !!('placeholder' in document.createElement('input'));

          if (!supportsPlaceholder && field &&
              (value === field.attr('placeholder') || value === Locale.translate('Required'))) {
            return false;
          }

          if (typeof value === 'string') {
            // strip out any HTML tags and focus only on text content.
            value = $.trim(value.replace(/<\/?[^>]*>/g, ''));
            if ($.trim(value).length === 0) {
              return false;
            }
            return true;
          }

          if (typeof value === 'number') {
            if (isNaN(value)) {
              return false;
            }
            return true;
          }

          return (value ? true : false);
        },

        // Check if at least one radio button checked in group
        isRadioChecked: function (field) {
          var name = field.attr('name');
          return (name && name.length && $('input[name="'+ name +'"]:radio:checked').length);
        },

        check: function (value, field) {
          var self = this;

          //Check all required fields filled on modal

          var allFilled = true;
          field.closest('.modal').find('input.required, textarea.required, select.required').not(':hidden').each(function () {
            if (!self.isNotEmpty($(this).val())) {
              allFilled = false;
            }
          });

          if (allFilled) {
            field.closest('.modal').find('.btn-modal-primary').not('.no-validation').removeAttr('disabled');
          } else {
            field.closest('.modal').find('.btn-modal-primary').not('.no-validation').attr('disabled', 'disabled');
          }

          this.message = Locale.translate('Required');
          return field.is(':radio') ? this.isRadioChecked(field) : this.isNotEmpty(value, field);
        },
        message: 'Required'
      },

      //date: Validate date, datetime (24hr or 12hr am/pm)
      date: {
        check: function (value, field) {
          this.message = Locale.translate('InvalidDate');

          if (value instanceof Date) {
            return value && value.getTime && !isNaN(value.getTime());
          }

          var dateFormat = (value.indexOf(':') > -1) ? Locale.calendar().dateFormat.datetime: Locale.calendar().dateFormat.short;

          if (field && field.data('datepicker')) {
            dateFormat = field.data('datepicker').pattern;
          }

          var isStrict = !(dateFormat === 'MMMM d' || dateFormat === 'yyyy'),
            parsedDate = Locale.parseDate(value, dateFormat, isStrict);
          return ((parsedDate === undefined) && value !== '') ? false : true;
        },
        message: 'Invalid Date'
      },

      //Validate date, disable dates
      availableDate: {
        check: function (value, field) {
          this.message = Locale.translate('UnavailableDate');
          var check = true;

          if(value !== '' && self.rules.date.check(value)) { //if valid date
            var d, i, l, min, max,
              d2 = new Date(value),
              options = field.data('datepicker').settings;

            if (options) {

              min = (new Date(options.disable.minDate)).setHours(0,0,0,0);
              max = (new Date(options.disable.maxDate)).setHours(0,0,0,0);

              //dayOfWeek
              if(options.disable.dayOfWeek.indexOf(d2.getDay()) !== -1) {
                check = false;
              }

              d2 = d2.setHours(0,0,0,0);

              //min and max
              if((d2 <= min) || (d2 >= max)) {
                check = false;
              }

              //dates
              if (options.disable.dates.length && typeof options.disable.dates === 'string') {
                options.disable.dates = [options.disable.dates];
              }
              for (i=0, l=options.disable.dates.length; i<l; i++) {
                d = new Date(options.disable.dates[i]);
                if(d2 === d.setHours(0,0,0,0)) {
                  check = false;
                  break;
                }
              }
            }
            check = ((check && !options.disable.isEnable) || (!check && options.disable.isEnable)) ? true : false;
          }

          return check;
        },
        message: 'Unavailable Date'
      },

      email: {
        check: function (value) {
          this.message = Locale.translate('EmailValidation');
          var regex = /^([\w-]+(?:\.[\w-]+)*)@((?:[\w-]+\.)*\w[\w-]{0,66})\.([a-z]{2,16}(?:\.[a-z]{2})?)$/i;

          return (value.length) ? regex.test(value) : true;
        },
        message: 'EmailValidation'
      },

      enableSubmit: {
        check: function (value, field) {
          var submit = field.closest('.signin').find('button[type="submit"]'),
            ok = ((value.length) && (self.rules.email.check(value) || self.rules.passwordConfirm.check(value, field)));

          if (ok) {
            submit.enable();
          } else {
            submit.disable();
          }
          return true;
        },
        message: ''
      },

      emailPositive: {
        check: function (value, field) {
          if($.trim(value).length && !field.is('[readonly]')) {
            self.rules.emailPositive.positive = true;
            this.message = Locale.translate('EmailValidation');

            var isValid = self.rules.email.check(value, field);

            if (isValid) {
              this.message = '';
            }

            return isValid;
          } else {
            self.rules.emailPositive.positive = false;
            return true;
          }
        },
        message: 'EmailValidation'
      },

      passwordReq: {
        check: function (value) {
         this.message = Locale.translate('PasswordValidation');
          /* Must be at least 10 characters which contain at least
          ** one lowercase letter,
          ** one uppercase letter,
          ** one numeric digit
          ** and one special character */
          var regex = /^(?=.*\d)(?=.*[a-z])(?=.*[A-Z])(?=.*[^a-zA-Z0-9])(?!.*\s).{10,}$/;
          return (value.length) ? value.match(regex) : true;
        },
        message: 'PasswordValidation'
      },

      passwordConfirm: {
        check: function (value, field) {
          this.message = Locale.translate('PasswordConfirmValidation');
          var passwordValue = $('input[type="password"]:not('+ field.attr('id') +')', field.closest('.signin')).eq(0).val(),
            check = ((value === passwordValue) && (self.rules.passwordReq.check(passwordValue)));
          return (value.length) ? check : true;
        },
        message: 'PasswordConfirmValidation'
      },

      time: {
        check: function(value, field) {
          value = value.replace(/ /g, '');
          this.message = Locale.translate('InvalidTime');
          var timepickerSettings = field && field.data('timepicker') ? field.data('timepicker').settings : {},
            pattern = timepickerSettings && timepickerSettings.timeFormat ? timepickerSettings.timeFormat : Locale.calendar().timeFormat,
            is24Hour = (pattern.match('HH') || []).length > 0,
            maxHours = is24Hour ? 24 : 12,
            colon = value.indexOf(Locale.calendar().dateFormat.timeSeparator),
            valueHours = 0,
            valueMins,
            valueM;

          if (value === '') {
            return true;
          }

          valueHours = parseInt(value.substring(0, colon));
          valueMins = parseInt(value.substring(colon + 1, colon + 3));

          if (valueHours.toString().length < 1 || isNaN(valueHours) || parseInt(valueHours) < 0 || parseInt(valueHours) > maxHours) {
            return false;
          }
          if (valueMins.toString().length < 1 || isNaN(valueMins) || parseInt(valueMins) < 0 || parseInt(valueMins) > 59) {
            return false;
          }

          // AM/PM
          if (!is24Hour) {
            if (parseInt(valueHours) < 1) {
              return false;
            }
            var period0 = new RegExp(Locale.calendar().dayPeriods[0], 'i'),
              period1 = new RegExp(Locale.calendar().dayPeriods[1], 'i');

            valueM = value.match(period0) || value.match(period1) || [];
            if (valueM.length === 0) {
              return false;
            }
          }

          return true;
        },
        message: 'Invalid Time'
      },

      //Test validation function, always returns false
      test: {

        check: function(value) {
          return value === '1' ? true : false;
        },

        message: 'Value is not valid (test).'
      }
    };
  };

  $.fn.validation = new Validation();

  $.fn.isValid = function() {
    return ($(this).data('isValid') ? true : false);
  };

 //Check validation manually
  $.fn.checkValidation = function() {
    var field = $(this),
      api = field.data('validate'),
      doAction = function(isValid) {
        field.data('isValid', isValid);
      };

    if (api && api.validate) {
      var fx = api.validate(field, false, 0);
      $.when.apply($, fx).always(function() {
        // [fail] returns the first fail, so we have to loop deferred objects
        $.each(fx, function() {
          this.done(function() {
            doAction(true);
          }).fail(function() {
            doAction(false);
          });
        });
      });
    }
  };

  //Clear out the stuff on the Form
  $.fn.resetForm = function() {
    var formFields = $(this).find('input, select, textarea');

    //Clear Errors
    formFields.removeClass('error');
    $(this).find('.error').removeClass('error');
    $(this).find('.icon-error').remove();
    $(this).find('.icon-confirm').remove();
    $(this).find('.error-message').remove();

    setTimeout(function () {
      $('#validation-errors').addClass('is-hidden');
    }, 300);

    //Remove Dirty
    formFields.data('isDirty', false).removeClass('isDirty');
    $(this).find('.isDirty').removeClass('isDirty');

    //reset form data
    if ($(this).is('form')) {
      $(this)[0].reset();
    }
  };


  //NOTE: Just this part will show up in SoHo Xi Builds.

  $.fn.wizard = function(options) {
    'use strict';

    // Settings and Options
    var pluginName = 'wizard',
        defaults = {
          ticks: null
        },
        settings = $.extend({}, defaults, options);

    /**
     * @constructor
     * @param {Object} element
     */
    function Wizard(element) {
      this.settings = $.extend({}, settings);
      this.element = $(element);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    // Plugin Methods
    Wizard.prototype = {

      init: function() {
        this
          .build()
          .handleEvents();
      },

      build: function() {
        this.header = this.element.find('.wizard-header');
        if (!this.header.length) {
          this.header = $('<div class="wizard-header"></div>').appendTo(this.element);
        }

        this.bar = this.element.find('.bar');
        if (!this.bar.length) {
          this.bar = $('<div class="bar"></div>').appendTo(this.header);
        }

        this.completedRange = this.element.find('.completed-range');
        if (!this.completedRange.length) {
          this.completedRange = $('<div class="completed-range"></div>').appendTo(this.bar);
        }

        this
          .buildTicks()
          .updateRange();

        return this;
      },

      handleEvents: function() {
        var self = this;

        this.element.on('updated', function() {
          self.updated();
        });

        this.ticks.onTouchClick('wizard').on('click.wizard', function(e) {
          self.activate(e, $(this));
        });

        return this;
      },

      buildTicks: function() {
        var settingTicks = this.settings.ticks,
          self = this;

        this.ticks = this.bar.children('.tick');

        if (!this.ticks.length && settingTicks) {

          for (var i = 0; i < settingTicks.length; i++) {
            var link = $('<a ng-click="handleClick()" class="tick ' + (settingTicks[i].state ? settingTicks[i].state : '') + '" href="'+ (settingTicks[i].href ? settingTicks[i].href : '#') +'"><span class="label">' + settingTicks[i].label + '</span></a>');

            if (settingTicks[i].ngClick) {
              link.attr('ng-click', settingTicks[i].ngClick);
            }

            self.bar.append(link);
          }
          this.ticks = this.bar.children('.tick');
        }
        this.positionTicks();

        $('.tick', self.element).each(function() {
          var tick = $(this);
          if (tick.hasClass('is-disabled')) {
            tick.removeAttr('onclick ng-click');
          }
        });

        this.element.find('.wizard-header')[0].style.opacity = '1';
        return this;
      },

      positionTicks: function() {
        var l = this.ticks.length,
          delta = 100 / (l - 1),
          tickPos = [];

        function getPoint(i) {
          if (i === 0) {
            return 0;
          }
          if (i === l - 1) {
            return 100;
          } else {
            return delta * i;
          }
        }

        for (var i = 0; i < l; i++) {
          tickPos.push(getPoint(i));
        }

        this.ticks.each(function(i) {
          var tick = $(this),
            label = tick.children('.label'),
            left = Locale.isRTL() ? (100-tickPos[i]) : tickPos[i];

          this.style.left = left + '%';

          for (var i2 = 0, l2 = label.length; i2 < l2; i2++) {
            label[i2].style.left = '-' + (label.outerWidth()/2 - tick.outerWidth()/2) + 'px';
          }

          if (tick.is('.is-disabled')) {
            tick.attr('tabindex', '-1');
          }
        });
      },

      updateRange: function() {
        var currentTick = this.ticks.filter('.current').last(),
          widthPercentage = 0;

        if (currentTick.length) {
          widthPercentage = (100 * parseFloat(window.getComputedStyle(currentTick[0]).left) / parseFloat(window.getComputedStyle(currentTick.parent()[0]).width));
          widthPercentage = Locale.isRTL() ? (100-widthPercentage) : widthPercentage;
        }

        this.completedRange[0].style.width = widthPercentage + '%';
        return this;
      },

      updated: function() {
        this
          .buildTicks()
          .updateRange();

        return this;
      },

      teardown: function() {
        this.ticks.offTouchClick('wizard').off('click.wizard');
        this.element.off('updated.wizard');

        this.ticks.remove();
        return this;
      },

      // Deprecating the "select()" method in favor of "activate()" to match the API of our other controls
      // Temporarily adding functionality that reroutes this method to the new "activate" method.
      select: function(e, tick) {
        return this.activate(e, tick);
      },

      // Activates one of the Wizard's ticks.
      // Tick can either be a number (representing the tick's index) or a jQuery element reference to a tick
      activate: function(e, tick) {
        if (e === undefined && !tick) {
          return this;
        }

        var self = this;

        function getTick() {
          var target;

          // Use the first variable as the tick definition or index if "e" is null, undefined, or not an event object.
          // This is for backwards compatibility with this control's old select() method, which took an index as an argument.
          if (e !== undefined && (e === undefined || e === null || !e.type || !e.target) && !tick) {
            tick = e;
          }

          if (tick === undefined) {
            target = $(e.target);
            return target.is('.label') ? target.parent() : target;
          }

          if (typeof tick === 'number') {
            return self.ticks.eq(tick);
          }

          return tick;
        }

        tick = getTick();

        if (e && (tick.is('[disabled], .is-disabled') || !tick.is('a'))) {
          e.preventDefault();
          e.stopPropagation();
          return this;
        }

        // Cancel selection by returning a 'beforeactivate' handler as 'false'
        var canNav = this.element.triggerHandler('beforeactivate', [tick]);
        if (canNav === false) {
          return this;
        }

        var trueIndex = this.ticks.index(tick);
        this.ticks.removeClass('complete current')
          .eq(trueIndex).addClass('current')
          .prevAll('.tick').addClass('complete');

        this.updateRange();
        this.element.trigger('activated', [tick]);

        // Timeout allows animation to finish
        setTimeout(function () {
          self.element.trigger('afteractivated', [tick]);
        }, 300);

        return this;
      },

      // Teardown - Remove added markup and events
      destroy: function() {
        this.teardown();
        $.removeData(this.element[0], pluginName);
      }
    };

    // Initialize the plugin (Once)
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (instance) {
        instance.settings = $.extend({}, instance.settings, options);
        instance.updated();
      } else {
        instance = $.data(this, pluginName, new Wizard(this, settings));
      }
    });
  };


  //NOTE: Just this part will show up in SoHo Xi Builds.

  $.fn.zoom = function(options) {
    'use strict';

    // Settings and Options
    var pluginName = 'zoom',
        settings = $.extend({}, options);

    /**
     * @constructor
     * @param {Object} element
     * @param {Object} settings
     */
    function Zoom(element, settings) {
      this.settings = $.extend({}, settings);
      this.element = $(element);
      Soho.logTimeStart(pluginName);
      this.init();
      Soho.logTimeEnd(pluginName);
    }

    Zoom.prototype = {
      init: function() {
        return this
          .build()
          .handleEvents();
      },

      // Add markup to the control
      build: function() {
        // get references to elements
        this.viewport = this.element.find('meta[name=viewport]');
        this.body = $('body');

        return this;
      },

      // Sets up event handlers for this control and its sub-elements
      handleEvents: function() {
        var self = this;

        // Allow the head to listen to events to globally deal with the zoom problem on
        // a per-control basis (for example, Dropdown/Multiselect need to handle this issue manually).
        this.element.on('updated.' + pluginName, function() {
          self.updated();
        }).on('enable-zoom', function() {
          self.enableZoom();
        }).on('disable-zoom', function() {
          self.disableZoom();
        });

        // Don't continue setting this up on each element if
        if (Soho.env.os.name !== 'ios') {
          return this;
        }

        // Setup conditional events for all elements that need it.
        this.body.on('touchstart.zoomdisabler', 'input, label', function() {
          if (self.noZoomTimeout) {
            return;
          }

          self.disableZoom();
        }).on('touchend.zoomdisabler', 'input, label', function() {
          if (self.noZoomTimeout) {
            clearTimeout(self.noZoomTimeout);
            self.noZoomTimeout = null;
          }
          self.noZoomTimeout = setTimeout(function() {
            self.noZoomTimeout = null;
            self.enableZoom();
          }, 600);
        });

        return this;
      },

      // TODO: Test to see if prepending this meta tag conflicts with Base Tag implementation
      enableZoom: function() {
        this.viewport[0].setAttribute('content', 'width=device-width, initial-scale=1.0, user-scalable=1');
      },

      // TODO: Test to see if prepending this meta tag conflicts with Base Tag implementation
      disableZoom: function() {
        this.viewport[0].setAttribute('content', 'width=device-width, initial-scale=1.0, user-scalable=0');
      },

      // Handle Updating Settings
      updated: function() {
        return this
          .teardown()
          .init();
      },

      // Simple Teardown - remove events & rebuildable markup.
      teardown: function() {
        this.element.off('updated.' + pluginName + ' enable-zoom disable-zoom');
        this.body.off('touchstart.zoomdisabler touchend.zoomdisabler');
        return this;
      },

      // Teardown - Remove added markup and events
      destroy: function() {
        this.teardown();
        $.removeData(this.element[0], pluginName);
      }
    };

    // Initialize the plugin (Once)
    return this.each(function() {
      var instance = $.data(this, pluginName);
      if (instance) {
        instance.settings = $.extend({}, instance.settings, options);
        instance.updated();
      } else {
        instance = $.data(this, pluginName, new Zoom(this, settings));
      }
    });
  };


}));
//# sourceURL=sohoxi.js